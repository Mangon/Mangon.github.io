<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    

    
    <title>
        HTTP-缓存 | 
        Gblog
    </title>
    <meta name="author" content="Mangon" />
    <meta name="version" content="1.1.0" />
    
    <meta name="keywords" content="Mangon blog, 技术博客, 前端学习, 前端基础" />
    
    
    <meta name="description" content="什么是HTTP缓存缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。HTTP 缓存机制就是，通过配置 HTTP 响应头来告诉浏览器是否应该对请求的资源进行缓存、缓存多长时间、缓存是否过期的一种机制。  缓存的优缺点缓存的优点：减少了不必要的数据传输，节省带宽减少服务器的负担，提升网站性能加快了客户端加载网页的速度缺点：资源如果有更改但是客户端不及时更新会造成用户获取信息滞后HTTP缓存有哪几种根据加载缓存是否需要同服务器交互可以将缓存分为 强缓存 与 协商缓存强缓" />
    
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    
    <meta name="baidu-site-verification" content="pWri9ahJmw" />
    
    
    
    <link rel="icon" href="/blog/images/favicon.ico">
    
    
<link rel="stylesheet" href="/blog/css/style.css">

    <link rel="stylesheet" href="/blog/css/jquery.modal.min.css"></link>
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/blog/atom.xml" title="Gblog" type="application/atom+xml">
</head>
<body>

    <main class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>
    <nav class="nav-inner">
        
            
                <li class="nav-item ">
                    <a class="nav-link" href="/blog/">主页</a>
                </li>
            
        
            
                <li class="nav-item ">
                    <a class="nav-link" href="/blog/archives">目录</a>
                </li>
            
        
    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <div class="search-box" id="search-box">
    <form>
        <div class="search-btn"></div>
        <input autocomplete="off" type="text" id="search-input" name="q" results="0" placeholder="搜索"
        />
        <button type="reset" class="reset-search-btn"></button>
    </form>
</div>        
        
            
        

        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFHTTP%E7%BC%93%E5%AD%98"><span class="toc-text">什么是HTTP缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">缓存的优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E7%BC%93%E5%AD%98%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D"><span class="toc-text">HTTP缓存有哪几种</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-text">缓存流程图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8EHTTP%E7%BC%93%E5%AD%98%E6%9C%89%E5%85%B3%E7%9A%84%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-text">与HTTP缓存有关的首部字段有哪些，有什么作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cache-Control"><span class="toc-text">Cache-Control</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Expires"><span class="toc-text">Expires</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Last-Modified"><span class="toc-text">Last-Modified</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ETag"><span class="toc-text">ETag</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#If-Non-Match-If-Modified-Since"><span class="toc-text">If-Non-Match If-Modified-Since</span></a></li></ol></li></ol>
        
        <div id="coffee-content"></div>
    </div>
</aside>

</header>

        
            <div data-spy="scroll" data-target="#aside-inner" id="content" class="content">
        
            <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            HTTP-缓存
        </h1>
        
        <div class="article-meta clearfix">
            <span class="article-date">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2021-04-22T16:41:47.000Z" itemprop="datePublished">2021-04-23</time>
</span>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/blog/tags/HTTP/" rel="tag">HTTP</a>, <a class="article-tag-link" href="/blog/tags/cache/" rel="tag">cache</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
            <h2 id="什么是HTTP缓存"><a href="#什么是HTTP缓存" class="headerlink" title="什么是HTTP缓存"></a>什么是HTTP缓存</h2><p>缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。<br>HTTP 缓存机制就是，通过配置 HTTP 响应头来告诉浏览器是否应该对请求的资源进行缓存、缓存多长时间、缓存是否过期的一种机制。  </p>
<span id="more"></span>
<h2 id="缓存的优缺点"><a href="#缓存的优缺点" class="headerlink" title="缓存的优缺点"></a>缓存的优缺点</h2><p>缓存的优点：</p>
<ol>
<li>减少了不必要的数据传输，节省带宽</li>
<li>减少服务器的负担，提升网站性能</li>
<li>加快了客户端加载网页的速度</li>
</ol>
<p>缺点：</p>
<p>资源如果有更改但是客户端不及时更新会造成用户获取信息滞后</p>
<h2 id="HTTP缓存有哪几种"><a href="#HTTP缓存有哪几种" class="headerlink" title="HTTP缓存有哪几种"></a>HTTP缓存有哪几种</h2><p>根据加载缓存是否需要同服务器交互可以将缓存分为 <em>强缓存</em> 与 <em>协商缓存</em></p>
<ul>
<li>强缓存：浏览器直接从本地缓存中获取数据，不与服务器进行交互。</li>
<li>协商缓存：浏览器发送请求到服务器，服务器判定是否可使用本地缓存。</li>
</ul>
<h2 id="缓存流程图"><a href="#缓存流程图" class="headerlink" title="缓存流程图"></a>缓存流程图</h2><p><img src="/blog/static/imgs/cache.png" alt="cache-process_inner"></p>
<h2 id="与HTTP缓存有关的首部字段有哪些，有什么作用"><a href="#与HTTP缓存有关的首部字段有哪些，有什么作用" class="headerlink" title="与HTTP缓存有关的首部字段有哪些，有什么作用"></a>与HTTP缓存有关的首部字段有哪些，有什么作用</h2><p>与HTTP缓存有关的字段有：  </p>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cache-Control</td>
<td>控制对资源的缓存行为</td>
</tr>
<tr>
<td>Expires</td>
<td>控制资源的过期时间</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>资源的最后修改日期时间</td>
</tr>
<tr>
<td>ETag</td>
<td>资源的匹配信息</td>
</tr>
<tr>
<td>If-Non-Match</td>
<td>条件式请求，服务器上没有任何资源的 ETag 属性值与这个首部中列出的相匹配的时候，服务器端会才返回所请求的资源，响应码为 200 。当验证失败的时候，服务器端必须返回响应码 304</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>条件式请求，服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 。如果请求的资源从那时起未经修改，那么返回一个不带有消息主体的 304 响应。当与 If-None-Match 一同出现时，If-Modified-Since 会被忽略掉。</td>
</tr>
</tbody>
</table>
<h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>代表了资源的缓存策略，常用的有以下几种选择：  </p>
<table>
<thead>
<tr>
<th>Cache-Control字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>max-age</td>
<td>表示缓存最大有效时间，以秒为单位</td>
</tr>
<tr>
<td>public</td>
<td>表示可以被浏览器和代理服务器缓存</td>
</tr>
<tr>
<td>private</td>
<td>客户端可以缓存该资源，但代理服务器不缓存</td>
</tr>
<tr>
<td>no-cache</td>
<td>跳过设置强缓存，强制设置协商缓存</td>
</tr>
<tr>
<td>no-store</td>
<td>不缓存，包括客户端、服务器都不缓存</td>
</tr>
<tr>
<td>immutable</td>
<td>表示该资源永久不变(非标准)</td>
</tr>
</tbody>
</table>
<h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>Expires 代表了资源的过期日期，在没有 Cache-Control 时，则会去查看是否包含 Expires 属性，通过比较 Expires 的值和首部里面 Date 属性的值来判断是否缓存还有效。  </p>
<h3 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h3><p>如果没有 Cache-Control 和 Expires 时，Last-Modified 响应头可以作为一种弱校验器。浏览器隐式的设置资源过期时间为 (Date - Last-Modified) * 10% 缓存过期时间。如果响应头里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。  </p>
<h3 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h3><p>ETag 代表了资源的特定版本的标识符，用做缓存的一种强校验器。  </p>
<ul>
<li>浏览器请求资源，服务器会在响应报文头中加入 ETag 字段。资源更新时，服务器端的ETag值也随之更新；</li>
<li>浏览器再次请求资源时，会在请求报文头中添加 If-None-Match 字段，它的值就是上次响应报文中的 ETag 的值；</li>
<li>服务器会比对 ETag 与 If-None-Match 的值是否一致，如果不一致，服务器则接受请求，返回更新后的资源；如果一致，表明资源未更新，则返回状态码为 304 的响应，可继续使用本地缓存，要注意的是，此时响应头还是会加上 ETag 字段，即使它没有变化。</li>
</ul>
<h3 id="If-Non-Match-If-Modified-Since"><a href="#If-Non-Match-If-Modified-Since" class="headerlink" title="If-Non-Match If-Modified-Since"></a>If-Non-Match If-Modified-Since</h3><p>当一个资源被缓存存储后，该资源应该可以被永久存储在缓存中。由于缓存只有有限的空间用于存储资源副本，所以缓存会定期地将一些副本删除，这个过程叫做 <em>缓存驱逐</em> 。另一方面，当服务器上面的资源进行了更新，那么缓存中的对应资源也应该被更新，由于HTTP是C/S模式的协议，服务器更新一个资源时，不可能直接通知客户端更新缓存，所以双方必须为该资源约定一个过期时间，在该过期时间之前，该资源（缓存副本）就是新鲜的，当过了过期时间后，该资源（缓存副本）则变为陈旧的。驱逐算法用于将陈旧的资源（缓存副本）替换为新鲜的，注意，一个陈旧的资源（缓存副本）是不会直接被清除或忽略的，当客户端发起一个请求时，缓存检索到已有一个对应的陈旧资源（缓存副本），则缓存会先将此请求附加一个 If-None-Match 头，然后发给目标服务器，以此来检查该资源副本是否是依然还是算新鲜的，若服务器返回了 304 (Not Modified)（该响应不会有带有实体信息），则表示此资源副本是新鲜的，这样一来，可以节省一些带宽。若服务器通过 If-None-Match 或 If-Modified-Since 判断后发现已过期，那么会带有该资源的实体内容返回。  </p>

        
    </section>
    
      <footer class="appreciate">
    <p>觉得本文不错？可以赞赏支持我创作！</p>
    <a id="appreciate-btn" href="#appreciate-modal" rel="modal:open" data-options='{"fadeDuration": 250,"fadeDelay": 0.80}'>
        <button type="button" class="appreciate-btn">赞赏支持</button>
    </a>
</footer>
    
</article>




        
            </div>
        
        <article id="search-result" class="search-result content"></article>
        <footer class="footer">
    
        <div class="license">
            <p>版权声明
                <a target="_blank" rel="license noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商用-相同方式共享4.0 (CC BY-NC-SA 4.0)</a>
            </p>
        </div>
    
</footer>


    </main>

    
    <div id="appreciate-modal" class="modal">
    <div class="appreciate-container">
        <div class="appreciate-image">
            <img src="/blog/images/zfb.png" alt="支付宝二维码"></img>
            <p>⬆️支付宝</p>
        </div>
        <div class="appreciate-image">
            <img src="/blog/images/wx.png" alt="微信二维码"></img>
            <p>⬆️微信</p>
        </div>
    </div>
</div>
    
    <script type="text/javascript" src="/blog/js/jquery.min.js"></script>
    <script type="text/javascript" src="/blog/js/jquery.modal.min.js"></script>
    <script type="text/javascript" src="/blog/js/common.js"></script>
    <script type="text/javascript" src="/blog/js/home.js"></script>
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('.toc-link').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();
                // console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');
                // console.log(nodes.navTags.attr('class'))
            });/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/
        });
    </script>
    
        <script type="text/javascript" src="/blog/js/search.js"></script>
        <script type="text/javascript">
            var search_path = "search.xml";
            if (search_path.length == 0) {
                search_path = "search.xml";
            }
            var path = "/blog/" + search_path;
            searchFunc(path, 'search-box', 'search-result');
        </script>
    
    
        <script type="text/javascript" src="/blog/js/scrollspy.min.js"></script>
        <script type="text/javascript">
        $('#content').scrollspy({target: '#aside-inner'});
        document.querySelector(decodeURIComponent(document.location.hash) || '#content')?.scrollIntoView();
        </script>
    
    
        <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?bd8c20273d10c04abf64252ca5fdf77b";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
        </script>
    
</body>
</html>
