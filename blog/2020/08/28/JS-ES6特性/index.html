<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    

    
    <title>
        ES6特性 | 
        Gblog
    </title>
    <meta name="author" content="Mangon" />
    <meta name="version" content="1.1.0" />
    
    <meta name="keywords" content="Mangon blog, 技术博客, 前端学习, 前端基础" />
    
    
    <meta name="description" content="ES6 是 ECMA 为 JavaScript 制定的第 6 个版本的标准，标准委员会 TC39 最终决定，标准在每年的 6 月份正式发布一次，作为当年的正式版本。ECMAscript 2015 是在2015年6月份发布的ES6的第一个版本。依次类推 ECMAscript 2016 是 ES6 的第二个版本、 ECMAscript 2017 是 ES6 的第三个版本。查看浏览器对ES6的语法支持情况。以下记录了 ES6 的比较常见的特性，并做了简单的解释，默认为 ES2015 引入（finish" />
    
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    
    <meta name="baidu-site-verification" content="pWri9ahJmw" />
    
    
    
    <link rel="icon" href="/blog/images/favicon.ico">
    
    
<link rel="stylesheet" href="/blog/css/style.css">

    <link rel="stylesheet" href="/blog/css/jquery.modal.min.css"></link>
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/blog/atom.xml" title="Gblog" type="application/atom+xml">
</head>
<body>

    <main class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>
    <nav class="nav-inner">
        
            
                <li class="nav-item ">
                    <a class="nav-link" href="/blog/">主页</a>
                </li>
            
        
            
                <li class="nav-item ">
                    <a class="nav-link" href="/blog/archives">目录</a>
                </li>
            
        
    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <div class="search-box" id="search-box">
    <form>
        <div class="search-btn"></div>
        <input autocomplete="off" type="text" id="search-input" name="q" results="0" placeholder="搜索"
        />
        <button type="reset" class="reset-search-btn"></button>
    </form>
</div>        
        
            
        

        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5-amp-%E5%A3%B0%E6%98%8E-amp-%E8%A1%A8%E8%BE%BE%E5%BC%8F-amp-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">语句 &amp; 声明 &amp; 表达式 &amp; 运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99"><span class="toc-text">正则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%80%BC"><span class="toc-text">数值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-text">函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-text">对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Symbol"><span class="toc-text">Symbol</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set-amp-Map"><span class="toc-text">Set &amp; Map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Proxy-amp-Reflect"><span class="toc-text">Proxy &amp; Reflect</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise"><span class="toc-text">Promise</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Generator"><span class="toc-text">Generator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#async-await-ES2017"><span class="toc-text">async await (ES2017)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Module-import-amp-export"><span class="toc-text">Module(import &amp; export)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#class"><span class="toc-text">class</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SharedArrayBuffer-amp-Atomics-ES2017"><span class="toc-text">SharedArrayBuffer &amp; Atomics (ES2017)</span></a></li></ol>
        
        <div id="coffee-content"></div>
    </div>
</aside>

</header>

        
            <div data-spy="scroll" data-target="#aside-inner" id="content" class="content">
        
            <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            ES6特性
        </h1>
        
        <div class="article-meta clearfix">
            <span class="article-date">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2020-08-28T06:34:12.000Z" itemprop="datePublished">2020-08-28</time>
</span>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/blog/tags/ES6/" rel="tag">ES6</a>, <a class="article-tag-link" href="/blog/tags/javascript/" rel="tag">javascript</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
            <p>ES6 是 ECMA 为 JavaScript 制定的第 6 个版本的标准，标准委员会 <a target="_blank" rel="noopener" href="https://tc39.es/">TC39</a> 最终决定，标准在每年的 6 月份正式发布一次，作为当年的正式版本。ECMAscript 2015 是在2015年6月份发布的ES6的第一个版本。依次类推 ECMAscript 2016 是 ES6 的第二个版本、 ECMAscript 2017 是 ES6 的第三个版本。<a target="_blank" rel="noopener" href="https://kangax.github.io/compat-table/es6/">查看浏览器对ES6的语法支持情况</a>。以下记录了 ES6 的比较常见的特性，并做了简单的解释，默认为 ES2015 引入（finished）的，如果不是则在后面用（）标志引入的版本。也可以<a target="_blank" rel="noopener" href="https://github.com/tc39/proposals/blob/master/finished-proposals.md">从这里查看从哪个版本支持</a>。</p>
<span id="more"></span>
<h2 id="语句-amp-声明-amp-表达式-amp-运算符"><a href="#语句-amp-声明-amp-表达式-amp-运算符" class="headerlink" title="语句 &amp; 声明 &amp; 表达式 &amp; 运算符"></a>语句 &amp; 声明 &amp; 表达式 &amp; 运算符</h2><ol>
<li>let 和 const 变量声明<br>let const 声明的变量具有块级作用域，不会变量提升，不能重复声明。<br>const 声明常量，声明时必须立即初始化。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> y = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>变量的解构赋值<br>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>globalThis 对象<br>引入globalThis作为顶层对象。也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。(ES2020)</p>
</li>
<li><p>for…of 循环表达式<br>for…of语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。</p>
</li>
<li><p>new.target<br>new.target属性允许你检测函数或构造函数是否是通过new运算符被调用的。在通过new运算符被初始化的函数或构造函数中，new.target返回一个指向构造函数或函数的引用。在普通的函数调用中，new.target 的值是undefined。</p>
</li>
<li><p>… spread扩展操作符<br>扩展运算符 … 将一个数组或arguments或对象的可遍历属性（ES2018）转为用逗号分隔的参数序列。</p>
</li>
<li><p>Hashbang<br>Unix命令脚本都支持 <code>#!</code> 命令，又称为 Hashbang，这个命令放在脚本文件或者模块文件的第一行，用来指定脚本的执行器。（ES2023）</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ol>
<li>支持 Unicode 表示，允许采用 \uxxxx 形式表示一个字符</li>
<li>行分隔符（U + 2028）和段分隔符（U + 2029）符号现在允许在字符串文字中，与JSON匹配 （ES2019）</li>
<li>为字符串添加了遍历器接口，支持使用for…of循环遍历字符串</li>
<li>模板字符串，可以使用反引号 ``来拼接多行字符串，将变量名写在 ${} 中</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#result&#x27;</span>).<span class="title function_">append</span>(<span class="string">`</span></span><br><span class="line"><span class="string">  There are &lt;b&gt;<span class="subst">$&#123;basket.count&#125;</span>&lt;/b&gt; items</span></span><br><span class="line"><span class="string">   in your basket, &lt;em&gt;<span class="subst">$&#123;basket.onSale&#125;</span>&lt;/em&gt;</span></span><br><span class="line"><span class="string">  are on sale!</span></span><br><span class="line"><span class="string">`</span>);</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>标签模板<br>模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。标签模板可以用来过滤 HTML 字符串，防止用户输入恶意内容，也可以用来解决多语言转换的问题（i18n）。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b &#125;</span>`</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="title function_">tag</span>([<span class="string">&#x27;Hello &#x27;</span>, <span class="string">&#x27; world &#x27;</span>, <span class="string">&#x27;&#x27;</span>], <span class="number">15</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>新添加的字符串方法及实例方法</li>
</ol>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>String.raw()</td>
<td>String.raw() 是一个模板字符串的标签函数，是用来获取一个模板字符串的原始字符串的，占位符（例如 ${foo}）会被处理为它所代表的其他字符串，而转义字符（例如 \n）不会。</td>
<td><code>String.raw(&#39;Hi\n$&#123;2+3&#125;!&#39;) ===  &#39;Hi\\n5!&#39;</code></td>
</tr>
<tr>
<td>String.fromCodePoint()</td>
<td>返回使用指定的代码点序列创建的字符串</td>
<td><code>String.fromCodePoint(0x1D306, 0x61, 0x1D307) === &quot;\uD834\uDF06a\uD834\uDF07&quot;</code></td>
</tr>
<tr>
<td>String.prototype.codePointAt()</td>
<td>返回一个 Unicode 编码点值的非负整数</td>
<td><code>&#39;d&#39;.codePointAt() === 100</code></td>
</tr>
<tr>
<td>String.prototype.startsWith()</td>
<td>用来判断当前字符串是否以另外一个给定的子字符串开头，并根据判断结果返回 true 或 false。</td>
<td><code>&#39;i love u&#39;.startsWith(&#39;i lo&#39;)</code></td>
</tr>
<tr>
<td>String.prototype.endsWith()</td>
<td>用来判断当前字符串是否是以另外一个给定的子字符串“结尾”的，根据判断结果返回 true 或 false。</td>
<td><code>&#39;i love u&#39;.endsWith(&#39;e u&#39;)</code></td>
</tr>
<tr>
<td>String.prototype.repeat()</td>
<td>构造并返回一个新字符串，该字符串包含被连接在一起的指定数量的字符串的副本。</td>
<td><code>&#39;isee &#39;.repeat(3) === &#39;isee isee isee &#39;</code></td>
</tr>
<tr>
<td>String.prototype.normalize()</td>
<td>按照指定的一种 Unicode 正规形式将当前字符串正规化。（如果该值不是字符串，则首先将其转换为一个字符串）。</td>
<td><code>&#39;\u00F1&#39;.normalize() === &#39;\u006E\u0303&#39;.normalize()</code></td>
</tr>
<tr>
<td>String.prototype.includes()</td>
<td>用于判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false。</td>
<td><code>&#39;To be, or not to be, that is the question.&#39;.includes(&#39;To be&#39;)</code></td>
</tr>
<tr>
<td>String.prototype.padStart()</td>
<td>用另一个字符串填充当前字符串(如果需要的话，会重复多次)，以便产生的字符串达到给定的长度。从当前字符串的左侧开始填充。(ES2017)</td>
<td><code>&#39;abc&#39;.padStart(10, &quot;foo&quot;) === &#39;foofoofabc&#39;</code></td>
</tr>
<tr>
<td>String.prototype.padEnd()</td>
<td>用一个字符串填充当前字符串（如果需要的话则重复填充），返回填充后达到指定长度的字符串。从当前字符串的末尾（右侧）开始填充。(ES2017)</td>
<td><code>&#39;abc&#39;.padEnd(10, &#39;foo&#39;) === &#39;abcfoofoof&#39;</code></td>
</tr>
<tr>
<td>String.prototype.trimStart()</td>
<td>从字符串的开头删除空格。trimLeft() 是此方法的别名。(ES2019)</td>
<td><code>&#39;   Hello world!   &#39;.trimStart() === &#39;Hello world!   &#39;</code></td>
</tr>
<tr>
<td>String.prototype.trimEnd()</td>
<td>从一个字符串的末端移除空白字符。trimRight() 是这个方法的别名。(ES2019)</td>
<td><code>&#39;   Hello world!   &#39;.trimStart() === &#39;   Hello world!&#39;</code></td>
</tr>
<tr>
<td>String.prototype.matchAll()</td>
<td>返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器。(ES2020)</td>
<td><code>&#39;test1test2&#39;.matchAll(/t(e)(st(\d?))/g)</code></td>
</tr>
<tr>
<td>String.prototype.replaceAll()</td>
<td>被用来在正则表达式和字符串直接比较，然后用新的子串来替换所有被匹配的子串。（ES2021）</td>
</tr>
</tbody>
</table>
<ol start="7">
<li>JSON.stringify 行为改变   (ES2019)<br>如果遇到0xD800到0xDFFF之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。</li>
</ol>
<h2 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h2><ol>
<li>从 ES2015 开始，当第一个参数为正则表达式而第二个标志参数存在时，不再抛错</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="regexp">/xyz/</span>, <span class="string">&#x27;i&#x27;</span>);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。ES6 将这 4 个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。</li>
</ol>
<p>String.prototype.match 调用 RegExp.prototype[Symbol.match]<br>String.prototype.replace 调用 RegExp.prototype[Symbol.replace]<br>String.prototype.search 调用 RegExp.prototype[Symbol.search]<br>String.prototype.split 调用 RegExp.prototype[Symbol.split]</p>
<ol start="3">
<li>新添加了实例属性与对应的修饰符</li>
</ol>
<table>
<thead>
<tr>
<th>实例属性</th>
<th>修饰符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>RegExp.prototype.unicode</td>
<td>u</td>
<td>用来正确处理大于\uFFFF的 Unicode 字符(ES2018)</td>
</tr>
<tr>
<td>RegExp.prototype.sticky</td>
<td>y</td>
<td>反映了搜索是否具有粘性（ 仅从正则表达式的 lastIndex 属性表示的索引处搜索 ）</td>
</tr>
<tr>
<td>RegExp.prototype.flags</td>
<td></td>
<td>返回一个字符串，由当前正则表达式对象的标志组成。</td>
</tr>
<tr>
<td>RegExp.prototype.dotAll</td>
<td>s</td>
<td>使得.可以匹配任意单个字符(ES2018)</td>
</tr>
</tbody>
</table>
<ol start="4">
<li>支持后行断言 (ES2018)</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先行断言 先行否定断言</span></span><br><span class="line">/\d+(?=%)/.<span class="title function_">exec</span>(<span class="string">&#x27;100% of US presidents have been male&#x27;</span>)  <span class="comment">// [&quot;100&quot;]</span></span><br><span class="line">/\d+(?!%)/.<span class="title function_">exec</span>(<span class="string">&#x27;that’s all 44 of them&#x27;</span>)                 <span class="comment">// [&quot;44&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//后行断言 后行否定断言</span></span><br><span class="line">/(?&lt;=\$)\d+<span class="regexp">/.exec(&#x27;Benjamin Franklin is on the $100 bill&#x27;)  /</span><span class="regexp">/ [&quot;100&quot;]</span></span><br><span class="line"><span class="regexp">/</span>(?&lt;!\$)\d+<span class="regexp">/.exec(&#x27;it’s is worth about €90&#x27;)                /</span><span class="regexp">/ [&quot;90&quot;]</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>Unicode 属性类 \P \p (ES2018)<br>引入了一种新的类的写法\p{…}和\P{…}，允许正则表达式匹配符合 Unicode 某种属性的所有字符。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> regexGreekSymbol = <span class="regexp">/\p&#123;Script=Greek&#125;/u</span>; <span class="comment">// \p&#123;Script=Greek&#125;指定匹配一个希腊文字母</span></span><br><span class="line">regexGreekSymbol.<span class="title function_">test</span>(<span class="string">&#x27;π&#x27;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ol start="6">
<li>具名组匹配 &amp; 具名组匹配的引用 (ES2018)<br>正则表达式可以使用圆括号进行组匹配</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">RE_DATE</span> = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matchObj = <span class="variable constant_">RE_DATE</span>.<span class="title function_">exec</span>(<span class="string">&#x27;1999-12-31&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> year = matchObj.<span class="property">groups</span>.<span class="property">year</span>; <span class="comment">// 1999</span></span><br><span class="line"><span class="keyword">const</span> month = matchObj.<span class="property">groups</span>.<span class="property">month</span>; <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">const</span> day = matchObj.<span class="property">groups</span>.<span class="property">day</span>; <span class="comment">// 31</span></span><br></pre></td></tr></table></figure>
<p>如果要在正则表达式内部引用某个“具名组匹配”，可以使用 <code>\k&lt;组名&gt;</code> 的写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">RE_TWICE</span> = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;$/</span>;</span><br><span class="line"><span class="variable constant_">RE_TWICE</span>.<span class="title function_">test</span>(<span class="string">&#x27;abc!abc&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable constant_">RE_TWICE</span>.<span class="title function_">test</span>(<span class="string">&#x27;abc!ab&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h2 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h2><ol>
<li>数值二进制和八进制表示法<br>分别用前缀0b（或0B）和0o（或0O）表示。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0b111110111</span> === <span class="number">503</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0o767</span> === <span class="number">503</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>方法 Number.isFinite(), Number.isNaN()<br>与全局方法isFinite()和isNaN()相比，这两个新方法只对数值有效，非数值返回 false</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isFinite</span>(<span class="number">25</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="string">&quot;25&quot;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isFinite</span>(<span class="number">25</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isFinite</span>(<span class="string">&quot;25&quot;</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="title class_">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;NaN&quot;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="title class_">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&quot;NaN&quot;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="number">1</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>Number.parseInt(), Number.parseFloat()<br>与全局方法 parseInt() 和 parseFloat() 相同</p>
</li>
<li><p>Number.isInteger()<br>用来判断一个数值是否为整数</p>
</li>
<li><p>Number.EPSILON 属性<br>常量，表示 1 与大于 1 的最小浮点数之间的差</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="property">EPSILON</span> === <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, -<span class="number">52</span>)</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>Number.MAX_SAFE_INTEGER 与 Number.MIN_SAFE_INTEGER，Number.isSafeInteger()<br>Number.MAX_SAFE_INTEGER 和 Number.MIN_SAFE_INTEGER这两个常量，用来表示JavaScript能够准确表示的整数范围的上下限。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span> === <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="property">MIN_SAFE_INTEGER</span> === -<span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。</p>
<ol start="7">
<li>Math 对象的新方法（17个）</li>
</ol>
<table>
<thead>
<tr>
<th>方法</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Math.trunc(x)</td>
<td>返回一个数的整数部分，直接去除其小数点及之后的部分。</td>
</tr>
<tr>
<td>Math.sign(x)</td>
<td>返回一个数的符号，得知一个数是正数、负数还是 0。</td>
</tr>
<tr>
<td>Math.cbrt(x)</td>
<td>返回一个数的立方根。</td>
</tr>
<tr>
<td>Math.clz32(x)</td>
<td>返回一个 32 位整数的前导零的数量。</td>
</tr>
<tr>
<td>Math.imul(x, y)</td>
<td>返回 32 位整数乘法的结果。</td>
</tr>
<tr>
<td>Math.fround(x)</td>
<td>返回最接近一个数的单精度浮点型表示。</td>
</tr>
<tr>
<td>Math.imul(x, y)</td>
<td>返回 32 位整数乘法的结果。</td>
</tr>
<tr>
<td>Math.hypot([x[, y[, …]]])</td>
<td>返回其所有参数平方和的平方根。</td>
</tr>
<tr>
<td>Math.expm1(x)</td>
<td>返回 exp(x) - 1 的值。</td>
</tr>
<tr>
<td>Math.log1p(x)</td>
<td>返回一个数加 1 的和的自然对数（㏒e，即 ㏑）。</td>
</tr>
<tr>
<td>Math.log10(x)</td>
<td>返回一个数以 10 为底数的对数。</td>
</tr>
<tr>
<td>Math.log2(x)</td>
<td>返回一个数以 2 为底数的对数。</td>
</tr>
<tr>
<td>Math.sinh(x)</td>
<td>返回x的双曲正弦</td>
</tr>
<tr>
<td>Math.cosh(x)</td>
<td>返回x的双曲余弦</td>
</tr>
<tr>
<td>Math.tanh(x)</td>
<td>返回x的双曲正切</td>
</tr>
<tr>
<td>Math.asinh(x)</td>
<td>返回x的反双曲正弦</td>
</tr>
<tr>
<td>Math.acosh(x)</td>
<td>返回x的反双曲余弦</td>
</tr>
<tr>
<td>Math.atanh(x)</td>
<td>返回x的反双曲正切</td>
</tr>
</tbody>
</table>
<ol start="8">
<li>指数运算符 **(ES2016)<br>右结合的指数运算符</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">2</span> === <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">2</span> ** <span class="number">3</span> ** <span class="number">2</span> === <span class="number">2</span> ** (<span class="number">3</span> ** <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<ol start="9">
<li><p>BitInt 数据类型 (ES2020)<br>BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示</p>
</li>
<li><p>_ 数字分隔符 （ES2021）<br>可以使用下划线来分割数字，下划线没有实际的意义数字的值不会变化，更具有可读性</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1_000_000_000</span> === <span class="number">1000000000</span>;</span><br><span class="line"><span class="number">101_475_938.38</span> === <span class="number">101475938.38</span>;</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ol>
<li>函数参数的默认值</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Point</span>(<span class="params">x = <span class="number">0</span>, y = <span class="number">0</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Point</span>();</span><br><span class="line">p <span class="comment">// &#123; x: 0, y: 0 &#125;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>rest 参数<br>允许将一个不定数量的参数表示为一个数组</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">...values</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式</p>
</li>
<li><p>函数 Function.name 属性，返回该函数的函数名</p>
</li>
<li><p>箭头函数<br>(1) 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。<br>(2) 不可以当作构造函数<br>(3) 不可以使用arguments对象<br>(4) 不可以使用yield命令</p>
</li>
<li><p>尾递归调用优化</p>
</li>
<li><p>允许函数的最后一个参数有尾逗号 (ES2017)</p>
</li>
<li><p>Function.prototype.toString() 将会包含注释空格 (ES2019)</p>
</li>
<li><p>catch 命令的参数可省略 (ES2019)</p>
</li>
</ol>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol>
<li>扩展运算符 … 将一个数组转为用逗号分隔的参数序列</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>Array.from() 方法 类似数组的对象（array-like object）和可遍历（iterable）的对象 转换为数组</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NodeList对象</span></span><br><span class="line"><span class="keyword">let</span> ps = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(ps).<span class="title function_">filter</span>(<span class="function"><span class="params">p</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> p.<span class="property">textContent</span>.<span class="property">length</span> &gt; <span class="number">100</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="comment">// [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set 对象</span></span><br><span class="line"><span class="keyword">let</span> namesSet = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(namesSet) <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;]</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>Array.of() 将一组值，转换为数组</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>) <span class="comment">// [3]</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li><p>数组实例方法 copyWithin() 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度</p>
</li>
<li><p>数组实例方法 find() 和 findIndex() 用于找出第一个符合条件的数组成员和位置</p>
</li>
<li><p>数组实例方法 fill() 使用给定值，填充一个数组</p>
</li>
<li><p>数组实例方法 entries() keys() values() 对健值对、健名、健值进行遍历，返回Interator对象</p>
</li>
<li><p>数组实例方法 includes() 返回一个布尔值，表示某个数组是否包含给定的值 (ES2016)</p>
</li>
<li><p>数组实例方法 flat() flatMap() 对数组进行扁平化，映射后扁平化 (ES2019)</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]].<span class="title function_">flat</span>()</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<ol start="10">
<li><p>Array.prototype.sort() 的默认排序算法稳定 (ES2019)</p>
</li>
<li><p>数组实例方法 groupBy() 该方法允许根据指定的键将数组元素分组（ES2022）</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> grouped = arr.<span class="title function_">groupBy</span>(<span class="function">(<span class="params">num</span>) =&gt;</span> num % <span class="number">2</span> === <span class="number">0</span> ? <span class="string">&#x27;even&#x27;</span> : <span class="string">&#x27;odd&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(grouped);</span><br><span class="line"><span class="comment">// 输出：&#123; odd: [1, 3, 5], even: [2, 4, 6] &#125;</span></span><br></pre></td></tr></table></figure>
<ol start="12">
<li><p>数组实例方法 findLast() 和 findLastIndex() 用于从数组的末尾开始遍历找出符合条件的数组成员和位置（ES2023）</p>
</li>
<li><p>数组实例方法 toReversed() 返回数组的逆转数组副本（ES2023）</p>
</li>
<li><p>数组实例方法 toSorted() 返回数组的排序数组副本（ES2023）</p>
</li>
<li><p>数组实例方法 toSpliced() 返回数组的替换（或删除）多个元素后的数组副本（ES2023）</p>
</li>
<li><p>数组实例方法 with() 返回数组的替换单个元素后的数组副本（ES2023）</p>
</li>
</ol>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ol>
<li>对象属性的简洁表示法</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> baz = &#123;foo&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> baz = &#123;<span class="attr">foo</span>: foo&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>定义对象时，属性名允许使用表达式</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> propKey = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [propKey]: <span class="literal">true</span>,</span><br><span class="line">  [<span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;bc&#x27;</span>]: <span class="number">123</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>super 关键字 代表对象的原型对象</p>
</li>
<li><p>扩展运算符 … 将一个对象的可遍历属性转为用逗号分隔的参数序列（ES2018）</p>
</li>
<li><p>可选链操作符 ?. 用于在获取对象属性或调用对象方法时预先判断对象的属性方法是否存在 （ES2020）</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> firstName = (message</span><br><span class="line">  &amp;&amp; message.<span class="property">body</span></span><br><span class="line">  &amp;&amp; message.<span class="property">body</span>.<span class="property">user</span></span><br><span class="line">  &amp;&amp; message.<span class="property">body</span>.<span class="property">user</span>.<span class="property">firstName</span>) || <span class="string">&#x27;default&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">const</span> firstName = message?.<span class="property">body</span>?.<span class="property">user</span>?.<span class="property">firstName</span> || <span class="string">&#x27;default&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>空值合并操作符 ?? 用于对 null 与 undefined的值赋值默认值 （ES2020）</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与逻辑或操作符（||）不同，逻辑或操作符会在左侧操作数为假值时返回右侧操作数。也就是说，如果使用 || 来为某些变量设置默认值，可能会遇到意料之外的行为。比如为假值（例如，&#x27;&#x27; 或 0 或 false）时。</span></span><br><span class="line"><span class="keyword">const</span> showMask = settings.<span class="property">showMask</span> || <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> showMask = settings.<span class="property">showMask</span> ?? <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>对象方法 Object.is() 用于判断两个值是否同值相等<br>与 === 基本一致，有两个例外</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0</span> === -<span class="number">0</span> <span class="comment">//true</span></span><br><span class="line"><span class="title class_">NaN</span> === <span class="title class_">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(+<span class="number">0</span>, -<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, <span class="title class_">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ol start="8">
<li><p>对象方法 Object.assign() 用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p>
</li>
<li><p>对象方法 Object.getOwnPropertyDescriptors() 用于获取所指定对象的所有自身属性的描述符 （ES2017）</p>
</li>
<li><p>对象方法 Object.getPrototypeOf() 与 Object.setPrototypeOf()</p>
</li>
</ol>
<p>在 ES2015中 Object.getPrototypeOf() 的入参如果不是对象将会被转换成对象<br>Object.setPrototypeOf() 用设置一个指定的对象的原型 (即, 内部[[Prototype]]属性）到另一个对象或 null。同样如果入参不是对象将会被转换成对象。</p>
<ol start="11">
<li><p>对象方法 Object.entries() (ES2017) Object.keys() Object.values() (ES2017) 对健值对、健名、健值进行遍历，返回Interator对象</p>
</li>
<li><p>对象方法 Object.fromEntries() 用于把键值对列表转换为一个对象。(ES2019)</p>
</li>
</ol>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值，一个symbol值能作为对象属性的标识符</p>
<ol>
<li><p>Symbol的实例属性 Symbol.prototype.description 返回Symbol 的描述 (ES2019)</p>
</li>
<li><p>Symbol方法 Symbol.for()，Symbol.keyFor()<br>Symbol.for(key) 方法会根据给定的键 key，来从运行时的 symbol 注册表中找到对应的 symbol，如果找到了，则返回它，否则，新建一个与该键关联的 symbol，并放入全局 symbol 注册表中。<br>Symbol.keyFor(sym) 方法用来获取 symbol 注册表中与某个 symbol 关联的键。</p>
</li>
<li><p>Symbol的属性<br>这些属性存在的意义为，子类可以重载这些属性来改变默认的行为。<br>这些属性都是不可写不可枚举不可配置的。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Symbol.hasInstance</td>
<td>Symbol.hasInstance用于判断某对象是否为某构造器的实例。因此你可以用它自定义 instanceof 操作符在某个类上的行为。</td>
</tr>
<tr>
<td>Symbol.isConcatSpreadable</td>
<td>Symbol.isConcatSpreadable用于配置某对象作为Array.prototype.concat()方法的参数时是否展开其数组元素。</td>
</tr>
<tr>
<td>Symbol.species</td>
<td>Symbol.species 是个函数值属性，其被构造函数用以创建派生对象</td>
</tr>
<tr>
<td>Symbol.match</td>
<td>Symbol.match 指定了匹配的是正则表达式而不是字符串。String.prototype.match() 方法会调用此函数</td>
</tr>
<tr>
<td>Symbol.replace</td>
<td>Symbol.replace 这个属性指定了当一个字符串替换所匹配字符串时所调用的方法。String.prototype.replace() 方法会调用此方法。</td>
</tr>
<tr>
<td>Symbol.search</td>
<td>Symbol.search 指定了一个搜索方法，这个方法接受用户输入的正则表达式，返回该正则表达式在字符串中匹配到的下标，这个方法由以下的方法来调用 String.prototype.search()</td>
</tr>
<tr>
<td>Symbol.split</td>
<td>Symbol.split 指向 一个正则表达式的索引处分割字符串的方法。 这个方法通过 String.prototype.split() 调用</td>
</tr>
<tr>
<td>Symbol.iterator</td>
<td>Symbol.iterator 为每一个对象定义了默认的迭代器。该迭代器可以被 for…of 循环使用</td>
</tr>
<tr>
<td>Symbol.toPrimitive</td>
<td>Symbol.toPrimitive 是一个内置的 Symbol 值，它是作为对象的函数值属性存在的，当一个对象转换为对应的原始值时，会调用此函数。</td>
</tr>
<tr>
<td>Symbol.toStringTag</td>
<td>Symbol.toStringTag 是一个内置 symbol，它通常作为对象的属性键使用，对应的属性值应该为字符串类型，这个字符串用来表示该对象的自定义类型标签，通常只有内置的 Object.prototype.toString() 方法会去读取这个标签并把它包含在自己的返回值里。</td>
</tr>
<tr>
<td>Symbol.unscopables</td>
<td>Symbol.unscopables 指用于指定对象值，其对象自身和继承的从关联对象的 with 环境绑定中排除的属性名称。</td>
</tr>
<tr>
<td>Symbol.asyncIterator</td>
<td>Symbol.asyncIterator 符号指定了一个对象的默认异步迭代器。如果一个对象设置了这个属性，它就是异步可迭代对象，可用于for await…of循环（ES2018）</td>
</tr>
</tbody>
</table>
<ol start="4">
<li>Symbol 可以作为 WeakMap 的键（ES2023）</li>
</ol>
<h2 id="Set-amp-Map"><a href="#Set-amp-Map" class="headerlink" title="Set &amp; Map"></a>Set &amp; Map</h2><p>Set对象是值的集合，你可以按照插入的顺序迭代它的元素。 Set中的元素只会出现一次，即 Set 中的元素是唯一的。</p>
<ol>
<li><p>Set的实例属性 Set.prototype.size 返回 Set 对象中的值的个数</p>
</li>
<li><p>Set的实例方法</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Set.prototype.add(value)</td>
<td>在Set对象尾部添加一个元素。返回该Set对象。</td>
</tr>
<tr>
<td>Set.prototype.delete(value)</td>
<td>删除某个值，返回一个布尔值，表示删除是否成功。</td>
</tr>
<tr>
<td>Set.prototype.has(value)</td>
<td>返回一个布尔值，表示该值是否为Set的成员。</td>
</tr>
<tr>
<td>Set.prototype.clear()</td>
<td>移除Set对象内的所有元素。</td>
</tr>
<tr>
<td>Set.prototype.entries()</td>
<td>返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值的[value, value]数组。为了使这个方法和Map对象保持相似， 每个值的键和值相等。</td>
</tr>
<tr>
<td>Set.prototype.keys()</td>
<td>与values()方法相同，返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。</td>
</tr>
<tr>
<td>Set.prototype.values()</td>
<td>返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。</td>
</tr>
<tr>
<td>Set.prototype.forEach(callbackFn[, thisArg])</td>
<td>按照插入顺序，为Set对象中的每一个值调用一次callBackFn。如果提供了thisArg参数，回调中的this会是这个参数。</td>
</tr>
</tbody>
</table>
<p>WeakSet 对象允许你将弱保持对象存储在一个集合中。<br>与Set有两点不同<br>（1）与Set相比，WeakSet 只能是对象的集合，而不能是任何类型的任意值。<br>（2）WeakSet持弱引用：集合中对象的引用为弱引用。 如果没有其他的对WeakSet中对象的引用，那么这些对象会被当成垃圾回收掉。 这也意味着WeakSet中没有存储当前对象的列表。 正因为这样，WeakSet 是不可枚举的。</p>
<p>Map 对象保存键值对，并且能够记住键的原始插入顺序。任何值(对象或者原始值) 都可以作为一个键或一个值。和Object类似，最大的不同的是Map的key可以是任意值，而Object的key必须是string 或者Symbol。</p>
<ol>
<li><p>Map的实例属性 Map.prototype.size 返回 Map 对象中键值对的个数。</p>
</li>
<li><p>Map的实例方法</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Map.prototype.get(key)</td>
<td>返回键对应的值，如果不存在，则返回undefined。</td>
</tr>
<tr>
<td>Map.prototype.set(key, value)</td>
<td>设置Map对象中键的值。返回该Map对象。</td>
</tr>
<tr>
<td>Map.prototype.delete(key)</td>
<td>如果 Map 对象中存在该元素，则移除它并返回 true；否则如果该元素不存在则返回 false。</td>
</tr>
<tr>
<td>Map.prototype.has(key)</td>
<td>返回一个布尔值，表示Map实例是否包含键对应的值。</td>
</tr>
<tr>
<td>Map.prototype.clear()</td>
<td>移除Map对象的所有键/值对</td>
</tr>
<tr>
<td>Map.prototype.entries()</td>
<td>返回一个新的 Iterator 对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。</td>
</tr>
<tr>
<td>Map.prototype.keys()</td>
<td>返回一个新的 Iterator对象， 它按插入顺序包含了Map对象中每个元素的键 。</td>
</tr>
<tr>
<td>Map.prototype.values()</td>
<td>返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的值 。</td>
</tr>
<tr>
<td>Map.prototype.forEach(callbackFn[, thisArg])</td>
<td>按插入顺序，为 Map对象里的每一键值对调用一次callbackFn函数。如果为forEach提供了thisArg，它将在每次回调中作为this值。</td>
</tr>
</tbody>
</table>
<p>WeakMap 对象是一组键/值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的。</p>
<h2 id="Proxy-amp-Reflect"><a href="#Proxy-amp-Reflect" class="headerlink" title="Proxy &amp; Reflect"></a>Proxy &amp; Reflect</h2><p>Proxy 对象用于代理基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）</p>
<p>用法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>
<p>target 要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。<br>handler 一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。</p>
<p>Reflect 是一个内置反射对象，它提供拦截 JavaScript 操作的方法。这些方法与proxy handlers的方法相同。Reflect不是一个函数对象，因此它是不可构造的。<br>Reflect可以和Proxy配合使用来完成默认行为的基础上定制自定义的行为。</p>
<p>handler 对象的方法</p>
<table>
<thead>
<tr>
<th>proxy handler方法</th>
<th>含义</th>
<th>Reflect方法</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>get(target, propKey, receiver)</td>
<td>拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。</td>
<td>Reflect.get(target, propKey, receiver)</td>
<td>获取对象身上某个属性的值，类似于 target[propKey]。</td>
</tr>
<tr>
<td>set(target, propKey, value, receiver)</td>
<td>拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。</td>
<td>Reflect.set(target, propKey, value, receiver)</td>
<td>将值分配给属性的函数。返回一个Boolean，如果更新成功，则返回true。</td>
</tr>
<tr>
<td>has(target, propKey)</td>
<td>拦截propKey in proxy的操作，返回一个布尔值。</td>
<td>Reflect.has(target, propKey)</td>
<td>判断一个对象是否存在某个属性，和 in 运算符 的功能完全相同。</td>
</tr>
<tr>
<td>deleteProperty(target, propKey)</td>
<td>拦截delete proxy[propKey]的操作，返回一个布尔值。</td>
<td>Reflect.deleteProperty(target, propKey)</td>
<td>作为函数的delete操作符，相当于执行 delete target[propKey]。</td>
</tr>
<tr>
<td>ownKeys(target)</td>
<td>拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。</td>
<td>Reflect.ownKeys(target)</td>
<td>返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 Object.keys(), 但不会受enumerable影响).</td>
</tr>
<tr>
<td>getOwnPropertyDescriptor(target, propKey)</td>
<td>拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</td>
<td>Reflect.getOwnPropertyDescriptor(target, propKey)</td>
<td>类似于 Object.getOwnPropertyDescriptor()。如果对象中存在该属性，则返回对应的属性描述符,  否则返回 undefined.</td>
</tr>
<tr>
<td>defineProperty(target, propKey, propDesc)</td>
<td>拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</td>
<td>Reflect.defineProperty(target, propKey, propDesc)</td>
<td>和 Object.defineProperty() 类似。如果设置成功就会返回 true</td>
</tr>
<tr>
<td>preventExtensions(target)</td>
<td>拦截Object.preventExtensions(proxy)，返回一个布尔值。</td>
<td>Reflect.preventExtensions(target)</td>
<td>类似于 Object.preventExtensions()。返回一个Boolean。</td>
</tr>
<tr>
<td>getPrototypeOf(target)</td>
<td>拦截Object.getPrototypeOf(proxy)，返回一个对象。</td>
<td>Reflect.getPrototypeOf(target)</td>
<td>类似于 Object.getPrototypeOf()。</td>
</tr>
<tr>
<td>isExtensible(target)</td>
<td>拦截Object.isExtensible(proxy)，返回一个布尔值。</td>
<td>Reflect.isExtensible(target)</td>
<td>类似于 Object.isExtensible().</td>
</tr>
<tr>
<td>setPrototypeOf(target, proto)</td>
<td>拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</td>
<td>Reflect.setPrototypeOf(target, proto)</td>
<td>设置对象原型的函数. 返回一个 Boolean， 如果更新成功，则返回true。</td>
</tr>
<tr>
<td>apply(target, object, args)</td>
<td>拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。</td>
<td>Reflect.apply(target, thisArgument, args)</td>
<td>对一个函数进行调用操作，同时可以传入一个数组作为调用参数。和 Function.prototype.apply() 功能类似。</td>
</tr>
<tr>
<td>construct(target, args)</td>
<td>拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。</td>
<td>Reflect.construct(target, args)</td>
<td>对构造函数进行 new 操作，相当于执行 new target(…args)。</td>
</tr>
</tbody>
</table>
<p>Proxy 方法 Proxy.revocable() 创建一个可销毁的代理对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;proxy, revoke&#125; = <span class="title class_">Proxy</span>.<span class="title function_">revocable</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用revoke()可销毁proxy</span></span><br><span class="line"><span class="title function_">revoke</span>()</span><br></pre></td></tr></table></figure>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise 对象用于表示一个异步操作的最终完成 (或失败), 及其结果值.<br>Promise 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象。<br>一个 Promise有以下几种状态:</p>
<ul>
<li>pending: 初始状态，既不是成功，也不是失败状态。</li>
<li>fulfilled: 意味着操作成功完成。</li>
<li>rejected: 意味着操作失败。</li>
</ul>
<ol>
<li><p>Promise实例方法 Promise.prototype.then() 用来执行resolved状态的回调</p>
</li>
<li><p>Promise实例方法 Promise.prototype.catch() 用来执行错误时的回调（包括reject和抛出错误）</p>
</li>
<li><p>Promise实例方法 Promise.prototype.finally() 用来执行不管 Promise 对象最后状态如何，都会执行的操作（ES2018）</p>
</li>
<li><p>Promise方法 Promise.all(iterable) 方法返回一个 Promise 实例，此实例在 iterable 参数内所有的 promise 都“完成（resolved）”或参数中不包含 promise 时回调完成（resolve）；如果参数中  promise 有一个失败（rejected），此实例回调失败（reject），失败的原因是第一个失败 promise 的结果。</p>
</li>
<li><p>Promise方法 Promise.race(iterable) 方法返回一个 promise，一旦迭代器中的某个promise resolve 或 reject，返回的 promise 就会 resolve 或 reject。</p>
</li>
<li><p>Promise方法 Promise.allSettled()返回一个在所有给定的promise都已经 fulfilled 或rejected 后的 promise ，并带有一个对象数组，每个对象表示对应的promise结果。 (ES2020)</p>
</li>
<li><p>Promise方法 Promise.any(iterable) 接收一个Promise对象的集合，当其中的一个promise 成功，就返回那个成功的 promise 的值。 (ES2021)</p>
</li>
<li><p>Promise方法 Promise.reject(reason) 方法返回一个带有拒绝原因的Promise对象。</p>
</li>
<li><p>Promise方法 Promise.resolve(value)方法返回一个以给定值解析后的Promise 对象。</p>
</li>
</ol>
<h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><p>Generator 是由一个 generator function(function*) 或 GeneratorFunction 构造器生成新的 返回的符合 iterator 和 iterable 的对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>();</span><br><span class="line"><span class="comment">// &quot;Generator &#123; &#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p>Gnerator对象实例方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Generator.prototype.next()</td>
<td>返回一个由 yield表达式生成的值。</td>
</tr>
<tr>
<td>Generator.prototype.return()</td>
<td>返回给定的值并结束生成器。</td>
</tr>
<tr>
<td>Generator.prototype.throw()</td>
<td>向生成器抛出一个错误。</td>
</tr>
</tbody>
</table>
<p>GeneratorFunction构造器生成新的 Generator 对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">GeneratorFunction</span> ([arg1[, arg2[, ...argN]],] functionBody)</span><br></pre></td></tr></table></figure>
<h2 id="async-await-ES2017"><a href="#async-await-ES2017" class="headerlink" title="async await (ES2017)"></a>async await (ES2017)</h2><p>async function 用来定义一个返回 AsyncFunction 对象的异步函数。异步函数是指通过事件循环异步执行的函数，它会通过一个隐式的 Promise 返回其结果。</p>
<h2 id="Module-import-amp-export"><a href="#Module-import-amp-export" class="headerlink" title="Module(import &amp; export)"></a>Module(import &amp; export)</h2><p>静态的import 语句用于导入由另一个模块导出的绑定。<br>export 语句用于从模块中导出实时绑定的函数、对象或原始值，以便其他程序可以通过 import 语句使用它们。</p>
<p>用法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> defaultExport <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> name <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">export</span> &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">export</span> <span class="keyword">as</span> alias &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; export1 , export2 &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; foo , bar &#125; <span class="keyword">from</span> <span class="string">&quot;module-name/path/to/specific/un-exported/file&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; export1 , export2 <span class="keyword">as</span> alias2 , [...] &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> defaultExport, &#123; <span class="keyword">export</span> [ , [...] ] &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> defaultExport, * <span class="keyword">as</span> name <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">import</span>(<span class="string">&quot;module-name&quot;</span>); <span class="comment">// 动态import (ES2020)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo =<span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">cube</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;foo <span class="keyword">as</span> bar&#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; es6 <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./someModule&#x27;</span>;  <span class="comment">// 支持引入导出重命名</span></span><br></pre></td></tr></table></figure>
<p>由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。<br>同时import命令具有提升效果，会提升到整个模块的头部，首先执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> * <span class="keyword">as</span> ns <span class="keyword">from</span> <span class="string">&quot;mod&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ns <span class="keyword">from</span> <span class="string">&quot;mod&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;ns&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>import.meta是一个给JavaScript模块暴露特定上下文的元数据属性的对象。它包含了这个模块的信息，比如说这个模块的URL。(ES2020)</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.mjs?someURLInfo=5&#x27;</span>;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">import</span>.<span class="property">meta</span>); <span class="comment">// &#123; url: &quot;file:///home/user/my-module.mjs&quot; &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p>class 声明创建一个基于原型继承的具有给定名称的新类。类声明不存在变量提升。</p>
<p>用法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> [<span class="keyword">extends</span>] &#123;</span><br><span class="line">  <span class="keyword">static</span> #privateProp = <span class="number">0</span>; <span class="comment">// 静态私有属性 (不会被实例继承，不会被子类继承)</span></span><br><span class="line">  #privateProp = <span class="number">0</span>; <span class="comment">// 私有属性 (不会被子类继承)</span></span><br><span class="line">  _prop = <span class="number">0</span>; <span class="comment">// 类实例属性 (实例继承)</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 类的构造函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_prop</span> = <span class="number">1</span>; <span class="comment">// this代表了实例</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">someMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 类实例方法(实例继承，子类继承)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">staticMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 静态方法（不会被实例继承，可以被子类继承）</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> #privateMethod = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 私有静态方法 （ES2020 stage3 不会被实例继承，不会被子类继承）</span></span><br><span class="line">  &#125;</span><br><span class="line">  #privateSomeMethod = <span class="function">()=&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 私有方法 （ES2020 stage3 实例继承，不会被子类继承）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> <span class="title class_">ClassName</span>(); <span class="comment">// 声明类的实例</span></span><br><span class="line">inst.<span class="title function_">someMethod</span>(); <span class="comment">// 调用实例的方法</span></span><br><span class="line"><span class="title class_">ClassName</span>.<span class="title function_">staticMethod</span>(); <span class="comment">// 调用类的静态方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChildClass</span> <span class="keyword">extends</span> <span class="title class_ inherited__">ClassName</span> &#123; <span class="comment">// 子类</span></span><br><span class="line">  <span class="title function_">someMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">staticMethod</span>(); <span class="comment">// 可以通过super调用父类上的方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ChildClass</span>.<span class="title function_">staticMethod</span>() <span class="comment">// 子类可以继承父类的静态方法</span></span><br></pre></td></tr></table></figure>
<h2 id="SharedArrayBuffer-amp-Atomics-ES2017"><a href="#SharedArrayBuffer-amp-Atomics-ES2017" class="headerlink" title="SharedArrayBuffer &amp; Atomics (ES2017)"></a>SharedArrayBuffer &amp; Atomics (ES2017)</h2><p>SharedArrayBuffer 对象用来表示一个通用的，固定长度的原始二进制数据缓冲区，类似于 ArrayBuffer 对象，它们都可以用来在共享内存（shared memory）上创建视图。与 ArrayBuffer 不同的是，SharedArrayBuffer 不能被分离。<br>Atomics 对象提供了一组静态方法用来对 SharedArrayBuffer 对象和 ArrayBuffer 对象进行原子操作。</p>

        
    </section>
    
      <footer class="appreciate">
    <p>觉得本文不错？可以赞赏支持我创作！</p>
    <a id="appreciate-btn" href="#appreciate-modal" rel="modal:open" data-options='{"fadeDuration": 250,"fadeDelay": 0.80}'>
        <button type="button" class="appreciate-btn">赞赏支持</button>
    </a>
</footer>
    
</article>




        
            </div>
        
        <article id="search-result" class="search-result content"></article>
        <footer class="footer">
    
        <div class="license">
            <p>版权声明
                <a target="_blank" rel="license noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商用-相同方式共享4.0 (CC BY-NC-SA 4.0)</a>
            </p>
        </div>
    
</footer>


    </main>

    
    <div id="appreciate-modal" class="modal">
    <div class="appreciate-container">
        <div class="appreciate-image">
            <img src="/blog/images/zfb.png" alt="支付宝二维码"></img>
            <p>⬆️支付宝</p>
        </div>
        <div class="appreciate-image">
            <img src="/blog/images/wx.png" alt="微信二维码"></img>
            <p>⬆️微信</p>
        </div>
    </div>
</div>
    
    <script type="text/javascript" src="/blog/js/jquery.min.js"></script>
    <script type="text/javascript" src="/blog/js/jquery.modal.min.js"></script>
    <script type="text/javascript" src="/blog/js/common.js"></script>
    <script type="text/javascript" src="/blog/js/home.js"></script>
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('.toc-link').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();
                // console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');
                // console.log(nodes.navTags.attr('class'))
            });/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/
        });
    </script>
    
        <script type="text/javascript" src="/blog/js/search.js"></script>
        <script type="text/javascript">
            var search_path = "search.xml";
            if (search_path.length == 0) {
                search_path = "search.xml";
            }
            var path = "/blog/" + search_path;
            searchFunc(path, 'search-box', 'search-result');
        </script>
    
    
        <script type="text/javascript" src="/blog/js/scrollspy.min.js"></script>
        <script type="text/javascript">
        $('#content').scrollspy({target: '#aside-inner'});
        document.querySelector(decodeURIComponent(document.location.hash) || '#content')?.scrollIntoView();
        </script>
    
    
        <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?bd8c20273d10c04abf64252ca5fdf77b";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
        </script>
    
</body>
</html>
