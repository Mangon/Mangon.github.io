<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JSDoc 小抄</title>
      <link href="/blog/2025/02/24/FE-JSDoc%E5%B0%8F%E6%8A%84/"/>
      <url>/blog/2025/02/24/FE-JSDoc%E5%B0%8F%E6%8A%84/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-JSDoc"><a href="#什么是-JSDoc" class="headerlink" title="什么是 JSDoc"></a>什么是 JSDoc</h2><p><a href="https://jsdoc.app/">JSDoc</a> (<a href="https://github.com/jsdoc/jsdoc">Github地址</a>) 是一种用于 JavaScript 代码的 API 文档生成工具，它允许开发者通过注释的方式为代码添加文档说明。JSDoc 可以解析这些注释，并生成 HTML 格式的文档，帮助开发者更好地理解和使用代码。JSDoc 采用了 Apache License 2.0 开源协议。VS Code 内置了对 JSDoc 风格注释的支持，在 Javascript 和 TypeScript 代码中书写 JSDoc 风格的注释会自动高亮。</p><h2 id="JSDoc-的实现原理"><a href="#JSDoc-的实现原理" class="headerlink" title="JSDoc 的实现原理"></a>JSDoc 的实现原理</h2><p>JSDoc 的实现原理主要基于注释解析。开发者在 JavaScript 代码中使用特定格式的注释（通常是以 <code>/**</code> 开头的多行注释），JSDoc 工具会扫描这些注释并提取信息。提取的信息包括函数的参数、返回值、类型、描述等。然后，JSDoc 会将这些信息转换为结构化的文档格式（如 HTML），并生成相应的文档。</p><h2 id="JSDoc-常见用法"><a href="#JSDoc-常见用法" class="headerlink" title="JSDoc 常见用法"></a>JSDoc 常见用法</h2><ol><li>基本注释格式：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 函数描述</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">类型</span>&#125; 参数名 参数描述</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">类型</span>&#125; 返回值描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params">param</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> param;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>类型注释：<br>可以使用 <code>&#123;&#125;</code> 来指定参数和返回值的类型，例如：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; name 用户名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; age 用户年龄</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">boolean</span>&#125; 是否成年</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isAdult</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> age &gt;= <span class="number">18</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>模块和类注释：<br>JSDoc 也支持模块和类的文档注释：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@class</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@constructor</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">name</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>使用名称路径<br>如果涉及到一个 JavaScript 变量，这个变量在文档中的其他地方，你必须提供一个唯一标识符映射到该变量。名称路径提供了一种这样做的方法，并且消除实例成员，静态成员和内部变量之间的歧义</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Person#say  // 名为&quot;say&quot;的实例方法</span></span><br><span class="line"><span class="comment"> * Person.say  // 名为&quot;say&quot;的静态方法</span></span><br><span class="line"><span class="comment"> * Person~say  // 名为&quot;say&quot;的内部函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@module</span> foo/bar // 名为&quot;foo/bar&quot;的模块</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@external</span> String // 内置的 string 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@event</span> module:foo/bar.event:MyEvent // 一个名为 module:foo/bar.event:MyEvent 的事件</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="JSDoc-块标签与内联标签"><a href="#JSDoc-块标签与内联标签" class="headerlink" title="JSDoc 块标签与内联标签"></a>JSDoc 块标签与内联标签</h2><p>JSDoc支持两种不同类型的标签：</p><p>· 块标签(Block): 这是在一个 JSDoc 注释的最高级别。<br>· 内联标签(inline): 块标签文本中的标签或说明。</p><p>块标签通常会提供有关代码的详细信息，如一个函数接受的参数。内联标签通常链接到文件的其他部分，类似于HTML中的锚（<code>&lt;a&gt;</code>）标记。</p><p>块标签总是以 <code>@</code> 符号开头。除了 JSDoc 注释中最后一个块标记，每个块标签后面必须跟一个换行符。</p><p>内联标签也以 <code>@</code> 符号开。然而，内联标签及其文本必须用花括号 <code>&#123;</code> 与 <code>&#125;</code> 括起来。 <code>&#123;</code> 表示行内联标签的开始，而 <code>&#125;</code> 表示内联标签的结束。如果标签文本中包含 <code>&#125;</code>，则必须用 <code>\</code> 进行转义。在内联标签后，你并不需要使用一个换行符。</p><p>大多数 JSDoc 标签是块标签。一般来说，当这个网站上说“JSDoc 标签”，我们真正的意思是“块标签”。<a href="https://jsdoc.app/#block-tags">block-tags</a> 记录了在 JSDoc 中所有识别的块标签。</p><p>如下是一个示例，<code>@param</code> 是一个块标签，而 <code>&#123;@link&#125;</code> 是一个内联标签：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set the shoe&#x27;s color. Use &#123;<span class="doctag">@link</span> Shoe#setSize&#125; to set the shoe size.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">color</span> - The shoe&#x27;s color.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">Shoe</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setColor</span> = <span class="keyword">function</span> (<span class="params">color</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="JSDoc-命令行"><a href="#JSDoc-命令行" class="headerlink" title="JSDoc 命令行"></a>JSDoc 命令行</h2><p>JSDoc 可以使用命令行工具生成文档：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g jsdoc</span><br><span class="line">jsdoc yourfile.js</span><br></pre></td></tr></table></figure><p>执行该命令后，JSDoc 会在 <code>/out</code> 目录下生成当前目录的文档。JSDoc 支持大量的命令行选项，其中许多选项有长和短两种形式。</p><table><thead><tr><th>短选项</th><th>完整选项</th><th>描述</th></tr></thead><tbody><tr><td><code>-c &lt;value&gt;</code></td><td><code>--configure &lt;value&gt;</code></td><td>JSDoc 配置文件的路径。默认为安装 JSDoc 目录下的 <code>conf.json</code> 或 <code>conf.json.EXAMPLE</code></td></tr><tr><td><code>-d &lt;value&gt;</code></td><td><code>--destination &lt;value&gt;</code></td><td>输出生成文档的文件夹路径。默认为 <code>./out</code></td></tr><tr><td><code>-e &lt;value&gt;</code></td><td><code>--encoding &lt;value&gt;</code></td><td>源文件的编码。默认为 <code>utf8</code></td></tr><tr><td><code>-h</code></td><td><code>--help</code></td><td>显示 JSDoc 的命令行选项的信息，然后退出</td></tr><tr><td><code>-p</code></td><td><code>--private</code></td><td>将标记有 <code>@private</code> 标签的标识符也生成到文档中。默认情况下，不包括私有标识符</td></tr><tr><td><code>-r</code></td><td><code>--recurse</code></td><td>扫描源文件和导览时递归到子目录</td></tr><tr><td><code>-t &lt;value&gt;</code></td><td><code>--template &lt;value&gt;</code></td><td>指定模板文件夹的路径。默认为 <code>./templates/default</code></td></tr><tr><td><code>-v</code></td><td><code>--version</code></td><td>显示 JSDoc 的版本号，然后退出</td></tr><tr><td></td><td><code>--verbose</code></td><td>日志的详细信息到控制台 JSDoc 运行。默认为 false</td></tr><tr><td></td><td><code>--debug</code></td><td>显示调试信息到控制台 JSDoc 运行。默认为 false</td></tr><tr><td></td><td><code>--pedantic</code></td><td>当 JSDoc 遇到错误时，它将停止运行。默认为 false</td></tr></tbody></table><h2 id="JSDoc-配置文件"><a href="#JSDoc-配置文件" class="headerlink" title="JSDoc 配置文件"></a>JSDoc 配置文件</h2><p>JSDoc 的命令行选项也可以在配置文件中指定。要使用配置文件运行 JSDoc，需要使用 <code>-c</code> 命令行选项（例如，<code>jsdoc -c /path/to/conf.json</code> 或 <code>jsdoc -c /path/to/conf.js</code>）。</p><p>默认配置如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="comment">// 无插件加载</span></span><br><span class="line">  <span class="attr">&quot;recurseDepth&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> <span class="comment">// 如果使用 -r 命令行标志启用递归，JSDoc 将搜索 10 层深的文件</span></span><br><span class="line">  <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 源代码配置</span></span><br><span class="line">    <span class="attr">&quot;includePattern&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.+\\.js(doc|x)?$&quot;</span><span class="punctuation">,</span> <span class="comment">// 只有以 .js、.jsdoc 和 .jsx 结尾的文件将会被处理</span></span><br><span class="line">    <span class="attr">&quot;excludePattern&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(^|\\/|\\\\)_&quot;</span> <span class="comment">// 任何文件或目录如果以 _ 开始将被忽略</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sourceType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;module&quot;</span><span class="punctuation">,</span> <span class="comment">// &quot;script&quot;，表示脚本文件，&quot;module&quot; 表示模块文件</span></span><br><span class="line">  <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 标签配置</span></span><br><span class="line">    <span class="attr">&quot;allowUnknownTags&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 允许使用未知的标签</span></span><br><span class="line">    <span class="attr">&quot;dictionaries&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;jsdoc&quot;</span><span class="punctuation">,</span> <span class="string">&quot;closure&quot;</span><span class="punctuation">]</span> <span class="comment">// 允许使用 jsdoc 标签 和 [closure 标签](https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler#jsdoc-tags)</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;templates&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 模板配置</span></span><br><span class="line">    <span class="attr">&quot;cleverLinks&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> <span class="comment">// 链接到源码</span></span><br><span class="line">    <span class="attr">&quot;monospaceLinks&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span> <span class="comment">// 源码行号</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="JSDoc-插件"><a href="#JSDoc-插件" class="headerlink" title="JSDoc 插件"></a>JSDoc 插件</h2><p>在 JSDoc 中，插件的作用是扩展 JSDoc 的功能，比如添加新的标签、解析新的语法等。首先，需要创建一个包含插件代码的 Javascript 模块，然后将该模块添加到 JSDoc 的配置文件 <code>plugin</code> 参数中，以启用插件。</p><p>一个 JSDoc 插件可以：<br>· 定义事件处理程序<br>· 定义自定义标签，如 <code>@author</code>、<code>@version</code> 等。<br>· 定义一个抽象的解析器，用于解析自定义标签。</p><p>JSDoc 插件的事件处理程序包括：<br><code>Event: parseBegin</code>: JSDoc 开始加载和解析源文件之前，parseBegin 事件被触发。插件可以通过修改事件的内容，来控制哪些文件将被 JSDoc 解析。(&gt;<a href="mailto:=JSDoc@3.2.0">=JSDoc@3.2.0</a>)<br><code>Event: fileBegin</code>: 当解析器即将解析一个文件 fileBegin 事件触发。如果需要，插件可以使用此事件触发每个文件的初始化。<br><code>Event: beforeParse</code>: beforeParse 事件在解析开始之前被触发。插件可以使用此方法来修改将被解析的源代码。<br><code>Event: jsdocCommentFound</code>: 每当 JSDoc 注释被发现，jsdocCommentFound 事件就会被触发。注释可以或不与任何代码相关联。你可以在注释被处理之前使用此事件修改注释的内容。(&gt;<a href="mailto:=JSDoc@3.5.0">=JSDoc@3.5.0</a>)<br><code>Event: symbolFound</code>: 当解析器在代码中遇到一个可能需要被文档化的标识符时，symbolFound 事件就会被触发。<br><code>Event: newDoclet</code>: newDoclet事件是最高级别的事件。新的 doclet 已被创建时，它就会被触发。这意味着一个 JSDoc 注释或标识符已被处理，并且实际传递给模板的 doclet 已被创建。<br><code>Event: fileComplete</code>: 当解析器解析完一个文件时，fileComplete 事件就会被触发。插件可以使用这个事件来触发每个文件的清理。<br><code>Event: parseComplete</code>: JSDoc 解析所有指定的源文件之后，parseComplete 事件就会被触发。(&gt;<a href="mailto:=JSDoc@3.2.0">=JSDoc@3.2.0</a>)<br><code>Event: processingComplete</code>: JSDoc 更新反映继承和借来的标识符的解析结果后，processingComplete 事件被触发。(&gt;<a href="mailto:=JSDoc@3.2.1">=JSDoc@3.2.1</a>)</p><p>JSDoc 包含一个 Markdown 插件来自动将 Markdown 格式文本转换成 HTML。可以通过如下配置开启：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;plugins/markdown&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;markdown&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;foo&quot;</span><span class="punctuation">,</span> <span class="string">&quot;bar&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="comment">// 扩展需解析 markdown 的标签</span></span><br><span class="line">      <span class="attr">&quot;excludeTags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;author&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span>  <span class="comment">// 不解析 markdown 的标签</span></span><br><span class="line">      <span class="attr">&quot;hardwrap&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 是否强制换行(&gt;=JSDoc@3.4.0)</span></span><br><span class="line">      <span class="attr">&quot;idInHeadings&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 是否在标题中添加 id(&gt;=JSDoc@3.4.0)</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>Markdown 插件默认只解析特定的 JSDoc 标签（<code>@author</code>,<code>@classdesc</code>,<code>@description</code>,<code>@param</code>,<code>@property</code>,<code>@return</code>,<code>@see</code>,<code>@throws</code>），可以通过在配置文件的 <code>markdown.tags</code> 字段中添加标签来扩展解析范围。可以通过 <code>markdown.excludeTags</code> 字段来排除默认标签的解析。</p><h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h2><p>· JSDoc 支持通过 <code>--tutorials</code> 或 <code>-u</code> 选项提供 JSDoc 要搜索的教程目录从而为 API 文档添加教程。<br>· JSDoc 支持通过 <code>--package</code> 或 <code>-P</code> 选项指定 package.json 文件的路径从而在生成文档的时候自动使用 package.json 的信息。(&gt;<a href="mailto:=JSDoc@3.3.0">=JSDoc@3.3.0</a>)<br>· JSDoc 支持通过 <code>--readme</code> 或 <code>-R</code> 选项指定将 README 文件中的信息合并到文档中。(&gt;<a href="mailto:=JSDoc@3.3.0">=JSDoc@3.3.0</a>)</p>]]></content>
      
      
      
        <tags>
            
            <tag> JSDoc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux系统下常用命令</title>
      <link href="/blog/2025/01/20/CS-linux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/blog/2025/01/20/CS-linux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h2><p><code>alias</code> 命令用于为命令创建别名，以便简化输入和提高效率。</p><h3 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> ll=<span class="string">&#x27;ls -la&#x27;</span></span><br></pre></td></tr></table></figure><p>这个命令会创建一个别名 <code>ll</code>，用于执行 <code>ls -la</code> 命令。</p><h3 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h3><ul><li>创建简单别名：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> gs=<span class="string">&#x27;git status&#x27;</span></span><br></pre></td></tr></table></figure><p>这个命令会创建一个别名 <code>gs</code>，用于快速查看 Git 状态。</p><ul><li>创建带参数的别名：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> <span class="built_in">rm</span>=<span class="string">&#x27;rm -i&#x27;</span></span><br></pre></td></tr></table></figure><p>这个命令会创建一个别名 <code>rm</code>，在删除文件时提示确认。</p><ul><li>查看当前所有别名：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span></span><br></pre></td></tr></table></figure><p>这个命令会列出当前会话中所有已定义的别名。</p><ul><li>删除别名：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unalias</span> ll</span><br></pre></td></tr></table></figure><p>这个命令会删除别名 <code>ll</code>。</p><ul><li>将别名永久保存：<br>可以将别名添加到用户的 <code>~/.bashrc</code> 或 <code>~/.bash_aliases</code> 文件中，以便在每次登录时自动加载。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;alias ll=&#x27;ls -la&#x27;&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><ul><li>创建复杂的别名（使用函数）：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> mygrep=<span class="string">&#x27;grep --color=auto&#x27;</span></span><br></pre></td></tr></table></figure><p>这个命令会创建一个别名 <code>mygrep</code>，在使用 <code>grep</code> 时自动启用颜色高亮。</p><ul><li>使用别名时显示帮助信息：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> h=<span class="string">&#x27;history&#x27;</span></span><br></pre></td></tr></table></figure><p>这个命令会创建一个别名 <code>h</code>，用于快速查看命令历史。</p><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><p><code>awk</code> 是一个强大的文本处理工具，主要用于模式扫描和处理。它可以从文本文件中提取和处理数据。</p><h3 id="用法示例-1"><a href="#用法示例-1" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> filename.txt</span><br></pre></td></tr></table></figure><p>这个命令会打印 <code>filename.txt</code> 文件中每一行的第一个字段。</p><h3 id="常见用法-1"><a href="#常见用法-1" class="headerlink" title="常见用法"></a>常见用法</h3><ul><li>统计文件中的行数：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;END &#123;print NR&#125;&#x27;</span> filename.txt</span><br></pre></td></tr></table></figure><ul><li>计算某一列的总和：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;sum += $1&#125; END &#123;print sum&#125;&#x27;</span> filename.txt</span><br></pre></td></tr></table></figure><ul><li>过滤特定模式的行：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;/pattern/&#x27;</span> filename.txt</span><br></pre></td></tr></table></figure><h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><p><code>cat</code> 命令用于连接文件并打印到标准输出，常用于查看文件内容。</p><h3 id="用法示例-2"><a href="#用法示例-2" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> filename.txt</span><br></pre></td></tr></table></figure><p>这个命令会打印 <code>filename.txt</code> 文件的所有内容。</p><h3 id="常见用法-2"><a href="#常见用法-2" class="headerlink" title="常见用法"></a>常见用法</h3><ul><li>查看多个文件的内容：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> file1.txt file2.txt</span><br></pre></td></tr></table></figure><ul><li>将文件内容输出到另一个文件：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> filename.txt &gt; newfile.txt</span><br></pre></td></tr></table></figure><ul><li>追加文件内容到另一个文件：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> filename.txt &gt;&gt; existingfile.txt</span><br></pre></td></tr></table></figure><ul><li>显示行号：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> -n filename.txt</span><br></pre></td></tr></table></figure><h2 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h2><p><code>cd</code> 命令用于更改当前工作目录。</p><h3 id="用法示例-3"><a href="#用法示例-3" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/directory</span><br></pre></td></tr></table></figure><p>这个命令会将当前工作目录更改为指定的目录。</p><h3 id="常见用法-3"><a href="#常见用法-3" class="headerlink" title="常见用法"></a>常见用法</h3><ul><li>返回上一级目录：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure><ul><li>返回用户主目录：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br></pre></td></tr></table></figure><ul><li>切换到上一次访问的目录：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> -</span><br></pre></td></tr></table></figure><ul><li>使用相对路径切换目录：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> subdirectory/</span><br></pre></td></tr></table></figure><p>这个命令会切换到当前目录下的 <code>subdirectory</code> 目录。</p><ul><li>切换到多个目录（使用 <code>pushd</code> 和 <code>popd</code>）：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pushd</span> /path/to/directory</span><br><span class="line"><span class="comment"># ... 在新目录中工作 ...</span></span><br><span class="line"><span class="built_in">popd</span></span><br></pre></td></tr></table></figure><p>这个命令会将当前目录推入目录栈并切换到指定目录，<code>popd</code> 则会返回到之前的目录。</p><h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><p><code>chmod</code> 命令用于更改文件或目录的权限。</p><h3 id="用法示例-4"><a href="#用法示例-4" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 755 filename.txt</span><br></pre></td></tr></table></figure><p>这个命令会将 <code>filename.txt</code> 的权限更改为可读、可写和可执行（所有者），可读和可执行（组和其他用户）。</p><h3 id="常见用法-4"><a href="#常见用法-4" class="headerlink" title="常见用法"></a>常见用法</h3><ul><li>递归更改目录及其内容的权限：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> -R 755 directory_name</span><br></pre></td></tr></table></figure><ul><li>仅添加执行权限：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x filename.sh</span><br></pre></td></tr></table></figure><ul><li>仅移除写权限：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> -w filename.txt</span><br></pre></td></tr></table></figure><ul><li>设置特定权限（如只读）：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 444 filename.txt</span><br></pre></td></tr></table></figure><ul><li>使用符号模式更改权限：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u+x filename.txt  <span class="comment"># 为文件所有者添加执行权限</span></span><br><span class="line"><span class="built_in">chmod</span> g-w filename.txt  <span class="comment"># 从组中移除写权限</span></span><br><span class="line"><span class="built_in">chmod</span> o=r filename.txt  <span class="comment"># 设置其他用户为只读权限</span></span><br></pre></td></tr></table></figure><h2 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h2><p><code>chown</code> 命令用于更改文件或目录的所有者和所属组。</p><h3 id="用法示例-5"><a href="#用法示例-5" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> user:group filename.txt</span><br></pre></td></tr></table></figure><p>这个命令会将 <code>filename.txt</code> 的所有者更改为 <code>user</code>，所属组更改为 <code>group</code>。</p><h3 id="常见用法-5"><a href="#常见用法-5" class="headerlink" title="常见用法"></a>常见用法</h3><ul><li>仅更改文件的所有者：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> user filename.txt</span><br></pre></td></tr></table></figure><ul><li>仅更改文件的所属组：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> :group filename.txt</span><br></pre></td></tr></table></figure><ul><li>递归更改目录及其内容的所有者和所属组：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> -R user:group directory_name</span><br></pre></td></tr></table></figure><ul><li>显示当前文件的所有者和所属组：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l filename.txt</span><br></pre></td></tr></table></figure><ul><li>更改多个文件的所有者：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> user1:usergroup file1.txt file2.txt</span><br></pre></td></tr></table></figure><h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h2><p><code>cp</code> 命令用于复制文件和目录。</p><h3 id="用法示例-6"><a href="#用法示例-6" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> source.txt destination.txt</span><br></pre></td></tr></table></figure><p>这个命令会将 <code>source.txt</code> 文件复制到 <code>destination.txt</code>。</p><h3 id="常见用法-6"><a href="#常见用法-6" class="headerlink" title="常见用法"></a>常见用法</h3><ul><li>复制文件到另一个目录：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> filename.txt /path/to/directory/</span><br></pre></td></tr></table></figure><ul><li>复制目录及其内容（使用 <code>-r</code> 选项）：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r sourcedir/ targetdir/</span><br></pre></td></tr></table></figure><ul><li>复制并重命名文件：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> filename.txt newname.txt</span><br></pre></td></tr></table></figure><ul><li>交互式复制（在覆盖文件前提示确认）：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -i filename.txt destination.txt</span><br></pre></td></tr></table></figure><ul><li>复制文件并保留文件属性：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -p filename.txt destination.txt</span><br></pre></td></tr></table></figure><h2 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h2><p><code>curl</code> 是一个用于在命令行中进行数据传输的工具，支持多种协议，包括 HTTP、HTTPS、FTP 等。</p><h3 id="用法示例-7"><a href="#用法示例-7" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://example.com</span><br></pre></td></tr></table></figure><p>这个命令会从 <code>http://example.com</code> 下载内容并打印到标准输出。</p><h3 id="常见用法-7"><a href="#常见用法-7" class="headerlink" title="常见用法"></a>常见用法</h3><ul><li>下载文件：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -O http://example.com/file.txt</span><br></pre></td></tr></table></figure><ul><li>发送 POST 请求：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -d <span class="string">&quot;param1=value1&amp;param2=value2&quot;</span> http://example.com/api</span><br></pre></td></tr></table></figure><ul><li>添加请求头：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H <span class="string">&quot;Authorization: Bearer TOKEN&quot;</span> http://example.com/api</span><br></pre></td></tr></table></figure><ul><li>显示请求和响应的详细信息：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v http://example.com</span><br></pre></td></tr></table></figure><ul><li>保存输出到文件：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o output.txt http://example.com</span><br></pre></td></tr></table></figure><h2 id="df"><a href="#df" class="headerlink" title="df"></a>df</h2><p><code>df</code> 命令用于显示文件系统的磁盘空间使用情况。</p><h3 id="用法示例-8"><a href="#用法示例-8" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span></span><br></pre></td></tr></table></figure><p>这个命令会显示所有挂载的文件系统的磁盘使用情况。</p><h3 id="常见用法-8"><a href="#常见用法-8" class="headerlink" title="常见用法"></a>常见用法</h3><ul><li>以人类可读的格式显示（例如，KB、MB、GB）：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br></pre></td></tr></table></figure><ul><li>显示特定文件系统的信息：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> /path/to/directory</span><br></pre></td></tr></table></figure><ul><li>显示所有文件系统，包括虚拟文件系统：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -a</span><br></pre></td></tr></table></figure><ul><li>显示 inode 使用情况：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -i</span><br></pre></td></tr></table></figure><p>这个命令会显示每个文件系统的 inode 使用情况。</p><h2 id="du"><a href="#du" class="headerlink" title="du"></a>du</h2><p><code>du</code> 命令用于显示目录或文件的磁盘使用情况。</p><h3 id="用法示例-9"><a href="#用法示例-9" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> /path/to/directory</span><br></pre></td></tr></table></figure><p>这个命令会显示指定目录及其子目录的磁盘使用情况。</p><h3 id="常见用法-9"><a href="#常见用法-9" class="headerlink" title="常见用法"></a>常见用法</h3><ul><li>显示指定目录的总大小：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -sh /path/to/directory</span><br></pre></td></tr></table></figure><p>这个命令会以人类可读的格式（如 KB、MB、GB）显示指定目录的总大小。</p><ul><li>显示每个子目录的大小：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -h /path/to/directory</span><br></pre></td></tr></table></figure><p>这个命令会以人类可读的格式显示指定目录下每个子目录的大小。</p><ul><li>递归显示所有子目录的大小：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -ah /path/to/directory</span><br></pre></td></tr></table></figure><p>这个命令会显示指定目录及其所有子目录和文件的大小。</p><ul><li>按大小排序显示：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -sh /path/to/directory/* | <span class="built_in">sort</span> -h</span><br></pre></td></tr></table></figure><p>这个命令会显示指定目录下每个文件和子目录的大小，并按大小排序。</p><ul><li>显示特定深度的目录大小：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -h --max-depth=1 /path/to/directory</span><br></pre></td></tr></table></figure><p>这个命令会显示指定目录下的每个子目录的大小，但只显示到第一层深度。</p><ul><li>显示文件系统的使用情况：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -x /path/to/directory</span><br></pre></td></tr></table></figure><p>这个命令会限制 <code>du</code> 只计算指定目录所在的文件系统的大小。</p><h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2><p><code>echo</code> 命令用于在终端输出文本或变量的值。</p><h3 id="用法示例-10"><a href="#用法示例-10" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure><p>这个命令会在终端打印 <code>Hello, World!</code>。</p><h3 id="常见用法-10"><a href="#常见用法-10" class="headerlink" title="常见用法"></a>常见用法</h3><ul><li>输出变量的值：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name=<span class="string">&quot;Alice&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello, <span class="variable">$name</span>!&quot;</span></span><br></pre></td></tr></table></figure><ul><li>输出带有换行符的文本：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;Line 1\nLine 2&quot;</span></span><br></pre></td></tr></table></figure><ul><li>不输出换行符：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;This is on the same line.&quot;</span></span><br></pre></td></tr></table></figure><ul><li>输出带有特殊字符的文本：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This is a dollar sign: \$&quot;</span></span><br></pre></td></tr></table></figure><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p><code>find</code> 命令用于在目录中查找文件和目录，支持多种搜索条件。</p><h3 id="用法示例-11"><a href="#用法示例-11" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path/to/directory -name <span class="string">&quot;filename.txt&quot;</span></span><br></pre></td></tr></table></figure><p>这个命令会在指定目录中查找名为 <code>filename.txt</code> 的文件。</p><h3 id="常见用法-11"><a href="#常见用法-11" class="headerlink" title="常见用法"></a>常见用法</h3><ul><li>查找特定类型的文件：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path/to/directory -<span class="built_in">type</span> f -name <span class="string">&quot;*.txt&quot;</span></span><br></pre></td></tr></table></figure><p>这个命令会查找所有以 <code>.txt</code> 结尾的文件。</p><ul><li>按文件大小查找：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path/to/directory -size +10M</span><br></pre></td></tr></table></figure><p>这个命令会查找大于 10MB 的文件。</p><ul><li>按修改时间查找：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path/to/directory -mtime -7</span><br></pre></td></tr></table></figure><p>这个命令会查找最近 7 天内修改过的文件。</p><ul><li>查找并执行命令：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path/to/directory -name <span class="string">&quot;*.log&quot;</span> -<span class="built_in">exec</span> <span class="built_in">rm</span> &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>这个命令会查找所有 <code>.log</code> 文件并删除它们。</p><ul><li>查找并显示详细信息：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path/to/directory -name <span class="string">&quot;*.txt&quot;</span> -<span class="built_in">print</span></span><br></pre></td></tr></table></figure><p>这个命令会查找所有 <code>.txt</code> 文件并打印其路径。</p><ul><li>查找空文件：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path/to/directory -<span class="built_in">type</span> f -empty</span><br></pre></td></tr></table></figure><p>这个命令会查找所有空文件。</p><ul><li>查找特定用户的文件：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path/to/directory -user username</span><br></pre></td></tr></table></figure><p>这个命令会查找属于指定用户的文件。</p><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p><code>grep</code> 命令用于在文件中搜索指定的模式，并打印匹配的行。</p><h3 id="用法示例-12"><a href="#用法示例-12" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&quot;pattern&quot;</span> filename.txt</span><br></pre></td></tr></table></figure><p>这个命令会在 <code>filename.txt</code> 文件中搜索包含 <code>pattern</code> 的行并打印出来。</p><h3 id="常见用法-12"><a href="#常见用法-12" class="headerlink" title="常见用法"></a>常见用法</h3><ul><li>忽略大小写搜索：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -i <span class="string">&quot;pattern&quot;</span> filename.txt</span><br></pre></td></tr></table></figure><ul><li>显示行号：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -n <span class="string">&quot;pattern&quot;</span> filename.txt</span><br></pre></td></tr></table></figure><ul><li>递归搜索目录中的文件：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r <span class="string">&quot;pattern&quot;</span> /path/to/directory/</span><br></pre></td></tr></table></figure><ul><li>只显示匹配的部分：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -o <span class="string">&quot;pattern&quot;</span> filename.txt</span><br></pre></td></tr></table></figure><ul><li>反向匹配（显示不包含模式的行）：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -v <span class="string">&quot;pattern&quot;</span> filename.txt</span><br></pre></td></tr></table></figure><h2 id="head"><a href="#head" class="headerlink" title="head"></a>head</h2><p><code>head</code> 命令用于显示文件的开头部分，默认情况下显示前 10 行。</p><h3 id="用法示例-13"><a href="#用法示例-13" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> filename.txt</span><br></pre></td></tr></table></figure><p>这个命令会打印 <code>filename.txt</code> 文件的前 10 行。</p><h3 id="常见用法-13"><a href="#常见用法-13" class="headerlink" title="常见用法"></a>常见用法</h3><ul><li>显示指定行数的开头部分：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> -n 5 filename.txt</span><br></pre></td></tr></table></figure><p>这个命令会打印 <code>filename.txt</code> 文件的前 5 行。</p><ul><li>显示多个文件的开头部分：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> file1.txt file2.txt</span><br></pre></td></tr></table></figure><ul><li>显示文件的字节数：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> -c 20 filename.txt</span><br></pre></td></tr></table></figure><p>这个命令会打印 <code>filename.txt</code> 文件的前 20 个字节。</p><h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><p><code>history</code> 命令用于显示用户在当前会话中输入的命令历史记录。</p><h3 id="用法示例-14"><a href="#用法示例-14" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span></span><br></pre></td></tr></table></figure><p>这个命令会列出当前用户在终端中输入的所有命令。</p><h3 id="常见用法-14"><a href="#常见用法-14" class="headerlink" title="常见用法"></a>常见用法</h3><ul><li>显示最近的命令数量：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> 10</span><br></pre></td></tr></table></figure><p>这个命令会显示最近输入的 10 条命令。</p><ul><li>重新执行某条命令：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!n</span><br></pre></td></tr></table></figure><p>其中 <code>n</code> 是命令在历史记录中的编号。例如，<code>!5</code> 会重新执行历史记录中编号为 5 的命令。</p><ul><li>清空命令历史：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> -c</span><br></pre></td></tr></table></figure><p>这个命令会清空当前会话的命令历史记录。</p><ul><li>将历史记录保存到文件：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> &gt; history.txt</span><br></pre></td></tr></table></figure><p>这个命令会将当前会话的命令历史保存到 <code>history.txt</code> 文件中。</p><ul><li>使用 <code>grep</code> 搜索历史记录：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> | grep <span class="string">&quot;pattern&quot;</span></span><br></pre></td></tr></table></figure><p>这个命令会在历史记录中搜索包含 <code>pattern</code> 的命令。</p><ul><li>在命令行中使用上一个命令：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!!</span><br></pre></td></tr></table></figure><p>这个命令会重新执行上一个输入的命令。</p><h2 id="kill-killall"><a href="#kill-killall" class="headerlink" title="kill/killall"></a>kill/killall</h2><p><code>kill</code> 命令用于向进程发送信号，通常用于终止进程。</p><h3 id="用法示例-15"><a href="#用法示例-15" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> PID</span><br></pre></td></tr></table></figure><p>这个命令会向指定的进程 ID（PID）发送终止信号。</p><h3 id="常见用法-15"><a href="#常见用法-15" class="headerlink" title="常见用法"></a>常见用法</h3><ul><li>强制终止进程：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 PID</span><br></pre></td></tr></table></figure><p>这个命令会强制终止指定的进程。</p><ul><li>发送其他信号（如停止进程）：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -STOP PID</span><br></pre></td></tr></table></figure><ul><li>查看所有进程并找到 PID：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep process_name</span><br></pre></td></tr></table></figure><ul><li>终止所有匹配的进程：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall process_name</span><br></pre></td></tr></table></figure><h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><p><code>ls</code> 命令用于列出目录中的文件和子目录。</p><h3 id="用法示例-16"><a href="#用法示例-16" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p>这个命令会列出当前目录中的所有文件和子目录。</p><h3 id="常见用法-16"><a href="#常见用法-16" class="headerlink" title="常见用法"></a>常见用法</h3><ul><li>列出详细信息（包括权限、所有者、大小等）：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l</span><br></pre></td></tr></table></figure><ul><li>列出所有文件，包括隐藏文件（以点开头的文件）：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -a</span><br></pre></td></tr></table></figure><ul><li>以人类可读的格式显示文件大小：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -lh</span><br></pre></td></tr></table></figure><ul><li>按时间排序列出文件：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -lt</span><br></pre></td></tr></table></figure><ul><li>递归列出所有子目录中的文件：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -R</span><br></pre></td></tr></table></figure><ul><li>列出特定类型的文件（例如，只列出目录）：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -d */</span><br></pre></td></tr></table></figure><h2 id="man"><a href="#man" class="headerlink" title="man"></a>man</h2><p><code>man</code> 命令用于查看其他命令的手册页，提供命令的详细信息和用法。</p><h3 id="用法示例-17"><a href="#用法示例-17" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man command_name</span><br></pre></td></tr></table></figure><p>这个命令会显示 <code>command_name</code> 的手册页。</p><h3 id="常见用法-17"><a href="#常见用法-17" class="headerlink" title="常见用法"></a>常见用法</h3><ul><li>查看特定命令的手册页：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><ul><li>搜索手册页中的关键字：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man -k keyword</span><br></pre></td></tr></table></figure><p>这个命令会列出所有包含 <code>keyword</code> 的手册页。</p><ul><li>查看手册页的特定部分（例如，用户命令、系统调用等）：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">man 1 command_name  <span class="comment"># 用户命令</span></span><br><span class="line">man 2 command_name  <span class="comment"># 系统调用</span></span><br><span class="line">man 3 command_name  <span class="comment"># 库函数</span></span><br></pre></td></tr></table></figure><ul><li><p>在手册页中向上或向下滚动：<br>使用 <code>↑</code> 和 <code>↓</code> 键进行滚动，使用 <code>q</code> 键退出手册页。</p></li><li><p>查看手册页的帮助信息：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man man</span><br></pre></td></tr></table></figure><p>这个命令会显示 <code>man</code> 命令本身的手册页。</p><h2 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h2><p><code>mv</code> 命令用于移动或重命名文件和目录。</p><h3 id="用法示例-18"><a href="#用法示例-18" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> oldname.txt newname.txt</span><br></pre></td></tr></table></figure><p>这个命令会将 <code>oldname.txt</code> 文件重命名为 <code>newname.txt</code>。</p><h3 id="常见用法-18"><a href="#常见用法-18" class="headerlink" title="常见用法"></a>常见用法</h3><ul><li>移动文件到另一个目录：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> filename.txt /path/to/directory/</span><br></pre></td></tr></table></figure><ul><li>移动并重命名文件：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> filename.txt /path/to/directory/newname.txt</span><br></pre></td></tr></table></figure><ul><li>交互式移动（在覆盖文件前提示确认）：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> -i filename.txt /path/to/directory/</span><br></pre></td></tr></table></figure><ul><li>强制移动（不提示确认）：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> -f filename.txt /path/to/directory/</span><br></pre></td></tr></table></figure><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p><code>ps</code> 命令用于显示当前运行的进程信息。</p><h3 id="用法示例-19"><a href="#用法示例-19" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps</span><br></pre></td></tr></table></figure><p>这个命令会列出当前用户的所有进程。</p><h3 id="常见用法-19"><a href="#常见用法-19" class="headerlink" title="常见用法"></a>常见用法</h3><ul><li>显示所有进程，包括其他用户的进程：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -e</span><br></pre></td></tr></table></figure><ul><li>显示详细信息：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -f</span><br></pre></td></tr></table></figure><ul><li>显示进程树：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ejH</span><br></pre></td></tr></table></figure><ul><li>显示特定用户的进程：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -u username</span><br></pre></td></tr></table></figure><ul><li>显示与特定命令相关的进程：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -C command_name</span><br></pre></td></tr></table></figure><h2 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h2><p><code>pwd</code> 命令用于显示当前工作目录的完整路径。</p><h3 id="用法示例-20"><a href="#用法示例-20" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure><p>这个命令会打印当前工作目录的绝对路径。</p><h3 id="常见用法-20"><a href="#常见用法-20" class="headerlink" title="常见用法"></a>常见用法</h3><ul><li>在脚本中使用 <code>pwd</code> 获取当前目录：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">current_dir=$(<span class="built_in">pwd</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;当前目录是: <span class="variable">$current_dir</span>&quot;</span></span><br></pre></td></tr></table></figure><ul><li>与其他命令结合使用：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/directory &amp;&amp; <span class="built_in">pwd</span></span><br></pre></td></tr></table></figure><p>这个命令会切换到指定目录并显示该目录的路径。</p><h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><p><code>rm</code> 命令用于删除文件和目录。</p><h3 id="用法示例-21"><a href="#用法示例-21" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> filename.txt</span><br></pre></td></tr></table></figure><p>这个命令会删除 <code>filename.txt</code> 文件。</p><h3 id="常见用法-21"><a href="#常见用法-21" class="headerlink" title="常见用法"></a>常见用法</h3><ul><li>删除多个文件：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> file1.txt file2.txt</span><br></pre></td></tr></table></figure><ul><li>递归删除目录及其内容（使用 <code>-r</code> 选项）：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -r directory_name</span><br></pre></td></tr></table></figure><ul><li>强制删除文件（不提示确认）：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -f filename.txt</span><br></pre></td></tr></table></figure><ul><li>交互式删除（在删除前提示确认）：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -i filename.txt</span><br></pre></td></tr></table></figure><ul><li>删除空目录：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rmdir</span> directory_name</span><br></pre></td></tr></table></figure><h2 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h2><p><code>scp</code> 命令用于在本地和远程主机之间安全地复制文件。</p><h3 id="用法示例-22"><a href="#用法示例-22" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp localfile.txt user@remotehost:/path/to/destination</span><br></pre></td></tr></table></figure><p>这个命令会将本地的 <code>localfile.txt</code> 文件复制到远程主机的指定路径。</p><h3 id="常见用法-22"><a href="#常见用法-22" class="headerlink" title="常见用法"></a>常见用法</h3><ul><li>从远程主机复制文件到本地：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp user@remotehost:/path/to/remotefile.txt /local/path</span><br></pre></td></tr></table></figure><ul><li>递归复制整个目录：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r localdir user@remotehost:/path/to/destination</span><br></pre></td></tr></table></figure><ul><li>使用特定端口进行连接：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -P 2222 localfile.txt user@remotehost:/path/to/destination</span><br></pre></td></tr></table></figure><ul><li>复制文件并保留文件属性：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -p localfile.txt user@remotehost:/path/to/destination</span><br></pre></td></tr></table></figure><ul><li>显示详细的传输过程：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -v localfile.txt user@remotehost:/path/to/destination</span><br></pre></td></tr></table></figure><h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><p><code>sed</code> 是一个流编辑器，用于对文本进行基本的转换和处理。</p><h3 id="用法示例-23"><a href="#用法示例-23" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/old/new/&#x27;</span> filename.txt</span><br></pre></td></tr></table></figure><p>这个命令会将 <code>filename.txt</code> 文件中每一行的第一个 <code>old</code> 替换为 <code>new</code>。</p><h3 id="常见用法-23"><a href="#常见用法-23" class="headerlink" title="常见用法"></a>常见用法</h3><ul><li>替换文件中的所有匹配项：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/old/new/g&#x27;</span> filename.txt</span><br></pre></td></tr></table></figure><ul><li>在特定行进行替换：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;2s/old/new/&#x27;</span> filename.txt</span><br></pre></td></tr></table></figure><p>这个命令会在第二行中将 <code>old</code> 替换为 <code>new</code>。</p><ul><li>删除特定行：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;3d&#x27;</span> filename.txt</span><br></pre></td></tr></table></figure><p>这个命令会删除 <code>filename.txt</code> 文件的第三行。</p><ul><li>直接修改文件（使用 <code>-i</code> 选项）：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/old/new/g&#x27;</span> filename.txt</span><br></pre></td></tr></table></figure><ul><li>显示行号：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed = filename.txt | sed <span class="string">&#x27;N;s/\n/ /&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><p><code>ssh</code> 命令用于安全地远程登录到另一台计算机。</p><h3 id="用法示例-24"><a href="#用法示例-24" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh user@remotehost</span><br></pre></td></tr></table></figure><p>这个命令会以 <code>user</code> 用户身份登录到 <code>remotehost</code>。</p><h3 id="常见用法-24"><a href="#常见用法-24" class="headerlink" title="常见用法"></a>常见用法</h3><ul><li>使用特定端口进行连接：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 2222 user@remotehost</span><br></pre></td></tr></table></figure><ul><li>在登录时执行命令：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh user@remotehost <span class="string">&#x27;command_to_run&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>使用密钥文件进行身份验证：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i /path/to/private_key user@remotehost</span><br></pre></td></tr></table></figure><ul><li>进行端口转发：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -L local_port:remotehost:remote_port user@remotehost</span><br></pre></td></tr></table></figure><ul><li>复制文件到远程主机（使用 <code>scp</code>）：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp localfile.txt user@remotehost:/path/to/destination</span><br></pre></td></tr></table></figure><h2 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h2><p><code>tail</code> 命令用于显示文件的结尾部分，默认情况下显示最后 10 行。</p><h3 id="用法示例-25"><a href="#用法示例-25" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> filename.txt</span><br></pre></td></tr></table></figure><p>这个命令会打印 <code>filename.txt</code> 文件的最后 10 行。</p><h3 id="常见用法-25"><a href="#常见用法-25" class="headerlink" title="常见用法"></a>常见用法</h3><ul><li>显示指定行数的结尾部分：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -n 5 filename.txt</span><br></pre></td></tr></table></figure><p>这个命令会打印 <code>filename.txt</code> 文件的最后 5 行。</p><ul><li>实时查看文件的新增内容（类似于日志文件）：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -f filename.txt</span><br></pre></td></tr></table></figure><ul><li>显示多个文件的结尾部分：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> file1.txt file2.txt</span><br></pre></td></tr></table></figure><ul><li>显示文件的字节数：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -c 20 filename.txt</span><br></pre></td></tr></table></figure><p>这个命令会打印 <code>filename.txt</code> 文件的最后 20 个字节。</p><h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><p><code>tar</code> 命令用于打包和压缩文件，常用于备份和传输文件。</p><h3 id="用法示例-26"><a href="#用法示例-26" class="headerlink" title="用法示例"></a>用法示例</h3><ul><li>创建一个 tar 包：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf archive.tar /path/to/directory</span><br></pre></td></tr></table></figure><p>这个命令会将指定目录打包成 <code>archive.tar</code> 文件。</p><h3 id="常见用法-26"><a href="#常见用法-26" class="headerlink" title="常见用法"></a>常见用法</h3><ul><li>创建一个压缩的 tar.gz 包：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czvf archive.tar.gz /path/to/directory</span><br></pre></td></tr></table></figure><p>这个命令会将指定目录打包并压缩成 <code>archive.tar.gz</code> 文件。</p><ul><li>解压 tar 包：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf archive.tar</span><br></pre></td></tr></table></figure><p>这个命令会解压 <code>archive.tar</code> 文件。</p><ul><li>解压 tar.gz 包：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf archive.tar.gz</span><br></pre></td></tr></table></figure><p>这个命令会解压 <code>archive.tar.gz</code> 文件。</p><ul><li>查看 tar 包内容：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -tvf archive.tar</span><br></pre></td></tr></table></figure><p>这个命令会列出 <code>archive.tar</code> 文件中的内容。</p><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p><code>top</code> 命令用于实时显示系统中正在运行的进程和系统资源的使用情况。</p><h3 id="用法示例-27"><a href="#用法示例-27" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure><p>这个命令会打开一个动态更新的界面，显示当前系统的进程信息和资源使用情况。</p><h3 id="常见用法-27"><a href="#常见用法-27" class="headerlink" title="常见用法"></a>常见用法</h3><ul><li><p>显示进程的详细信息：<br>在 <code>top</code> 界面中，可以按 <code>Shift + M</code> 按内存使用量排序，按 <code>Shift + P</code> 按 CPU 使用量排序。</p></li><li><p>结束进程：<br>在 <code>top</code> 界面中，按 <code>k</code> 键，然后输入要结束的进程 ID（PID），最后按 <code>Enter</code>。</p></li><li><p>刷新间隔：<br>在 <code>top</code> 界面中，按 <code>d</code> 键可以设置刷新间隔（以秒为单位）。</p></li><li><p>显示帮助信息：<br>在 <code>top</code> 界面中，按 <code>h</code> 键可以查看帮助信息。</p></li><li><p>退出 <code>top</code>：<br>在 <code>top</code> 界面中，按 <code>q</code> 键可以退出。</p></li></ul><h2 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h2><p><code>touch</code> 命令用于创建空文件或更新文件的时间戳。</p><h3 id="用法示例-28"><a href="#用法示例-28" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> filename.txt</span><br></pre></td></tr></table></figure><p>这个命令会创建一个名为 <code>filename.txt</code> 的空文件，如果文件已存在，则更新其最后修改时间。</p><h3 id="常见用法-28"><a href="#常见用法-28" class="headerlink" title="常见用法"></a>常见用法</h3><ul><li>创建多个空文件：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> file1.txt file2.txt file3.txt</span><br></pre></td></tr></table></figure><ul><li>更新文件的时间戳：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> existingfile.txt</span><br></pre></td></tr></table></figure><ul><li>创建带有特定时间戳的文件：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> -t 202301010101 filename.txt</span><br></pre></td></tr></table></figure><p>这个命令会将 <code>filename.txt</code> 的时间戳设置为 2023 年 1 月 1 日 01:01。</p><ul><li>使用当前时间戳创建文件：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> -a filename.txt</span><br></pre></td></tr></table></figure><p>这个命令会更新 <code>filename.txt</code> 的访问时间为当前时间。</p><h2 id="vi"><a href="#vi" class="headerlink" title="vi"></a>vi</h2><p><code>vi</code> 是一个强大的文本编辑器，广泛用于 Unix 和 Linux 系统中。</p><h3 id="用法示例-29"><a href="#用法示例-29" class="headerlink" title="用法示例"></a>用法示例</h3><p>打开文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi filename.txt</span><br></pre></td></tr></table></figure><p>这个命令会打开 <code>filename.txt</code> 文件进行编辑。</p><h3 id="常见用法-29"><a href="#常见用法-29" class="headerlink" title="常见用法"></a>常见用法</h3><ul><li><p>进入插入模式：<br>在命令模式下，按 <code>i</code> 进入插入模式，可以开始编辑文本。</p></li><li><p>保存并退出：<br>在命令模式下，输入 <code>:wq</code> 保存文件并退出 <code>vi</code>。</p></li><li><p>仅保存：<br>在命令模式下，输入 <code>:w</code> 仅保存文件而不退出。</p></li><li><p>退出不保存：<br>在命令模式下，输入 <code>:q!</code> 强制退出而不保存更改。</p></li><li><p>删除行：<br>在命令模式下，输入 <code>dd</code> 删除当前行。</p></li><li><p>撤销操作：<br>在命令模式下，输入 <code>u</code> 撤销上一步操作。</p></li><li><p>查找文本：<br>在命令模式下，输入 <code>/pattern</code> 查找指定的 <code>pattern</code>。</p></li><li><p>替换文本：<br>在命令模式下，输入 <code>:%s/old/new/g</code> 将文件中的所有 <code>old</code> 替换为 <code>new</code>。</p></li></ul><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><p><code>vim</code> 是 <code>vi</code> 的增强版，提供了更多功能和更好的用户体验。</p><h3 id="用法示例-30"><a href="#用法示例-30" class="headerlink" title="用法示例"></a>用法示例</h3><p>打开文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim filename.txt</span><br></pre></td></tr></table></figure><p>这个命令会打开 <code>filename.txt</code> 文件进行编辑。</p><h3 id="常见用法-30"><a href="#常见用法-30" class="headerlink" title="常见用法"></a>常见用法</h3><ul><li><p>进入插入模式：<br>在命令模式下，按 <code>i</code> 进入插入模式，可以开始编辑文本。</p></li><li><p>保存并退出：<br>在命令模式下，输入 <code>:wq</code> 保存文件并退出 <code>vim</code>。</p></li><li><p>仅保存：<br>在命令模式下，输入 <code>:w</code> 仅保存文件而不退出。</p></li><li><p>退出不保存：<br>在命令模式下，输入 <code>:q!</code> 强制退出而不保存更改。</p></li><li><p>删除行：<br>在命令模式下，输入 <code>dd</code> 删除当前行。</p></li><li><p>撤销操作：<br>在命令模式下，输入 <code>u</code> 撤销上一步操作。</p></li><li><p>查找文本：<br>在命令模式下，输入 <code>/pattern</code> 查找指定的 <code>pattern</code>。</p></li><li><p>替换文本：<br>在命令模式下，输入 <code>:%s/old/new/g</code> 将文件中的所有 <code>old</code> 替换为 <code>new</code>。</p></li><li><p>显示行号：<br>在命令模式下，输入 <code>:set number</code> 显示行号。</p></li><li><p>语法高亮：<br>在命令模式下，输入 <code>:syntax on</code> 启用语法高亮。</p></li></ul><h2 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h2><p><code>wget</code> 是一个用于从网络下载文件的命令行工具，支持 HTTP、HTTPS 和 FTP 协议。</p><h3 id="用法示例-31"><a href="#用法示例-31" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://example.com/file.txt</span><br></pre></td></tr></table></figure><p>这个命令会从指定的 URL 下载 <code>file.txt</code> 文件。</p><h3 id="常见用法-31"><a href="#常见用法-31" class="headerlink" title="常见用法"></a>常见用法</h3><ul><li>下载文件并指定输出文件名：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O newname.txt http://example.com/file.txt</span><br></pre></td></tr></table></figure><ul><li>递归下载整个网站：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -r http://example.com</span><br></pre></td></tr></table></figure><ul><li>限制下载速度：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --limit-rate=200k http://example.com/file.txt</span><br></pre></td></tr></table></figure><ul><li>继续未完成的下载：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -c http://example.com/file.txt</span><br></pre></td></tr></table></figure><ul><li>下载时不显示进度条：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -q http://example.com/file.txt</span><br></pre></td></tr></table></figure><ul><li>下载多个文件：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -i filelist.txt</span><br></pre></td></tr></table></figure><p>这个命令会从 <code>filelist.txt</code> 文件中读取 URL 并下载。</p><h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><p><code>xargs</code> 命令用于将标准输入的数据转换为命令行参数，常用于处理大量数据。</p><h3 id="用法示例-32"><a href="#用法示例-32" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;file1.txt file2.txt file3.txt&quot;</span> | xargs <span class="built_in">rm</span></span><br></pre></td></tr></table></figure><p>这个命令会删除 <code>file1.txt</code>、<code>file2.txt</code> 和 <code>file3.txt</code> 文件。</p><h3 id="常见用法-32"><a href="#常见用法-32" class="headerlink" title="常见用法"></a>常见用法</h3><ul><li>从文件中读取参数：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xargs -a filelist.txt <span class="built_in">rm</span></span><br></pre></td></tr></table></figure><p>这个命令会从 <code>filelist.txt</code> 文件中读取文件名并删除它们。</p><ul><li>限制每次执行的命令参数数量：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">&quot;*.txt&quot;</span> | xargs -n 2 <span class="built_in">rm</span></span><br></pre></td></tr></table></figure><p>这个命令会每次删除两个 <code>.txt</code> 文件。</p><ul><li>使用自定义分隔符：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;file1.txt,file2.txt,file3.txt&quot;</span> | xargs -d <span class="string">&#x27;,&#x27;</span> <span class="built_in">rm</span></span><br></pre></td></tr></table></figure><p>这个命令会使用逗号作为分隔符来删除文件。</p><ul><li>与其他命令结合使用：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">&quot;*.log&quot;</span> | xargs grep <span class="string">&quot;error&quot;</span></span><br></pre></td></tr></table></figure><p>这个命令会在所有 <code>.log</code> 文件中搜索包含 “error” 的行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端常用node包</title>
      <link href="/blog/2023/09/27/FE-%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81node%E5%8C%85/"/>
      <url>/blog/2023/09/27/FE-%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81node%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>以下列举了一些前端常见node包，包括项目中引入的包和编译使用到的包，排除了知名的框架库、UI库或者工具库。开发用常见于 package.json 的 dependency 中，编译用常见于 package.json 的 devDependecy 中。</p><p>开发用：<br><a href="https://github.com/MikeMcl/big.js#readme">big.js</a>: A small, fast, easy-to-use library for arbitrary-precision decimal arithmetic<br><a href="https://github.com/thlorenz/brace">brace</a>: browserify compatible version of the ace editor.<br><a href="https://github.com/JedWatson/classnames#readme">classnames</a>: A simple utility for conditionally joining classNames together<br><a href="https://github.com/nodeca/pako#readme">pako</a>: zlib port to javascript - fast, modularized, with browser support<br><a href="http://github.com/brix/crypto-js">crypto-js</a>: JavaScript library of crypto standards.<br><a href="https://day.js.org">day.js</a>: 2KB immutable date time library alternative to Moment.js with the same modern API<br><a href="https://github.com/tsayen/dom-to-image#readme">dom-to-image</a>: Generates an image from a DOM node using HTML5 canvas and SVG<br><a href="https://echarts.apache.org">echarts</a>: Apache ECharts is a powerful, interactive charting and data visualization library for browser<br><a href="https://github.com/ecomfe/echarts-gl#readme">echarts-gl</a>: Extension pack of ECharts providing 3D plots and globe visualization<br><a href="http://www.travistidwell.com/jsencrypt">encryptlong</a>: js encrypt<br><a href="https://github.com/eligrey/FileSaver.js#readme">file-saver</a>: An HTML5 saveAs() FileSaver implementation<br><a href="https://handsontable.com/">handsontable</a>: Handsontable is a JavaScript Spreadsheet Component available for React, Angular and Vue.<br><a href="mutate a copy of data without changing the original source">immutability-helper</a>: https://github.com/kolodny/immutability-helper#readme<br><a href="https://github.com/localForage/localForage">localForage</a>: Offline storage, improved.<br><a href="https://lodash.com/">lodash</a>: Lodash modular utilities.</p><p>编译用：</p><p><a href="https://github.com/kentcdodds/cross-env">cross-env</a>: Run scripts that set and use environment variables across platforms<br><a href="https://eslint.org">eslint</a>: An AST-based pattern checker for JavaScript.<br><a href="https://typicode.github.io/husky">husky</a>: Modern native Git hooks made easy<br><a href="https://prettier.io">prettier</a>: Prettier is an opinionated code formatter<br><a href="https://stylelint.io">stylelint</a>: A mighty CSS linter that helps you avoid errors and enforce conventions.<br><a href="https://github.com/cssnano/cssnano">cssnano</a>: A modular minifier, built on top of the PostCSS ecosystem.<br><a href="https://github.com/postcss/autoprefixer#readme">autoprefixer</a>: Parse CSS and add vendor prefixes to CSS rules using values from the Can I Use website<br><a href="https://github.com/browserify/commonjs-assert">assert</a>: The assert module from Node.js, for the browser.<br><a href="https://github.com/feross/buffer">buffer</a>: Node.js Buffer API, for the browser<br><a href="https://github.com/chalk/chalk#readme">chalk</a>: Terminal string styling done right<br><a href="https://github.com/crypto-browserify/crypto-browserify">crypto-browserify</a>: implementation of crypto for the browser<br><a href="https://github.com/devongovett/browserify-zlib">browserify-zlib</a>: Full zlib module for the browser<br><a href="https://github.com/jprichardson/node-fs-extra">fs-extra</a>: fs-extra contains methods that aren’t included in the vanilla Node.js fs package. Such as recursive mkdir, copy, and remove.<br><a href="https://github.com/sindresorhus/get-port#readme">get-port</a>: Get an available port<br><a href="https://github.com/isaacs/node-glob#readme">glob</a>: the most correct and second fastest glob implementation in JavaScript<br><a href="https://github.com/indutny/node-ip">ip</a>: IP address tools for node.js<br><a href="https://github.com/minimistjs/minimist">minimist</a>: parse argument options<br><a href="https://github.com/browserify/path-browserify">path-browserify</a>: the path module from node core for browsers<br><a href="https://github.com/browserify/stream-browserify">stream-browserify</a>: the stream module from node core for browsers<br><a href="https://github.com/defunctzombie/node-url#readme">url</a>: The core <code>url</code> packaged standalone for use with Browserify.<br><a href="https://github.com/browserify/node-util">util</a>: Node.js’s util module for all engines<br><a href="https://github.com/substack/vm-browserify#readme">vm</a>: vm module for the browser<br><a href="https://github.com/SBoudrias/Inquirer.js">inquirer</a>: A collection of common interactive command line user interfaces.<br><a href="https://github.com/ZJONSSON/node-unzipper#readme">unzipper</a>: Unzip cross-platform streaming API<br><a href="https://github.com/isaacs/rimraf">rimraf</a>: The UNIX command <code>rm -rf</code> for node.</p>]]></content>
      
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> software </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件包管理工具</title>
      <link href="/blog/2023/09/25/CS-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
      <url>/blog/2023/09/25/CS-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h2><p><a href="https://brew.sh/">Homebrew</a> 是 macOS 上最流行的软件包管理工具，允许用户轻松安装和管理软件包。<br><a href="https://github.com/Homebrew">Homebrew</a></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>简单易用，命令直观。</li><li>拥有丰富的软件库。</li><li>社区活跃，更新频繁。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>主要针对 macOS，Windows 支持有限。</li><li>某些软件包可能不够稳定。</li></ul><h2 id="Chocolatey"><a href="#Chocolatey" class="headerlink" title="Chocolatey"></a>Chocolatey</h2><p><a href="https://chocolatey.org/">Chocolatey</a> 是 Windows 平台上的软件包管理工具，基于 NuGet。<br><a href="https://github.com/chocolatey">Chocolatey</a></p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>支持大量 Windows 软件。</li><li>可以通过命令行轻松安装和更新软件。</li><li>与 Windows PowerShell 集成良好。</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>依赖于 .NET Framework。</li><li>有些软件包可能需要额外配置。</li></ul><h2 id="Scoop"><a href="#Scoop" class="headerlink" title="Scoop"></a>Scoop</h2><p><a href="https://scoop.sh/">Scoop</a> 是一个 Windows 软件包管理工具，提供了命令行式的安装过程。<br><a href="https://github.com/ScoopInstaller/scoop">Scoop</a></p><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul><li>安装过程简单，不需要管理员权限。</li><li>支持从 GitHub 等源安装软件。</li><li>轻量级，易于使用。</li></ul><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul><li>软件库相对较小。</li><li>主要针对开发者，普通用户可能不太友好。</li></ul><h2 id="APT"><a href="#APT" class="headerlink" title="APT"></a>APT</h2><p><a href="https://wiki.debian.org/Apt">APT</a>（Advanced Package Tool）是 Debian 和 Ubuntu 系统的包管理工具。常用命令为 <code>apt-get</code>。<br><a href="https://github.com/Debian/apt">APT</a></p><h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><ul><li>提供强大的依赖管理。</li><li>软件库丰富，更新频繁。</li><li>支持图形界面和命令行操作。</li></ul><h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><ul><li>主要针对 Debian 系列的 Linux 发行版。</li><li>对于新手用户，命令行操作可能有一定学习曲线。</li></ul><h2 id="YUM"><a href="#YUM" class="headerlink" title="YUM"></a>YUM</h2><p><a href="https://yum.baseurl.org/">YUM</a>（Yellowdog Updater, Modified）是 Red Hat 和 CentOS 系统的包管理工具。</p><h3 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h3><ul><li>支持自动解决依赖关系。</li><li>提供丰富的软件库。</li><li>可以通过命令行轻松管理软件包。</li></ul><h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3><ul><li>主要针对 Red Hat 系列的 Linux 发行版。</li><li>在某些情况下，更新速度可能较慢。</li></ul><h2 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h2><p>NPM（Node Package Manager）是 Node.js 的包管理工具。</p><h3 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h3><ul><li>拥有庞大的 JavaScript 库。</li><li>支持快速安装和更新 Node.js 包。</li><li>与 Node.js 生态系统紧密集成。</li></ul><h3 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h3><ul><li>依赖管理有时可能会出现问题。</li><li>对于大型项目，可能会导致依赖树过于复杂。</li></ul><h2 id="cURL"><a href="#cURL" class="headerlink" title="cURL"></a>cURL</h2><p><a href="https://curl.se/">cURL</a> 是一个命令行数据传输工具，它支持 DICT、FILE、FTP、FTPS、Gopher、HTTP、HTTPS、IMAP、IMAPS、LDAP、LDAPS、POP3、POP3S、RTMP、RTSP、SCP、SFTP、SMB、SMBS、SMTP、SMTPS、Telnet 与 TFTP 等协议。<br><a href="https://github.com/curl/curl">cURL</a></p><h3 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h3><ul><li>支持多种协议，灵活性高。</li><li>可以处理复杂的请求，如表单提交和文件上传。</li><li>支持代理和认证。</li></ul><h3 id="缺点-6"><a href="#缺点-6" class="headerlink" title="缺点"></a>缺点</h3><ul><li>对新手用户可能不太友好，学习曲线较陡。</li><li>在某些情况下，错误信息不够明确。</li></ul><h2 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h2><p><a href="https://www.gnu.org/software/wget/">wget</a> 是 linux 上的命令行下载工具。这是一个 GPL 许可证下的自由软件。wget 支持 HTTP 和 FTP 协议，支持代理服务器和断点续传功能，能够自动递归远程主机的目录，找到合乎条件的文件并将其下载到本地硬盘上；如果必要，wget 将恰当地转换页面中的超链接以在本地生成可浏览的镜像。</p><p><a href="https://github.com/mirror/wget">wget</a></p><h3 id="优点-7"><a href="#优点-7" class="headerlink" title="优点"></a>优点</h3><ul><li>简单易用，适合批量下载。</li><li>支持断点续传，下载中断后可以继续。</li><li>可以递归下载整个网站。</li></ul><h3 id="缺点-7"><a href="#缺点-7" class="headerlink" title="缺点"></a>缺点</h3><ul><li>对于复杂的请求支持有限。</li><li>处理 HTTPS 时可能需要额外配置。</li></ul><h2 id="aira2"><a href="#aira2" class="headerlink" title="aira2"></a>aira2</h2><p><a href="https://github.com/aria2/aria2">aria2</a>是一个轻量级的多协议、多源、跨平台下载实用程序，在命令行中运行。它支持 HTTP/HTTPS、FTP、SFTP、BitTorrent 和 Metalink 。</p><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><ul><li><strong>平台支持</strong>：Homebrew 主要用于 macOS，Chocolatey 和 Scoop 主要用于 Windows，APT 和 YUM 主要用于 Linux，NPM 主要用于 Node.js。</li><li><strong>易用性</strong>：Homebrew 和 Scoop 的安装过程相对简单，而 Chocolatey 和 APT 需要一些额外的配置。</li><li><strong>软件库</strong>：Homebrew 和 NPM 的软件库最为丰富，Chocolatey、APT 和 YUM 的软件库也相对较大，而 Scoop 的软件库较小。</li><li><strong>社区支持</strong>：Homebrew 和 NPM 拥有最活跃的社区，更新频繁。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> package </tag>
            
            <tag> installer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>glob通配符</title>
      <link href="/blog/2023/09/25/CS-glob%E9%80%9A%E9%85%8D%E7%AC%A6/"/>
      <url>/blog/2023/09/25/CS-glob%E9%80%9A%E9%85%8D%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>Unix 早期版本的命令解释器依赖于一个单独的程序来将未引用参数中的通配符扩展为命令：<code>/etc/glob</code>。该程序执行了扩展，并将扩展后的文件路径列表提供给命令执行。其名称是“global command”的缩写。后来，这个功能被提供为库函数 <code>glob()</code>，由 shell 等程序使用。</p><p>glob 通配符早于正则表达式出现，没有正则表达式强大，但提供了简单方便的功用于匹配符合指定模式的文件集合。</p><p>glog 通配符现在常用于执行 <em>命令行</em> 例如 <code>ls *.js</code> 或者在一些 ignore 文件，例如 <code>.gitignore</code> 中，或者用到路径匹配功能的工具，例如代理工具 whistle 支持 glob 路径匹配。</p><h2 id="glob-语法"><a href="#glob-语法" class="headerlink" title="glob 语法"></a>glob 语法</h2><table><thead><tr><th>通配符</th><th>描述</th><th>例子</th><th>匹配</th><th>不匹配</th></tr></thead><tbody><tr><td><code>*</code></td><td>匹配任意数量的任何字符，包括无字符</td><td><code>Law*</code></td><td>Law, Laws, Lawyer</td><td>GrokLaw, La, aw</td></tr><tr><td><code>?</code></td><td>匹配任何 <strong>单个</strong> 字符</td><td><code>?at</code></td><td>Cat, cat, Bat, bat</td><td>at</td></tr><tr><td><code>**</code></td><td>匹配任意数量的文件夹和子文件夹</td><td></td><td></td></tr><tr><td><code>[abc]</code></td><td>匹配括号中给出的一个字符</td><td><code>[CB]at</code></td><td>Cat, Bat</td><td>cat, bat</td></tr><tr><td><code>[a-z]</code></td><td>匹配括号中给出的范围中的一个字符</td><td><code>Letter[0-9]</code></td><td>Letter0, Letter1 … Letter9</td><td>Letters, Letter, Letter10</td></tr><tr><td><code>[!abc]</code> 或 <code>[^abc]</code></td><td>匹配括号中未给出的一个字符</td><td><code>[!C]at</code></td><td>Bat, bat, cat</td><td>Cat</td></tr><tr><td><code>[!a-z]</code></td><td>匹配不在括号内给定范围内的一个字符</td><td><code>Letter[!3-5]</code></td><td>Letter1…</td><td>Letter3 … Letter5, Letterxx</td></tr><tr><td><code>&#123;a,b&#125;</code></td><td>匹配括号中给出的多个字符/通配符</td><td><code>&#123;C,B&#125;at</code></td><td>Cat, Bat</td><td>cat, bat</td></tr><tr><td><code>&#123;start..end&#125;</code></td><td>会匹配连续范围的字符</td><td><code>d&#123;a..d&#125;g</code></td><td>dag, dbg, dcg, ddg</td></tr></tbody></table><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>通配符是先解释，再执行<br>Bash 接收到命令以后，发现里面有通配符，会进行通配符扩展，然后再执行命令。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> a*.txt</span><br><span class="line">ab.txt</span><br></pre></td></tr></table></figure>上面命令的执行过程是，Bash 先将 <code>a*.txt</code> 扩展成 <code>ab.txt</code> ，然后再执行 <code>ls ab.txt</code>。</li><li>通配符不匹配，会原样输出<br>Bash 扩展通配符的时候，发现不存在匹配的文件，会将通配符原样输出。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不存在 r 开头的文件名</span></span><br><span class="line">$ <span class="built_in">echo</span> r*</span><br><span class="line">r*</span><br></pre></td></tr></table></figure>上面代码中，由于不存在 r 开头的文件名，<code>r*</code> 会原样输出。</li><li>只适用于单层路径<br>上面所有通配符只匹配单层路径，不能跨目录匹配，即无法匹配子目录里面的文件。或者说，<code>?</code> 或 <code>*</code> 这样的通配符，不能匹配路径分隔符 <code>（/）</code>。<br>如果要匹配子目录里面的文件，可以写成下面这样：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> */*.txt</span><br></pre></td></tr></table></figure></li><li>可用于文件名<br>Bash 允许文件名使用通配符。这时，引用文件名的时候，需要把文件名放在单引号里面。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">touch</span> <span class="string">&#x27;fo*&#x27;</span></span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">fo*</span><br></pre></td></tr></table></figure></li></ol><h2 id="gitignore"><a href="#gitignore" class="headerlink" title="gitignore"></a>gitignore</h2><p>git 中的 .gitignore 文件可以使用 glob 模式匹配，另外还有一些规则：</p><ul><li>所有空行或者以 <code>#</code> 开头的行都会被 Git 忽略</li><li>匹配模式可以以 <code>/</code> 开头防止递归</li><li>匹配模式可以以 <code>/</code> 结尾指定目录</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号 <code>!</code> 取反</li></ul><h2 id="vite"><a href="#vite" class="headerlink" title="vite"></a>vite</h2><p>Vite 支持使用特殊的 <code>import.meta.glob</code> 函数从文件系统导入多个模块：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> modules = <span class="keyword">import</span>.<span class="property">meta</span>.<span class="title function_">glob</span>(<span class="string">&#x27;./dir/*.js&#x27;</span>);</span><br></pre></td></tr></table></figure><p>以上将会被转译为下面的样子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite 生成的代码</span></span><br><span class="line"><span class="keyword">const</span> modules = &#123;</span><br><span class="line">  <span class="string">&#x27;./dir/foo.js&#x27;</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./dir/foo.js&#x27;</span>),</span><br><span class="line">  <span class="string">&#x27;./dir/bar.js&#x27;</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./dir/bar.js&#x27;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>你可以遍历 modules 对象的 key 值来访问相应的模块：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> path <span class="keyword">in</span> modules) &#123;</span><br><span class="line">  modules[path]().<span class="title function_">then</span>(<span class="function"><span class="params">mod</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(path, mod);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匹配到的文件默认是懒加载的，通过动态导入实现，并会在构建时分离为独立的 chunk。如果你倾向于直接引入所有的模块（例如依赖于这些模块中的副作用首先被应用），你可以传入 <code>&#123; eager: true &#125;</code> 作为第二个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> modules = <span class="keyword">import</span>.<span class="property">meta</span>.<span class="title function_">glob</span>(<span class="string">&#x27;./dir/*.js&#x27;</span>, &#123; <span class="attr">eager</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure><p>以上会被转译为下面的样子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite 生成的代码</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> __glob__0_0 <span class="keyword">from</span> <span class="string">&#x27;./dir/foo.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> __glob__0_1 <span class="keyword">from</span> <span class="string">&#x27;./dir/bar.js&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> modules = &#123;</span><br><span class="line">  <span class="string">&#x27;./dir/foo.js&#x27;</span>: __glob__0_0,</span><br><span class="line">  <span class="string">&#x27;./dir/bar.js&#x27;</span>: __glob__0_1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="相关-node-库"><a href="#相关-node-库" class="headerlink" title="相关 node 库"></a>相关 node 库</h2><p>https://github.com/mrmlnc/fast-glob<br>https://github.com/isaacs/node-glob<br>https://github.com/sindresorhus/globby</p>]]></content>
      
      
      
        <tags>
            
            <tag> unix </tag>
            
            <tag> glob </tag>
            
            <tag> gitignore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pinia小抄</title>
      <link href="/blog/2023/09/22/Vue-Pinia%E5%B0%8F%E6%8A%84/"/>
      <url>/blog/2023/09/22/Vue-Pinia%E5%B0%8F%E6%8A%84/</url>
      
        <content type="html"><![CDATA[<p>Pinia (<code>/piːnjʌ/</code>)是一款类型安全、可扩展以及模块化设计的 Vue.js 状态管理库。</p><h2 id="Pinia-应用示例"><a href="#Pinia-应用示例" class="headerlink" title="Pinia 应用示例"></a>Pinia 应用示例</h2><p>通过 <code>defineStore</code> 先创建一个 Store:</p><figure class="highlight js"><figcaption><span>stores/counter.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCounterStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;counter&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 也可以这样定义</span></span><br><span class="line">  <span class="comment">// state: () =&gt; (&#123; count: 0 &#125;)</span></span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在组件中引入该 Store 并使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">// setup() 函数</span><br><span class="line">import &#123; useCounterStore &#125; from &#x27;@/stores/counter&#x27;;</span><br><span class="line">const counter = useCounterStore();</span><br><span class="line">counter.count++;</span><br><span class="line">// 自动补全</span><br><span class="line">counter.$patch(&#123; count: counter.count + 1 &#125;);</span><br><span class="line">// 或使用 action 代替</span><br><span class="line">counter.increment();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;!-- 直接从 store 中访问 state --&gt;</span><br><span class="line">  &lt;div&gt;Current Count: &#123;&#123; counter.count &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>Pinia 也提供了一组类似 Vuex 的映射 state 的辅助函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> useCounterStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;counter&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;),</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="attr">double</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">count</span> * <span class="number">2</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useUserStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;user&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">// 其他计算属性</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 允许访问 this.counterStore 和 this.userStore</span></span><br><span class="line">    ...<span class="title function_">mapStores</span>(useCounterStore, useUserStore),</span><br><span class="line">    <span class="comment">// 允许读取 this.count 和 this.double</span></span><br><span class="line">    ...<span class="title function_">mapState</span>(useCounterStore, [<span class="string">&#x27;count&#x27;</span>, <span class="string">&#x27;double&#x27;</span>])</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="comment">// 允许读取 this.increment()</span></span><br><span class="line">    ...<span class="title function_">mapActions</span>(useCounterStore, [<span class="string">&#x27;increment&#x27;</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Pinia-应用方式"><a href="#Pinia-应用方式" class="headerlink" title="Pinia 应用方式"></a>Pinia 应用方式</h2><p>使用包管理器安装 Pinia:</p><ul><li>Yarn: <code>yarn add pinia</code></li><li>NPM: <code>npm install pinia</code></li></ul><p>Pinia 使用到了组合式 API，如果你是用的 Vue&lt;2.7版本，还需要安装组合式API包： <code>@vue/composition-api</code> 。</p><p>在 Vue3 中，创建一个 pinia 实例 并将其传递给应用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createPinia &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pinia = <span class="title function_">createPinia</span>();</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(pinia);</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在 Vue2 中，还需要安装一个插件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createPinia, <span class="title class_">PiniaVuePlugin</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">PiniaVuePlugin</span>);</span><br><span class="line"><span class="keyword">const</span> pinia = <span class="title function_">createPinia</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="comment">// 其他配置...</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 请注意，同一个`pinia&#x27;实例</span></span><br><span class="line">  <span class="comment">// 可以在同一个页面的多个 Vue 应用中使用。</span></span><br><span class="line">  pinia</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Pinia-概念"><a href="#Pinia-概念" class="headerlink" title="Pinia 概念"></a>Pinia 概念</h2><h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>Store 是一个保存状态和业务逻辑的实体，它并不与你的组件树绑定，承载着全局状态。一个 Store 应该包含可以在整个应用中访问的数据，你应该避免在 Store 中引入那些原本可以在组件中保存的本地数据。</p><p>Store 是用 <code>defineStore()</code> 定义的，它的第一个参数要求是一个唯一的名字，用作id，返回一个函数，为了符合组合式函数风格，通常命名为 <code>use&lt;id&gt;Store</code>。<code>defineStore()</code> 的第二个参数可接受两类值：Setup 函数或 Option 对象</p><p>当第二个参数使用 Option 对象时，可以传入一个带有 <code>state</code> 、<code>action</code>、<code>getters</code> 属性的 Option 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCounterStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;counter&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;),</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="attr">double</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">count</span> * <span class="number">2</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>第二个参数使用 Setup 函数时，该函数定义了一些响应式属性和方法，并且返回一个带有我们想暴露出去的属性和方法的对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCounterStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;counter&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    count.<span class="property">value</span>++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; count, increment &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在 Setup Store 中：</p><ul><li><code>ref()</code> 就是 <code>state</code> 属性</li><li><code>computed()</code> 就是 <code>getters</code></li><li><code>function()</code> 就是 <code>actions</code></li></ul><p>Store 在使用 <code>&lt;script setup&gt;</code> 调用 <code>useStore()</code> (或者调用 <code>setup()</code> 函数)时，会被创建。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; useCounterStore &#125; from &#x27;@/stores/counter&#x27;;</span><br><span class="line">// 可以在组件中的任意位置访问 `store` 变量</span><br><span class="line">const store = useCounterStore();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>为了从 store 中提取属性时保持其响应性，你需要使用 <code>storeToRefs()</code>，它将为每一个响应式属性创建引用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; storeToRefs &#125; from &#x27;pinia&#x27;;</span><br><span class="line">const store = useCounterStore();</span><br><span class="line">// `name` 和 `doubleCount` 是响应式的 ref</span><br><span class="line">// 同时通过插件添加的属性也会被提取为 ref</span><br><span class="line">// 并且会跳过所有的 action 或非响应式 (不是 ref 或 reactive) 的属性</span><br><span class="line">const &#123; name, doubleCount &#125; = storeToRefs(store);</span><br><span class="line">// 作为 action 的 increment 可以直接解构</span><br><span class="line">const &#123; increment &#125; = store;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>state 被定义为一个返回初始状态的函数，代表了应用中的状态。</p><p>默认情况下，可以通过 <code>store</code> 实例访问 state，并进行读写。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="title function_">useStore</span>();</span><br><span class="line">store.<span class="property">count</span>++;</span><br></pre></td></tr></table></figure><p>使用选项式 API 时，可以通过调用 <code>$reset</code> 方法将 state 重置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="title function_">useStore</span>();</span><br><span class="line">store.$reset();</span><br></pre></td></tr></table></figure><p>可以通过调用 <code>$patch</code> 方法同时修改多个属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">store.$patch(&#123;</span><br><span class="line">  <span class="attr">count</span>: store.<span class="property">count</span> + <span class="number">1</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">120</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;DIO&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>$patch</code> 方法也接受一个函数来对集合进行修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">store.$patch(<span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">  state.<span class="property">items</span>.<span class="title function_">push</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;shoes&#x27;</span>, <span class="attr">quantity</span>: <span class="number">1</span> &#125;);</span><br><span class="line">  state.<span class="property">hasChanged</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>你不能完全替换掉 store 的 state，因为那样会破坏其响应性。但是，你可以通过 <code>$patch</code> 方法替换它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这实际上并没有替换`$state`</span></span><br><span class="line">store.<span class="property">$state</span> = &#123; <span class="attr">count</span>: <span class="number">24</span> &#125;;</span><br><span class="line"><span class="comment">// 在它内部调用 `$patch()`：</span></span><br><span class="line">store.$patch(&#123; <span class="attr">count</span>: <span class="number">24</span> &#125;);</span><br></pre></td></tr></table></figure><p>你可以通过 store 的 <code>$subscribe</code> 方法侦听 state 及其变化,相当于组件中的 <code>watch()</code>, 比起普通的 <code>watch()</code>，使用 <code>$subscribe()</code> 的好处是 subscriptions 在 patch 后只触发一次 (例如，当使用上面的函数版本时)。</p><h3 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h3><p>Getter 完全等同于 store 的 state 的计算值（computed value）。推荐使用箭头函数，并且它将接收 <code>state</code> 作为第一个参数。在使用常规函数定义 getter 时，我们也可以通过 this 访问到整个 store 实例，从而访问其他 getter。</p><p>你可以访问其他 store 的 getter:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useOtherStore &#125; <span class="keyword">from</span> <span class="string">&#x27;./other-store&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;main&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="title function_">otherGetter</span>(<span class="params">state</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> otherStore = <span class="title function_">useOtherStore</span>();</span><br><span class="line">      <span class="keyword">return</span> state.<span class="property">localData</span> + otherStore.<span class="property">data</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>Action 相当于组件中的 method，它们定义了业务逻辑。action 也可通过 this 访问整个 store 实例。action 也可以是异步的，可以像函数或方法一样被调用，也可以在另一个 store 的 action 中被调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useAuthStore &#125; <span class="keyword">from</span> <span class="string">&#x27;./auth-store&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useSettingsStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;settings&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">preferences</span>: <span class="literal">null</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">fetchUserPreferences</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> auth = <span class="title function_">useAuthStore</span>();</span><br><span class="line">      <span class="keyword">if</span> (auth.<span class="property">isAuthenticated</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">preferences</span> = <span class="keyword">await</span> <span class="title function_">fetchPreferences</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;User must be authenticated&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>你可以通过 <code>store.$onAction()</code> 来监听 action 和他们的结果。传递给它的回调函数会在 action 本身之前执行。<code>after</code> 允许在 promise 解决之后执行回调函数。onError 允许在 action 抛出错误或 reject 时执行回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unsubscribe = someStore.$onAction(</span><br><span class="line">  <span class="function">(<span class="params">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    name, // action 名称</span></span></span><br><span class="line"><span class="params"><span class="function">    store, // store 实例，类似 <span class="string">`someStore`</span></span></span></span><br><span class="line"><span class="params"><span class="function">    args, // 传递给 action 的参数数组</span></span></span><br><span class="line"><span class="params"><span class="function">    after, // 在 action 返回或解决后的钩子</span></span></span><br><span class="line"><span class="params"><span class="function">    onError // action 抛出或拒绝的钩子</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 为这个特定的 action 调用提供一个共享变量</span></span><br><span class="line">    <span class="keyword">const</span> startTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="comment">// 这将在执行 &quot;store &quot;的 action 之前触发。</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Start &quot;<span class="subst">$&#123;name&#125;</span>&quot; with params [<span class="subst">$&#123;args.join(<span class="string">&#x27;, &#x27;</span>)&#125;</span>].`</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这将在 action 成功并完全运行后触发。</span></span><br><span class="line">    <span class="comment">// 它等待着任何返回的 promise</span></span><br><span class="line">    <span class="title function_">after</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Finished &quot;<span class="subst">$&#123;name&#125;</span>&quot; after <span class="subst">$&#123;<span class="built_in">Date</span>.now() - startTime&#125;</span>ms.\nResult: <span class="subst">$&#123;result&#125;</span>.`</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 action 抛出或返回一个拒绝的 promise，这将触发</span></span><br><span class="line">    <span class="title function_">onError</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">`Failed &quot;<span class="subst">$&#123;name&#125;</span>&quot; after <span class="subst">$&#123;<span class="built_in">Date</span>.now() - startTime&#125;</span>ms.\nError: <span class="subst">$&#123;error&#125;</span>.`</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动删除监听器</span></span><br><span class="line"><span class="title function_">unsubscribe</span>();</span><br></pre></td></tr></table></figure><h2 id="Pinia-插件"><a href="#Pinia-插件" class="headerlink" title="Pinia 插件"></a>Pinia 插件</h2><p>Pinia 支持通过 <code>pinia.use()</code> 添加插件，Pinia 插件是一个函数，可以选择性地返回要添加到 store 的属性。它接收一个可选参数，即 context：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createPinia &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建的每个 store 中都会添加一个名为 `secret` 的属性。</span></span><br><span class="line"><span class="comment">// 在安装此插件后，插件可以保存在不同的文件中</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SecretPiniaPlugin</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// context.pinia // 用 `createPinia()` 创建的 pinia。</span></span><br><span class="line">  <span class="comment">// context.app // 用 `createApp()` 创建的当前应用(仅 Vue 3)。</span></span><br><span class="line">  <span class="comment">// context.store // 该插件想扩展的 store</span></span><br><span class="line">  <span class="comment">// context.options // 定义传给 `defineStore()` 的 store 的可选对象。</span></span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">secret</span>: <span class="string">&#x27;the cake is a lie&#x27;</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pinia = <span class="title function_">createPinia</span>();</span><br><span class="line"><span class="comment">// 将该插件交给 Pinia</span></span><br><span class="line">pinia.<span class="title function_">use</span>(<span class="title class_">SecretPiniaPlugin</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在另一个文件中</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">useStore</span>();</span><br><span class="line">store.<span class="property">secret</span>; <span class="comment">// &#x27;the cake is a lie&#x27;</span></span><br></pre></td></tr></table></figure><p>以下为插件可扩展的内容：</p><ul><li>为 store 添加新的属性</li><li>定义 store 时增加新的选项</li><li>为 store 增加新的方法</li><li>包装现有的方法</li><li>改变甚至取消 action</li><li>实现副作用，如本地存储</li><li>仅应用插件于特定 store</li></ul><p>当添加外部属性、第三方库的类实例或非响应式的简单值时，你应该先用 markRaw() 来包装一下它，再将它传给 pinia。下面是一个在每个 store 中添加路由器的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; markRaw &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="comment">// 根据你的路由器的位置来调整</span></span><br><span class="line"><span class="keyword">import</span> &#123; router &#125; <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span>;</span><br><span class="line"></span><br><span class="line">pinia.<span class="title function_">use</span>(<span class="function">(<span class="params">&#123; store &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  store.<span class="property">router</span> = <span class="title function_">markRaw</span>(router);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Pinia-与-Vuex-区别"><a href="#Pinia-与-Vuex-区别" class="headerlink" title="Pinia 与 Vuex 区别"></a>Pinia 与 Vuex 区别</h2><p>Pinia 是 Vue3 推荐的状态管理库，而 Vuex 将不再更迭，从事件顺序上看，Pinia 可以看做是 Vuex5 。</p><ol><li>Pinia 提供了更简单的 API，也提供了符合组合式 API 风格的 API，搭配 Typescript 一起使用时有可靠的类型推断支持。</li><li>Pinia API 已经稳定，新功能需要经过 RFC 流程。Vuex 不再更新。</li><li>Vuex3.x 只适配 Vue2，Vuex 4.x 适配 Vue3, Pinia 适配 Vue3 和 Vue2。</li><li>Pinia 没有 mutation，Vuex 中使用 mutation 记录数据的更新。<br>Pinia 在 action 执行完成后会自动发布给订阅者，所以不需要 mutation。</li><li>Pinia 无需要创建自定义的复杂包装器来支持 TypeScript。</li><li>Pinia 无过多的魔法字符串注入，只需要导入函数并调用它们。</li><li>Pinia 无需动态添加 Store，默认即是动态的。</li><li>Pinia 不再有嵌套结构的模块，提供扁平的 Store 结构。</li><li>Pinia 不再有可命名的模块。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> vue3 </tag>
            
            <tag> pinia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MobX小抄</title>
      <link href="/blog/2023/09/21/React-MobX%E5%B0%8F%E6%8A%84/"/>
      <url>/blog/2023/09/21/React-MobX%E5%B0%8F%E6%8A%84/</url>
      
        <content type="html"><![CDATA[<p>MobX 是一款简单可扩展的状态管理库。它通过运用透明的函数式响应编程（Transparent Functional Reactive Programming，TFRP）使状态管理变得简单和可扩展。</p><h2 id="MobX-应用示例"><a href="#MobX-应用示例" class="headerlink" title="MobX 应用示例"></a>MobX 应用示例</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; makeAutoObservable &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; observer &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx-react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应用状态进行建模。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span> &#123;</span><br><span class="line">  secondsPassed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">makeAutoObservable</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">increase</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">secondsPassed</span> += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">reset</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">secondsPassed</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成应用状态实例</span></span><br><span class="line"><span class="keyword">const</span> myTimer = <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建一个使用 observable 状态的“用户界面”。</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">TimerView</span> = <span class="title function_">observer</span>(<span class="function">(<span class="params">&#123; timer &#125;</span>) =&gt;</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> timer.reset()&#125;&gt;已过秒数：&#123;timer.secondsPassed&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">));</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">TimerView</span> <span class="attr">timer</span>=<span class="string">&#123;myTimer&#125;</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="property">body</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每秒更新一次‘已过秒数：X’中的文本。</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  myTimer.<span class="title function_">increase</span>();</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>围绕 React 组件 <code>TimerView</code> 的 <code>observer</code> 包装会自动侦测到依赖于 observable <code>timer.secondsPassed</code> 的渲染——即使这种依赖关系没有被明确定义出来。 响应性系统会负责在未来恰好那个字段被更新的时候将组件重新渲染。<br>每个事件（<code>onClick</code> 或 <code>setInterval</code>）都会调用一个用来更新 observable 状态 <code>myTimer.secondsPassed</code> 的 action（<code>myTimer.increase</code> 或 <code>myTimer.reset</code>）。Observable 状态的变更会被精确地传送到 <code>TimerView</code> 中所有依赖于它们的计算和副作用里。</p><p>状态流转概念图如下所示：</p><p><img src="/blog/static/imgs/mobx/mobxflow.png" alt="mobx_inner"></p><h2 id="MobX-应用方式"><a href="#MobX-应用方式" class="headerlink" title="MobX 应用方式"></a>MobX 应用方式</h2><p>MobX 有两种 React 绑定方式，其中 <code>mobx-react-lite</code> 仅支持函数组件，<code>mobx-react</code> 还支持基于类的组件。可以使用 Yarn、NPM、CDN 集成 MobX 到项目中：</p><ul><li>Yarn: <code>yarn add mobx</code></li><li>NPM: <code>npm install --save mobx</code></li><li>CDN: https://cdnjs.com/libraries/mobx 或者 https://unpkg.com/mobx/dist/mobx.umd.production.min.js</li></ul><p>因为使用到了类属性特性，在与 Typescript 或 Babel 一起使用时且计划使用类时，需要转换类字段。</p><ul><li>Babel: 版本&gt;7.12 使用 <code>@babel/plugin-proposal-class-properties</code> 插件，配置 <code>[&quot;@babel/plugin-proposal-class-properties&quot;, &#123; &quot;loose&quot;: false &#125;]</code></li><li>Typescript: 在 tsconfig.json 中启用编译器选项 <code>&quot;useDefineForClassFields&quot;: true</code></li></ul><p>MobX 使用到了 Proxy 特性，如果在不支持 Proxy 特性的运行时上使用 MobX ，需要明确启用降级方案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; configure &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx&#x27;</span>;</span><br><span class="line"><span class="title function_">configure</span>(&#123; <span class="attr">useProxies</span>: <span class="string">&#x27;never&#x27;</span> &#125;); <span class="comment">// Or &quot;ifavailable&quot;.</span></span><br></pre></td></tr></table></figure><p>在 MobX6 中，为了与标准 Javascript 兼容，放弃了装饰器语法，如果需要使用 <code>@observable</code> 等装饰器，需要明确启用同时使用 Typescript 或 Babel 进行转译：</p><ul><li>Typescript：在 tsconfig.json 中启用编译器选项 <code>&quot;experimentalDecorators&quot;: true</code> 和 <code>&quot;useDefineForClassFields&quot;: true</code>。</li><li>Babel: 使用 <code>@babel/plugin-proposal-class-properties</code> 和 <code>@babel/plugin-proposal-decorators</code> 插件，配置：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">[</span><span class="string">&quot;@babel/plugin-proposal-decorators&quot;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;legacy&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span> <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">[</span><span class="string">&quot;@babel/plugin-proposal-class-properties&quot;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;loose&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span> <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="comment">// 与MobX 4/5不同的是, &quot;loose&quot; 必须为 false!    ^</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="MobX-概念"><a href="#MobX-概念" class="headerlink" title="MobX 概念"></a>MobX 概念</h2><p>MobX区分了应用程序中的以下三个概念：</p><ul><li>State(状态)</li><li>Actions(动作)</li><li>Derivations(派生)</li></ul><p>State(状态): 是驱动你的应用程序的数据。通常来说，状态有领域 <em>特定状态</em> 和 <em>视图状态</em>。State 可以使用任何数据结构，但是需要被标记为 <code>observable</code> 从而使 MobX 可跟踪它。<br>Action(动作) : 是任意可以改变 State(状态) 的代码，比如用户事件处理、后端推送数据处理、调度器事件处理等等。<br>Derivation(派生): 任何 来源是 State(状态) 并且不需要进一步交互的东西都是 Derivation(派生)。<br>Mobx 区分了两种 Derivation :</p><ul><li>Computed values：总是可以通过纯函数从当前的可观测 State 中派生</li><li>Reactions：当 State 改变时需要自动运行的副作用 (命令式编程和响应式编程之间的桥梁)</li></ul><h2 id="MobX-数据流向"><a href="#MobX-数据流向" class="headerlink" title="MobX 数据流向"></a>MobX 数据流向</h2><p>Mobx 使用单向数据流，利用 action 改变 state ，进而更新所有受影响的 view:</p><p><img src="/blog/static/imgs/mobx/mobx.png" alt="mobx_inner"></p><ol><li>所有的 derivations 将在 state 改变时自动且原子化地更新。因此不能观察中间值。</li><li>所有的 derivations 默认将会同步更新，这意味着 action 可以在 state 改变之后安全的直接获得 computed value。</li><li>computed value 的更新是惰性的，任何 computed value 在需要他们的副作用发生之前都是不激活的。</li><li>所有的 computed value 都应是纯函数，他们不应该修改 state。</li></ol><h2 id="MobX核心"><a href="#MobX核心" class="headerlink" title="MobX核心"></a>MobX核心</h2><h3 id="创建可观察-observable-state"><a href="#创建可观察-observable-state" class="headerlink" title="创建可观察(observable) state"></a>创建可观察(observable) state</h3><h4 id="makeObservable"><a href="#makeObservable" class="headerlink" title="makeObservable"></a>makeObservable</h4><p>用法： <code>makeObservable(target, annotations?, options?)</code></p><p><code>makeObservable</code> 为每个属性指定一个注解:</p><ul><li><code>observable</code> 定义一个存储 state 的可追踪字段。</li><li><code>action</code> 将一个方法标记为可以修改 state 的 action。</li><li><code>computed</code> 标记一个可以由 state 派生出新的值并且缓存其输出的 getter。</li><li><code>flow</code> 创建一个 flow 管理异步进程。</li><li><code>override</code> 用于子类覆盖继承的 <code>action</code>，<code>flow</code>，<code>computed</code>，<code>action.bound</code></li><li><code>autoAction</code> 不应被显式调用，但 <code>makeAutoObservable</code> 内部会对其进行调用，以便根据调用上下文将方法标识为 action 或者派生值。</li></ul><p>一般情况下，<code>makeObservable</code> 是在类的构造函数中调用的，并且它的第一个参数是 <code>this</code> 。</p><p>所有带注解 的字段都是 不可配置的。<br>所有的不可观察（无状态）的字段（<code>action</code>, <code>flow</code>）都是 不可写的。</p><h4 id="makeAutoObservable"><a href="#makeAutoObservable" class="headerlink" title="makeAutoObservable"></a>makeAutoObservable</h4><p>用法：<code>makeAutoObservable(target, overrides?, options?)</code></p><p><code>makeAutoObservable</code> 就像是加强版的 <code>makeObservable</code>，在默认情况下它将推断所有的属性。<code>makeAutoObservable</code> 不能被用于带有 super 的类或 子类。</p><p>推断规则：</p><ul><li>所有 _自有_ 属性都成为 <code>observable</code>。</li><li>所有 <code>get</code>ters 都成为 <code>computed</code>。</li><li>所有 <code>set</code>ters 都成为 <code>action</code>。</li><li>所有 <em>prototype 中的 functions</em> 都成为 <code>autoAction</code>。</li><li>所有 <em>prototype 中的 generator functions</em> 都成为 <code>flow</code>。（需要注意，generators 函数在某些编译器配置中无法被检测到，如果 <code>flow</code> 没有正常运行，请务必明确地指定 <code>flow</code> 注解。）</li><li>在 <code>overrides</code> 参数中标记为 <code>false</code> 的成员将不会被添加注解。例如，将其用于像标识符这样的只读字段。</li></ul><h4 id="observable"><a href="#observable" class="headerlink" title="observable"></a>observable</h4><p>用法：<code>observable(source, overrides?, options?)</code></p><p><code>observable</code> 注解可以作为一个函数进行调用，从而一次性将整个对象变成可观察的，之后被添加到这个对象中的属性也将被侦测并使其转化为可观察对象。</p><h3 id="使用-actions-更新-state"><a href="#使用-actions-更新-state" class="headerlink" title="使用 actions 更新 state"></a>使用 actions 更新 state</h3><h4 id="action"><a href="#action" class="headerlink" title="action"></a>action</h4><p>用法：</p><ul><li><code>action</code> （注解）</li><li><code>action(fn)</code></li><li><code>action(name, fn)</code></li></ul><p>action 注解表示了一段修改 state 的代码。<br>Actions 可以帮助你更好的组织你的代码并提供以下性能优势：</p><ol><li>它们在 <code>transactions</code> 内部运行。任何可观察对象在最外层的 action 完成之前都不会被更新，这一点保证了在 action 完成之前，action 执行期间生成的中间值或不完整的值对应用程序的其余部分都是不可见的。</li><li>默认情况下，不允许在 actions 之外改变 state。这有助于在代码中清楚地对状态更新发生的位置进行定位。</li></ol><p>action 注解应该仅用于会修改 state 的函数。带有 action 注解的成员是不可枚举的。</p><h4 id="action-bound"><a href="#action-bound" class="headerlink" title="action.bound"></a>action.bound</h4><p>用法： <code>action.bound</code> （注解）</p><p><code>action.bound</code> 注解可用于将方法自动绑定到正确的实例，这样 <code>this</code> 会始终被正确绑定在函数内部。</p><h4 id="runInAction"><a href="#runInAction" class="headerlink" title="runInAction"></a>runInAction</h4><p>用法：<code>runInAction(fn)</code></p><p>使用这个工具函数来创建一个会被立即调用的临时 action。</p><h4 id="flow"><a href="#flow" class="headerlink" title="flow"></a>flow</h4><p>用法：</p><ul><li><code>flow</code> （注解）</li><li><code>flow(function* (args) &#123; &#125;)</code></li></ul><p><code>flow</code> 包装器是一个可选的 <code>async</code> / <code>await</code> 替代方案，它让 MobX action 使用起来更加容易。</p><p><code>flow</code> 将一个 generator 函数 作为唯一输入。 在 generator 内部，你可以使用 yield 串联 Promise（使用 <code>yield somePromise</code> 代替 <code>await somePromise</code>）。 <code>flow</code> 机制将会确保 generator 在 Promise resolve 之后继续运行或者抛出错误。</p><p>带有 flow 注解的成员是不可枚举的。 <code>flow</code> 的返回值是一个 Promise，在 generator 函数运行完成时它将会被 resolve。 返回的 Promise 中还有一个 <code>cancel()</code> 方法，该方法可以打断正在运行的 generator 并取消它。 所有 <code>try</code> / <code>finally</code> 语句仍然会被运行。</p><h4 id="flow-bound"><a href="#flow-bound" class="headerlink" title="flow.bound"></a>flow.bound</h4><p>用法： <code>flow.bound</code> （注解）</p><p><code>flow.bound</code> 注解可用于将方法自动绑定到正确的实例，这样 <code>this</code> 会始终被正确绑定在函数内部。</p><h3 id="通过-computeds-派生信息"><a href="#通过-computeds-派生信息" class="headerlink" title="通过 computeds 派生信息"></a>通过 computeds 派生信息</h3><h4 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h4><p>用法：</p><ul><li><code>computed</code> （注解）</li><li><code>computed(options)</code> （注解）</li><li><code>computed(fn, options?)</code></li></ul><p>computed 可以用来从其他可观察对象中派生信息。</p><p>使用 computed value 时，需遵循以下规则：</p><ol><li>它们不应该有副作用或者更新其他可观察对象</li><li>避免创建和返回新的可观察对象</li><li>它们不应该依赖非可观察对象的值</li></ol><h3 id="使用-reactions-处理副作用"><a href="#使用-reactions-处理副作用" class="headerlink" title="使用 reactions 处理副作用"></a>使用 reactions 处理副作用</h3><h4 id="autorun"><a href="#autorun" class="headerlink" title="autorun"></a>autorun</h4><p><code>autorun</code> 函数接受一个函数作为参数，每当该函数所观察的值发生变化时，它都应该运行。<br><code>autorun</code> 通过在响应式上下文运行 <code>effect</code> 来工作。在给定的函数执行期间，MobX 会持续跟踪被 effect 直接或间接读取过的所有可观察对象和计算值。 一旦函数执行完毕，MobX 将收集并订阅所有被读取过的可观察对象，并等待其中任意一个再次发生改变。 一旦有改变发生，<code>autorun</code> 将会再次触发，重复整个过程。</p><p><img src="/blog/static/imgs/mobx/autorun.png" alt="mobx_autorun_inner"></p><h4 id="reaction"><a href="#reaction" class="headerlink" title="reaction"></a>reaction</h4><p><code>reaction</code> 类似于 autorun，但可以让你更加精细地控制要跟踪的可观察对象。 它接受两个函数作为参数：第一个，data 函数，其是被跟踪的函数并且其返回值将会作为第二个函数，effect 函数，的输入。 重要的是要注意，副作用只会对 data 函数中被访问过的数据做出反应，这些数据可能少于 effect 函数中实际使用的数据。<br>一般的模式是在 <em>data</em> 函数中返回你在副作用中需要的所有数据， 并以这种方式更精确地控制副作用触发的时机。 与 <code>autorun</code> 不同，副作用在初始化时不会自动运行，而只会在 data 表达式首次返回新值之后运行。</p><h4 id="when"><a href="#when" class="headerlink" title="when"></a>when</h4><p><code>when</code> 会观察并运行给定的 <em>predicate</em> 函数，直到其返回 <code>true</code>。 一旦 predicate 返回了 <code>true</code>，给定的 effect 函数就会执行并且自动执行器函数将会被清理掉。<br>如果你没有传入 <code>effect</code> 函数，<code>when</code> 函数返回一个 <code>Promise</code> 类型的 disposer，并允许你手动取消。</p><p>使用 reactive context 需要遵守一些规则：</p><ol><li>默认情况下，如果可观察对象发生了改变，受其影响的 reactions 会立即（同步）运行。然而，它们直到当前最外层的 (trans)action 执行结束后才会运行。</li><li>autorun 只会跟踪给定函数在同步执行过程中所读取的可观察对象，不会跟踪异步发生的变化。</li><li>autorun 不会跟踪被其调用的 action 所读取的可观察对象，因为 action 始终不会被追踪。</li><li>reactions 总是会返回一个 disposer 函数，一旦不再需要这些方法中的副作用时，需要调用它们所返回的 disposer 函数。 否则可能导致内存泄漏。</li></ol><p>使用 <code>mobx-react</code> 等库时，绑定中的 observer 等方式会间接创建 reaction，无需手动创建。在手动创建 reaction 之前，需要检查是否符合以下原则：</p><ol><li>只有在引起副作用的一方与副作用之间没有直接关系的情况下才使用 reaction</li><li>reactions 不应该更新其他可观察对象</li><li>reactions 应该是独立的</li></ol><h2 id="MobX-和-Redux-的区别"><a href="#MobX-和-Redux-的区别" class="headerlink" title="MobX 和 Redux 的区别"></a>MobX 和 Redux 的区别</h2><p>参见 <a href="/blog/2022/11/25/React-Redux小抄/#Redux-和-MobX-的区别">Redux 和 MobX 的区别</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> MobX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tsconfig.json是什么</title>
      <link href="/blog/2023/09/13/FE-tsconfig-json%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/blog/2023/09/13/FE-tsconfig-json%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>当目录中出现了 <code>tsconfig.json</code> 文件，则说明该目录是 TypeScript 项目的根目录。<code>tsconfig.json</code> 文件指定了编译项目所需的根目录下的文件以及编译选项。</p><p>JavaScript 项目可以使用 <code>jsconfig.json</code> 文件，它的作用与 <code>tsconfig.json</code> 基本相同，只是默认启用了一些 JavaScript 相关的编译选项。</p><p>一个项目将以下列之一的方式使用 <code>tsconfig.json</code> 或者 <code>jsconfig.json</code> 进行编译：</p><ul><li><p>在调用 tsc 命令并且没有其它输入文件参数时，编译器将由当前目录开始向父级目录寻找包含 tsconfig 文件的目录。</p></li><li><p>调用 tsc 命令并且没有其他输入文件参数，可以使用 <code>--project</code> （或者只是 <code>-p</code>）的命令行选项来指定包含了 <code>tsconfig.json</code> 的目录，或者包含有效配置的 .json 文件路径。</p></li></ul><p>当在命令行上指定输入文件时，<code>tsconfig.json</code> 文件将被忽略。</p><p>一个 <code>tsconfig.json</code> 的示例如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;system&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;noImplicitAny&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;removeComments&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;preserveConstEnums&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;outFile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;../../built/local/tsc.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sourceMap&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;include&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/**/*&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;exclude&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;node_modules&quot;</span><span class="punctuation">,</span> <span class="string">&quot;**/*.spec.ts&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="基本的-tsconfig"><a href="#基本的-tsconfig" class="headerlink" title="基本的 tsconfig"></a>基本的 tsconfig</h2><p>根据你要在其中运行代码的不同的 JavaScript 运行时环境，你可以在 <a href="https://github.com/tsconfig/bases/">github.com/tsconfig/bases</a> 上寻找一个合适的基本配置。 你可以通过扩展（extends）这些已经处理过不同的 JavaScript 运行时环境的 <code>tsconfig.json</code> 文件来简化你项目中的 <code>tsconfig.json</code> 。</p><p>可选的基本 tsconfig 如下所示：</p><table><thead><tr><th>名称</th><th>包</th><th>说明</th></tr></thead><tbody><tr><td>Recommended</td><td><code>@tsconfig/recommended</code></td></tr><tr><td>Bun</td><td><code>@tsconfig/bun</code></td></tr><tr><td>Create React App</td><td><code>@tsconfig/create-react-app</code></td></tr><tr><td>Cypress</td><td><code>@tsconfig/cypress</code></td></tr><tr><td>Deno</td><td><code>@tsconfig/deno</code></td></tr><tr><td>Docusaurus v2</td><td><code>@tsconfig/docusaurus</code></td></tr><tr><td>Ember</td><td><code>@tsconfig/ember</code></td></tr><tr><td>Next.js</td><td><code>@tsconfig/next</code></td></tr><tr><td>Node LTS</td><td><code>@tsconfig/node-lts</code></td></tr><tr><td>Node 10</td><td><code>@tsconfig/node10</code></td><td>Node也有 12 14 16 17 18 19 20 版本，写法类似</td></tr><tr><td>Nuxt</td><td><code>@tsconfig/nuxt</code></td></tr><tr><td>React Native</td><td><code>@tsconfig/react-native</code></td></tr><tr><td>Remix</td><td><code>@tsconfig/remix</code></td></tr><tr><td>Strictest</td><td><code>@tsconfig/strictest</code></td></tr><tr><td>Svelte</td><td><code>@tsconfig/svelte</code></td></tr><tr><td>Taro</td><td><code>@tsconfig/taro</code></td></tr><tr><td>Vite React</td><td><code>@tsconfig/vite-react</code></td></tr></tbody></table><h2 id="tsconfig-配置参考"><a href="#tsconfig-配置参考" class="headerlink" title="tsconfig 配置参考"></a>tsconfig 配置参考</h2><p>详细参考见 https://www.typescriptlang.org/tsconfig</p><h3 id="compilerOptions"><a href="#compilerOptions" class="headerlink" title="compilerOptions"></a>compilerOptions</h3><p><code>compilerOptions</code> 构成了 TypeScript 配置的大部分内容，它涵盖了语言应该如何工作。</p><p>大致包括以下部分：</p><ol><li>类型检查 Type Checking</li><li>模块 Modules</li><li>发布 Emit</li><li>JavaScript 支持 JavaScript Support</li><li>编辑器支持 Editor Support</li><li>交互限制 Interop Constraints</li><li>向后兼容性 Backwards Compatibility</li><li>语言与环境 Language and Environment</li><li>编译器诊断 Compiler Diagnostics</li><li>项目 Projects</li><li>输出格式化 Output Formatting</li><li>完整性 Completeness</li><li>命令行 Command Line</li><li>监视选项 Watch Options</li></ol><p>详见 <a href="/blog/2023/09/13/FE-tsconfig-json是什么/#编译选项-compilerOptions">编译选项</a></p><h3 id="files"><a href="#files" class="headerlink" title="files"></a>files</h3><p>类型：<code>array&lt;string&gt;</code><br>默认值： <code>false</code><br>指定要包含在程序中的文件的允许列表。如果找不到任何文件，就会发生错误。<br>当只有少量文件并且不需要使用 glob 模式来引用多个文件时，可以使用 <code>files</code>。其他情况使用 <code>include</code>。</p><h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><p>类型： <code>string</code><br>默认值： <code>false</code><br>指定包含要从中继承的另一个配置文件的路径。路径可能使用 Node.js 样式的解析。<br>首先加载基本文件中的配置，然后由继承配置文件中的那些配置覆盖。在配置文件中找到的所有相对路径都将相对于它们源自的配置文件进行解析。配置之间不允许循环继承。<code>references</code> 无法被继承。</p><h3 id="include"><a href="#include" class="headerlink" title="include"></a>include</h3><p>类型：<code>array</code><br>默认值：如果有 <code>file</code> 则默认为 <code>[]</code> 否则默认为 <code>**/*</code><br>指定要包含在程序中的文件名或模式的数组。这些文件名是相对于包含 <code>tsconfig.json</code> 文件的目录解析的。</p><p><code>include</code> 和 <code>exclude</code> 支持通配符以生成 glob 模式：</p><ul><li><code>*</code> 匹配零个或多个字符（不包括目录分隔符）</li><li><code>?</code> 匹配任何一个字符（不包括目录分隔符）</li><li><code>**/</code> 匹配嵌套到任何级别的任何目录</li></ul><p>如果模式中的最后一个路径段不包含文件扩展名或通配符，则将其视为一个目录，并包括该目录中具有支持扩展名的文件（例如，默认情况下为 .ts 、.tsx 和 .d.ts ，如果 <code>allowJs</code> 设置为 true ，则使用 .js 和 .jsx ）。</p><h3 id="exclude"><a href="#exclude" class="headerlink" title="exclude"></a>exclude</h3><p>类型：<code>array</code><br>默认值：<code>[&#39;node_modules&#39;, &#39;bower_components&#39;, &#39;jspm_packages&#39;, &#39;%outDir%&#39;]</code><br>指定在解析include时应跳过的文件名或模式的数组。</p><p><strong>重要提示</strong>：<code>exclude</code> 仅排除由于 <code>include</code> 设置而包含的文件。<code>exclude</code> 指定的文件仍然可以成为代码库的一部分，这是由于代码中的 <code>import</code> 语句、<code>types</code> 包含、<code>///&lt;reference</code> 指令或在 <code>files</code> 列表中指定。</p><h3 id="references"><a href="#references" class="headerlink" title="references"></a>references</h3><p>项目引用是一种将 TypeScript 程序解构成更小部分的方法。使用项目引用可以极大地缩短构建和编辑器交互时间，强制组件之间的逻辑分离，并以新的和改进的方式组织代码。详见 <a href="https://www.typescriptlang.org/docs/handbook/project-references.html">Project References</a>。</p><h2 id="编译选项-compilerOptions"><a href="#编译选项-compilerOptions" class="headerlink" title="编译选项 compilerOptions"></a>编译选项 compilerOptions</h2><h3 id="类型检查-Type-Checking"><a href="#类型检查-Type-Checking" class="headerlink" title="类型检查 Type Checking"></a>类型检查 Type Checking</h3><h4 id="allowUnreachableCode"><a href="#allowUnreachableCode" class="headerlink" title="allowUnreachableCode"></a>allowUnreachableCode</h4><p>允许无法访问的代码</p><ul><li><p><code>undefined</code>（默认）将建议作为警告提供给编辑器</p></li><li><p><code>true</code> 忽略无法访问的代码</p></li><li><p><code>false</code> 引发关于无法访问代码的编译器错误</p></li></ul><h4 id="allowUnusedLabels"><a href="#allowUnusedLabels" class="headerlink" title="allowUnusedLabels"></a>allowUnusedLabels</h4><p>允许未使用的标签（label）</p><ul><li><p><code>undefined</code>（默认）将建议作为警告提供给编辑器</p></li><li><p><code>true</code> 忽略未使用的标签</p></li><li><p><code>false</code> 引发关于未使用标签的编译器错误</p></li></ul><h4 id="alwaysStrict"><a href="#alwaysStrict" class="headerlink" title="alwaysStrict"></a>alwaysStrict</h4><p>确保在 ECMAScript 严格模式下解析文件，并为每个源文件添加 <code>use strict</code> 。</p><p>默认值：如果有 <code>strict</code> 则默认为 <code>true</code> 否则为 <code>false</code> 。</p><h4 id="exactOptionalPropertyTypes"><a href="#exactOptionalPropertyTypes" class="headerlink" title="exactOptionalPropertyTypes"></a>exactOptionalPropertyTypes</h4><p>启用 exactOptionalPropertyTypes 后，TypeScript 对具有 <code>?</code> 前缀的类型或接口的属性启用更加精确的规则。</p><h4 id="noFallthroughCasesInSwitch"><a href="#noFallthroughCasesInSwitch" class="headerlink" title="noFallthroughCasesInSwitch"></a>noFallthroughCasesInSwitch</h4><p>在 switch 语句中进入穿透分支时报告错误。确保 switch 语句中的任何非空分支都包括 break、return 或 throw 。这意味着你不会意外地遇到穿透分支的bug。</p><h4 id="noImplicitAny"><a href="#noImplicitAny" class="headerlink" title="noImplicitAny"></a>noImplicitAny</h4><p>在某些不存在类型注释的情况下，当 TypeScript 无法推断变量的类型时，它将回退到 any 类型。</p><p>默认值：如果有 <code>strict</code> 则默认为 <code>true</code> 否则为 <code>false</code> 。</p><h4 id="noImplicitOverride"><a href="#noImplicitOverride" class="headerlink" title="noImplicitOverride"></a>noImplicitOverride</h4><p>当处理使用继承的类时，子类可能会与在基类中重命名时重载的函数“不同步”（隐式重载）。<br>使用 noImplicitOverride 可以确保重载的函数必需包含关键字 override ，从而确保子类永远不会失去同步。</p><h4 id="noImplicitReturns"><a href="#noImplicitReturns" class="headerlink" title="noImplicitReturns"></a>noImplicitReturns</h4><p>启用后，TypeScript 将检查函数中的所有代码路径，以确保它们返回值。</p><h4 id="noImplicitThis"><a href="#noImplicitThis" class="headerlink" title="noImplicitThis"></a>noImplicitThis</h4><p>在具有隐含 “any” 类型的 “this” 表达式上引发错误。</p><h4 id="noPropertyAccessFromIndexSignature"><a href="#noPropertyAccessFromIndexSignature" class="headerlink" title="noPropertyAccessFromIndexSignature"></a>noPropertyAccessFromIndexSignature</h4><p>此设置可确保通过点（<code>obj.key</code>）语法和索引（<code>obj[&quot;key&quot;]</code>）访问字段以及在类型中声明属性的方式之间的一致性。如果没有此标志，TypeScript 将允许你使用点语法访问未定义的字段。</p><h4 id="noUncheckedIndexedAccess"><a href="#noUncheckedIndexedAccess" class="headerlink" title="noUncheckedIndexedAccess"></a>noUncheckedIndexedAccess</h4><p>TypeScript 有一种方法可以通过索引签名来描述对象上具有未知键但已知值的对象。<br>启用 noUncheckedIndexedAccess 将向类型中任何未声明的字段添加 undefined 类型。</p><h4 id="noUnusedLocals"><a href="#noUnusedLocals" class="headerlink" title="noUnusedLocals"></a>noUnusedLocals</h4><p>对未使用的局部变量报告错误。</p><h4 id="noUnusedParameters"><a href="#noUnusedParameters" class="headerlink" title="noUnusedParameters"></a>noUnusedParameters</h4><p>对函数中未使用的参数报告错误。</p><h4 id="strict"><a href="#strict" class="headerlink" title="strict"></a>strict</h4><p>严格标志可以实现广泛的类型检查行为，从而为程序的正确性提供更强的保证。启用此选项相当于启用以下列出的所有严格模式族选项（以 strict 开头的选项）。然后，你可以根据需要关闭单独的严格模式族检查。</p><h4 id="strictBindCallApply"><a href="#strictBindCallApply" class="headerlink" title="strictBindCallApply"></a>strictBindCallApply</h4><p>设置后，TypeScript 将检查函数 call、bind 和 apply 的内置方法是否使用基础函数的正确参数调用。</p><h4 id="strictFunctionTypes"><a href="#strictFunctionTypes" class="headerlink" title="strictFunctionTypes"></a>strictFunctionTypes</h4><p>启用时，此标志会使函数参数得到更正确的检查。</p><h4 id="strictNullChecks"><a href="#strictNullChecks" class="headerlink" title="strictNullChecks"></a>strictNullChecks</h4><p>当 strictNullChecks 为 false 时，语言会有效地忽略 null 和 undefined 。这可能会导致运行时出现意外错误。<br>当 strictNullChecks 为 true 时， null 和 undefined 有各自不同的类型，如果你试图在需要具体值的地方使用它们，则会出现类型错误。</p><h4 id="strictPropertyInitialization"><a href="#strictPropertyInitialization" class="headerlink" title="strictPropertyInitialization"></a>strictPropertyInitialization</h4><p>当设置为 true 时，当类属性已声明但未在构造函数中设置时，TypeScript 将引发错误。</p><h4 id="useUnknownInCatchVariables"><a href="#useUnknownInCatchVariables" class="headerlink" title="useUnknownInCatchVariables"></a>useUnknownInCatchVariables</h4><p>在 TypeScript 4.0 中添加了新的功能，允许将 catch 子句中变量的类型从 any 更改为 unknown 。<br>这种模式确保错误处理代码变得更加全面，因为你不能提前保证抛出的对象是 error 子类。<br>启用了 useUnknownCatchVariables 标志后，就不需要额外的语法（<code>:unknown</code>）或 linter 规则来强制执行此行为。</p><h3 id="Modules-模块"><a href="#Modules-模块" class="headerlink" title="Modules 模块"></a>Modules 模块</h3><h4 id="allowArbitraryExtensions"><a href="#allowArbitraryExtensions" class="headerlink" title="allowArbitraryExtensions"></a>allowArbitraryExtensions</h4><p>在 TypeScript 5.0 中，当导入路径的扩展名不是已知的 JavaScript 或 TypeScript 文件扩展名时，编译器将为该路径查找一个形式为 <code>&#123;file-basename&#125;.d.&#123;extension&#125;.ts</code> 的声明文件。<br>默认情况下，此导入会引发一个错误，让你知道 TypeScript 不理解此文件类型，并且你的运行时可能不支持导入它。但是，如果你已将运行时或打包器配置为可以处理它，则可以使用新的 <code>--allowArbitraryExtensions</code> 编译器选项来抑制该错误。</p><h4 id="allowImportingTsExtensions"><a href="#allowImportingTsExtensions" class="headerlink" title="allowImportingTsExtensions"></a>allowImportingTsExtensions</h4><p><code>--allowImportingTsExtensions</code> 允许 TypeScript 文件使用 TypeScript 特定的扩展名（如 .ts、.mts 或 .tsx）相互导入。<br>只有启用 <code>--noEmit</code> 或 <code>--emitDeclarationOnly</code> 时才允许使用此标志，因为这些导入路径在运行时无法在 JavaScript 输出文件中解析。这里的期望是，你的解析器（例如，你的打包器、运行时或其他工具）将会做这些在 .ts 文件之间的导入工作。</p><h4 id="allowUmdGlobalAccess"><a href="#allowUmdGlobalAccess" class="headerlink" title="allowUmdGlobalAccess"></a>allowUmdGlobalAccess</h4><p>当设置为 true 时， allowUmdGlobalAccess 允许你从模块文件内部访问作为全局变量的 UMD 导出。模块文件是具有导入和/或导出功能的文件。如果没有此标志，使用 UMD 模块的导出需要导入声明。</p><h4 id="baseUrl"><a href="#baseUrl" class="headerlink" title="baseUrl"></a>baseUrl</h4><p>设置要从中解析非相对模块名称的基本目录。<br>使用 <code>&quot;baseUrl&quot;：&quot;./&quot;</code> 时，TypeScript 将查找与 tsconfig.json 位于同一文件夹的文件。</p><h4 id="customConditions"><a href="#customConditions" class="headerlink" title="customConditions"></a>customConditions</h4><p><code>--customConditions</code> 获取 TypeScript 从 package.json 的导出或导入字段解析时应成功的附加条件列表。这些条件将添加到解析程序默认使用的任何现有条件中。<br>该字段仅在 <code>--moduleSolution</code> 为 <code>node16</code> 、<code>nodenext</code> 或 <code>bundler</code> 时有效。</p><h4 id="module"><a href="#module" class="headerlink" title="module"></a>module</h4><p>设置应用程序的模块系统。改变 <code>module</code> 会影响 <code>moduleResolution</code>。</p><p>默认值：如果 <code>target</code> 为 <code>ES3</code> 或者 <code>ES5</code> 那么 <code>module</code> 默认为 <code>CommonJS</code>，否则默认为 <code>ES6</code>/<code>ES2015</code> 。</p><p>以下为该文件的一些例子输出：</p><figure class="highlight js"><figcaption><span>index.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; valueOfPi &#125; <span class="keyword">from</span> <span class="string">&quot;./constants&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> twoPi = valueOfPi * <span class="number">2</span>;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>CommonJS</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="built_in">exports</span>, <span class="string">&quot;__esModule&quot;</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">twoPi</span> = <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> constants_1 = <span class="built_in">require</span>(<span class="string">&quot;./constants&quot;</span>);</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">twoPi</span> = constants_1.<span class="property">valueOfPi</span> * <span class="number">2</span>;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>UMD</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params">factory</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">module</span> === <span class="string">&quot;object&quot;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="variable language_">module</span>.<span class="property">exports</span> === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> v = <span class="title function_">factory</span>(<span class="built_in">require</span>, <span class="built_in">exports</span>);</span><br><span class="line">        <span class="keyword">if</span> (v !== <span class="literal">undefined</span>) <span class="variable language_">module</span>.<span class="property">exports</span> = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&quot;function&quot;</span> &amp;&amp; define.<span class="property">amd</span>) &#123;</span><br><span class="line">        <span class="title function_">define</span>([<span class="string">&quot;require&quot;</span>, <span class="string">&quot;exports&quot;</span>, <span class="string">&quot;./constants&quot;</span>], factory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(<span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span></span>) &#123;</span><br><span class="line">    <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="built_in">exports</span>, <span class="string">&quot;__esModule&quot;</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">    <span class="built_in">exports</span>.<span class="property">twoPi</span> = <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> constants_1 = <span class="built_in">require</span>(<span class="string">&quot;./constants&quot;</span>);</span><br><span class="line">    <span class="built_in">exports</span>.<span class="property">twoPi</span> = constants_1.<span class="property">valueOfPi</span> * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>AMD</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">define</span>([<span class="string">&quot;require&quot;</span>, <span class="string">&quot;exports&quot;</span>, <span class="string">&quot;./constants&quot;</span>], <span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, constants_1</span>) &#123;</span><br><span class="line">    <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="built_in">exports</span>, <span class="string">&quot;__esModule&quot;</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">    <span class="built_in">exports</span>.<span class="property">twoPi</span> = <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">exports</span>.<span class="property">twoPi</span> = constants_1.<span class="property">valueOfPi</span> * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>System</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">System</span>.<span class="title function_">register</span>([<span class="string">&quot;./constants&quot;</span>], <span class="keyword">function</span> (<span class="params">exports_1, context_1</span>) &#123;</span><br><span class="line">    <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> constants_1, twoPi;</span><br><span class="line">    <span class="keyword">var</span> __moduleName = context_1 &amp;&amp; context_1.<span class="property">id</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">setters</span>: [</span><br><span class="line">            <span class="keyword">function</span> (<span class="params">constants_1_1</span>) &#123;</span><br><span class="line">                constants_1 = constants_1_1;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">execute</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            exports_1(<span class="string">&quot;twoPi&quot;</span>, twoPi = constants_1.<span class="property">valueOfPi</span> * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>ESNext</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; valueOfPi &#125; <span class="keyword">from</span> <span class="string">&quot;./constants&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> twoPi = valueOfPi * <span class="number">2</span>;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>ES2015/ES6/ES2020/ES2022</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; valueOfPi &#125; <span class="keyword">from</span> <span class="string">&quot;./constants&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> twoPi = valueOfPi * <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>除了 <code>ES2015</code>/<code>ES6</code> 的基本功能外，<code>ES2020</code> 还增加了对动态导入和 <code>import.meta</code> 的支持，而 <code>ES2022</code> 则进一步增加了对 top await 的支持。</p><figure class="highlight js"><figcaption><span>None</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="built_in">exports</span>, <span class="string">&quot;__esModule&quot;</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">twoPi</span> = <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> constants_1 = <span class="built_in">require</span>(<span class="string">&quot;./constants&quot;</span>);</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">twoPi</span> = constants_1.<span class="property">valueOfPi</span> * <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h4 id="moduleResolution"><a href="#moduleResolution" class="headerlink" title="moduleResolution"></a>moduleResolution</h4><p>指定模块解析策略：</p><ul><li><code>node16</code> 或者 <code>nodenext</code> 表示使用 Node.js 的现代版本。Node.js v12及更高版本同时支持 ECMAScript import 和 CommonJS require</li><li><code>node10</code>（以前称为 <code>node</code> ）适用于 v10 以内的 Node.js 版本，仅支持 CommonJS require。</li><li>用于打包器的 <code>bundler</code>。与 node16 和 nodenext 一样，该模式支持 package.json 的 “imports” 和 “exports” ，但与 Node.js 解析模式不同，bundler 在导入中不需要相对路径上的文件扩展名。</li><li>在 1.6 版本之前，TypeScript 中使用了 <code>classic</code>。</li></ul><p>默认值：如果 <code>module</code> 是 <code>AMD</code>,<code>UMD</code>,<code>System</code> 或者 <code>ES6</code>/<code>ES2015</code> 则默认值是 <code>Calssic</code>；如果 <code>module</code> 是 <code>node16</code> 或者 <code>nodenext</code>，则与之相匹配; 否则默认值为 <code>Node</code> 。</p><h4 id="moduleSuffixes"><a href="#moduleSuffixes" class="headerlink" title="moduleSuffixes"></a>moduleSuffixes</h4><p>类型：<code>array&lt;string&gt;</code><br>提供一种在解析模块时覆盖要搜索的文件名后缀的默认列表的方法。</p><h4 id="noResolve"><a href="#noResolve" class="headerlink" title="noResolve"></a>noResolve</h4><p>默认情况下，TypeScript 将检查 import 和 <code>reference</code> 指令的初始文件集，并将这些解析的文件添加到程序中。<br>如果设置了 <code>noResolve</code> ，则不会发生此过程。但是，import 语句仍然会被检查，以查看它们是否解析为有效的模块，因此你需要确保通过其他方式满足这一要求。</p><h4 id="paths"><a href="#paths" class="headerlink" title="paths"></a>paths</h4><p>将 paths 中所列出的一系列条目的 import 重新映射，如果设置了 baseUrl，则相对于 baseUrl 进行查找，否则相对于 tsconfig 文件本身的位置进行查找。通过设置 paths，TypeScript 文件解析器可以支持自定义前缀来查找代码引入路径。</p><h4 id="resolveJsonModule"><a href="#resolveJsonModule" class="headerlink" title="resolveJsonModule"></a>resolveJsonModule</h4><p>允许导入带有 .json 扩展名的模块，这是 node 项目中的常见做法。这包括基于静态 JSON 形状为 import 生成一个类型。</p><h4 id="resolvePackageJsonExports"><a href="#resolvePackageJsonExports" class="headerlink" title="resolvePackageJsonExports"></a>resolvePackageJsonExports</h4><p><code>--resolvePackageJsonExports</code> 强制 TypeScript 在读取 node_modules 中的包时，查阅 package.json 文件的 exports 字段。</p><p>默认值：当 <code>moduleResolution</code> 是 <code>node16</code> , <code>nodenext</code> 或者 <code>bundler</code> 时，默认值为 <code>true</code>, 否则为 <code>false</code>。</p><h4 id="resolvePackageJsonImports"><a href="#resolvePackageJsonImports" class="headerlink" title="resolvePackageJsonImports"></a>resolvePackageJsonImports</h4><p><code>--resolvePackageJsonImports</code> 强制 TypeScript 在从祖先目录包含 package.json 的文件执行以 # 开头的查找时，查阅 package.json 文件的 imports 字段。</p><p>默认值：当 <code>moduleResolution</code> 是 <code>node16</code> , <code>nodenext</code> 或者 <code>bundler</code> 时，默认值为 <code>true</code>, 否则为 <code>false</code>。</p><h4 id="rootDir"><a href="#rootDir" class="headerlink" title="rootDir"></a>rootDir</h4><p>根节点。</p><p>默认值：所有非声明输入文件的最长公共路径。如果设置了 <code>composite</code>，则默认为包含 tsconfig.json 文件的目录。</p><h4 id="rootDirs"><a href="#rootDirs" class="headerlink" title="rootDirs"></a>rootDirs</h4><p>使用 rootDirs ，你可以通知编译器有许多“虚拟”目录充当单个根目录。这允许编译器解析这些“虚拟”目录中的相对模块导入，就好像它们被合并到一个目录中一样。</p><h4 id="typeRoots"><a href="#typeRoots" class="headerlink" title="typeRoots"></a>typeRoots</h4><p>默认情况下，所有可见的 <code>@types</code> 包都包含在编译中。如果指定了 <code>typeRoots</code> ，则只包括 <code>typeRoots</code> 下的包。所有路径都是相对于 <code>tsconfig.json</code> 的。</p><h4 id="types"><a href="#types" class="headerlink" title="types"></a>types</h4><p>默认情况下，所有可见的 <code>@types</code> 包都包含在编译中。如果指定了 <code>types</code>，则只有列出的包才会包含在全局作用域中。</p><h3 id="Emit-生成"><a href="#Emit-生成" class="headerlink" title="Emit 生成"></a>Emit 生成</h3><h4 id="declaration"><a href="#declaration" class="headerlink" title="declaration"></a>declaration</h4><p>为项目中的每个 TypeScript 或 JavaScript 文件生成 <code>.d.ts</code> 文件。这些 <code>.d.ts</code> 文件是描述模块的外部API的类型定义文件。有了 <code>.d.ts</code> 文件，像 TypeScript 这样的工具可以为正在键入的代码提供智能提示和准确的类型。</p><p>默认值：如果 <code>composite</code> 则默认值为 <code>true</code> ，否则为 <code>false</code> 。</p><h4 id="declarationDir"><a href="#declarationDir" class="headerlink" title="declarationDir"></a>declarationDir</h4><p>提供了一种配置根目录的方法，该根目录用于生成类型描述文件( <code>.d.ts</code> )。</p><h4 id="declarationMap"><a href="#declarationMap" class="headerlink" title="declarationMap"></a>declarationMap</h4><p>为映射回原始 .ts 源文件的 .d.ts 文件生成源映射。这将允许 VS Code 等编辑器在使用 go to Definition 等功能时转到原始 .ts 文件。</p><h4 id="downlevelIteration"><a href="#downlevelIteration" class="headerlink" title="downlevelIteration"></a>downlevelIteration</h4><p>如果存在 Symbol.iterator 的实现，那么 downlevelIteration 允许在 ES5 环境中更准确地使用这些迭代方法的原始语法。</p><h4 id="emitBOM"><a href="#emitBOM" class="headerlink" title="emitBOM"></a>emitBOM</h4><p>控制 TypeScript 在写入输出文件时是否会生成字节顺序标记（BOM）。一些运行时环境需要 BOM 来正确解释 JavaScript 文件；其他人则要求它不存在。默认值 false 通常是最好的，除非你有理由更改它。</p><h4 id="emitDeclarationOnly"><a href="#emitDeclarationOnly" class="headerlink" title="emitDeclarationOnly"></a>emitDeclarationOnly</h4><p>仅生成 <code>.d.ts</code> 文件；不生成 <code>.js</code> 文件。</p><h4 id="importHelpers"><a href="#importHelpers" class="headerlink" title="importHelpers"></a>importHelpers</h4><p>对于某些降级操作，TypeScript 使用一些辅助代码来执行诸如继承类、扩展数组或对象以及异步操作等。默认情况下，这些辅助代码会插入到使用它们的文件中。如果在许多不同的模块中使用相同的辅助代码，这可能会导致代码重复。如果 importHelpers 标志处于启用状态，则这些辅助函数将改为从 tslib 模块导入。你需要确保 tslib 模块能够在运行时导入。这只会影响模块；全局脚本文件将不会尝试导入模块。</p><h4 id="importsNotUsedAsValues"><a href="#importsNotUsedAsValues" class="headerlink" title="importsNotUsedAsValues"></a>importsNotUsedAsValues</h4><p>此标志控制 <code>import</code> 的工作方式，有三个不同的选项：</p><ul><li>remove：删除仅引用类型的 <code>import</code> 语句。</li><li>preserve：保留其值或类型从未使用过的所有 <code>import</code> 语句。这可能会导致保留 引入/副作用。</li><li>error：这将保留所有 <code>import</code>（与 preserve 选项相同），但当 <code>import</code> 仅用作类型时会出错。如果你希望确保没有意外导入值，但仍然显式导入副作用，那么这可能会很有用。</li></ul><p>这个标志之所以有效，是因为你可以使用 <code>import type</code> 显式地创建一个 <code>import</code> 语句，而该语句永远不应该被生成到 JavaScript 中。</p><h4 id="inlineSourceMap"><a href="#inlineSourceMap" class="headerlink" title="inlineSourceMap"></a>inlineSourceMap</h4><p>设置后，TypeScript 将把源映射内容嵌入 <code>.js</code> 文件中，而不是生成 <code>.js.map</code> 文件来提供源映射。</p><h4 id="inlineSources"><a href="#inlineSources" class="headerlink" title="inlineSources"></a>inlineSources</h4><p>设置后，TypeScript 将把 <code>.ts</code> 文件的原始内容作为嵌入字符串包含在源映射中（使用源映射的 sourcesContent 属性）。</p><h4 id="mapRoot"><a href="#mapRoot" class="headerlink" title="mapRoot"></a>mapRoot</h4><p>指定调试器应该定位映射文件的位置，而不是生成的位置。</p><h4 id="newLine"><a href="#newLine" class="headerlink" title="newLine"></a>newLine</h4><p>指定在生成文件时使用的行尾序列:’ CRLF ‘ (dos)或’ LF ‘ (unix)。</p><h4 id="noEmit"><a href="#noEmit" class="headerlink" title="noEmit"></a>noEmit</h4><p>不要生成编译器输出文件，如 JavaScript 源代码、源映射或声明。<br>这为 Babel 或 swc 等其他工具腾出了空间来处理将 TypeScript 文件转换为可以在 JavaScript 环境中运行的文件。</p><h4 id="noEmitHelpers"><a href="#noEmitHelpers" class="headerlink" title="noEmitHelpers"></a>noEmitHelpers</h4><p>你可以在全局作用域中为你使用的帮助程序提供一种实现，而不是使用 importthelpers 导入帮助程序，并完全关闭生成或帮助函数。</p><h4 id="noEmitOnError"><a href="#noEmitOnError" class="headerlink" title="noEmitOnError"></a>noEmitOnError</h4><p>如果报告了任何错误，不要生成编译器输出文件，如 JavaScript 源代码、源映射或声明。</p><p>默认值：false</p><h4 id="outDir"><a href="#outDir" class="headerlink" title="outDir"></a>outDir</h4><p>如果指定，<code>.js</code> （以及 <code>.d.ts</code> <code>.js.Map</code> 等）文件将被生成到该目录。</p><h4 id="outFile"><a href="#outFile" class="headerlink" title="outFile"></a>outFile</h4><p>如果指定，所有全局（非模块）文件将被连接到指定的单个输出文件中。</p><h4 id="preserveConstEnums"><a href="#preserveConstEnums" class="headerlink" title="preserveConstEnums"></a>preserveConstEnums</h4><p>不要在生成的代码中删除 <code>const enum</code> 声明。<code>const enum</code> 提供了一种在运行时通过生成枚举值而不是引用来减少应用程序总体内存占用的方法。</p><h4 id="preserveValueImports"><a href="#preserveValueImports" class="headerlink" title="preserveValueImports"></a>preserveValueImports</h4><p><code>preserveValueImports</code> 会阻止 TypeScript 移除 import，即使它看起来没有被使用。</p><h4 id="removeComments"><a href="#removeComments" class="headerlink" title="removeComments"></a>removeComments</h4><p>当转换为 JavaScript 时，从 TypeScript 文件中删除所有注释。</p><p>默认值：false</p><h4 id="sourceMap"><a href="#sourceMap" class="headerlink" title="sourceMap"></a>sourceMap</h4><p>允许生成源映射文件。</p><h4 id="sourceRoot"><a href="#sourceRoot" class="headerlink" title="sourceRoot"></a>sourceRoot</h4><p>指定调试器应该定位 TypeScript 文件的位置，而不是相对源位置。</p><h4 id="stripInternal"><a href="#stripInternal" class="headerlink" title="stripInternal"></a>stripInternal</h4><p>不要为 JSDoc 注释中有 <code>@internal</code> 注释的代码生成声明文件。</p><h3 id="Javascript-支持"><a href="#Javascript-支持" class="headerlink" title="Javascript 支持"></a>Javascript 支持</h3><h4 id="allowJs"><a href="#allowJs" class="headerlink" title="allowJs"></a>allowJs</h4><p>允许在项目中导入 JavaScript 文件，而不仅仅是 <code>.ts</code> 和 <code>.tsx</code> 文件。</p><h4 id="checkJs"><a href="#checkJs" class="headerlink" title="checkJs"></a>checkJs</h4><p>与 <code>allowJs</code> 协同工作。当 checkJs 被启用时，会在 JavaScript 文件中报告错误。这相当于在项目中包含的所有 JavaScript 文件的顶部包含 <code>// @ts-check</code> 。</p><h4 id="maxNodeModuleJsDepth"><a href="#maxNodeModuleJsDepth" class="headerlink" title="maxNodeModuleJsDepth"></a>maxNodeModuleJsDepth</h4><p>在 node_modules 下搜索和加载 JavaScript 文件的最大依赖深度。仅 <code>allowJs</code> 开启时有效。</p><h3 id="编辑器支持"><a href="#编辑器支持" class="headerlink" title="编辑器支持"></a>编辑器支持</h3><h4 id="disableSizeLimit"><a href="#disableSizeLimit" class="headerlink" title="disableSizeLimit"></a>disableSizeLimit</h4><p>为了避免在处理非常大的 JavaScript 项目时可能出现的内存膨胀问题，TypeScript 会分配一个内存上限。打开此标志将取消限制。</p><h4 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h4><p>要在编辑器中运行的语言服务插件列表。</p><h3 id="交互限制"><a href="#交互限制" class="headerlink" title="交互限制"></a>交互限制</h3><h4 id="allowSyntheticDefaultImports"><a href="#allowSyntheticDefaultImports" class="headerlink" title="allowSyntheticDefaultImports"></a>allowSyntheticDefaultImports</h4><p>当设置为true时，allowsyntheticdefaulultimports允许你编写这样的导入:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br></pre></td></tr></table></figure><p>而不是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br></pre></td></tr></table></figure><p>当模块未显式指定默认导出时。</p><h4 id="esModuleInterop"><a href="#esModuleInterop" class="headerlink" title="esModuleInterop"></a>esModuleInterop</h4><p>默认情况下（esModuleInterop 为 false 或未设置）d，TypeScript 对待 CommonJS/AMD/UMD 模块的方式与对待 ES6 模块类似。在此过程中，有两个部分被证明是有缺陷的：</p><ul><li><p>像 <code>import * as moment from &quot;moment&quot;</code> 这样的命名空间导入与 <code>const moment = require(&quot;moment&quot;)</code> 的作用相同</p></li><li><p>像 <code>import moment from &quot;moment&quot;</code> 这样的默认导入与 <code>const moment = require(&quot;moment&quot;).default</code> 的作用相同</p></li></ul><p>这种不匹配导致了以下两个问题:</p><p>ES6 模块规范规定，命名空间 <code>import (import * as x)</code> 只能是一个对象，通过让 TypeScript 像对待<code>= require(&quot;x&quot;)</code> 一样对待它，那么 TypeScript 就允许将导入作为一个函数来对待，并且可以被调用。根据 Javascript 说明书，这是无效的。</p><p>虽然符合 ES6 模块规范，但大多数带有 CommonJS/AMD/UMD 模块的库并不像 TypeScript 的实现那样严格遵守规范。</p><p>打开 esModuleInterop 会在 TypeScript 编译的代码中修复这两个问题。第一个改变了编译器中的行为，第二个通过两个新的帮助函数修复，这两个帮助函数提供了一个机制，以确保所生成的 JavaScript 可以兼容。</p><h4 id="forceConsistentCasingInFileNames"><a href="#forceConsistentCasingInFileNames" class="headerlink" title="forceConsistentCasingInFileNames"></a>forceConsistentCasingInFileNames</h4><p>当设置了这个选项后，如果一个程序试图用不同于磁盘上的大小写来引入一个文件，TypeScript 会提示一个错误。</p><h4 id="isolatedModules"><a href="#isolatedModules" class="headerlink" title="isolatedModules"></a>isolatedModules</h4><p>设置 <code>isolatedModules</code> 标志告诉 TypeScript，如果你写的某些代码不能被单文件编译过程正确解释，它会警告你。</p><h4 id="preserveSymlinks"><a href="#preserveSymlinks" class="headerlink" title="preserveSymlinks"></a>preserveSymlinks</h4><p>该配置与 Node.js 中相同的标志含义相同;不解析符号链接的实际路径。</p><h4 id="verbatimModuleSyntax"><a href="#verbatimModuleSyntax" class="headerlink" title="verbatimModuleSyntax"></a>verbatimModuleSyntax</h4><p>任何没有 <code>type</code> 修饰符的导入或导出都将保留。任何使用 <code>type</code> 修饰符的内容都将被完全删除。</p><h3 id="向后兼容性"><a href="#向后兼容性" class="headerlink" title="向后兼容性"></a>向后兼容性</h3><p>以下为废弃的或向后兼容配置：</p><p><code>charset</code> <code>keyofStringsOnly</code> <code>noImplicitUseStrict</code> <code>noStrictGenericChecks</code> <code>out</code> <code>suppressExcessPropertyErrors</code> <code>suppressImplicitAnyIndexErrors</code> <code>reactNamespace</code> <code>skipDefaultLibCheck</code></p><h3 id="语言与环境"><a href="#语言与环境" class="headerlink" title="语言与环境"></a>语言与环境</h3><h4 id="emitDecoratorMetadata"><a href="#emitDecoratorMetadata" class="headerlink" title="emitDecoratorMetadata"></a>emitDecoratorMetadata</h4><p>与模块 <code>reflect-metadata</code> 共同使用，启用对装饰器（decorator）生成类型元数据（metadata）的实现性支持。</p><h4 id="experimentalDecorators"><a href="#experimentalDecorators" class="headerlink" title="experimentalDecorators"></a>experimentalDecorators</h4><p>启用对 decorator 的实验性支持。</p><h4 id="jsx"><a href="#jsx" class="headerlink" title="jsx"></a>jsx</h4><p>控制文件中 JSX 结构如何生成 JavaScript。只影响 .tsx 文件。</p><table><thead><tr><th>可选项</th><th>含义</th></tr></thead><tbody><tr><td><code>react</code></td><td>带 JSX 的 js 文件会被转换成等效的 <code>React.createElement</code> 调用</td></tr><tr><td><code>react-jsx</code></td><td>带 JSX 的 js 文件会被转换成 <code>_jsx</code> 调用</td></tr><tr><td><code>react-jsxdev</code></td><td>带 JSX 的 js 文件会被转换成 <code>_jsx</code> 调用</td></tr><tr><td><code>preserve</code></td><td>带 JSX 的 js 文件中的 JSX 不会被转换</td></tr><tr><td><code>react-native</code></td><td>带 JSX 的 js 文件中的 JSX 不会被转换</td></tr></tbody></table><h4 id="jsxFactory"><a href="#jsxFactory" class="headerlink" title="jsxFactory"></a>jsxFactory</h4><p>使用 JSX 运行时编译 JSX 元素时，更改 <code>.js</code> 文件中调用的函数。最常见的更改是使用 <code>h</code> 或 <code>preact.h</code>，而不是默认的 <code>React.createElement</code>（如果使用 preact）。</p><h4 id="jsxFragmentFactory"><a href="#jsxFragmentFactory" class="headerlink" title="jsxFragmentFactory"></a>jsxFragmentFactory</h4><p>指定在带有 <code>jsxFactory</code> 编译器选项的目标 react JSX 生成时要使用的 JSX fragment 工厂函数，例如 <code>Fragment</code>。</p><h4 id="jsxImportSource"><a href="#jsxImportSource" class="headerlink" title="jsxImportSource"></a>jsxImportSource</h4><p>当 <code>jsx</code> 属性为为 “react jsx” 或 “react jsonxdev” 时，声明用于导入 <code>jsx</code> 和 <code>jsxs</code> 工厂函数的模块说明符。</p><p>默认值： <code>react</code></p><h4 id="lib"><a href="#lib" class="headerlink" title="lib"></a>lib</h4><p>用于使 TypeScript 包括与你指定的目标匹配的 JS 新功能的 API 的类型声明。</p><h4 id="moduleDetection"><a href="#moduleDetection" class="headerlink" title="moduleDetection"></a>moduleDetection</h4><p>此设置控制 TypeScript 如何确定文件是脚本还是模块。</p><table><thead><tr><th>可选项</th><th>含义</th></tr></thead><tbody><tr><td><code>auto</code></td><td>默认值，TypeScript 不仅会查找导入和导出语句，而且当使用 <code>module</code>:<code>nodenext</code> 或 <code>node16</code> 运行时，它还会检查 <code>package.json</code> 中的 <code>“type”</code> 字段是否设置为 “module”，当 <code>jsx</code> 配置项为 <code>react-jsx</code> 时，还会检查当前文件是否为 JSX 文件。</td></tr><tr><td><code>legacy</code></td><td>使用导入和导出语句来确定文件是否为模块。</td></tr><tr><td><code>force</code></td><td>确保每个非声明文件都被视为一个模块。</td></tr></tbody></table><h4 id="noLib"><a href="#noLib" class="headerlink" title="noLib"></a>noLib</h4><p>禁用自动包含任何库文件。如果设置了此选项，则会忽略 <code>lib</code> 配置项。</p><h4 id="target"><a href="#target" class="headerlink" title="target"></a>target</h4><p>target 配置项决定了哪些 JS 特性降级了，哪些保持不变。</p><h4 id="useDefineForClassFields"><a href="#useDefineForClassFields" class="headerlink" title="useDefineForClassFields"></a>useDefineForClassFields</h4><p>这个标志被用作迁移到即将到来的 class 字段标准版本的一部分。</p><p>默认值：如果 <code>target</code> 是 <code>ES2022</code> 或者更高版本（包括 <code>ESNext</code>） 则为 <code>true</code>，否则为 <code>false</code></p><h3 id="编译诊断"><a href="#编译诊断" class="headerlink" title="编译诊断"></a>编译诊断</h3><h4 id="diagnostics"><a href="#diagnostics" class="headerlink" title="diagnostics"></a>diagnostics</h4><p>输出诊断信息，用于调试。</p><h4 id="explainFiles"><a href="#explainFiles" class="headerlink" title="explainFiles"></a>explainFiles</h4><p>打印 TypeScript 认为是你项目一部分的文件名，以及它们成为编译一部分的原因。</p><h4 id="extendedDiagnostics"><a href="#extendedDiagnostics" class="headerlink" title="extendedDiagnostics"></a>extendedDiagnostics</h4><p>你可以使用这个标志来发现 TypeScript 在编译时把时间花在了哪里。这是一个用于全面了解代码库性能特征的工具。</p><h4 id="generateCpuProfile"><a href="#generateCpuProfile" class="headerlink" title="generateCpuProfile"></a>generateCpuProfile</h4><p>这个选项让你有机会让 TypeScript 在编译器运行期间输出 v8 CPU 配置文件。CPU 配置文件可以深入了解构建可能缓慢的原因。</p><p>默认值： <code>profile.cpuprofile</code></p><h4 id="listEmittedFiles"><a href="#listEmittedFiles" class="headerlink" title="listEmittedFiles"></a>listEmittedFiles</h4><p>将编译过程中生成的文件的名称打印到终端。</p><h4 id="listFiles"><a href="#listFiles" class="headerlink" title="listFiles"></a>listFiles</h4><p>打印编译过程中文件的名称。</p><h4 id="traceResolution"><a href="#traceResolution" class="headerlink" title="traceResolution"></a>traceResolution</h4><p>让 TypeScript 为每个处理过的文件打印有关它的解析过程的信息。</p><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><h4 id="composite"><a href="#composite" class="headerlink" title="composite"></a>composite</h4><p><code>composite</code> 选项强制了某些约束，使得构建工具（包括 TypeScript 本身，在 <code>-—build</code> 模式下）能够快速确定项目是否已经构建完成。</p><h4 id="disableReferencedProjectLoad"><a href="#disableReferencedProjectLoad" class="headerlink" title="disableReferencedProjectLoad"></a>disableReferencedProjectLoad</h4><p>如果你的项目很大，你可以使用 disableReferencedProjectLoad 标志来禁用所有项目的自动加载。相反，当你通过编辑器打开文件时，会动态加载项目。</p><h4 id="disableSolutionSearching"><a href="#disableSolutionSearching" class="headerlink" title="disableSolutionSearching"></a>disableSolutionSearching</h4><p>当使用复合 TypeScript 项目时，该选项提供了一种方式来声明，当使用诸如 <em>查找所有引用</em> 或在编辑器中 <em>跳转到定义</em> 之类的特性时，你不希望包含某个项目。</p><h4 id="disableSourceOfProjectReferenceRedirect"><a href="#disableSourceOfProjectReferenceRedirect" class="headerlink" title="disableSourceOfProjectReferenceRedirect"></a>disableSourceOfProjectReferenceRedirect</h4><p>当使用复合 TypeScript 项目时，该选项提供了一种回到 Typescript 3.7 之前的行为的方法，在 Typescript 3.7 之前，<code>d.ts</code> 文件被用作模块之间的边界。</p><h4 id="incremental"><a href="#incremental" class="headerlink" title="incremental"></a>incremental</h4><p>告诉 TypeScript 将上次编译时的项目图信息保存到存储在磁盘上的文件 <code>.tsbuildinfo</code> 中。</p><p>默认值：如果 <code>composite</code> 配置项为 <code>true</code> 则为 <code>true</code>，否则为 <code>false</code>。</p><h4 id="tsBuildInfoFile"><a href="#tsBuildInfoFile" class="headerlink" title="tsBuildInfoFile"></a>tsBuildInfoFile</h4><p>这个设置允许你指定一个文件来存储增量编译信息，作为复合项目的一部分，这样可以更快地构建更大的 TypeScript 代码库。</p><p>默认值：<code>.tsbuildinfo</code></p><h3 id="输出格式化"><a href="#输出格式化" class="headerlink" title="输出格式化"></a>输出格式化</h3><h4 id="noErrorTruncation"><a href="#noErrorTruncation" class="headerlink" title="noErrorTruncation"></a>noErrorTruncation</h4><p>不要截断错误消息。</p><h4 id="preserveWatchOutput"><a href="#preserveWatchOutput" class="headerlink" title="preserveWatchOutput"></a>preserveWatchOutput</h4><p>是否将过时的控制台输出保持在监视模式，而不是每次发生更改时清除屏幕。</p><h4 id="pretty"><a href="#pretty" class="headerlink" title="pretty"></a>pretty</h4><p>使用颜色和上下文对错误和消息进行风格化，默认开启。</p><h3 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h3><h4 id="skipLibCheck"><a href="#skipLibCheck" class="headerlink" title="skipLibCheck"></a>skipLibCheck</h4><p>跳过声明文件的类型检查。</p><h3 id="监视选项"><a href="#监视选项" class="headerlink" title="监视选项"></a>监视选项</h3><h4 id="assumeChangesOnlyAffectDirectDependencies"><a href="#assumeChangesOnlyAffectDirectDependencies" class="headerlink" title="assumeChangesOnlyAffectDirectDependencies"></a>assumeChangesOnlyAffectDirectDependencies</h4><p>当启用这个选项时，TypeScript 将避免重新检查/重建所有真正可能受到影响的文件，只重新检查/重建那些已经改变的文件，以及那些直接导入它们的文件。</p>]]></content>
      
      
      
        <tags>
            
            <tag> typescript </tag>
            
            <tag> tsconfig </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EventSource API</title>
      <link href="/blog/2023/08/04/FE-EventSource/"/>
      <url>/blog/2023/08/04/FE-EventSource/</url>
      
        <content type="html"><![CDATA[<p>EventSource 接口是 web 内容与服务器发送事件通信的接口。</p><p>一个 EventSource 实例会对 HTTP 服务器开启一个持久化的连接，以 <code>text/event-stream</code> 格式发送事件，此连接会一直保持开启直到通过调用 <code>EventSource.close()</code> 关闭。一旦连接开启，来自服务端传入的消息会以事件的形式分发至客户端中，如果接收消息中有一个 event 字段，触发的事件与 event 字段的值相同。如果不存在 event 字段，则将触发通用的 message 事件。</p><p>与 WebSocket 不同的是，服务器发送事件是单向的。数据消息只能从服务端发送到客户端（如用户的浏览器）。这使其成为不需要从客户端往服务器发送消息的情况下的最佳选择。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p><code>EventSource()</code></p><p>创建一个新的 EventSource，用于从指定的 URL 接收服务器发送事件，可以选择开启凭据模式。</p><p>用法： <code>cosnt pc = new EventSource(url, configuration);</code></p><p>url 表示远程资源的位置，configuration 为配置新连接提供选项，目前只有一个可选项 withCredentials，默认为 false，指示 CORS 是否应包含凭据。</p><h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><p>此接口从其父接口 EventTarget 继承属性。</p><ul><li><p>EventSource.readyState 只读<br>一个代表连接状态的数字。可能值是 CONNECTING（0）、OPEN（1）或 CLOSED（2）。</p></li><li><p>EventSource.url 只读<br>一个表示事件源的 URL 字符串。</p></li><li><p>EventSource.withCredentials 只读<br>一个布尔值，表示 EventSource 对象是否使用跨域资源共享（CORS）凭据来实例化（true），或者不使用（false，即默认值）。</p></li></ul><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><p>此接口从其父接口 EventTarget 继承方法。</p><ul><li>EventSource.close()<br>关闭连接（如果有），并将 readyState 属性设置为 CLOSED。如果连接已经关闭，则该方法不执行任何操作。</li></ul><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ul><li><p>error<br>在事件源连接未能打开时触发。</p></li><li><p>message<br>在从事件源接收到数据时触发。</p></li><li><p>open<br>在与事件源的连接打开时触发。</p></li></ul><p>此外，事件源本身可以发送具有 event 字段的消息，这将创建一个以该值为键的特定事件。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>在这个基本的例子中，创建了一个 EventSource 来从服务器接收未命名的事件；一个名为 sse.php 的页面负责生成这些事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> evtSource = <span class="keyword">new</span> <span class="title class_">EventSource</span>(<span class="string">&quot;sse.php?message=hello&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> eventList = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;ul&quot;</span>);</span><br><span class="line"></span><br><span class="line">evtSource.<span class="property">onmessage</span> = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> newElement = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;li&quot;</span>);</span><br><span class="line"></span><br><span class="line">  newElement.<span class="property">textContent</span> = <span class="string">`message: <span class="subst">$&#123;e.data&#125;</span>`</span>;</span><br><span class="line">  eventList.<span class="title function_">appendChild</span>(newElement);</span><br><span class="line">  evtSource.<span class="title function_">close</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个接收到的事件都会导致我们的 EventSource 对象的 onmessage 事件处理程序运行。它会创建一个新的 <code>&lt;li&gt;</code> 元素，并将消息的数据写入其中，然后将新元素附加到文档中已有的列表元素中。</p><p>要监听具名事件，你需要为每种类型的事件添加一个监听器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sse = <span class="keyword">new</span> <span class="title class_">EventSource</span>(<span class="string">&quot;/api/v1/sse&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这将仅监听类似下面的事件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * event: notice</span></span><br><span class="line"><span class="comment"> * data: useful data</span></span><br><span class="line"><span class="comment"> * id: someid</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sse.<span class="title function_">addEventListener</span>(<span class="string">&quot;notice&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">data</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 同理，以下代码将监听具有字段 `event: update` 的事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sse.<span class="title function_">addEventListener</span>(<span class="string">&quot;update&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">data</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * “message”事件是一个特例，因为它可以捕获没有 event 字段的事件，</span></span><br><span class="line"><span class="comment"> * 以及具有特定类型 `event：message` 的事件。</span></span><br><span class="line"><span class="comment"> * 它不会触发任何其他类型的事件。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sse.<span class="title function_">addEventListener</span>(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">data</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li><p>浏览器同域名下的HTTP请求数量是有限制的（例如Chrome浏览器的限制为6个），所以如果打开多个选项卡，这种长连接可能会因为占满限制名额而导致无法发送新的HTTP请求。</p></li><li><p>EventSource API 发送的HTTP请求为GET类型的，如果想要发送POST类型的HTTP请求，或者修改HTTP请求的headers，可以使用 <code>@microsoft/fetch-event-source</code> 库，该库对这种情况进行了polyfill，使用方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; fetchEventSource &#125; <span class="keyword">from</span> <span class="string">&#x27;@microsoft/fetch-event-source&#x27;</span>;</span><br><span class="line"><span class="title function_">fetchEventSource</span>(url, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    <span class="title class_">Accept</span>: <span class="string">&#x27;*/*&#x27;</span>,</span><br><span class="line">    <span class="title class_">Connection</span>: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">    <span class="attr">messages</span>: [&#123;</span><br><span class="line">      <span class="attr">content</span>: <span class="string">&#x27;Hello.&#x27;</span>,</span><br><span class="line">      <span class="attr">role</span>: <span class="string">&#x27;user&#x27;</span>,</span><br><span class="line">    &#125;],</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="title function_">onmessage</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`EventSource onmessage <span class="subst">$&#123;<span class="built_in">Date</span>.now()&#125;</span>: <span class="subst">$&#123;event.data&#125;</span>`</span>);</span><br><span class="line">  &#125;，</span><br><span class="line">  <span class="title function_">onerror</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;EventSource onerror&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>类似的库还有 <code>event-source-polyfill</code> 库。</p></li><li><p>针对问答式的请求，服务器端返回的文本数据为流式时，EventSource API 相比 WebSocket 更加简单便捷，chatGPT 类问答服务多采用 EventSource API 来实现。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> performance </tag>
            
            <tag> Web API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高级编程语言</title>
      <link href="/blog/2023/08/04/CS-%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
      <url>/blog/2023/08/04/CS-%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>语言名称</th><th>发布时间</th><th>作者</th><th>特点</th></tr></thead><tbody><tr><td>Fortran</td><td>1957年</td><td>John Backus</td><td>Fortran是第一种高级编程语言，由IBM的John Backus和他的团队开发。它主要用于科学和工程计算，并在数值计算领域取得了巨大成功。</td></tr><tr><td>Lisp</td><td>1958年</td><td>John McCarthy</td><td>Lisp是第一种函数式编程语言，由John McCarthy开发。它在人工智能和符号处理领域得到广泛应用，并成为函数式编程的重要基础。</td></tr><tr><td>COBOL</td><td>1959年</td><td>Grace Hopper</td><td>COBOL是一种商业计算语言，由美国国家标准局（NBS）的Grace Hopper领导的团队开发。它被广泛用于商业和金融领域，并成为最早的通用商业计算语言之一。</td></tr><tr><td>Basic</td><td>1964年</td><td>John G. Kemeny</td><td>Basic语言于1964年由John G. Kemeny和Thomas E. Kurtz在达特茅斯学院开发。它是一种易学易用的高级编程语言，主要用于教育和初学者的编程。它具有简单的语法和交互式编程特性，适合用于学习编程基础和算法思维。</td></tr><tr><td>C</td><td>1972年</td><td>Dennis Ritchie</td><td>C语言由Dennis Ritchie在贝尔实验室开发。它是一种通用的高级编程语言，被广泛用于系统软件开发和操作系统编写。C语言也成为后来许多其他编程语言的基础。</td></tr><tr><td>C++</td><td>1983年</td><td>Bjarne Stroustrup</td><td>C++是由Bjarne Stroustrup在C语言基础上扩展而来的编程语言。它引入了面向对象编程的概念，并成为许多应用程序和系统软件的首选语言之一。</td></tr><tr><td>Python</td><td>1991年</td><td>Guido van Rossum</td><td>Python是由Guido van Rossum开发的一种高级编程语言。它以简洁和易读的语法而闻名，并在数据科学、人工智能和Web开发等领域得到广泛应用。</td></tr><tr><td>PHP</td><td>1994年</td><td>Rasmus Lerdorf</td><td>PHP于1994年由Rasmus Lerdorf创建，最初被称为”Personal Home Page”（个人主页）的缩写。它是一种功能强大、易学易用的服务器端脚本语言，适用于Web开发，并且拥有广泛的应用领域和活跃的开发者社区。</td></tr><tr><td>Ruby</td><td>1995年</td><td>松本行弘（Yukihiro Matsumoto）</td><td>Ruby是一种简洁而优雅的动态类型编程语言，注重开发人员的幸福感。它具有简单易读的语法和强大的元编程能力，被广泛应用于Web开发和脚本编程。</td></tr><tr><td>Java</td><td>1995年</td><td>James Gosling</td><td>Java是由Sun Microsystems（现在是Oracle）的James Gosling和他的团队开发的。它是一种跨平台的编程语言，被广泛应用于企业级应用程序和移动应用开发。</td></tr><tr><td>JavaScript</td><td>1995年</td><td>Brendan Eich</td><td>JavaScript于1995年由Brendan Eich在Netscape公司开发。JavaScript主要用于Web前端开发，包括网页交互、表单验证、动态内容更新、动画效果等。它也被广泛应用于移动应用开发（使用框架如React Native）、服务器端开发（使用Node.js）以及游戏开发（使用HTML5游戏引擎）等领域。</td></tr><tr><td>C#</td><td>2000年</td><td>Anders Hejlsberg</td><td>C#是一种由Microsoft开发的通用编程语言，用于开发Windows应用程序、Web应用程序和游戏等。它具有类似于Java的语法和面向对象编程的特性，被广泛应用于Microsoft生态系统中。</td></tr><tr><td>Scala</td><td>2003年</td><td>Martin Odersky</td><td>Scala是一种运行在Java虚拟机上的多范式编程语言，结合了面向对象编程和函数式编程的特性。它具有强大的静态类型系统和丰富的函数式编程库，被广泛应用于大数据处理和分布式系统开发。</td></tr><tr><td>Go</td><td>2009年</td><td>Robert Griesemer</td><td>Go语言于2009年由Google的Robert Griesemer、Rob Pike和Ken Thompson共同设计和开发。它是一种注重高效性能、简洁易学的编程语言，适用于并发编程和构建高性能的应用程序。它具有丰富的标准库和跨平台性，被广泛应用于各种领域的软件开发。</td></tr><tr><td>Rust</td><td>2010年</td><td>Graydon Hoare</td><td>Rust于2010年由Mozilla的Graydon Hoare开始开发，2015年首次发布。Rust主要用于系统级编程，如操作系统、嵌入式设备、网络服务和游戏引擎等领域。由于其内存安全和并发性能，Rust也逐渐在Web后端开发和网络安全领域得到应用。</td></tr><tr><td>Kotlin</td><td>2011年</td><td>Andrey Breslav</td><td>Kotlin是一种基于Java虚拟机的静态类型编程语言，由JetBrains开发。它具有与Java互操作性、简洁的语法和空安全等特性。Kotlin被广泛应用于Android应用程序开发，并逐渐成为替代Java的首选语言。</td></tr><tr><td>TypeScript</td><td>2012年</td><td>Microsoft</td><td>TypeScript于2012年由Microsoft推出。它主要用于Web前端开发，特别是大型项目和团队协作。通过引入静态类型检查，TypeScript可以提高代码的可维护性和可读性，减少潜在的错误。它也可以与现有的JavaScript代码无缝集成，逐步迁移项目到TypeScript。</td></tr><tr><td>Swift</td><td>2014年</td><td>Chris Lattner</td><td>Swift是由Apple开发的一种多用途编程语言，用于iOS、macOS、watchOS和tvOS应用程序开发。它具有现代化的语法、强大的类型推断和丰富的标准库，使得开发iOS应用变得更加高效和安全。</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> language </tag>
            
            <tag> programmer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据可视化平台调研</title>
      <link href="/blog/2023/02/27/CS-%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B3%E5%8F%B0%E8%B0%83%E7%A0%94/"/>
      <url>/blog/2023/02/27/CS-%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B3%E5%8F%B0%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h2 id="数据可视化（Data-Visualization）"><a href="#数据可视化（Data-Visualization）" class="headerlink" title="数据可视化（Data Visualization）"></a>数据可视化（Data Visualization）</h2><p>数据可视化是关于数据视觉表现形式的科学技术研究，主要旨在借助于图形化手段，清晰有效地传达与沟通信息。简单来说，数据可视化就是将数据转换成图或表等，以一种更直观的方式展现和呈现数据，让读者能“一眼看懂”你想表达的信息。通过“可视化”的方式，复杂的数据通过图形化的手段进行有效表达，准确高效、简洁全面地传递某种信息，甚至我们帮助发现某种规律和特征，挖掘数据背后的价值。<br>数据可视化主要应用在一些 <strong>报表类软件</strong> 、 <strong>商业智能（Business Intelligence,BI）分析工具</strong> 或 <strong>系统监控类应用</strong> 中。</p><h2 id="数据分析关键字"><a href="#数据分析关键字" class="headerlink" title="数据分析关键字"></a>数据分析关键字</h2><p><strong>维度</strong>：数据的维数一般是指数据不相干的几种特性，可以理解为数据分类的字段，比如地区、名称、日期等。<br><strong>钻取/下钻</strong>：钻取是改变维度的层次，变换分析的粒度。它包括向上钻取和向下钻取。通过向导的方式，用户可以定义分析因素的汇总行，例如对于各地区各年度的销售情况，可以生成地区与年度的合计行，也可以生成地区或者年度的合计行。<br><strong>联动</strong>：一张可视化图表可以用来对另一张可视化图表中已经录入的数据，进行直接或有条件地调用称为联动。</p><h2 id="可视化平台基础架构"><a href="#可视化平台基础架构" class="headerlink" title="可视化平台基础架构"></a>可视化平台基础架构</h2><p>数据可视化平台基础架构如下：</p><p><img src="/blog/static/imgs/datavisual/data-visual.svg" alt="data-visual_inner"></p><p>绿色代表重要的功能，红色代表可选功能，灰色代表不重要功能。</p><p>一般分为四层，从下到上依次为 <strong>数据源</strong>、<strong>数据集</strong>、<strong>视图层</strong>、<strong>仪表板</strong>，根据规模和实际应用情况，还会有 <strong>系统管理层</strong> 用来承接系统层面的公共功能。</p><p><strong>数据源</strong>为系统获取数据的来源，根据类型可以分为 数据库类（例如从 MySQL、SQLServer、Oracel等类型数据库中获取数据）、文件类（例如 Excel表格）、API。配置好数据源后，平台从数据源获取数据并进行导入。如果数据量过大，会有任务管理模块用来控制数据导入任务。一些系统会支持定时同步或实时获取（常见于系统监控类应用），另一些则是线下分析（常见于报表类软件）。<br>从数据源获取到的数据会被存放在平台的<strong>数据集</strong>中，支持查询与数据联动。一些平台支持根据规则进行计算，例如通过企业历史财务物料数据进行计划预算。<br><strong>视图层</strong>是指可视化图表可显示的模块与组件，视图层一般以图标库（例如Echarts）为基础，支持多种视图组件（例如柱状图、折线图等），用户需要设置组件的属性（例如宽、高、位置、颜色、背景等）、数据来源（从数据集中选择，X轴、Y轴的维度以及示例等）。一些可视化平台支持多图表联动及数据钻取，还有一些平台会支持对维度进行过滤。<br><strong>仪表盘</strong>是用户可见的可视化图表UI层。用户可以通过拖拽的方式进行图表的布局，一般平台也会支持多端查看（即在PC、移动端、大屏等多种终端上查看效果）。</p><h2 id="数据可视化工具"><a href="#数据可视化工具" class="headerlink" title="数据可视化工具"></a>数据可视化工具</h2><p>以下将列举出一些开源的数据可视化工具及平台：</p><table><thead><tr><th>工具</th><th>热度</th><th>开源协议</th><th>体验</th></tr></thead><tbody><tr><td>Grafana</td><td>54.1k</td><td>AGPL-3.0</td><td><a href="https://play.grafana.org/">在线体验</a></td></tr><tr><td>Apache Superset</td><td>50.7k</td><td>Apache-2.0</td></tr><tr><td>DataEase</td><td>9k</td><td>GPL-3.0</td><td><a href="https://dataease.fit2cloud.com/">在线体验</a> 用户名：demo 密码：dataease</td></tr><tr><td>DataV</td><td>7.5k</td><td>MIT</td><td>在线体验：<br><a href="http://datav.jiaminghi.com/demo/construction-data/index.html">施工养护综合数据</a><br><a href="http://datav.jiaminghi.com/demo/manage-desk/index.html">机电运维管理台</a><br><a href="http://datav.jiaminghi.com/demo/electronic-file/index.html">机电设备电子档案</a></td></tr><tr><td>big_screen</td><td>1.3k</td><td>MIT</td><td><a href="bigscreen.turboway.top/corp">在线体验</a></td></tr><tr><td>datart</td><td>1.2k</td><td>Apache-2.0</td><td><a href="http://datart-demo.retech.cc">在线体验</a> 用户名：demo 密码：123456</td></tr></tbody></table><h3 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h3><p><a href="https://github.com/grafana/grafana">Grafana</a> 是一款用于实时监控的开源平台。Grafana 支持对数据进行查询、可视化、提醒与维度分析，支持多种数据源。同时，通过 Grafana，团队成员可以共同创建、探索和分享仪表盘，并通过数据驱动业务成长。</p><p>Grafana效果预览：<br><img src="/blog/static/imgs/datavisual/grafana.png" alt="grafana_inner"></p><h3 id="Apache-Superset"><a href="#Apache-Superset" class="headerlink" title="Apache Superset"></a>Apache Superset</h3><p><a href="https://github.com/apache/superset">Apache Superset</a> 是一个面向企业的现代商业智能 web 应用和数据可视化平台。它与各种数据源集成良好，也可以与各种商业BI进行集成。</p><p>Superset效果预览：<br><img src="/blog/static/imgs/datavisual/superset.jpg" alt="superset_inner"></p><h3 id="DataEase"><a href="#DataEase" class="headerlink" title="DataEase"></a>DataEase</h3><p><a href="https://github.com/dataease/dataease">DataEase</a> 是一款开源的数据可视化分析工具，由 fit2cloud 飞致云开发。它支持 Excel、MySQL、ORACEL、SQLServer、MariaDB、达梦、人大金仓 等多种数据源，能够通过拖拽方式快速制作图表，并且支持PC端、移动端、大屏等多种表现形式。</p><p>DataEase效果图预览：<br><img src="/blog/static/imgs/datavisual/dataease.gif" alt="dataease_inner"></p><!--DataEase技术栈：    前端：[Vue.js](https://vuejs.org/)、[Element](https://element.eleme.cn/#/)    图库：[Apache ECharts](https://github.com/apache/echarts)、[AntV](https://antv.vision/zh/)    后端：[Spring Boot](https://spring.io/projects/spring-boot/)    中间件：[MySQL](https://www.mysql.com/)    数据处理：[Kettle](https://github.com/pentaho/pentaho-kettle)、[Apache Doris](https://github.com/apache/doris)    基础设施：[Docker](https://www.docker.com/)DataEase架构：![dataease_inner](/blog/static/imgs/datavisual/dataease_struc.jpg)--><h3 id="DataV"><a href="#DataV" class="headerlink" title="DataV"></a>DataV</h3><p><a href="https://github.com/DataV-Team/DataV">DataV</a> 是一个基于 Vue 的数据可视化组件库，提供用于提升页面视觉效果的 SVG 边框和装饰，提供常用的图表如折线图等，也提供了飞线图/轮播表等其他组件。</p><p>DataV效果图预览：<br><img src="/blog/static/imgs/datavisual/datav.jpg" alt="datav_inner"></p><h3 id="big-screen"><a href="#big-screen" class="headerlink" title="big_screen"></a>big_screen</h3><p><a href="https://github.com/TurboWay/big_screen">big_screen</a> 是一款数据大屏可视化工具,由 TurboWay 开发，通过 Python 工具获取数据并进行可视化展示。</p><p>big_screen效果图预览：<br><img src="/blog/static/imgs/datavisual/big_screen.jpg" alt="big_screen_inner"></p><!--big_screen 技术栈：前端 HTML后端 Python--><h3 id="datart"><a href="#datart" class="headerlink" title="datart"></a>datart</h3><p><a href="https://github.com/running-elephant/datart">datart</a> 是一款数据可视化开放平台，支持报表、仪表板、大屏、分析和可视化数据应用的敏捷构建。</p><p>datart效果图预览：<br><img src="/blog/static/imgs/datavisual/datart.jpg" alt="datart_inner"></p><!--datart架构：![datart_inner](/blog/static/imgs/datavisual/datart_struc.png)-->]]></content>
      
      
      
        <tags>
            
            <tag> BI </tag>
            
            <tag> data-visualization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>限制并发数量的多请求执行</title>
      <link href="/blog/2023/02/09/FE-%E9%99%90%E5%88%B6%E5%B9%B6%E5%8F%91%E6%95%B0%E9%87%8F%E7%9A%84%E5%A4%9A%E8%AF%B7%E6%B1%82%E6%89%A7%E8%A1%8C/"/>
      <url>/blog/2023/02/09/FE-%E9%99%90%E5%88%B6%E5%B9%B6%E5%8F%91%E6%95%B0%E9%87%8F%E7%9A%84%E5%A4%9A%E8%AF%B7%E6%B1%82%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>在项目中，我们经常会遇到同时发送多个HTTP请求的情况，对于同域名的请求，浏览器会限制同时发起的请求数量，当超过浏览器并发请求限制时，超过的请求将会等待，直到有请求返回时才会进行下一次请求。这是浏览器的一种保护机制，为了防止通过浏览器发起过量的请求，耗尽资源。在小程序中也会有同样的机制，例如，微信小程序中说明 <code>wx.request</code> 的最大并发限制是 10 个，<code>wx.connectSocket</code> 的最大并发限制是 5 个（参见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/ability/network.html">微信小程序官方文档-基础能力/网络/使用说明-网络-3.网络请求-使用限制</a> ），但是这里有个BUG，在小程序中如果并发请求超过10个，并不会等待而是直接失败，所以实际上需要用户自己处理并发请求数，在超过10个时，请求需要在队列中等待而不是直接失败。</p><span id="more"></span><p>假如我们的请求方法 <code>request</code> 形如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">request</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;options&#125;</span> is start`</span>)</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;options&#125;</span> is finished`</span>)</span><br><span class="line">            <span class="title function_">resolve</span>(&#123; <span class="attr">data</span>: options &#125;);</span><br><span class="line">        &#125;, <span class="number">3000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>request</code> 是一个通用的请求方法，它接受请求的参数，返回请求的 Promise，其中 options 是形如 <code>&#123;url: &#39;&#39;, method: &#39;GET&#39;, params: &#123;&#125;&#125;</code> 的请求相关参数对象。</p><p>在业务中，我们会通过 <code>fetch</code> 方法获取请求内容并处理请求结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fetch</span>(<span class="params">options</span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">request</span>(options).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fetch</code> 是一个和业务相关的请求方法，它接受请求的参数，对请求的结果进行处理。</p><p>当发起多个并行请求时，最简单直接的方法就是使用 <code>Promise.all</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多请求并行执行</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">parallelRequest</span>(<span class="params">optionsList</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(optionsList.<span class="title function_">map</span>(<span class="function"><span class="params">options</span> =&gt;</span> <span class="title function_">request</span>(options)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">parallelRequest</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br></pre></td></tr></table></figure><p>如果需要请求串行发送，可以通过 <code>async/await</code> 的方式等待前一个请求返回后再发起下一个请求:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多请求串行执行</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">serialRequest</span>(<span class="params">optionsList</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; optionsList.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="title function_">request</span>(optionsList[i]);</span><br><span class="line">        res.<span class="title function_">push</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">serialRequest</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br></pre></td></tr></table></figure><p>串行是可以避免超过10个请求后，再次发送请求失败的问题，但是没有充分利用并行发送的数量，更好的方式是通过参数限制并发请求数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 限制并发数量的多请求执行</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">multiRequest</span>(<span class="params">optionsList = [], maxNum</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> len = optionsList.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>(len).<span class="title function_">fill</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count &lt; maxNum) &#123;</span><br><span class="line">            <span class="title function_">next</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> current = count++;</span><br><span class="line">            <span class="keyword">if</span> (current &gt;= len) &#123;</span><br><span class="line">                !result.<span class="title function_">includes</span>(<span class="literal">false</span>) &amp;&amp; <span class="title function_">resolve</span>(result);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> options = optionsList[current];</span><br><span class="line">            <span class="title function_">request</span>(options)</span><br><span class="line">                .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">                    result[current] = res;</span><br><span class="line">                    <span class="keyword">if</span> (current &lt; len) &#123;</span><br><span class="line">                        <span class="title function_">next</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">                    result[current] = err;</span><br><span class="line">                    <span class="keyword">if</span> (current &lt; len) &#123;</span><br><span class="line">                        <span class="title function_">next</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">multiRequest</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>], <span class="number">3</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br></pre></td></tr></table></figure><p>实际业务场景中，我们并不会在一个地方同时发起多个请求，而是在不同的地方发起请求，所以限制并发数量的的 request 方法应该是一个工具函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提供给第三方使用的 request 方法，内部实现支持限制并发数量的请求</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LimitRequest</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">limit</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">limit</span> = limit; <span class="comment">// 并发请求限制数量</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tasks</span> = []; <span class="comment">// 请求等待队列</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">current</span> = <span class="number">0</span>; <span class="comment">// 当前并发请求数量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">addRequest</span>(<span class="params">reqFn</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!reqFn || !(reqFn <span class="keyword">instanceof</span> <span class="title class_">Function</span>)) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;当前请求不是一个Function&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tasks</span>.<span class="title function_">push</span>(reqFn);</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">current</span> &lt; <span class="variable language_">this</span>.<span class="property">limit</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">run</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">current</span>++;</span><br><span class="line">            <span class="keyword">const</span> fn = <span class="variable language_">this</span>.<span class="property">tasks</span>.<span class="title function_">shift</span>();</span><br><span class="line">            <span class="keyword">await</span> <span class="title function_">fn</span>();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(err);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">current</span>--;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">tasks</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">run</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> limitRequest = <span class="keyword">new</span> <span class="title class_">LimitRequest</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">    limitRequest.<span class="title function_">addRequest</span>(fetch.<span class="title function_">bind</span>(<span class="literal">null</span>, i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上面用的是 fetch 方法，当需要发送请求时，需要确定请求返回后的处理逻辑，将整体的方法写成 fetch 方法，并通过 <code>addRequest</code> 添加到并行的队列中去。</p><p>我们也可以优化一下，使用 request 方法，这样可以在请求时不必确定返回后的逻辑，将 <em>请求</em> 这个动作与业务分离：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LimitRequest</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">limit</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">limit</span> = limit; <span class="comment">// 并发限制数量</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tasks</span> = []; <span class="comment">// 等待的请求队列</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">current</span> = <span class="number">0</span>;  <span class="comment">// 当前进行中的请求数量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">request</span>(<span class="params">options</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> reqFn = request.<span class="title function_">bind</span>(<span class="literal">null</span>, options);</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">tasks</span>.<span class="title function_">push</span>([reqFn, resolve, reject]);</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">current</span> &lt; <span class="variable language_">this</span>.<span class="property">limit</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">run</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">current</span>++;</span><br><span class="line">            <span class="keyword">const</span> [fn, resolve, reject] = <span class="variable language_">this</span>.<span class="property">tasks</span>.<span class="title function_">shift</span>();</span><br><span class="line">            <span class="keyword">await</span> <span class="title function_">fn</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(res);</span><br><span class="line">            &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">reject</span>(err);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(err);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">current</span>--;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">tasks</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">run</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> limitRequest = <span class="keyword">new</span> <span class="title class_">LimitRequest</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> newRequest = limitRequest.<span class="property">request</span>.<span class="title function_">bind</span>(limitRequest);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">newRequest</span>(i).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为 utils 方法，可以这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> limit = <span class="number">3</span>; <span class="comment">// 并发限制数量</span></span><br><span class="line"><span class="keyword">let</span> tasks = []; <span class="comment">// 等待的请求队列</span></span><br><span class="line"><span class="keyword">let</span> current = <span class="number">0</span>;  <span class="comment">// 当前进行中的请求数量</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">limitRequest</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> reqFn = request.<span class="title function_">bind</span>(<span class="literal">null</span>, options);</span><br><span class="line">        tasks.<span class="title function_">push</span>([reqFn, resolve, reject]);</span><br><span class="line">        <span class="keyword">if</span> (current &lt; limit) &#123;</span><br><span class="line">            <span class="title function_">run</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">setLimit</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    limit = num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        current++;</span><br><span class="line">        <span class="keyword">const</span> [fn, resolve, reject] = <span class="variable language_">this</span>.<span class="property">tasks</span>.<span class="title function_">shift</span>();</span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">fn</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(res);</span><br><span class="line">        &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(err);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(err);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        current--;</span><br><span class="line">        <span class="keyword">if</span> (tasks.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="title function_">run</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">limitRequest</span>(i).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> interview </tag>
            
            <tag> front-end </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端性能优化</title>
      <link href="/blog/2023/01/31/FE-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/blog/2023/01/31/FE-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>对比两款功能相似的产品，我们如何才能说一个产品的性能优于另外一个产品呢，无外乎以下几种情况</p><ol><li>页面打开的速度快，用户可以很快的看到期望的内容</li><li>页面流转流畅，不会出现卡顿的情况</li><li>页面不会出现非预期的错误，例如白屏</li></ol><p>性能优化也即从技术的角度提升产品的用户体验。</p><span id="more"></span><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><ol><li>建立性能监控机制<ol><li>打点记录pv/uv，首页进入占比</li><li>错误监控机制，记录JSError、http请求错误</li><li>记录白屏时间、首屏加载时间、用户可操作时间</li></ol></li><li>进行性能分析<ol><li>从性能数据进行分析</li><li>针对项目类型进行分析</li><li>从项目代码进行分析</li></ol></li><li>采用性能优化手段<ol><li>采用控制变量法评判性能优化的有效性</li><li>多次实验取平均值，减少误差</li></ol></li><li>建立常态化的性能准入机制</li></ol><h2 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h2><ol><li>减少请求次数</li><li>减小请求体积</li><li>加快请求速度</li><li>缩短渲染时间</li></ol><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="减少请求次数"><a href="#减少请求次数" class="headerlink" title="减少请求次数"></a>减少请求次数</h3><ol><li><p>静态资源用单独域名，与后端数据请求域名隔离</p></li><li><p>合并请求，合理利用浏览器同域名并发请求限制</p></li><li><p>使用 css sprite，减少图片请求次数</p></li><li><p>避免空 image src</p></li><li><p>避免 301 重定向</p></li><li><p>缓存 ajax 数据</p></li></ol><h3 id="减小请求体积"><a href="#减小请求体积" class="headerlink" title="减小请求体积"></a>减小请求体积</h3><ol><li><p>减少HTTP请求内容，例如列表进行分页</p></li><li><p>外部引用 js &amp; css 等静态资源而不是直接嵌入到 html 中</p></li><li><p>使用 gzip 压缩</p></li><li><p>对 JS,CSS 进行压缩混淆</p></li><li><p>Tree shaking，删除未使用的代码</p></li><li><p>减少cookie大小</p></li><li><p>压缩图片，优化图片大小，减少缩放，采用渐进式jpeg</p></li><li><p>减少组件的复杂度，减小组件体积</p></li><li><p>减少 favicon.icon 体积</p></li></ol><h3 id="加快请求速度"><a href="#加快请求速度" class="headerlink" title="加快请求速度"></a>加快请求速度</h3><ol><li><p>使用cdn，减少资源物理上与用户的距离</p></li><li><p>添加 expires/cache-control/etag header 字段，利用浏览器的缓存策略</p></li><li><p>预加载组件</p></li></ol><h3 id="缩短渲染时间"><a href="#缩短渲染时间" class="headerlink" title="缩短渲染时间"></a>缩短渲染时间</h3><ol><li><p>将 css 放到 html 顶部加载，将 js 放到底部加载</p></li><li><p>减少 dom 元素个数</p></li><li><p>减少 dom 操作</p></li><li><p>减少 iframes</p></li><li><p>采用事件委托</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> front-end </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React-diff算法原理及优化</title>
      <link href="/blog/2023/01/30/React-diff%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96/"/>
      <url>/blog/2023/01/30/React-diff%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="React的渲染过程"><a href="#React的渲染过程" class="headerlink" title="React的渲染过程"></a>React的渲染过程</h2><ul><li>如果是HTML标签则直接渲染真实DOM</li><li>如果是JSX，则按以下流程进行<ol><li>将JSX转换成 <code>createElement</code> 的代码</li><li>执行 <code>createElement</code> 创建虚拟DOM, 得到虚拟DOM树</li><li>根据虚拟DOM树在界面上生成真实DOM</li></ol></li></ul><p>JSX<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>我是span<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>转换为 <code>createElement</code> 代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>,</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>,</span><br><span class="line">        <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;p&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;我是段落&quot;</span>)),</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>,</span><br><span class="line">        <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;span&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;我是span&quot;</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>生成虚拟DOM<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="attr">targetName</span>: <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line"> <span class="attr">children</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="attr">targetName</span>: <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">     <span class="attr">children</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">         <span class="attr">targetName</span>: <span class="string">&#x27;p&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">     ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="attr">targetName</span>: <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">     <span class="attr">children</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">         <span class="attr">targetName</span>: <span class="string">&#x27;span&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">     ]</span><br><span class="line">    &#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Diff算法的原理"><a href="#Diff算法的原理" class="headerlink" title="Diff算法的原理"></a>Diff算法的原理</h2><p>更新时为了避免，为了计算出 Virtual DOM 中真正变化的部分，并只针对该部分进行原生 DOM 操作，而非重新渲染整个页面。React 使用了 Diff 算法对虚拟 DOM 的变化进行比较，基本原则为：</p><ul><li>进行同层同位置的比较</li><li>如果是相同类型的元素，记录变化</li><li>如果是不同类型的元素，删除以前的，使用新的</li></ul><h2 id="Diff算法的优化"><a href="#Diff算法的优化" class="headerlink" title="Diff算法的优化"></a>Diff算法的优化</h2><p>Diff算法虽然只进行同层同位置的比较，但也有一些优化：</p><ol><li>同层节点之间相互比较，不会跨节点比较(tree diff)；</li><li>拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。(component diff)；</li><li>可以通过唯一 key 来指定哪些节点在不同的渲染下保持稳定(element diff）；</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端常见面试题索引</title>
      <link href="/blog/2023/01/30/FE-%E9%9D%A2%E8%AF%95%E7%B4%A2%E5%BC%95/"/>
      <url>/blog/2023/01/30/FE-%E9%9D%A2%E8%AF%95%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<style>.article-body>.article-item {    display: flex;    flex-wrap: wrap;}.article-body>.article-item>a {    margin: 20px;}</style><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><div class="article-item"><br><br><a href="/blog/2021/04/22/HTTP小抄/#HTTPS">HTTPS相对HTTP的区别</a><br><a href="/blog/2021/12/29/HTTP-Cookie/">HTTP Cookie的作用</a><br><a href="/blog/2021/04/23/HTTP-缓存/">HTTP 强缓存与协商缓存</a><br><a href="/blog/2021/12/30/HTTP-同源策略与跨域/">浏览器同源策略与跨域</a><br><a href="/blog/2022/01/04/FE-浏览器架构与基本原理/#浏览器工作流程（页面加载过程）">浏览器中从输入URL到页面加载的流程</a><br><a href="/blog/2021/03/19/HTML-cookie、sessionStorage、localStorage区别与作用/">Cookie与sessionStorage、localStorage的区别</a><br><br></div><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><div class="article-item"><br><br><a href="/blog/2018/09/10/HACK-CSRF攻击/#CSRF防范">如何防范CSRF攻击</a><br><a href="/blog/2018/09/09/HACK-XSS攻击/#XSS防御">如何防范XSS攻击</a><br><br></div><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><div class="article-item"><br><br><a href="/blog/2023/01/31/FE-前端性能优化/#方法">性能优化的方法</a><br><br></div><h2 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h2><div class="article-item"><br><br><a href="/blog/2021/03/22/FE-前端工程化/">谈谈你对前端工程化的理解</a><br><a href="/blog/2020/05/22/FE-Javascript模块化/">模块化</a><br><a href="/blog/2022/12/26/FE-前端异常监控/">前端异常监控</a><br><br></div><h2 id="前端趋势"><a href="#前端趋势" class="headerlink" title="前端趋势"></a>前端趋势</h2><div class="article-item"><br><br><a href="/blog/2021/03/25/HTML-HTML5特性/">HTML5特性</a><br><a href="/blog/2020/08/28/JS-ES6特性/">ES6特性</a><br><a href="/blog/2021/03/26/CSS-CSS3特性/">CSS3特性</a><br><a href="/blog/2023/01/06/React-React18新功能和作用/">React18新特性</a><br><a href="/blog/2021/03/30/Vue-Vue3新功能和作用/">Vue3新特性</a><br><a href="/blog/2021/04/22/HTTP小抄/#HTTP2-特性">HTTP2新特性</a><br><br></div><h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><div class="article-item"><br><br><a href="/blog/2021/03/20/JS-数据类型/">数据类型</a><br><a href="/blog/2021/03/24/JS-原型链/">原型链</a><br><a href="/blog/2021/04/26/JS-继承/">继承</a><br><a href="/blog/2021/03/19/JS-闭包/">闭包</a><br><a href="/blog/2018/08/31/JS-防抖与截流/">防抖与截流的区别</a><br><a href="/blog/2021/03/19/JS-js的异步运行机制/">任务队列与事件循环</a><br><a href="/blog/2021/04/20/JS-js内存回收机制/">内存回收机制gc</a><br><a href="/blog/2021/03/23/JS-Promise/">Promise</a><br><a href="/blog/2022/11/23/JS-Object-对象/">Object</a><br><a href="/blog/2021/03/21/JS-Array-数组/">Array</a><br><a href="/blog/2022/11/22/JS-Function-函数/">Function</a><br><a href="/blog/2022/11/22/JS-String-字符串/">String</a><br><br></div><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><div class="article-item"><br><br><a href="/blog/2021/03/19/HTML-事件绑定-事件委托/">事件绑定与事件委托</a><br><a href="/blog/2021/03/19/HTML-页面渲染html的过程/">页面渲染HTML的过程</a><br><br></div><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><div class="article-item"><br><br><a href="/blog/2018/12/06/CSS-Flex布局/">Flex布局</a><br><a href="/blog/2018/09/18/CSS-长度单位/">CSS长度单位有哪些</a><br><a href="/blog/2021/03/19/CSS-水平-垂直居中/">CSS水平居中与垂直居中</a><br><a href="/blog/2021/03/16/CSS-transform-transition-animation/">CSS属性transition、transform、animation</a><br><br></div><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><div class="article-item"><br><br><a href="/blog/2021/04/24/Vue-Vue生命周期/">Vue生命周期有哪些</a><br><a href="/blog/2018/10/12/Vue-组件间通信/">Vue如何实现组件间通信</a><br><a href="/blog/2022/11/29/Vue-Vue面试手册/#Vue-2-0-响应式数据的原理">Vue响应式数据的原理</a><br><a href="/blog/2019/02/12/Vue-读Vue源码所能想到的面试问题/#哪些数据变化情况无法被-Vue-的响应式系统观测到，应该如何处理？">Vue中哪些数据类型变化时无法被Vue的响应式系统观测到，应该如何处理</a><br><a href="/blog/2021/04/21/Vue-keep-alive实现原理/">Vue keep-alive实现原理</a><br><a href="/blog/2021/04/24/Vue-Vue最佳实践/">Vue有哪些最佳实践</a><br><br></div><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><div class="article-item"><br><br><a href="/blog/2022/11/24/React-React组件/">React 组件</a><br><a href="/blog/2022/11/25/React-React-Hook/">React Hook</a><br><a href="/blog/2022/11/24/React-React组件的状态state与属性props/">React组件的状态state与属性props</a><br><a href="/blog/2018/09/06/React-React父子组件数据传递/">React父子组件数据传递</a><br><a href="/blog/2022/11/25/React-Virtual-DOM/">React Virtual DOM</a><br><a href="/blog/2023/01/30/React-diff算法原理及优化/">React Diff 算法原理及优化</a><br><a href="/blog/2021/11/29/React-router速读速懂/">React Router</a><br><a href="/blog/2022/11/25/React-Redux小抄/">Redux</a><br><a href="/blog/2022/11/24/React-对比Vue和React/">React与Vue区别</a><br><br></div><h2 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h2><div class="article-item"><br><br><a href="/blog/2021/04/20/FE-jsBridge/">JS Bridge原理</a><br><br></div><h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><div class="article-item"><br><br><a href="/blog/2021/01/19/FE-webpack小抄/">Webpack</a><br><a href="/blog/2021/01/19/FE-webpack小抄/#loader-和-plugin-的区别">Webpack loader 和 plugin 的区别</a><br><a href="/blog/2021/01/19/FE-webpack小抄/#webpack-Tree-shaking原理">Webpack Tree-shaking原理</a><br><br></div>]]></content>
      
      
      
        <tags>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React18新功能和作用</title>
      <link href="/blog/2023/01/06/React-React18%E6%96%B0%E5%8A%9F%E8%83%BD%E5%92%8C%E4%BD%9C%E7%94%A8/"/>
      <url>/blog/2023/01/06/React-React18%E6%96%B0%E5%8A%9F%E8%83%BD%E5%92%8C%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>2022 年 3 月 29 日 React18 正式发布。</p><p>React18 放弃了对 IE11 的支持。</p><h2 id="新增-createRoot-API-并支持并发模式渲染"><a href="#新增-createRoot-API-并支持并发模式渲染" class="headerlink" title="新增 createRoot API 并支持并发模式渲染"></a>新增 createRoot API 并支持并发模式渲染</h2><p>为了更好的管理 root 节点，React18 引入了一个新的 root API，新的 root API 还支持并发模式的渲染（new concurrent renderer），允许进入并发模式（concurrent mode）。</p><p>React18 从 <em>同步不可中断的更新</em> 变成了 <em>异步可中断的更新</em>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React 17</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)!;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// React 18</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom/client&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)!;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(root).<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>);</span><br></pre></td></tr></table></figure><p>同时，在卸载组件时，我们也需要将 <code>unmountComponentAtNode</code> 升级为 <code>root.unmount</code> :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React 17</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">unmountComponentAtNode</span>(root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// React 18</span></span><br><span class="line">root.<span class="title function_">unmount</span>();</span><br></pre></td></tr></table></figure><p>除此之外，React18 还从 render 方法中删除了回调函数，因为当使用 Suspense 时，它通常不会有预期的结果。</p><p>在新版本中，如果需要在 render 方法中使用回调函数，我们可以在组件中通过 useEffect 实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React 17</span></span><br><span class="line"><span class="keyword">const</span> root = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)!;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, root, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;渲染完成&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// React 18</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AppWithCallback</span>: <span class="title class_">React</span>.<span class="property">FC</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;渲染完成&#x27;</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> root = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)!;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(root).<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">AppWithCallback</span> /&gt;</span></span>);</span><br></pre></td></tr></table></figure><p>最后，如果项目使用了服务端渲染（SSR），需要把 <code>ReactDOM.hydration</code> 升级为 <code>ReactDOM.hydrateRoot</code> ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React 17</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> root = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">hydrate</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// React 18</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom/client&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> root = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)!;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">hydrateRoot</span>(root, <span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>);</span><br></pre></td></tr></table></figure><p>另外，还需要更新 TypeScript 类型定义，如果项目使用了 TypeScript，最值得注意的变化是，现在在定义 props 类型时，如果需要获取子组件 children ，那么需要显式的定义它，例如这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React 17</span></span><br><span class="line">interface <span class="title class_">MyButtonProps</span> &#123;</span><br><span class="line">  <span class="attr">color</span>: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyButton</span>: <span class="title class_">React</span>.<span class="property">FC</span>&lt;<span class="title class_">MyButtonProps</span>&gt; = <span class="function">(<span class="params">&#123; children &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 在 React 17 的 FC 中，默认携带了 children 属性</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">MyButton</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// React 18</span></span><br><span class="line">interface <span class="title class_">MyButtonProps</span> &#123;</span><br><span class="line">  <span class="attr">color</span>: string;</span><br><span class="line">  children?: <span class="title class_">React</span>.<span class="property">ReactNode</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyButton</span>: <span class="title class_">React</span>.<span class="property">FC</span>&lt;<span class="title class_">MyButtonProps</span>&gt; = <span class="function">(<span class="params">&#123; children &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 在 React 18 的 FC 中，不存在 children 属性，需要手动申明</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">MyButton</span>;</span><br></pre></td></tr></table></figure><h2 id="setState-自动批量处理更新"><a href="#setState-自动批量处理更新" class="headerlink" title="setState 自动批量处理更新"></a>setState 自动批量处理更新</h2><p>批处理是指为了获得更好的性能，在数据层，将多个状态更新批量处理，合并成一次更新（在视图层，将多个渲染合并成一次渲染）。</p><p>在 React18 之前，只有在 react 事件处理函数中，才会自动执行批处理，其它情况会多次更新；在 React18 之后，任何情况都会自动执行批处理，多次更新始终合并为一次。</p><p>React18 通过在默认情况下执行批处理来实现了开箱即用的性能改进。</p><h2 id="新增-flushSync-手动退出批量更新"><a href="#新增-flushSync-手动退出批量更新" class="headerlink" title="新增 flushSync 手动退出批量更新"></a>新增 flushSync 手动退出批量更新</h2><p>批处理是一个破坏性改动，如果想退出批量更新，可以使用 <code>flushSync</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; flushSync &#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">App</span>: <span class="title class_">React</span>.<span class="property">FC</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count1, setCount1] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [count2, setCount2] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">        flushSync(() =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">          setCount1(count =&gt; count + 1);</span></span><br><span class="line"><span class="language-xml">        &#125;);</span></span><br><span class="line"><span class="language-xml">        // 第一次更新</span></span><br><span class="line"><span class="language-xml">        flushSync(() =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">          setCount2(count =&gt; count + 1);</span></span><br><span class="line"><span class="language-xml">        &#125;);</span></span><br><span class="line"><span class="language-xml">        // 第二次更新</span></span><br><span class="line"><span class="language-xml">      &#125;&#125;</span></span><br><span class="line"><span class="language-xml">    &gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>count1： &#123;count1&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>count2： &#123;count2&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>注意：<code>flushSync</code> 函数内部的多个 <code>setState</code> 仍然为批量更新，这样可以精准控制哪些不需要的批量更新。</p><h2 id="删除了卸载组件后再更新组件状态时的警告"><a href="#删除了卸载组件后再更新组件状态时的警告" class="headerlink" title="删除了卸载组件后再更新组件状态时的警告"></a>删除了卸载组件后再更新组件状态时的警告</h2><p>删除了以下警告：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warining: Can&#x27;t perfform a React state update on an unmounted component...</span><br></pre></td></tr></table></figure><p>这个错误的初衷，原本旨在针对一些特殊场景，譬如 在 <code>useEffect</code> 里面设置了定时器，或者订阅了某个事件，从而在组件内部产生了副作用，而且忘记 <code>return</code> 一个函数清除副作用，则会发生内存泄漏之类的场景<br>但是在实际开发中，更多的场景是，我们在 <code>useEffect</code> 里面发送了一个异步请求，在异步函数还没有被 <code>resolve</code> 或者被 <code>reject</code> 的时候，我们就卸载了组件。 在这种场景中，警告同样会触发。但是，在这种情况下，组件内部并没有内存泄漏，因为这个异步函数已经被垃圾回收了，此时，警告具有误导性。</p><h2 id="React-组件的返回值可以为-undefined"><a href="#React-组件的返回值可以为-undefined" class="headerlink" title="React 组件的返回值可以为 undefined"></a>React 组件的返回值可以为 undefined</h2><p>在 React17 中，如果需要返回一个空组件，React 只允许返回 null 。如果显式的返回了 undefined，控制台则会在运行时抛出一个错误。在 React18 中，不再检查因返回 undefined 而导致崩溃。既能返回 null，也能返回 undefined。</p><h2 id="严格模式（Strict-Mode）取消了第二次渲染的控制台日志"><a href="#严格模式（Strict-Mode）取消了第二次渲染的控制台日志" class="headerlink" title="严格模式（Strict Mode）取消了第二次渲染的控制台日志"></a>严格模式（Strict Mode）取消了第二次渲染的控制台日志</h2><p>当使用严格模式时，React 会对每个组件进行两次渲染，以便观察一些意想不到的结果。在 React17 中，取消了其中一次渲染的控制台日志，以便让日志更容易阅读。如果安装了 React DevTools，第二次渲染的日志信息将显示为灰色，以柔和的方式显式在控制台。</p><h2 id="Suspense-不再需要-fallback-来捕获"><a href="#Suspense-不再需要-fallback-来捕获" class="headerlink" title="Suspense 不再需要 fallback 来捕获"></a>Suspense 不再需要 fallback 来捕获</h2><p>在 React18 的 Suspense 组件中，官方对空的 fallback 属性的处理方式做了改变：不再跳过缺失值或值为 null 的 fallback 的 Suspense 边界。相反，会捕获边界并且向外层查找，如果查找不到，将会把 fallback 呈现为 null。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React 17</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Suspense fallback=&#123;&lt;Loading /&gt;&#125;&gt; // &lt;--- 这个边界被使用，显示 Loading 组件</span><br><span class="line">      &lt;Suspense&gt;                      // &lt;--- 这个边界被跳过，没有 fallback 属性</span><br><span class="line">        &lt;Page /&gt;</span><br><span class="line">      &lt;/Suspense&gt;</span><br><span class="line">    &lt;/Suspense&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default App;</span><br><span class="line"></span><br><span class="line">// React 18</span><br><span class="line">const App = () =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Suspense fallback=&#123;&lt;Loading /&gt;&#125;&gt; // &lt;--- 不使用</span><br><span class="line">      &lt;Suspense&gt;                      // &lt;--- 这个边界被使用，将 fallback 渲染为 null</span><br><span class="line">        &lt;Page /&gt;</span><br><span class="line">      &lt;/Suspense&gt;</span><br><span class="line">    &lt;/Suspense&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><h2 id="新增-userId-API"><a href="#新增-userId-API" class="headerlink" title="新增 userId API"></a>新增 userId API</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> id = <span class="title function_">useId</span>();</span><br></pre></td></tr></table></figure><p>支持同一个组件在客户端和服务端生成相同的唯一的 ID，避免 <code>hydration</code> 的不兼容，这解决了在 React17 及 17 以下版本中已经存在的问题。因为我们的服务器渲染时提供的 HTML 是无序的，useId 的原理就是每个 id 代表该组件在组件树中的层级结构。</p><h2 id="新增-useSyncExternalStore-API"><a href="#新增-useSyncExternalStore-API" class="headerlink" title="新增 useSyncExternalStore API"></a>新增 useSyncExternalStore API</h2><p><code>useSyncExternalStore</code> 能够通过强制同步更新数据让 React 组件在并发模式下安全地有效地读取外接数据源。 在并发模式下，React 一次渲染会分片执行（以 fiber 为单位），中间可能穿插优先级更高的更新。假如在高优先级的更新中改变了公共数据（比如 Redux 中的数据），那之前低优先的渲染必须要重新开始执行，否则就会出现前后状态不一致的情况。<code>useSyncExternalStore</code> 一般是三方状态管理库使用。React 自身的 useState 已经原生的解决了并发特性下 state 更新问题。目前 React-Redux 8.0 已经基于 <code>useSyncExternalStore</code> 实现。</p><h2 id="新增-useInsertionEffect-API"><a href="#新增-useInsertionEffect-API" class="headerlink" title="新增 useInsertionEffect API"></a>新增 useInsertionEffect API</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">useCSS</span> = rule =&gt; &#123;</span><br><span class="line">  <span class="title function_">useInsertionEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isInserted.<span class="title function_">has</span>(rule)) &#123;</span><br><span class="line">      isInserted.<span class="title function_">add</span>(rule);</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(<span class="title function_">getStyleForRule</span>(rule));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> rule;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">App</span>: <span class="title class_">React</span>.<span class="property">FC</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> className = <span class="title function_">useCSS</span>(rule);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;className&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>这个 Hook 只建议 css-in-js 库来使用。 这个 Hooks 执行时机在 DOM 生成之后，<code>useLayoutEffect</code> 之前，它的工作原理大致和 <code>useLayoutEffect</code> 相同，只是此时无法访问 DOM 节点的引用，一般用于提前注入 <code>&lt;style&gt;</code> 脚本。</p><h2 id="新增-startTransition-API"><a href="#新增-startTransition-API" class="headerlink" title="新增 startTransition API"></a>新增 startTransition API</h2><p><code>startTransition</code>，主要为了能在大量的任务下也能保持 UI 响应。这个新的 API 可以通过将特定更新标记为“过渡”来显著改善用户交互，简单来说，就是被 <code>startTransition</code> 回调包裹的 <code>setState</code> 触发的渲染被标记为不紧急渲染，这些渲染可能被其他紧急渲染所抢占。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useEffect, useTransition &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">App</span>: <span class="title class_">React</span>.<span class="property">FC</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [list, setList] = useState&lt;any[]&gt;([]);</span><br><span class="line">  <span class="keyword">const</span> [isPending, startTransition] = <span class="title function_">useTransition</span>();</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 使用了并发特性，开启并发更新</span></span><br><span class="line">    <span class="title function_">startTransition</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setList</span>(<span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10000</span>).<span class="title function_">fill</span>(<span class="literal">null</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;list.map((_, i) =&gt; (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;i&#125;</span>&gt;</span>&#123;i&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      ))&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>由于 <code>setList</code> 在 <code>startTransition</code> 的回调函数中执行（使用了并发特性），所以 <code>setList</code> 会触发 <em>并发更新</em>。</p><h2 id="新增-useDeferredValue-API"><a href="#新增-useDeferredValue-API" class="headerlink" title="新增 useDeferredValue API"></a>新增 useDeferredValue API</h2><p><code>useDeferredValue</code> 返回一个延迟响应的值，可以让一个 state 延迟生效，只有当前没有紧急更新时，该值才会变为最新值。<code>useDeferredValue</code> 和 <code>startTransition</code> 一样，都是标记了一次非紧急更新。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useEffect, useDeferredValue &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">App</span>: <span class="title class_">React</span>.<span class="property">FC</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [list, setList] = useState&lt;any[]&gt;([]);</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setList</span>(<span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10000</span>).<span class="title function_">fill</span>(<span class="literal">null</span>));</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="comment">// 使用了并发特性，开启并发更新</span></span><br><span class="line">  <span class="keyword">const</span> deferredList = <span class="title function_">useDeferredValue</span>(list);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;deferredList.map((_, i) =&gt; (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;i&#125;</span>&gt;</span>&#123;i&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      ))&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端异常监控</title>
      <link href="/blog/2022/12/26/FE-%E5%89%8D%E7%AB%AF%E5%BC%82%E5%B8%B8%E7%9B%91%E6%8E%A7/"/>
      <url>/blog/2022/12/26/FE-%E5%89%8D%E7%AB%AF%E5%BC%82%E5%B8%B8%E7%9B%91%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<p>前端异常监控是指在能够对前端项目运行过程中的错误和异常能够记录和上报从而可以对项目不断分析和优化的流程。从流程上来分，前端异常监控分为数据捕获和数据上报两个部分。</p><span id="more"></span><h2 id="数据捕获"><a href="#数据捕获" class="headerlink" title="数据捕获"></a>数据捕获</h2><p>前端异常数据捕获为全局捕获和单点捕获。全局捕获代码集中，易于管理；单点捕获作为补充，对某些特殊情况进行捕获，但较分散，不利于管理。</p><h3 id="全局捕获"><a href="#全局捕获" class="headerlink" title="全局捕获"></a>全局捕获</h3><ul><li>通过 web API 全局的接口，将捕获代码集中写在一个地方<ul><li><code>window.onerror</code> 可以捕获 JavaScript 运行时错误与语法错误</li><li><code>window.addEventListener(&#39;unhandledrejection&#39;)</code> 可以捕获 未被 catch 的 reject 状态的 Promise(Promise 异常)</li><li><code>document.addEventListener(&#39;click&#39;)</code> 全局的点击事件</li></ul></li><li>框架级别的全局监听<ul><li>aixos 中使用 interceptor 进行拦截</li><li>vue 中的 errorCaptured、errorHandler</li><li>react 中的 ErrorBoundary</li></ul></li><li>通过对全局函数进行封装包裹，实现在调用该函数时自动捕获异常<ul><li>例如对 xhr/Fetch 进行封装，在发送 Ajax 请求时进行记录</li></ul></li><li>对实例方法重写（Patch），在原有功能基础上包裹一层<ul><li>例如对 setTimeout、setInterval、requrestAnimationFrame、console 进行重写，在使用方法不变的情况下也可以异常捕获</li></ul></li></ul><h3 id="单点捕获"><a href="#单点捕获" class="headerlink" title="单点捕获"></a>单点捕获</h3><ul><li>在业务代码中对单个代码块进行包裹，或在逻辑流程中打点，实现有针对性的异常捕获</li><li><code>try catch</code> 语句块记录 JS Error 异常</li><li>专门写一个函数来收集异常信息，在异常发生时，调用该函数</li><li>专门写一个函数来包裹其他函数，得到一个新函数，该新函数运行结果和原函数一模一样，只是在发生异常时可以捕获异常</li></ul><h2 id="数据上报"><a href="#数据上报" class="headerlink" title="数据上报"></a>数据上报</h2><p>异常数据上报，即通过一定方式将收集到的参数上报到服务器的过程。</p><ul><li>异步请求，通过 xhr/fetch 上报</li><li><code>new Image()</code> 上报（1x1的透明gif）</li></ul><h2 id="sentry"><a href="#sentry" class="headerlink" title="sentry"></a>sentry</h2><p><a href="https://github.com/getsentry/sentry">Sentry</a> 是一款开源的错误捕获和性能监控系统。类似的商业化（非开源）前端错误与性能监控平台还有 Fundebug、FrontJS、rollbar.js 等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> front-end </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue面试手册</title>
      <link href="/blog/2022/11/29/Vue-Vue%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%8C/"/>
      <url>/blog/2022/11/29/Vue-Vue%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue-是什么"><a href="#Vue-是什么" class="headerlink" title="Vue 是什么"></a>Vue 是什么</h2><p>Vue是一个构建用户界面的渐进式 MVVM 框架。它的核心在于数据驱动和组件化的思想。</p><p>Vue的优点主要有：</p><ul><li>轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 kb ；</li><li>简单易学：中文文档丰富，易于理解和学习；</li><li>双向数据绑定：保留了 Angular 的特点，在数据操作方面更为方便；</li><li>组件化：保留了 React 的优点，通过单页面组件实现了 html 的封装和重用，在构建单页面应用方面有着独特的优势；</li><li>视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；</li><li>虚拟DOM：dom 操作是非常耗费性能的，不再使用原生的 dom 操作节点，极大解放 dom 操作；</li><li>运行速度更快：相比较于 react 而言，同样是操作虚拟 dom，就性能而言， vue 存在很大的优势。</li></ul><h2 id="为什么说Vue是一个渐进式框架"><a href="#为什么说Vue是一个渐进式框架" class="headerlink" title="为什么说Vue是一个渐进式框架"></a>为什么说Vue是一个渐进式框架</h2><p>Vue 实现了构建 web 应用最核心的 mvvm 绑定部分，用户可以选择使用其他库（例如vuex、axios、vue-router）来搭配使用构建最适合自己的应用。</p><h2 id="v-model-双向绑定的原理是什么"><a href="#v-model-双向绑定的原理是什么" class="headerlink" title="v-model 双向绑定的原理是什么"></a>v-model 双向绑定的原理是什么</h2><p>v-model 实际上是语法糖，以 input 元素为例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;inputV&quot;</span> /&gt;</span></span><br><span class="line">// 等同于</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">&quot;inputV&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;inputV = $event.target.value&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>input 组件的 value 属性绑定于 inputV 变量上，也就是当 inputV 变化时，input 组件的 value 也会跟着变化；</li><li>监听 input 事件，该事件在 input 的值改变时触发，事件触发时给 inputV 重新赋值，所赋的值是 <code>$event.target.value</code>，也就是当前触发 input 事件时的 value 值，也就是该 input 组件的值。</li></ul><h2 id="Vue-2-0-响应式数据的原理"><a href="#Vue-2-0-响应式数据的原理" class="headerlink" title="Vue 2.0 响应式数据的原理"></a>Vue 2.0 响应式数据的原理</h2><p>Vue.js 是采用 <em>数据劫持</em> 结合 <em>发布者-订阅者模式</em> 的方式，通过 <code>Object.defineProperty()</code> 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：</p><ul><li>对需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter，这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化；</li><li>Compile 负责解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图；</li><li>Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是: <ul><li>在自身实例化时往属性订阅器(dep)里面添加自己 </li><li>自身必须有一个 <code>update()</code> 方法</li><li>待属性变动 <code>dep.notice()</code> 通知时，能调用自身的 <code>update()</code> 方法，并触发 Compile 中绑定的回调</li></ul></li><li>MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到 数据变化 -&gt; 视图更新；视图交互变化（input） -&gt; 数据（model）变更的双向绑定效果。</li></ul><p><img src="/blog/static/imgs/vue/vue2.png" alt="vue2_inner"></p><h2 id="Vue3-中为什么使用-Proxy-来替代-Object-defineProperty-实现数据劫持？"><a href="#Vue3-中为什么使用-Proxy-来替代-Object-defineProperty-实现数据劫持？" class="headerlink" title="Vue3 中为什么使用 Proxy 来替代 Object.defineProperty() 实现数据劫持？"></a>Vue3 中为什么使用 Proxy 来替代 <code>Object.defineProperty()</code> 实现数据劫持？</h2><p><code>Object.defineProperty</code> 无法监听 下标方式修改数组数据 或者 给对象新增属性 的操作，Proxy 可以监听。</p><h2 id="Vue-data-中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗"><a href="#Vue-data-中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗" class="headerlink" title="Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗"></a>Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗</h2><p>不会立即同步执行重新渲染。Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环 tick 中，Vue 刷新队列并执行实际（已去重的）工作。</p><h2 id="Vue2-监控不了数组类型-data-的变化，有什么解决办法"><a href="#Vue2-监控不了数组类型-data-的变化，有什么解决办法" class="headerlink" title="Vue2 监控不了数组类型 data 的变化，有什么解决办法"></a>Vue2 监控不了数组类型 data 的变化，有什么解决办法</h2><ul><li>使用 <code>this.$set(obj，key，value)</code> 更新数组</li><li>调用以下几个数组的方法 <code>splice()、 push()、pop()、shift()、unshift()、sort()、reverse()</code></li></ul><h2 id="Vue2-中何时使用-Vue-nextTick"><a href="#Vue2-中何时使用-Vue-nextTick" class="headerlink" title="Vue2 中何时使用 Vue.$nextTick()?"></a>Vue2 中何时使用 <code>Vue.$nextTick()</code>?</h2><ul><li>在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变化的 DOM 结构的时候，这个操作就需要方法在 <code>nextTick()</code> 的回调函数中。</li><li>在 vue 生命周期中，如果在 <code>created()</code> 钩子进行DOM操作，也一定要放在 <code>nextTick()</code> 的回调函数中。因为在 <code>created()</code> 钩子函数中，页面的DOM还未渲染，这时候没办法操作DOM。</li></ul><h2 id="什么是-Vue-mixin？"><a href="#什么是-Vue-mixin？" class="headerlink" title="什么是 Vue.mixin？"></a>什么是 <code>Vue.mixin</code>？</h2><p>混入（mixin）是指当多个组件共享同样的功能（生命周期hook、方法等）时，将同样的功能剥离开来并在多个组件中引入该部分实现从而代码重用的目的。</p><h2 id="vue-router有多少种模式？"><a href="#vue-router有多少种模式？" class="headerlink" title="vue-router有多少种模式？"></a>vue-router有多少种模式？</h2><ul><li><p>hash模式：兼容所有浏览器，包括不支持 HTML5 History Api 的浏览器。例如 <code>https://example.com/#index</code> hash 的值为 <code>#index</code>， hash 的改变会触发 hashchange 事件，我们可以通过监听 hashchange 事件来完成操作实现前端路由。</p></li><li><p>history模式：能支持 HTML5 History Api 的浏览器，依赖 HTML5 History API 来实现前端路由。例如 <code>https://example.com/index</code> 。为防止服务器请求不到资源时返回 404，需要在服务器端设置，匹配不到资源时返回 index.html ，同时由前端来控制 404 页面的显示。例如，nginx 需配置</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    try_files  $uri $uri/ @router index index.html;</span><br><span class="line">&#125;</span><br><span class="line">location @router &#123;</span><br><span class="line">    rewrite ^.*$ /index.html last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>abstract模式：支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式。</li></ul><h2 id="hash和history模式实现vue-router跳转api的区别"><a href="#hash和history模式实现vue-router跳转api的区别" class="headerlink" title="hash和history模式实现vue-router跳转api的区别"></a>hash和history模式实现vue-router跳转api的区别</h2><table><thead><tr><th>api</th><th>hash</th><th>history</th></tr></thead><tbody><tr><td>push</td><td><code>window.location.assign</code></td><td><code>window.history.pushState</code></td></tr><tr><td>replace</td><td><code>window.location.replace</code></td><td>window.history.replaceState`</td></tr><tr><td>go</td><td><code>window.history.go</code></td><td><code>window.history.go</code></td></tr><tr><td>back</td><td><code>window.history.go(-1)</code></td><td><code>window.history.go(-1)</code></td></tr><tr><td>forward</td><td><code>window.history.go(1)</code></td><td><code>window.history.go(1)</code></td></tr></tbody></table><h2 id="vue-指令有哪些？"><a href="#vue-指令有哪些？" class="headerlink" title="vue 指令有哪些？"></a>vue 指令有哪些？</h2><p>v-show、v-if、v-else-if、v-else、v-for、v-on、v-bind、v-model、v-once、v-slot、v-html、v-text</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS编写规则</title>
      <link href="/blog/2022/11/29/CSS-%E7%BC%96%E5%86%99%E8%A7%84%E5%88%99/"/>
      <url>/blog/2022/11/29/CSS-%E7%BC%96%E5%86%99%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>OOCSS，SMACSS，BEM，ITCSS，Utility-First CSS，ACSS 都是 CSS 编写规则，是结构化编写和组织 CSS 的指南，在一个项目中采用一致的 CSS 编写规则，更利于他人理解你的代码和团队协作。</p><h2 id="面向对象的-CSS"><a href="#面向对象的-CSS" class="headerlink" title="面向对象的 CSS"></a>面向对象的 CSS</h2><p>面向对象的 CSS（Object Oriented CSS，OOCSS）是指把样式重复的代码片段，定义为 CSS 对象</p><ul><li>盒模型与皮肤无关：盒模型属性与颜色、背景等皮肤主题属性分选择器定义</li><li>样式与位置无关：避免使用标签、关系选择器，应用时，我们通常提取多个元素的公用属性，作为基本类 在其基础上，通过其它类扩展每个元素的个性属性 这是避免 CSS 代码冗余的常用方法</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box bg-red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box bg-green&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bg-red</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bg-green</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可扩展模块化-CSS-架构"><a href="#可扩展模块化-CSS-架构" class="headerlink" title="可扩展模块化 CSS 架构"></a>可扩展模块化 CSS 架构</h2><p>可扩展模块化 CSS 架构（Scalable and Modular Architecture for CSS，SMACSS）定义了 CSS 分类和命名规则，并对 CSS 书写提出优化建议</p><ul><li>Base：默认，基础，通用规则，包括重置浏览器样式的规则</li><li>Layout：布局规则，以 <code>l-</code> 或 <code>layout-</code>开头</li><li>Module：可复用模块规则</li><li>State：布局或模块的特殊状态规则，如隐藏，激活等，以 <code>is</code> 开头</li><li>Theme：皮肤或主题规则，可能包含另一种配色方案</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* base */</span></span><br><span class="line"><span class="selector-tag">button</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ababab</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#f2f2f2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* layout */</span></span><br><span class="line"><span class="selector-class">.l-header</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.l-primarynav</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.l-main-content</span> &#123;&#125;</span><br><span class="line"><span class="comment">/* module */</span></span><br><span class="line"><span class="selector-class">.article-title</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.article-content</span> &#123;&#125;</span><br><span class="line"><span class="comment">/* state */</span></span><br><span class="line"><span class="selector-class">.is-hidden</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.is-shown</span> &#123;&#125;</span><br><span class="line"><span class="comment">/* theme */</span></span><br><span class="line"><span class="selector-class">.button-large</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">60px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="块元素修饰符"><a href="#块元素修饰符" class="headerlink" title="块元素修饰符"></a>块元素修饰符</h2><p>块元素修饰符（Block Element Modifier，BEM）定义了一种 CSS 的命名规则，用于解决命名冲突</p><ul><li>Block：块，忽略结构和优先级，具有独立意义的实体</li><li>Element：元素，块内部没有独立意义的实体</li><li>Modifier：修饰符，标识块或元素的外观、行为、状态被修改，含有修饰符的类名不可独立出现，通常跟在不含修饰符的类名后</li></ul><p>BEM 在书写时需要遵循三个原则：</p><ul><li>使用 <code>__</code> 两个下划线将块名称与元素名称分开</li><li>使用 <code>--</code> 两个破折号分隔元素名称及其修饰符</li><li>一切样式都是一个类，不能嵌套</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.block__elementOne--modifier</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="倒三角形CSS"><a href="#倒三角形CSS" class="headerlink" title="倒三角形CSS"></a>倒三角形CSS</h2><p>倒三角形CSS（Inverted Triangle CSS，ITCSS）主要用 SASS 实现 提供了一种 CSS 由通用到具体的分层（分类）方法，层次可以按需增删</p><ul><li>Settings：全局变量、方法，例如字体、颜色定义</li><li>Tools：结合预处理器使用，全局使用的函数（function）、混入器（mixin）</li><li>Generic：浏览器默认样式重置，例如 normalize.css、reset.css</li><li>Elements（Base）：仅可使用类型（标签）选择器，例如 <code>h1 &#123;&#125;</code></li><li>Objects：遵循 OOCSS 的对象的盒模型，无颜色、背景等</li><li>Components：可复用的 UI 组件</li><li>Trumps(Utilities)：对组件的微调和其他样式定义，可使用 <code>!important</code></li></ul><h2 id="实用类优先CSS"><a href="#实用类优先CSS" class="headerlink" title="实用类优先CSS"></a>实用类优先CSS</h2><p>实用类优先CSS（Utility-First CSS） 提供了一种外观组件的构建方法，以 tailwindcss 为代表</p><ul><li>按照一定规则，基于 CSS 实用类构建复杂外观组件</li><li>不用起类名</li><li>样式文件体积不会随项目无限增长</li><li>增删类名，比直接修改属性更安全，维护更容易</li></ul><h2 id="原子CSS"><a href="#原子CSS" class="headerlink" title="原子CSS"></a>原子CSS</h2><p>原子CSS（Atomic CSS），可以看成 Utility-First CSS 的极致抽象 提供了一种 CSS 类的定义方法，提升大型项目 CSS 复用度</p><ul><li>每个类选择器中只包含一条属性定义，一次编写，到处运行</li><li>属性名类似函数，属性值类似函数参数，像写内联样式一样写类名，适合 CSS-in-JS</li><li>提供工具，可按需编译</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对比Less/Sass/Stylus/PostCSS</title>
      <link href="/blog/2022/11/29/CSS-%E5%AF%B9%E6%AF%94Less-Sass-Stylus-PostCSS/"/>
      <url>/blog/2022/11/29/CSS-%E5%AF%B9%E6%AF%94Less-Sass-Stylus-PostCSS/</url>
      
        <content type="html"><![CDATA[<p>Less、Sass 和 Stylus 是 CSS 预处理器，PostCSS 是转换 CSS 工具的平台</p><span id="more"></span><h2 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h2><ul><li>变量：<code>$</code> 标识符变量，使用 <code>&#123;&#125;</code> 插值</li><li>嵌套：支持 <code>&#123; &#125;</code> 大括号嵌套</li><li>混入器：支持 选择器 混入 或 使用 <code>.selector(@param)</code> 创建纯混入器</li><li>扩展 / 继承 / 运算符 / @import：支持</li><li>流程：支持 if 条件判断，支持 when 递归模拟循环</li><li>映射：支持 @ 声明和使用 Map</li><li>特有：提供 Less.js，直接在浏览器使用 Less</li></ul><h2 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a>Sass</h2><ul><li>变量：支持 <code>$</code> 标识符变量，使用 <code>#&#123;&#125;</code> 插值</li><li>嵌套：支持 <code>&#123; &#125;</code>大括号嵌套，支持缩进嵌套</li><li>混入器：<code>@mixin</code> 创建 <code>@include</code> 使用</li><li>扩展 / 继承 / 运算符 / @import：支持</li><li>流程：支持 if else 条件判断，支持 for while each 循环</li><li>映射：支持 <code>$()</code> 声明 Map，提供 map-get(map, key) map-keys(map) map-values(map) 等一系列方法操作 Map，支持遍历 Map</li><li>特有：支持 compass ，内含 自动私有前缀 等一系列有用 Sass 模块，支持压缩输出</li></ul><h2 id="Stylus"><a href="#Stylus" class="headerlink" title="Stylus"></a>Stylus</h2><ul><li>变量：支持 <code>$</code> 标识符变量 和 赋值表达式变量，使用 <code>&#123;&#125;</code> 插值</li><li>嵌套：支持 <code>&#123; &#125;</code> 大括号嵌套 和 缩进嵌套</li><li>混入器：像函数一样创建和使用</li><li>扩展 / 继承 / 运算符 / @import：支持</li><li>流程：支持 if else unless 三元 条件判断，支持 for 循环</li><li>映射：像 JS 一样创建和使用对象</li><li>特有：支持中间件，自动分配函数变量，提供 JS API。支持压缩输出</li></ul><h2 id="PostCSS"><a href="#PostCSS" class="headerlink" title="PostCSS"></a>PostCSS</h2><ul><li>接受 CSS 文件，把 CSS 规则转换为抽象语法树</li><li>提供 API 供插件调用，对 CSS 处理</li><li>插件：支持 Autoprefixer 自动添加私有前缀、css-modules CSS 模块 stylelint CSS 语法检查等插件，PostCSSS 是工具的工具</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> less </tag>
            
            <tag> sass </tag>
            
            <tag> stylus </tag>
            
            <tag> postcss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redux小抄</title>
      <link href="/blog/2022/11/25/React-Redux%E5%B0%8F%E6%8A%84/"/>
      <url>/blog/2022/11/25/React-Redux%E5%B0%8F%E6%8A%84/</url>
      
        <content type="html"><![CDATA[<p>Redux 是一款小巧的 JavaScript 状态容器，提供可预测化的状态管理。Redux 常见于 React 应用的数据状态管理，但是 Redux 不仅仅局限于 React，还支持其它 UI 库。</p><h2 id="Redux-应用示例"><a href="#Redux-应用示例" class="headerlink" title="Redux 应用示例"></a>Redux 应用示例</h2><p>在 Redux 中，应用的整体全局状态以对象树的方式存放于单个 store 中。唯一改变状态树（state tree）的方法是创建 action。action 是一个描述发生了什么的对象，并将其 dispatch 给 store。要指定状态树如何响应 action 来进行更新，可以编写纯 reducer 函数，这些函数根据旧 state 和 action 来计算新 state。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个 reducer 函数：接受当前 state 值和描述“发生了什么”的 action 对象，它返回一个新的 state 值。</span></span><br><span class="line"><span class="comment"> * reducer 函数签名是 : (state, action) =&gt; newState</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Redux state 应该只包含普通的 JS 对象、数组和基本类型。</span></span><br><span class="line"><span class="comment"> * 根状态值通常是一个对象。 重要的是，不应该改变 state 对象，而是在 state 发生变化时返回一个新对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你可以在 reducer 中使用任何条件逻辑。 在这个例子中，我们使用了 switch 语句，但这不是必需的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">counterReducer</span>(<span class="params">state = &#123; value: <span class="number">0</span> &#125;, action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;counter/incremented&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">value</span>: state.<span class="property">value</span> + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;counter/decremented&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">value</span>: state.<span class="property">value</span> - <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个包含应用程序 state 的 Redux store。</span></span><br><span class="line"><span class="comment">// 它的 API 有 &#123; subscribe, dispatch, getState &#125;.</span></span><br><span class="line"><span class="keyword">let</span> store = <span class="title function_">createStore</span>(counterReducer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你可以使用 subscribe() 来更新 UI 以响应 state 的更改。</span></span><br><span class="line"><span class="comment">// 通常你会使用视图绑定库（例如 react-redux）而不是直接使用 subscribe()。</span></span><br><span class="line"><span class="comment">// 可能还有其他用例对 subscribe 也有帮助。</span></span><br><span class="line"></span><br><span class="line">store.<span class="title function_">subscribe</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(store.<span class="title function_">getState</span>()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变内部状态的唯一方法是 dispatch 一个 action。</span></span><br><span class="line"><span class="comment">// 这些 action 可以被序列化、记录或存储，然后再重放。</span></span><br><span class="line">store.<span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;counter/incremented&#x27;</span> &#125;);</span><br><span class="line"><span class="comment">// &#123;value: 1&#125;</span></span><br><span class="line">store.<span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;counter/incremented&#x27;</span> &#125;);</span><br><span class="line"><span class="comment">// &#123;value: 2&#125;</span></span><br><span class="line">store.<span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;counter/decremented&#x27;</span> &#125;);</span><br><span class="line"><span class="comment">// &#123;value: 1&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Redux-的应用场景"><a href="#Redux-的应用场景" class="headerlink" title="Redux 的应用场景"></a>Redux 的应用场景</h2><ol><li>同一个 state 需要在多个 Component 中共享，例如应用需要登录，登录后的用户信息可以存放于 store 中</li><li>需要操作一些全局性的常驻 Component，比如 Notifications，Tooltips 等</li><li>太多 props 需要在组件树中传递，但其中大部分只是为了透传给子组件</li><li>业务太复杂导致 Component 文件太大，可以考虑将业务逻辑拆出来放到 Reducer 中</li></ol><p>不适用的场景：<br>使用 Redux 需要创建很多模版代码，会让 state 的更新变得非常繁琐，如果应用数据流向比较简单，可以不使用 Redux 。</p><h2 id="Redux-数据流向"><a href="#Redux-数据流向" class="headerlink" title="Redux 数据流向"></a>Redux 数据流向</h2><p>严格的单向数据流是 Redux 架构的设计核心。Redux 应用中数据的生命周期遵循下面 4 个步骤：</p><ol><li>View 中的某个操作调用 <code>store.dispatch(action)</code> 。</li><li>Redux store 调用传入的 reducer 函数，入参为 当前的 state 和 action。</li><li>根 reducer 应该把多个子 reducer 输出合并成一个单一的 state 树。</li><li>Redux store 保存了根 reducer 返回的完整 state 树。</li></ol><p>Redux 数据流向</p><p><img src="/blog/static/imgs/redux/redux.png" alt="redux_inner"></p><p>带 middleware 的 Redux 数据流向</p><p><img src="/blog/static/imgs/redux/redux-middleware.png" alt="redux_middleware_inner"></p><p>Action: Action 是把数据从应用传到 store 的有效载荷，本质上是 JavaScript 普通对象。action 内必须使用一个字符串类型的 type 字段来表示将要执行的动作。<br>Reducer: Reducer 指定了应用状态的变化如何响应 action 并发送到 store 的。它是一个纯函数，接收旧的 state 和action，返回新的 state 。<br>State: State 记录了应用的状态。在 Redux 应用中，所有的 state 都被保存在一个单一对象中，即 store 中。<br>Store: Redux 应用只有一个单一的 store，它维持应用的 state，提供 <code>getState()</code> 方法获取 state；提供 <code>dispatch(action)</code> 方法更新 state；通过 <code>subscribe(listener)</code> 注册监听器；通过 <code>subscribe(listener)</code> 返回的函数注销监听器。</p><h2 id="Redux-和-Flux-的区别"><a href="#Redux-和-Flux-的区别" class="headerlink" title="Redux 和 Flux 的区别"></a>Redux 和 Flux 的区别</h2><p>Flux</p><ul><li>Flux 是用于构建用户界面的应用程序架构，通过单向数据流补充 React 可组合的视图组件</li><li>Flux 更像模式而非框架，没有任何硬依赖</li><li>Flux 架构的应用包含 4 部分<ul><li>Action<ul><li>通过 Action creators 创建</li><li>每个 Action 拥有 type 或类似属性</li><li>传递给 Dispatcher</li></ul></li><li>Dispatcher<ul><li>分发 Actions 给所有注册 Store 的回调函数</li></ul></li><li>Store<ul><li>接受 Action 更新数据后，触发 change 事件，通知 View</li><li>可以由多个 Store</li></ul></li><li>View 视图组件，即 Controller-View<ul><li>change 事件，从 Store 取回数据，将数据传递给子组件或更新组件状态</li><li>响应用户输入，生成新的 Action</li></ul></li></ul></li></ul><p>Redux</p><ul><li>Redux 是 JavaScript 应用的可预测状态容器</li><li>Redux 对不同框架都有完整实现，Facebook 官方推荐使用代替 Flux</li><li>Redux 架构与 Flux 基本一致，但做了简化<ul><li>State 只读，更改 State 的方式是返回新的对象，即引入 Reducer 纯函数</li><li>Action 与 Dispatcher ，只需返回包含 type 和 payload 属性的对象</li><li>Store<ul><li>store 唯一</li><li>createStore 基于 Reducer 纯函数创建</li><li><code>store.dispatch()</code> 调用 Action</li></ul></li><li>View<ul><li>通过 <code>store.getState()</code> 获取最新状态</li><li>通过 <code>store.subscribe()</code> 订阅状态更新<ul><li><code>store.subscribe()</code> 返回函数可取消订阅</li></ul></li></ul></li></ul></li></ul><p>综上，Redux 与 Flux 都基于单向数据流，架构相似，但 Redux 默认应用只有唯一 Store，精简掉 Dispatcher，引入 Reducer 纯函数，通过返回新对象，而不是更改对象，更新状态。</p><p>对比 Flux 的官方实现，Redux 的 API 更简洁，并且提供了如 <code>combineReducers</code> 等工具函数及 React-Toolkit 工具集，以及对状态的撤销、重做和持久化等更复杂的功能。提供如 React-Redux 等简化 Redux 与其他第三方库的连接。</p><h2 id="Redux-和-Vuex-的区别"><a href="#Redux-和-Vuex-的区别" class="headerlink" title="Redux 和 Vuex 的区别"></a>Redux 和 Vuex 的区别</h2><p>Vuex 和 Redux 的本质思想是一致的，均是将数据从视图中抽离的方案，通过单一的数据源 store 和可预测的数据变化反馈视图的改变。</p><ol><li>Redux 不仅仅局限于 React，还支持其它 UI 库；Vuex 和 Vue 深度绑定</li><li>Vuex 定义了 state、getter、mutation、action 四个对象；Redux 定义了 store、reducer、action</li><li>Vuex 事件触发方式 包括 commit 同步和 dispatch 异步；Redux 同步和异步都是用 dispatch</li><li>Vuex 中 state 统一存放；Redux 中 store 依赖所有 reducer 的初始值</li><li>Vuex 中有 getter 可以便捷的得到 state; React-redux 中 mapStateToProps 参数做了这个工作</li><li>Vuex 中的 action 可以使用异步 ajax 请求；Redux 中的 action 仅支持发送数据对象，异步 ajax 需要使用 redux-thunk 或 redux-saga 等第三方 middleware</li><li>Redux 中的是不可变数据，Vuex 中的数据是可变的。Redux 每次使用新的 store 替换旧的 store，Vuex 是直接修改 state</li><li>Redux 在检测数据变化的时候，是要通过 diff 的方式进行比较的，而 Vuex 是通过 getter/setter 来比较的</li></ol><h2 id="Redux-和-MobX-的区别"><a href="#Redux-和-MobX-的区别" class="headerlink" title="Redux 和 MobX 的区别"></a>Redux 和 MobX 的区别</h2><ol><li>Redux 的编程范式是函数式；Mobx 是面向对象的</li><li>Redux 中的数据是不可变对象，每次更新返回一个新的数据；MobX 中的数据从始至终都是同一份引用</li><li>MobX 没有全局的状态树，状态分散在各个独立的 store 中；Redux 中的 store 是全局唯一的</li><li>MobX 相对 Redux 来说会少些工程化模板</li><li>MobX 中使用 async/await 或 flow 来处理异步逻辑；Redux 需要使用第三方 middleware</li></ol><h2 id="Redux-的核心原则"><a href="#Redux-的核心原则" class="headerlink" title="Redux 的核心原则"></a>Redux 的核心原则</h2><p>Redux 设计和使用遵循三个基本原则：</p><ul><li>单一数据源，Store 唯一<br>整个应用程序的状态 State 存储在单一对象树 Object tree 中<br>Object tree 只存在唯一的 Store 中<br>单一对象树让跟踪状态的时间变化，调试和检查应用程度都更加容易</li><li>状态是只读的<br>Redux 假设开发者永远不会更改数据，而是在 Reducer 中返回新对象来更新状态<br>更改状态的唯一方法是发出一个动作 Action，Action 是对已发生事情的抽象描述的对象<br>数据变更，如用户输入和网络请求都不能直接更改状态</li><li>Reducer 是纯函数，用来归并状态 State<br>接受原状态和 Action，返回新状态 <code>reducer(state, action) =&gt; new State</code><br>纯函数，无副作用，输出和输入一一对应，与执行上下文、时间、调用次数无关。不应在函数内请求 API，操作 DOM，使用 <code>Date.now()</code> 等时间耦合方法或随机值</li></ul><h2 id="React-Context-和-Redux-的区别"><a href="#React-Context-和-Redux-的区别" class="headerlink" title="React Context 和 Redux 的区别"></a>React Context 和 Redux 的区别</h2><p>ReactContext</p><ul><li>React Context API 是为了解决跨组件层级传递 props 的效率问题</li><li>试验性的 Context API 存在问题<ul><li>提供数据源的父组件和接收数据的子组件间的某个组件的 shouldComponentUpdate 返回 false 跳过更新，子组件也会被动跳过更新</li></ul></li><li>ContextAPI 正式在 React16.3 引入，使用方法<ul><li>创建 context 对象实例: <code>const MyContext = React.createContext(defaultValue)</code><br>订阅 context 的变化: 使用 <code>&lt;MyContext.Provider value=&#123;/* 某个值 */&#125;&gt;</code> 组件去声明想要传递的数据源</li><li>消费数据<br>​高阶组件写法 <code>&lt;MyContext.Consumer&gt;&#123;vaule=&gt; /* 基于 context 值进行渲染 */ &#125;&lt;/Consumer&gt;</code><br>Hook写法 <code>const value = useContext(MyContext)</code></li></ul></li></ul><p>Redux</p><ul><li>Redux 是 JavaScript 应用的可预测状态容器</li><li><p>Redux 使用方法</p><ul><li>声明 reducer 函数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">reducer</span> = (<span class="params">state, action</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;INCREMENT&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;DECREMENT&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> state - <span class="number">1</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>创建 store 对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(reducer);</span><br></pre></td></tr></table></figure></li><li>使用 state dispatch<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">MyComponent</span> = (<span class="params">&#123; value, onIncrement, onDecrement &#125;</span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;value&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onIncrement&#125;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onDecrement&#125;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">MyComponent</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">value</span>=<span class="string">&#123;store.getState()&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">onIncrement</span>=<span class="string">&#123;()</span> =&gt;</span> store.dispatch(&#123; type: &#x27;INCREMENT&#x27; &#125;)&#125;</span></span><br><span class="line"><span class="language-xml">    onDecrement=&#123;() =&gt; store.dispatch(&#123; type: &#x27;DECREMENT&#x27; &#125;)&#125;</span></span><br><span class="line"><span class="language-xml">  /&gt;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>目的</p><ul><li>ReactContext 解决跨组件层级传递 props 的效率问题</li><li>Redux 是 JavaScript 应用的可预测状态容器，拥有完整的状态管理功能</li></ul></li><li>更新机制<ul><li>ReactContext：Context 的 value 更新，它内部所有消费组件都会重新渲染，并且不受制于 shouldComponentUpdate 函数，需要手动优化<ul><li>避免使用<em>对象</em>字面量作为 value</li><li>拆分 Context</li><li>记忆化</li><li>使用 createContext 的第二参数手动优化</li></ul></li><li>Redux<ul><li>只有当前组件所消费的状态值改变，当前组件才会被更新</li></ul></li></ul></li><li>调试<ul><li>ReactContext 支持 ReactDevTools 调试</li><li>Redux 支持 Redux DevTools 调试<ul><li>可以方便地跟踪应用的状态何时、何处、为什么及如何改变</li><li>Redux 架构允许开发者记录更改，使用“时间旅行调试”</li></ul></li></ul></li><li>中间件<ul><li>ReactContext 不支持中间件</li><li>Redux 支持 applyMiddleware 将所有中间件组成一个数据，依次执行，最后执行 <code>store.dispatch</code>，依靠中间件扩展 Redux 功能，如简化异步操作等</li></ul></li></ul><h2 id="React-访问-ReduxStore-的方法"><a href="#React-访问-ReduxStore-的方法" class="headerlink" title="React 访问 ReduxStore 的方法"></a>React 访问 ReduxStore 的方法</h2><ul><li>connect：适合 React 组件访问 ReduxStore</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">MyComponent</span> = (<span class="params">&#123;value&#125;</span>) =&gt; <span class="language-xml"><span class="tag">&lt;&gt;</span>&#123;value&#125;<span class="tag">&lt;/&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">mapStateToProps</span>= (<span class="params">&#123;value&#125;</span>) =&gt; (&#123;value&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="title function_">connect</span>(mapStateToProps)(<span class="title class_">MyComponent</span>)</span><br></pre></td></tr></table></figure><ul><li>导出 store：适合非服务端渲染<ul><li>创建 store 并导出<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125;<span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;./reducer&#x27;</span></span><br><span class="line">conststore = <span class="title function_">createStore</span>(reducer)</span><br><span class="line"><span class="keyword">export</span> defaultstore</span><br></pre></td></tr></table></figure></li><li>引入 sotre 通过 getState 获取状态<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> state = store.<span class="title function_">getState</span>();</span><br><span class="line">  <span class="keyword">const</span> &#123; value &#125; = state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>使用 redux-thunk 的第二参数 getState</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">&#x27;redux-thunk&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;./reducer&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(reducer, <span class="title function_">applyMiddleware</span>(thunk));</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">get</span> = (<span class="params"></span>) =&gt; <span class="function">(<span class="params">dispatch, getState</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;getStart&#x27;</span> &#125;);</span><br><span class="line">  <span class="keyword">const</span> &#123; token &#125; = <span class="title function_">getState</span>();</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/user/info&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">    <span class="attr">header</span>: &#123;</span><br><span class="line">      <span class="title class_">Authorization</span>: <span class="string">`Bearer <span class="subst">$&#123;token&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> res.<span class="title function_">json</span>())</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">json</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;getSuccess&#x27;</span>, <span class="attr">payload</span>: &#123; <span class="attr">user</span>: json &#125; &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">store.<span class="title function_">dispatch</span>(<span class="title function_">get</span>());</span><br></pre></td></tr></table></figure><ul><li>手写中间件 middleware，截获 action 的 payload，或者直接输出 getState 方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;./reducer&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> payload = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">myMiddleware</span> = store =&gt; <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">action</span>(store);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    payload = action.<span class="property">payload</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">next</span>(action);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(reducer, <span class="title function_">applyMiddleware</span>(myMiddleware));</span><br><span class="line">store.<span class="title function_">dispatch</span>(<span class="function"><span class="params">store</span> =&gt;</span> store.<span class="title function_">getState</span>()); <span class="comment">// 直接调用 store 的方法</span></span><br><span class="line">store.<span class="title function_">dispatch</span>(&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;start&#x27;</span>,</span><br><span class="line">  <span class="attr">payload</span>: <span class="string">&#x27;payload&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(payload); <span class="comment">// payload</span></span><br></pre></td></tr></table></figure><h2 id="Redux-中异步请求数据时发送多-Action-方法"><a href="#Redux-中异步请求数据时发送多-Action-方法" class="headerlink" title="Redux 中异步请求数据时发送多 Action 方法"></a>Redux 中异步请求数据时发送多 Action 方法</h2><p>异步请求数据等异步操作通常要发出三种 Action</p><ul><li>操作发起时 Action，以 start 为例</li><li>操作成功时 Action，以 success 为例</li><li>操作失败时 Action，以 failure 为例</li></ul><p>发送多 Action 方法:</p><ul><li>mapDispatchToprops<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">mapDispatchToprops</span> = dispatch =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">asyncAction</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;start&#x27;</span> &#125;)</span><br><span class="line">      <span class="title function_">fetch</span>(<span class="string">&#x27;/api&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> res.<span class="property">json</span>).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;success&#x27;</span>, <span class="attr">payload</span>: &#123; data &#125; &#125;)</span><br><span class="line">      &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">error</span>=&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;failure&#x27;</span>, <span class="attr">payload</span>: &#123; error &#125; &#125;)</span><br><span class="line">      &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>redux-thunk，使 dispatch 支持传入函数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">&#x27;redux-thunk&#x27;</span></span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;./reducer&#x27;</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(reducer, <span class="title function_">applyMiddleware</span>(thunk))</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">asyncAction</span> = dispatch =&gt; &#123;</span><br><span class="line">  <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;start&#x27;</span> &#125;)</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/api&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> res.<span class="property">json</span>).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;success&#x27;</span>, <span class="attr">payload</span>: &#123; data &#125; &#125;)</span><br><span class="line">  &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;failure&#x27;</span>, <span class="attr">payload</span>: &#123; error &#125; &#125;)</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br><span class="line">store.<span class="title function_">dispatch</span>(<span class="title function_">asyncAction</span>())</span><br></pre></td></tr></table></figure></li><li><p>redux-promise，使 dispatch 支持传入 Promise</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> promiseMiddleware <span class="keyword">from</span> <span class="string">&#x27;redux-promise&#x27;</span></span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;./reducer&#x27;</span></span><br><span class="line"><span class="keyword">const</span> stroe = <span class="title function_">createStore</span>(reducer, <span class="title function_">applyMiddleware</span>(promiseMiddleware))</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">asyncAction</span> = dispatch =&gt; <span class="title function_">fetch</span>(<span class="string">&#x27;/api&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span>res.<span class="property">json</span>).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;success&#x27;</span>, <span class="attr">payload</span>: &#123; data &#125; &#125;)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;failure&#x27;</span>, <span class="attr">payload</span>: &#123; error &#125; &#125;)</span><br><span class="line">&#125;))</span><br><span class="line">store.<span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;start&#x27;</span> &#125;)</span><br><span class="line">store.<span class="title function_">dispatch</span>(<span class="title function_">asyncAction</span>())</span><br></pre></td></tr></table></figure></li><li><p>redux-saga，采用 Generator 生成器函数支持异步多 Action</p><figure class="highlight js"><figcaption><span>sagas.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; call, put, takeEvery, takeLatest &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-saga/effects&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">asyncAction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">yield</span> <span class="title function_">call</span>(<span class="string">&#x27;/api&#x27;</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">put</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;success&#x27;</span>, <span class="attr">payload</span>: &#123; data &#125; &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">put</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;failure&#x27;</span>, <span class="attr">payload</span>: &#123; error &#125; &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">mySaga</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 支持并发</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="title function_">takeEvery</span>(<span class="string">&#x27;start&#x27;</span>, asyncAction);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">mySage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//不支持并发，前个处理中的相同 type 的 Action 会被取消</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="title function_">takeLatest</span>(<span class="string">&#x27;start&#x27;</span>, asyncAction);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> mySage;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>main.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> createSagaMiddleware <span class="keyword">from</span> <span class="string">&#x27;react-saga&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;./reducer&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> mySaga <span class="keyword">from</span> <span class="string">&#x27;./sagas&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> sagaMiddleware = <span class="title function_">createSagaMiddleware</span>();</span><br><span class="line">conststore = <span class="title function_">createStore</span>(reducer, <span class="title function_">applyMiddleware</span>(sagaMiddleware));</span><br><span class="line">sagaMiddleware.<span class="title function_">run</span>(mySaga);</span><br></pre></td></tr></table></figure></li></ul><h2 id="如何判断项目需要引入-Redux"><a href="#如何判断项目需要引入-Redux" class="headerlink" title="如何判断项目需要引入 Redux"></a>如何判断项目需要引入 Redux</h2><p>并非所有应用程序都需要 Redux，是否引入 Redux 由以下决定</p><ul><li>正在构建的应用程序类型</li><li>需要解决的问题类型</li><li>哪些工具可以更好地解决问题</li></ul><p>Redux 可以共享和管理状态</p><ul><li>通过可预测的行为来帮助回答：状态何时、何处、为什么及如何改变</li><li>增加概念、代码和限制，增加学习成本和项目复杂度</li></ul><p>平衡利弊，在以下情况引入 Redux 最有用</p><ul><li>应用程序许多地方都需要状态</li><li>应用程序的状态经常更新</li><li>更新状态的逻辑比较复杂</li><li>项目较大，需要比较多的人协作</li><li>想查看状态何时、何处、为什么及如何改变</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Virtual DOM</title>
      <link href="/blog/2022/11/25/React-Virtual-DOM/"/>
      <url>/blog/2022/11/25/React-Virtual-DOM/</url>
      
        <content type="html"><![CDATA[<ul><li>Virtual DOM 是一种编程概念<ul><li>UI 以一种理想化的，或者说“虚拟的”表现形式被保存在内存中<ul><li>支持可以优化的 Diff 算法</li><li>避免多次调用 DOM 操作影响渲染无效的内容</li></ul></li><li>通过 ReactDOM 等类库与真实 DOM 同步，这一过程也被叫做<em>协调</em>（reconciliation）<ul><li>支持按照优先级更新，并行可中断的协调策略</li><li>支持 ReactCanvas 和 ReactNative 等其他渲染方式，甚至非浏览器环境</li></ul></li></ul></li><li>Virtual DOM 赋予 React 声明式的 API<ul><li>告诉 React 希望让 UI 是什么状态，React 就确保 DOM 匹配该状态</li><li>开发者不必关心属性操作、事件处理和手动 DOM 更新这些构建应用程序必要的操作</li></ul></li><li>Virtual DOM 在 React 中是一种视图更新技术或设计模式，<ul><li>Virtual DOM 通常与 React 元素关联，代表用户界面的对象</li><li>React 使用 fibers 内部对象来存放组件树的附加信息</li><li>React Fiber 是 React 中的协调引擎，主要目的是使 Virtual DOM 可以增量式渲染</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Hook</title>
      <link href="/blog/2022/11/25/React-React-Hook/"/>
      <url>/blog/2022/11/25/React-React-Hook/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-React-Hook"><a href="#什么是-React-Hook" class="headerlink" title="什么是 React Hook"></a>什么是 React Hook</h2><p>Hook 是 React 16.8 的新增特性</p><ul><li>允许开发者在函数组件里使用 React state 及生命周期等特性的函数<ul><li>React 内置如 useState、useEffect 等 Hook</li></ul></li><li>Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据）<ul><li>非强制按照生命周期划分，避免每个生命周期包含不相关的逻辑</li></ul></li><li>开发者可以在不编写 class 的情况下使用 state 以及其他的 React 特性<ul><li>无需考虑 this，无需考虑函数和 class 组件的区别和应用场景</li><li>便于使用 Prepack 试验 component folding，使代码更易于优化</li><li>拥抱函数式编程</li></ul></li><li>Hook 和现有代码可以同时工作，渐进式地使用</li></ul><span id="more"></span><h2 id="什么是-State-Hook"><a href="#什么是-State-Hook" class="headerlink" title="什么是 State Hook"></a>什么是 State Hook</h2><ul><li>State Hook 允许开发者在 React 函数组件中添加 state 的 Hook</li><li>这种 Hook 在 React 的原生实现是 <code>useState</code>，它是一种函数调用时保存变量的方式，它与 class 里面的 this.state 提供的功能完全相同</li><li>useState 的唯一参数是初始 state，支持数字、字符串、对象等类型</li><li>useState 方法的返回值分别是当前 state 以及更新 state 的函数，使用数组解构获取赋值</li><li>state 只在组件首次渲染时创建，下次重新渲染时，返回当前的 state</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="什么是-Effect-Hook"><a href="#什么是-Effect-Hook" class="headerlink" title="什么是 Effect Hook"></a>什么是 Effect Hook</h2><ul><li>Effect Hook 允许开发者在函数组件中执行副作用操作，包括数据获取、设置订阅以及手动更改 React 组件中的 DOM。</li><li>这种 Hook 在 React 的原生实现是 useEffect</li><li>useEfect 支持两个参数<ul><li>第一个参数为函数，默认在组件第一次渲染和每次更新、浏览器完成画面渲染之后执行，调用时机可以看作 class 组件的 componentDidMount、componentDidUpdate 生命周期 + 浏览器完成画面渲染时</li><li>第二个参数为数组，只有数组元素发生变化时，才会调用第一个参数的函数</li><li>当第二个参数为空数组 [] 时，第一个参数的函数仅会在组件挂载和卸载时执行</li></ul></li><li>useEffect 可以返回一个函数，用于移除订阅等副作用，区别于 class 组件的 componetWillUnMount，React 会在执行当前 effect 之前对上一个 effect 进行清除</li><li>useEffect 可以直接访问 state 和 props</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Update the document title using the browser API</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h2 id="useReducer-和-useState-区别"><a href="#useReducer-和-useState-区别" class="headerlink" title="useReducer 和 useState 区别"></a>useReducer 和 useState 区别</h2><p>useReducer 是 useState 在某些场景下的替代方案，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。它接收一个形如 <code>(state, action) =&gt; newState</code> 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法。一个典型的应用场景就是计数器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, initialArg, init);</span><br></pre></td></tr></table></figure><h2 id="useMemo-和-useCallback-区别"><a href="#useMemo-和-useCallback-区别" class="headerlink" title="useMemo 和 useCallback 区别"></a>useMemo 和 useCallback 区别</h2><p>useMemo 返回一个 <em>被记忆的</em> 值，把值的“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算该 <em>被记忆的</em> 值。这种优化有助于避免在每次渲染时都进行高开销的计算。</p><p>useCallback 返回一个 <em>被记忆的</em> 回调函数。把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。</p><p><code>useCallback(fn, deps)</code> 相当于 <code>useMemo(() =&gt; fn, deps)</code>。</p><h2 id="useEffect-和-useLayoutEffect-区别"><a href="#useEffect-和-useLayoutEffect-区别" class="headerlink" title="useEffect 和 useLayoutEffect 区别"></a>useEffect 和 useLayoutEffect 区别</h2><p>相同点：</p><ul><li>执行时机都是组件挂载或更新之后，浏览器执行绘制之前</li><li>支持返回清除函数，函数执行时机是组件卸载之前</li></ul><p>不同点：</p><ul><li>useLayoutEffect 在所有 DOM 变更之后同步调用 effect，用来读取 DOM 布局并同步触发重渲染</li><li>useEffect 在所有 DOM 变更并且浏览器完成渲染后调用 effect</li><li>服务端渲染组件引入 useLayoutEffect 会触发 React 告警</li></ul><h2 id="useRef-和-Refs-的区别"><a href="#useRef-和-Refs-的区别" class="headerlink" title="useRef 和 Refs 的区别"></a>useRef 和 Refs 的区别</h2><p>useRef 返回一个可变的 ref 对象，其 current 属性被初始化为传入的参数 （initialValue），返回的 ref 对象在组件的整个生命周期保持不变。<br>一个常见的用例便是命令式地访问子组件，例如将 input 元素的 ref 属性设置为 useRef 返回的 ref 对象，则可以通过该 ref 对象的 current 属性设置 input 元素是否聚焦。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">TextInputWithFocusButton</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> inputEl = <span class="title function_">useRef</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onButtonClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// `current` 指向已挂载到 DOM 上的文本输入元素</span></span><br><span class="line">    inputEl.<span class="property">current</span>.<span class="title function_">focus</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputEl&#125;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onButtonClick&#125;</span>&gt;</span>Focus the input<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Refs 使用 <code>React.createRef()</code> 创建的，并通过 ref 属性附加到 React 元素，当 ref 被传递给 render 中的元素时，对节点的引用可以在 ref 的 current 属性中被访问。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(props)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">myRef</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.myRef&#125;</span> /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区别：<br>useRef</p><ul><li>函数组件可用</li><li>用途多样，useRef() 创建一个普通 Javascript 对象，每次渲染时返回同一个 ref 对象<br>  可以在其 current 属性保存任何可变值。<br>Refs</li><li>class 组件或 HTML 元素，函数组件无实例，不可用</li><li>用途单一，current 属性为实例的引用，根据节点的类型不同<ul><li>当 ref 属性用于 HTML 元素时，构造函数中使用 React.createRef() 创建的 ref 接收底层 DOM 元素作为 current 属性</li><li>当 ref 属性用于自定义 class 组件时，ref 对象接收组件的挂载实例作为其 current 属性</li></ul></li></ul><h2 id="如何自定义-Hook"><a href="#如何自定义-Hook" class="headerlink" title="如何自定义 Hook"></a>如何自定义 Hook</h2><h3 id="什么是自定义-Hook"><a href="#什么是自定义-Hook" class="headerlink" title="什么是自定义 Hook"></a>什么是自定义 Hook</h3><p>自定义 Hook，是将组件逻辑提取到可重用的函数，它可以像 render props 和高阶组件来共享组件之间的状态逻辑，而不增加组件。</p><h3 id="自定义-Hook-需要遵循哪些规则"><a href="#自定义-Hook-需要遵循哪些规则" class="headerlink" title="自定义 Hook 需要遵循哪些规则"></a>自定义 Hook 需要遵循哪些规则</h3><ul><li>名称以 “use” 开头的函数，表示这是一个 Hook，函数内部可以调用其他的 Hook。</li><li>参数和返回可以自定义，可以像使用函数一样在不同 Hook 间传递信息</li><li>其中所有 state 和副作用完全隔离，每次调用 Hook，都会获取独立的 state</li></ul><h3 id="自定义-Hook-作用"><a href="#自定义-Hook-作用" class="headerlink" title="自定义 Hook 作用"></a>自定义 Hook 作用</h3><p>将组件逻辑提取到可重用的函数中，简化代码逻辑</p><h2 id="为什么不能在循环，条件或嵌套函数中调用-Hook？"><a href="#为什么不能在循环，条件或嵌套函数中调用-Hook？" class="headerlink" title="为什么不能在循环，条件或嵌套函数中调用 Hook？"></a>为什么不能在循环，条件或嵌套函数中调用 Hook？</h2><p>React 通过 Hook 调用的顺序来将 state 与对应的 useState 相关联，所以需要确保 Hook 的调用顺序在多次渲染之间保持一致。如果想要有条件地执行一个 effect，可以将判断放到 Hook 的内部。</p><h2 id="useDeferredValue-和-useTransition-的区别"><a href="#useDeferredValue-和-useTransition-的区别" class="headerlink" title="useDeferredValue 和 useTransition 的区别"></a>useDeferredValue 和 useTransition 的区别</h2><ul><li>useDeferredValue 本质上和内部实现与 useTransition 一样，都是标记成了延迟更新任务。</li><li>useTransition 是把更新任务变成了延迟更新任务，而 useDeferredValue 是产生一个新的值，这个值作为延时状态。（一个用来包装方法，一个用来包装值）</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React组件的状态state与属性props</title>
      <link href="/blog/2022/11/24/React-React%E7%BB%84%E4%BB%B6%E7%9A%84%E7%8A%B6%E6%80%81state%E4%B8%8E%E5%B1%9E%E6%80%A7props/"/>
      <url>/blog/2022/11/24/React-React%E7%BB%84%E4%BB%B6%E7%9A%84%E7%8A%B6%E6%80%81state%E4%B8%8E%E5%B1%9E%E6%80%A7props/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-React-的状态（state）"><a href="#什么是-React-的状态（state）" class="headerlink" title="什么是 React 的状态（state）"></a>什么是 React 的状态（state）</h2><ul><li>React 的状态 state 是一个对象<ul><li>类组件中，状态通过 <code>this.state</code> 创建，通过 <code>this.setState</code> 合并更改，异步更新</li><li>React Hook 中，状态通过 <code>this.useState</code> 或 <code>this.useReducer</code> 使用</li></ul></li><li>React 将组件看做状态机，状态改变触发渲染</li><li>React 建议减少有状态的组件，提高组件复用度，利于维护<ul><li>只将无法从 props 传递，无法从其他数据计算，并且随时间可能变化的数据作为 state</li><li>多个组件 state 的数据源相同，应将状态提升到父组件或容器组件</li><li>避免使用 context，仅在 React 的状态管理无法满足需求时使用 Redux</li></ul></li></ul><span id="more"></span><h2 id="什么是-React-的状态提升"><a href="#什么是-React-的状态提升" class="headerlink" title="什么是 React 的状态提升"></a>什么是 React 的状态提升</h2><ul><li>React 中，任何可变数据应当只有一个相对应的唯一“数据源”</li><li>多个组件反映相同的变化数据时，共享状态提升到最近的共同父组件<ul><li>state 应首先添加到需要渲染数据的组件</li><li>其他组件也需要这个 state，将它提升至这些组件的最近共同父组件</li></ul></li><li>state 只能由拥有它们的组件修改，bug 排查范围被大大缩减</li></ul><h2 id="状态（state）和属性（props）的区别是什么"><a href="#状态（state）和属性（props）的区别是什么" class="headerlink" title="状态（state）和属性（props）的区别是什么"></a>状态（state）和属性（props）的区别是什么</h2><ul><li><p>相同点</p><ul><li>state 和 props 都是原生的 JavaScript 对象，在 React 中代表了组件的数据来源</li><li>state 和 props 的变化都会触发生命周期钩子 componentWillUpdate、useEffect / useLayoutEffect、和渲染</li><li>同样的 state/props 渲染结果相同</li><li>state 和 props 都可以在组件内部设置默认值</li></ul></li><li><p>不同点</p><ul><li>获取<ul><li>state 由当前组件声明</li><li>props 由父组件传入</li></ul></li><li>更新<ul><li>state<ul><li>由所在组件通过 useState / useReducer 或 setState 方法更新</li><li>由子组件通过传入的 props 中的回调函数间接更新</li></ul></li><li>props 不允许修改</li></ul></li><li>数据<ul><li>state 通常存储组件相关的可变数据，避免多层嵌套或使用不可变对象便于优化渲染</li><li>props 除数据外，还多用于回调函数，组件（children），路由（history）的传递</li></ul></li></ul></li></ul><h2 id="setState-和-replaceState-的区别"><a href="#setState-和-replaceState-的区别" class="headerlink" title="setState 和 replaceState 的区别"></a>setState 和 replaceState 的区别</h2><ul><li>setState 会合并当前状态与之前状态</li><li>replaceState 会丢弃之前状态，用新状态替代</li><li>replaceState 等同于先在 setState 中将状态设置为 false / null，再设置新状态</li></ul><h2 id="如何优化-setState，减少不必要更新"><a href="#如何优化-setState，减少不必要更新" class="headerlink" title="如何优化 setState，减少不必要更新"></a>如何优化 setState，减少不必要更新</h2><ul><li>通过 <code>setState(updater, [callback])</code> 的用法，第一参数使用带有形式参数的函数</li><li>通过 updater 函数 <code>(state, props) =&gt; stateChange</code> 的第一参数，接受原来的 state 状态值</li><li>对比新旧状态值<ul><li>相同，返回 null，不渲染</li><li>不同，返回新状态值，触发异步合并渲染</li></ul></li></ul><p>示例代码:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getData = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; time &#125; = data</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state.<span class="property">time</span> === time ?  <span class="literal">null</span> : &#123; time &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="当-state-值为-Object-时，如何优化"><a href="#当-state-值为-Object-时，如何优化" class="headerlink" title="当 state 值为 Object 时，如何优化"></a>当 state 值为 Object 时，如何优化</h2><ul><li>避免使用 Object 作为 state 值，使用 PureComponent 的浅比较的自动优化失效</li><li>必需使用 Object 作为 state 值<ul><li>避免嵌套过多层级</li><li>设置更新 state 的前置条件或使用 shouldComponentUpdate 手动优化</li></ul></li><li>已经使用 Object 作为 state 值，并且嵌套层级过多<ul><li>拆分 state 到子组件</li><li>使用不可变对象 Immutable，只要 state 更新，返回对象新引用，重新渲染修改节点</li></ul></li></ul><h2 id="什么是-React-的属性（props）"><a href="#什么是-React-的属性（props）" class="headerlink" title="什么是 React 的属性（props）"></a>什么是 React 的属性（props）</h2><ul><li>属性是组件的入参，用法同 HTML 自定义属性，可将任意类型数据从父组件传给子组件</li><li>属性的改变可以触发组件的生命周期流程和渲染</li><li>建议从组件自身的角度，不依赖于调用中间的上下文命名 props</li><li>属性具有只读性，所有 React 组件必须像纯函数一样保护它们的 props 不被更改</li><li>请避免使用匿名函数作为属性值，避免引起重复渲染</li><li>具有 render prop 的组件接受一个返回 React 元素的函数，并在组件内部通过调用此函数来实现自己的渲染逻辑</li></ul><h2 id="为什么不能直接修改属性（props）"><a href="#为什么不能直接修改属性（props）" class="headerlink" title="为什么不能直接修改属性（props）"></a>为什么不能直接修改属性（props）</h2><ul><li>React 仅支持单向数据流，数据通过 props 由外向内传递</li><li>从 state 派生数据或 UI 只能影响“低于”它们的组件，设计简单高效，便于调试</li><li>所有 React 组件必须像纯函数一样保护它们的 props 不被更改，保证组件没有副作用</li></ul><h2 id="通过属性（props）传递组件本身的方法有哪些"><a href="#通过属性（props）传递组件本身的方法有哪些" class="headerlink" title="通过属性（props）传递组件本身的方法有哪些"></a>通过属性（props）传递组件本身的方法有哪些</h2><ul><li>props.children<ul><li>子组件可以获取父组件开始标签和结束标签之间的内容</li></ul></li><li>render props<ul><li>向子组件传入函数，返回组件需要渲染什么内容</li><li>直接在父组件的标签之间，调用函数返回组件</li><li>避免使用匿名函数返回组件，避免重复渲染</li></ul></li></ul><h2 id="使用-key-属性有哪些注意事项"><a href="#使用-key-属性有哪些注意事项" class="headerlink" title="使用 key 属性有哪些注意事项"></a>使用 key 属性有哪些注意事项</h2><ul><li>key 用来帮助 React 识别数组列表中哪些元素改变了，从而更好的更新元素</li><li>key 在数组列表及兄弟节点之间必须唯一</li><li>不建议使用索引作为 key 值，如果不显示指定 key 值，默认使用索引作为 key 值</li><li>key 只有放在就近的数组上下文中才有意义</li><li>key 不会传递给子组件，需要使用 key 属性的值，需使用其他属性显式传递</li></ul><h2 id="如何在-React-中进行静态类型检查"><a href="#如何在-React-中进行静态类型检查" class="headerlink" title="如何在 React 中进行静态类型检查"></a>如何在 React 中进行静态类型检查</h2><ul><li>React.PropTypes 或 prop-types 库<ul><li>提供一系列验证器，确保组件接收到的数据类型有效</li><li>PropTypes 仅在开发模下进行检查并在控制台显示警告</li><li>通过特定的 defaultProps 属性来定义 props 的默认值</li></ul></li><li>Flow<ul><li>Flow 是一个针对 JavaScript 代码的静态类型检测器</li><li>由 Facebook 开发，经常与 React 一起使用</li><li>Flow 通过特殊类型语法为变量、函数以及 React 组件提供注解</li><li>Flow 添加方法<ul><li>将 Flow 添加到项目依赖</li><li>确保编译后的代码已经去除 Flow 语法</li><li>添加类型注解并且运行 Flow 来检查</li></ul></li></ul></li><li>TypeScript<ul><li>TypeScript 是微软开发的编程语言，它是 JavaScript 的类型超集，包含独立编译器</li><li>强类型语言，构建时可以发现 bug 和错误</li><li>TypeScript 添加方法<ul><li>将 TypeScript 添加到项目依赖</li><li>配置 TypeScript 编译选项</li><li>使用正确的文件扩展名，React 的 JSX 使用.tsx作为扩展名</li><li>为已经使用的库添加定义，现实其他包的错误和提示</li></ul></li></ul></li></ul><h2 id="React-是否支持原生-HTML-属性"><a href="#React-是否支持原生-HTML-属性" class="headerlink" title="React 是否支持原生 HTML 属性"></a>React 是否支持原生 HTML 属性</h2><ul><li>任何标准和自定义的 DOM 属性都是完全支持的</li><li>React 为 DOM 提供了一套以 JavaScript 为中心的 API<ul><li>标准 DOM 属性采用小驼峰命名</li><li>自定义属性全部小写</li></ul></li><li>React 与 HTML 之间部分属性存在差异<ul><li>checked<ul><li>受控组件 checked</li><li>非受控组件用 defaultChecked 设置组件首次挂载时是否被选中</li></ul></li><li>className<ul><li>用于指定 DOM 节点和 SVG 元素的 class</li><li>React 中，使用 Web Components，使用 class 属性代替</li></ul></li><li>dangerouslySetInnerHTML<ul><li>React 为浏览器 DOM 提供 innerHTML 的替换方案</li><li>需要向该属性传入 key 为 __html 的对象，用来警示跨站脚本（XSS）攻击风险</li></ul></li><li>htmlFor<ul><li>for 是 JavaScript 关键字，React 元素使用 htmlFor 代替</li></ul></li><li>onChange<ul><li>onChange 事件与预期行为一致：表单字段变化时，事件都会被触发</li><li>与浏览器已有的默认行为不一致：<ul><li>用户更改 <code>&lt;input&gt;</code>，<code>&lt;select&gt;</code> 和 <code>&lt;textarea&gt;</code> 元素的值并提交更改时 change 事件在这些元素上触发</li><li>与 input 事件不一样，change 事件不是每次元素的 value 改变时都会被触发</li></ul></li><li>React 依靠该事件实时处理用户输入</li></ul></li><li>selected<ul><li>将 <code>&lt;option&gt;</code> 标记为已选中状态，请在 select 的 value 中引用该选项的值</li></ul></li><li>style<ul><li>接受小驼峰命名属性的 JavaScript 对象，而不是 CSS 字符串</li><li>与 JavaScript 属性一致，同时会更高效，且能预防跨站脚本（XSS）的安全漏洞</li><li>样式不会自动补齐浏览器私有前缀，除 ms 外，浏览器引擎前缀都应以大写字母开头</li><li>React 自动添加 “px” 后缀到内联样式为数字的属性，本来没有单位的属性 zoom,order,flex 不会转换像素字符串</li><li>需使用 “px” 以外单位，请将值设为数字与所需单位组成的字符串</li></ul></li><li>suppressContentEditableWaring<ul><li>禁止拥有子节点的元素比标记为 contentEditable 时 React 发出警告</li></ul></li><li>suprressHydrationWarning<ul><li>禁止 React 服务端渲染与客户端渲染不同内容时发出警告</li><li>只会对元素一级深度有效，应急方案使用，不过过度使用</li></ul></li><li>value<ul><li><code>&lt;input&gt;</code>，<code>&lt;select&gt;</code>，<code>&lt;textarea&gt;</code> 组件支持 value 属性</li><li>非受控组件使用 dafaultValue 属性设置组件第一次挂载时的 value</li></ul></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React组件</title>
      <link href="/blog/2022/11/24/React-React%E7%BB%84%E4%BB%B6/"/>
      <url>/blog/2022/11/24/React-React%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-React-组件"><a href="#什么是-React-组件" class="headerlink" title="什么是 React 组件"></a>什么是 React 组件</h2><p>React 组件允许用户将 UI 拆分成独立可复用的代码片段，并对每个片段进行独立构思。React 组件从概念上类似于 JavaScript 函数，接受任意的入参 Props，返回用于描述页面展示内容的 React 元素。</p><span id="more"></span><h2 id="React-组件分类"><a href="#React-组件分类" class="headerlink" title="React 组件分类"></a>React 组件分类</h2><ul><li><p>按定义分类</p><ul><li>类组件，使用 ES6 的 class 定义，维护 state，有生命周期</li><li>函数组件，使用普通函数定义，可以通过 hooks 维护状态和副作用</li></ul></li><li><p>按状态分</p><ul><li>有状态组件，组件返回结果，受时间、空间或上下文影响</li><li>无状态组件，通常是纯展示 UI 组件，容易复用</li></ul></li><li><p>按定位分</p><ul><li>展示型组件，接收 props，负责 UI 展示</li><li>容器组件，管理 states，负责数据获取和组件间通信，多用于状态提升</li></ul></li><li><p>按 React 内置类型分类</p><ul><li>有状态组件<ul><li>ClassComponent，由 class 创建</li><li>ContextProvider，由 createContext 创建</li></ul></li><li>无状态组件<ul><li>IndeterminateComponent，FunctionCompoent 挂载前的初始类型</li><li>FunctionComponent，即函数组件</li><li>ForwardRef，由 React.forwardRef 创建，接收 ref 并转发给子组件</li><li>MemoComponent，由 React.memo 创建，条件渲染子组件</li><li>SimpleMemoCompoent，由 React.memo 创建且不指定条件</li></ul></li><li>FiberNode<ul><li>HostRoot，由 ReactDOM.render 创建</li><li>HostPortal，由 React.createPortal 创建，多用于模态框</li><li>HostComponent，对应元素节点</li><li>HostText，对应文本节点</li></ul></li><li>内置类型<ul><li>Fragment，分组子列表，无需向 DOM 添加额外节点，可用短语法&lt;&gt;</li><li>Profiler，测量 React 应用多久渲染一次以及渲染一次的“代价”</li><li>StrictMode，严格模式，用来突出显示应用程序中潜在问题的工具</li><li>Suspense，等待目标代码加载，并且可以指定一个加载界面，在用户等待时显示</li><li>PureCompoent，浅层对比 prop 和 state 实现</li></ul></li></ul></li></ul><h2 id="类组件和函数组件的区别"><a href="#类组件和函数组件的区别" class="headerlink" title="类组件和函数组件的区别"></a>类组件和函数组件的区别</h2><table><thead><tr><th>说明</th><th>类组件</th><th>函数组件</th></tr></thead><tbody><tr><td>回调钩子</td><td>生命周期</td><td>useEffect / useLayoutEffect</td></tr><tr><td>this</td><td>有，事件处理函数需绑定 this</td><td>无</td></tr><tr><td>state</td><td>有，this.setState 更新</td><td>无，useState / useReducer 引入</td></tr><tr><td>实例化</td><td>是</td><td>否</td></tr><tr><td>性能</td><td>现代浏览器中，闭包和类的原始性能只有在极端场景才会有明显差别</td><td>使用 Hooks 某些情况更加高效,避免了 class 需要的额外成本，如创建类实例和在构造函数绑定事件处理器的成本,符合语言习惯的代码不需要很深的组件库嵌套</td></tr></tbody></table><h2 id="受控组件和非受控组件的区别"><a href="#受控组件和非受控组件的区别" class="headerlink" title="受控组件和非受控组件的区别"></a>受控组件和非受控组件的区别</h2><ul><li>受控组件<ul><li>React 的 state 是表单元素的“唯一数据源”，控制用户输入过程中表单发生的操作</li><li>表单元素的 value 跟随 state 变化，默认值由 defaultValue 设置</li><li>表单元素需要被 React 组件包裹</li><li>每种数据变化都需要编写事件处理函数</li><li>不支持 value 只读的表单元素，如 <code>&lt;input type=&quot;file&quot; /&gt;</code> 的 value 由用户设置</li></ul></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">MyInput</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> [username, setUsername] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> handleChange = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">setUsername</span>(e.<span class="property">target</span>.<span class="property">value</span>);</span><br><span class="line">    &#125;, []);</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&#123;username&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;handleChange&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>非受控组件<ul><li>表单数据交由 DOM 节点处理</li><li>使用 ref 从 DOM 节点获取表单数据</li><li>表单元素无需被 React 组件包裹</li><li>只关心业务需要的数据变化，减少代码量</li><li>集成 React 和非 React 代码，不推荐使用</li></ul></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">MyInput</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;defaultName&#125; = props;</span><br><span class="line">    <span class="keyword">const</span> inputRef = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line">    <span class="keyword">const</span> handleChange = <span class="title function_">useCallback</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(inputRef.<span class="property">current</span>.<span class="property">value</span>);</span><br><span class="line">        e.<span class="property">preventDefault</span>;</span><br><span class="line">    &#125;, []);</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">defaultValue</span>=<span class="string">&#123;defaultName&#125;</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;handleChange&#125;/</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="什么是高阶组件"><a href="#什么是高阶组件" class="headerlink" title="什么是高阶组件"></a>什么是高阶组件</h2><ul><li>高阶组件（Higher-Order Components，HoC）是<em>参数为组件</em>，<em>返回值为新组件</em>的函数，某种角度上就是高阶函数</li><li>高阶组件是 React 中复用组件逻辑的一种高级技巧</li><li>高阶组件不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式</li></ul><h2 id="什么是-Pure-Component"><a href="#什么是-Pure-Component" class="headerlink" title="什么是 Pure Component"></a>什么是 Pure Component</h2><p><code>React.PureComponent</code> 与 <code>React.Component</code> 相似，区别是 <code>React.PureComponent</code> 并未直接实现 <code>shouldComponentUpdate</code>，它是以浅层对比 prop 和 state 方式实现了 <code>shouldComponentUpdate</code>：<code>React.PureComponent</code> 无法检查对象的深层差别， prop 和 state 使用深层数据结构时，调用 <code>forceUpdate()</code> 来确保组件正确更新，使用 immutable 对象 加速嵌套数据的比较。</p><h2 id="展示组件和容器组件的区别"><a href="#展示组件和容器组件的区别" class="headerlink" title="展示组件和容器组件的区别"></a>展示组件和容器组件的区别</h2><p>React 组件按照用途可以分为展示组件和容器组件。<br>React 推荐所有新组件，无论是展示组件，还是容器组件，都采用函数组件 + Hook 方式编写</p><ul><li>展示组件<ul><li>关心页面 UI，有自己的 HTML 标签和样式</li><li>如果有状态，仅与 UI 相关。与其他组件、store 无关</li><li>不关心数据源，通过 props 获取数据，并执行回调</li></ul></li><li>容器组件<ul><li>关心功能实现，无自己的 HTML 标签和样式</li><li>有状态。包含请求数据源等副作用。状态提升时，维护多个子组件的状态</li><li>可以由第三方库生成，如 react-redux 的 <code>connect()</code> 和 Relay 的 <code>createFragmentContainer</code></li></ul></li></ul><p>React 分离展示组件和容器组件的优势：</p><ul><li>关注点分离，便于维护</li><li>提高展示组件的复用度，便于调整 UI</li><li>便于通过如 <code>this.props.children</code> 传递组件本身，减少相同 props 层层传递</li></ul><h2 id="如何劫持-React-组件提高组件复用度"><a href="#如何劫持-React-组件提高组件复用度" class="headerlink" title="如何劫持 React 组件提高组件复用度"></a>如何劫持 React 组件提高组件复用度</h2><p>劫持 React 组件又被称为<em>渲染劫持</em>，即将已有组件包装，注入新属性和功能，输出高阶组件，来实现组件复用。<br>劫持需要遵守高阶组件的约定：</p><ul><li>不要改变原始组件，仅组合组件</li><li>保持组件的接口与已有组件相似，透传与自身无关的 props 给已有组件</li><li>最大化可组合性，确保函数签名类型一致，输入函数，返回函数，输入组件，返回组件</li><li>包装显示名称便于调试，如 <code>withSubscription(CommentList)</code></li></ul><h2 id="如何设计一个-React-组件"><a href="#如何设计一个-React-组件" class="headerlink" title="如何设计一个 React 组件"></a>如何设计一个 React 组件</h2><ul><li>将设计好的 UI 划分为组件层级<ul><li>根据单一功能原则分离 UI 与数据源的结构一一对应</li><li>明确组件的包含关系</li></ul></li><li>用 React 创建一个静态版本<ul><li>将静态数据通过 props 父组件到子组件单向传递</li><li>构建应用<ul><li>简单应用，自上而下，从高层组件到低层组件构建</li><li>大型应用，自下而上，从低层组件到高层组件构建，同时为低层组件编写测试</li></ul></li></ul></li><li>确定 UI state 的最小（且完整）表示<ul><li>排除通过 props 传递来的数据</li><li>排除不随时间变化的数据</li><li>排除可以由其他 state 或 props 计算得出的数据</li></ul></li><li>确定 state 放置位置<ul><li>找出根据 state 渲染的所有组件</li><li>找出这些组件的共同上级组件</li><li>state 应该放置在共同上级组件或者更高层级的组件中</li></ul></li><li>添加反向数据流<ul><li>state 只能由拥有它们的组件更改</li><li>在该组件添加修改 state 的回调函数</li><li>将该回调函数通过 props 传递给子组件，在子组件中，如事件处理函数中调用</li></ul></li></ul><h2 id="React-组件与-Web-Components-共存的最佳实践"><a href="#React-组件与-Web-Components-共存的最佳实践" class="headerlink" title="React 组件与 Web Components 共存的最佳实践"></a>React 组件与 Web Components 共存的最佳实践</h2><ul><li>访问 Web Components 的命令式 API：使用 ref 与 DOM 节点进行交互</li><li>引入第三方 Web Components：编写 React 组件包装该 Web Components</li><li>Web Components 触发事件：React 组件中手动添加事件处理器来处理事件</li></ul><h2 id="React-Suspence-组件和-React-lazy-函数有什么作用？"><a href="#React-Suspence-组件和-React-lazy-函数有什么作用？" class="headerlink" title="React.Suspence 组件和 React.lazy 函数有什么作用？"></a>React.Suspence 组件和 React.lazy 函数有什么作用？</h2><p>React.Suspense 可以指定加载指示器，以防其组件树中的某些子组件尚未具备渲染条件。它的 fallback 属性接受任何在组件加载过程中你想展示的 React 元素（通常为 loading 指示器）。</p><p>React.lazy 函数能让你像渲染常规组件一样处理动态引入的组件，即懒加载。React.lazy 接受一个函数，这个函数需要动态调用 import()。它必须返回一个 Promise，该 Promise 需要 resolve 一个 default export 的 React 组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该组件是动态加载的</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">OtherComponent</span> = <span class="title class_">React</span>.<span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./OtherComponent&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// 显示 &lt;Spinner&gt; 组件直至 OtherComponent 加载完成</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">React.Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">Spinner</span> /&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">OtherComponent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">React.Suspense</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React.Suspense 组件和 React.lazy 函数通常配合使用来实现动态引入（懒加载）和优雅降级（loading 指示器）。</p><h2 id="当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用哪个API？"><a href="#当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用哪个API？" class="headerlink" title="当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用哪个API？"></a>当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用哪个API？</h2><p><code>static getDerivedStateFromError(error)</code><br><code>componentDidCatch(error, info)</code></p><p><code>static getDerivedStateFromError()</code> 此生命周期会在后代组件抛出错误后被调用。 它将抛出的错误作为参数，并返回一个值以更新 state 来处理降级渲染。</p><p><code>componentDidCatch()</code> 此生命周期在后代组件抛出错误后被调用。 它接收两个参数：error —— 抛出的错误。info —— 带有 componentStack key 的对象，其中包含有关组件引发错误的栈信息。它应该用于记录错误之类的情况。</p><p>Error boundaries 是 React 提供的用来处理错误的方案。Error boundaries 是 React 组件，它会在其子组件树中的任何位置捕获 JavaScript 错误，并记录这些错误，展示降级 UI 而不是崩溃的组件树。Error boundaries 组件会捕获在渲染期间，在生命周期方法以及其整个树的构造函数中发生的错误。如果 class 组件定义了生命周期方法 <code>static getDerivedStateFromError()</code> 或 <code>componentDidCatch()</code> 中的任何一个（或两者），它就成为了 Error boundaries。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getDerivedStateFromError</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 更新 state 使下一次渲染可以显降级 UI</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">hasError</span>) &#123;</span><br><span class="line">      <span class="comment">// 你可以渲染任何自定义的降级  UI</span></span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Something went wrong.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">children</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么列表中需要有不重复的key，如果有重复的-key-更新时会发生什么？"><a href="#为什么列表中需要有不重复的key，如果有重复的-key-更新时会发生什么？" class="headerlink" title="为什么列表中需要有不重复的key，如果有重复的 key 更新时会发生什么？"></a>为什么列表中需要有不重复的key，如果有重复的 key 更新时会发生什么？</h2><p>在一个组件中渲染列表时，需要给每个列表元素分配一个 key 属性，key 帮助 React 识别哪些元素改变了，比如被添加或删除。不指定显式的 key 值时，React 将默认使用索引作为列表项目的 key 值。</p><p>当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个 mutation。当从头部插入式，React 无法意识到是从头部插入，而是会逐个更新，这会带来性能问题。新增 key 之后，使得更新的效率提高了。</p><h2 id="React-性能优化方案"><a href="#React-性能优化方案" class="headerlink" title="React 性能优化方案"></a>React 性能优化方案</h2><ol><li>使用生产版本 React</li><li>使用 TerserPlugin 来对代码进行压缩</li><li>使用开发者工具中的分析器对组件进行分析</li><li>虚拟化长列表</li><li>避免调停，通过覆盖生命周期方法 shouldComponentUpdate 来进行提速</li><li>使用 React.PureComponent 对煎蛋 props 和 state 进行浅比较</li><li>使用不可变对象，例如使用 <code>Object.assign</code> 来更新对象</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对比Angular和React</title>
      <link href="/blog/2022/11/24/React-%E5%AF%B9%E6%AF%94Angular%E5%92%8CReact/"/>
      <url>/blog/2022/11/24/React-%E5%AF%B9%E6%AF%94Angular%E5%92%8CReact/</url>
      
        <content type="html"><![CDATA[<ul><li>核心功能<ul><li>React 核心库只提供构建 UI 组件的方法，其他功能通过社区提供</li><li>Angular 集成了 路由、异步请求、表单、模块化 CSS 等功能</li></ul></li><li>组件<ul><li>React 组件推荐使用 JSX，可以一个文件包含 HTML、CSS 和 JS，也可以分开</li><li>Angular 组件 HTML、CSS 和 TS 分别是一个文件</li></ul></li><li>DOM<ul><li>React 基于 Virtual DOM，组件会被编译成 JS 对象，数据更改时通过 Diff 算法更新</li><li>Angular 基于 Incremental DOM，组件会被编译成指令，数据更改时就地更新。没有使用规定指令的组件可以被 Tree Shaking</li></ul></li><li>数据绑定<ul><li>React 单向数据绑定，声明状态，更新视图</li><li>Angular 双向数据绑定，数据改变，更新视图</li></ul></li><li>全局状态管理<ul><li>React 可以用全局对象或 Redux 实现</li><li>Angualr 可以用 Service 依赖注入实现</li></ul></li><li>上手成本<ul><li>React 推荐了解 JSX，可以作为库函数渐进式使用</li><li>Angluar 需要了解 TypeScript，Rxjs，OOP 和装饰器等，推荐作为web应用的基础框架独立使用</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对比Vue和React</title>
      <link href="/blog/2022/11/24/React-%E5%AF%B9%E6%AF%94Vue%E5%92%8CReact/"/>
      <url>/blog/2022/11/24/React-%E5%AF%B9%E6%AF%94Vue%E5%92%8CReact/</url>
      
        <content type="html"><![CDATA[<p>Vue3 和 React16.8 引入了较大的变更，所以 Vue 和 React 的对比一般指 Vue2 和 React16.7 的对比。</p><p>相同点</p><ul><li>使用 Virtual DOM</li><li>提供了响应式（Reactive）和组件化（Composable）的视图组件</li><li>核心库与路由（react-router、vue-router）和状态管理（redux、vuex）分离</li><li>支持 JSX，移动端都支持原生渲染</li><li>提供了命令行工具（create-react-app、vue-cli）</li><li>提供了跨端解决方案（React Native、weex）</li></ul><p>不同点</p><ul><li>预编译<ul><li>React 可以通过 Prepack 优化 JavaScript 源代码，在编译时执行原本在运行时的计算过程，通过简单的赋值序列提高 JavaScript 代码的执行效率，消除中间计算过程及分配对象操作。缓存 JavaScript 解析结果，优化效果最佳</li><li>Vue 可以静态分析 template，构造 AST 树，通过 PatchFlags 标记节点变化类型</li></ul></li><li>渲染<ul><li>React<ul><li>通过 shouldComponentUpdate / setState，使用 PureCompoent 等对比前后状态和属性，手动决定是否渲染来优化</li><li>推荐 jsx 语法，可扩展性好，可以渐进式应用</li><li>CSS in JS</li></ul></li><li>Vue<ul><li>推荐 template 语法，自动追踪组件依赖，精确渲染状态改变的组件</li><li>支持并且默认单文件组件，样式仍旧是 CSS 语法，迁移方便</li></ul></li></ul></li><li>事件处理<ul><li>React<ul><li>事件委托到 document，之后委托到 根节点</li><li>所有事件被合并为合成事件并兼容不同浏览器</li><li>事件处理函数中的 this 需要手动绑定或使用箭头函数声明</li></ul></li><li>Vue<ul><li>支持原生事件</li><li>this 自动绑定执行上下文</li></ul></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS Object 对象</title>
      <link href="/blog/2022/11/23/JS-Object-%E5%AF%B9%E8%B1%A1/"/>
      <url>/blog/2022/11/23/JS-Object-%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>Object 是 JavaScript 的一种 数据类型 。它用于存储各种键值集合和更复杂的实体。Objects 可以通过 <code>Object()</code> 构造函数或者使用 对象字面量 的方式创建。在 JavaScript 中，几乎所有的对象都是 Object 类型的实例，它们都会从 <code>Object.prototype</code> 继承属性和方法，虽然大部分属性都会被覆盖（shadowed）或者说被重写了（overridden）。</p><span id="more"></span><h2 id="Object-的属性-amp-方法"><a href="#Object-的属性-amp-方法" class="headerlink" title="Object 的属性&amp;方法"></a>Object 的属性&amp;方法</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li><code>Object.prototype.constructor</code>: 返回对象的构造函数（用于创建实例对象）。</li><li><del><code>Object.prototype.__proto__</code></del>: 访问器属性，暴露了通过它访问的对象的内部 <code>[[Prototype]]</code> ，。非标准属性，不推荐使用。使用 <code>Object.getPrototypeOf()</code> 和 <code>Object.setPrototypeOf()</code> 来替代。</li></ul><h3 id="原型方法（实例方法）"><a href="#原型方法（实例方法）" class="headerlink" title="原型方法（实例方法）"></a>原型方法（实例方法）</h3><ul><li><code>Object.prototype.isPrototypeOf(obj)</code>: 测试一个对象是否存在于另一个对象的原型链上。</li><li><p><code>Object.prototype.propertyIsEnumerable(prop)</code>: 判断对象的属性是否可枚举。与 <code>Object.getOwnPropertyDescriptor(obj, prop).enumerable</code> 相同。</p></li><li><p><code>Object.prototype.toLocaleString()</code>: 返回一个该对象的特定语言环境的字符串表示。</p></li><li><code>Object.prototype.toString()</code>: 返回一个表示该对象的字符串。</li><li><code>Object.prototype.valueOf()</code>: 将 this 值转换为一个对象并返回。此方法旨在用于自定义类型转换的逻辑时，重写派生类对象。</li></ul><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><h4 id="属性与属性操作符"><a href="#属性与属性操作符" class="headerlink" title="属性与属性操作符"></a>属性与属性操作符</h4><ul><li><code>Object.defineProperties(obj, props)</code>: 在一个对象上定义多个新的属性或修改现有属性，并返回该对象。</li><li><code>Object.defineProperty(obj, prop, descriptor)</code>: 在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回该对象。</li><li><code>Object.getOwnPropertyDescriptor(obj, prop)</code>: 返回指定对象上一个自有属性对应的属性描述符。</li><li><code>Object.getOwnPropertyDescriptors(obj)</code>: 返回一个对象的所有自有属性的属性描述符。</li><li><code>Object.getOwnPropertyNames(obj)</code>: 返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括 Symbol 值作为名称的属性）组成的数组。</li><li><code>Object.getOwnPropertySymbols(obj)</code>: 返回一个给定对象自身的所有 Symbol 属性的数组。</li></ul><h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><ul><li><code>Object.getPrototypeOf()</code>: 返回指定对象的原型（内部 <code>[[Prototype]]</code> 属性的值）。</li><li><code>Object.setPrototypeOf()</code>: 设置一个指定对象的原型。</li></ul><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><ul><li><code>Object.entries(obj)</code>: 返回一个给定对象<em>自身</em>可枚举属性的键值对数组，其排列与使用 <code>for...in</code> 循环遍历该对象时返回的顺序一致（区别在于 <code>for-in</code> 循环还会枚举原型链中的属性）。</li><li><code>Object.keys(obj)</code>: 返回一个给定对象<em>自身</em>所有可枚举属性组成的数组，数组中属性的顺序与使用 <code>for...in</code> 循环的顺序一致。</li><li><code>Object.values(obj)</code>: 返回一个给定对象<em>自身</em>所有可枚举值的数组，数组中值的顺序与使用 <code>for...in</code> 循环的顺序相同（区别在于 for-in 循环枚举原型链中的属性）。</li><li><code>Object.fromEntries(iterable)</code>: 把键值对列表（例如Array 、 Map 或者其它实现了可迭代协议的可迭代对象）转换为一个对象，返回该对象。<code>Object.fromEntries(iterable)</code> 与 <code>Object.entries(obj)</code> 互逆。</li></ul><h4 id="操作对象"><a href="#操作对象" class="headerlink" title="操作对象"></a>操作对象</h4><ul><li><code>Object.create(proto[, propertiesObject])</code>: 创建一个新对象，使用现有的对象来作为新创建对象的原型。在实践中，以 <code>null</code> 为原型的对象通常用于作为数据类型 <code>map</code> 的替代。</li><li><code>Object.freeze(obj)</code>: 冻结一个对象，使一个对象不能被修改，返回该对象。不能被修改包括不能添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性和值。冻结后该对象的原型也不能被修改。</li><li><code>Object.seal(obj)</code>: 封闭一个对象，对象不能添加新属性并将所有现有属性标记为不可配置的。</li><li><code>Object.preventExtensions(obj)</code>: 让一个对象变的不可扩展，也就是不能再添加新的属性。</li><li><code>Object.assign(target, ...sources)</code>: 将所有可枚举（<code>Object.prototype.propertyIsEnumerable()</code> 返回 true）的自有（<code>Object.prototype.hasOwnProperty()</code> 返回 true）属性从一个或多个源对象复制到目标对象，返回修改后的对象。</li></ul><h4 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h4><ul><li><code>Object.hasOwn(obj, prop)</code>: 用来判断一个属性是否是对象的自有属性。同 <code>Object.prototype.hasOwnProperty()</code> 类似。</li><li><code>Object.is(value1, value2)</code>: 判断两个值是否相同。几乎与 <code>===</code> 相同，差别是它们对待有符号的零和 NaN 不同，<code>Object.is()</code> 将数字 -0 和 +0 视为不同的，而将 <code>Number.NaN</code> 与 <code>NaN</code> 视为相同的。</li><li><code>Object.isExtensible(obj)</code>: 判断一个对象是否是可扩展的，也即是否可以在它上面添加新的属性。</li><li><code>Object.isFrozen(obj)</code>: 判断一个对象是否被冻结，也即是否完全不能被修改。</li><li><code>Object.isSealed(obj)</code>: 判断一个对象是否被封闭，也即对象不能添加新属性并且所有现有属性都是不可配置的。</li></ul><h2 id="Object-prototype-isPrototypeOf-与-instanceof-运算符的区别"><a href="#Object-prototype-isPrototypeOf-与-instanceof-运算符的区别" class="headerlink" title="Object.prototype.isPrototypeOf() 与 instanceof 运算符的区别"></a><code>Object.prototype.isPrototypeOf()</code> 与 <code>instanceof</code> 运算符的区别</h2><p><code>isPrototypeOf()</code> 与 <code>instanceof</code> 运算符不同。在表达式 <code>object instanceof AFunction</code> 中，object 的原型链是针对 <code>AFunction.prototype</code> 进行检查的，而不是针对 <code>AFunction</code> 本身。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> <span class="title function_">x</span>();</span><br><span class="line">y <span class="keyword">instanceof</span> x; <span class="comment">// true</span></span><br><span class="line">(x.<span class="property"><span class="keyword">prototype</span></span>).<span class="title function_">isPrototypeOf</span>(y); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="Function-prototype-prototype-与-Object-prototype-proto-的区别"><a href="#Function-prototype-prototype-与-Object-prototype-proto-的区别" class="headerlink" title="Function.prototype.prototype 与 Object.prototype.__proto__ 的区别"></a><code>Function.prototype.prototype</code> 与 <code>Object.prototype.__proto__</code> 的区别</h2><ol><li><code>prototype</code> 是函数实例的属性，<code>__proto__</code> 是对象实例的属性。</li><li><code>prototype</code> 是标准的属性，<code>__proto__</code> 是非标准的属性但现代浏览器一般已实现。</li><li><code>obj.__proto__ === obj.constructor.prototype</code> ， <code>__proto__</code> 为构造函数的原型</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> object </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS Function 函数</title>
      <link href="/blog/2022/11/22/JS-Function-%E5%87%BD%E6%95%B0/"/>
      <url>/blog/2022/11/22/JS-Function-%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>在 js 中每个 JavaScript 函数实际上都是一个 Function 对象。</p><span id="more"></span><h2 id="Function-的属性-amp-方法"><a href="#Function-的属性-amp-方法" class="headerlink" title="Function 的属性&amp;方法"></a>Function 的属性&amp;方法</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li><code>Function.prototype.name</code>: 返回函数实例的名称。</li><li><code>Function.prototype.length</code>: 返回函数实例的形参个数。</li><li><code>Function.prototype.prototype</code>: 返回将函数作为构造函数时创建的实例对象的原型，即 <code>new</code> 操作符创建的实例对象的原型。</li><li><del><code>Function.prototype.arguments</code></del>: 返回传入函数的实参，它是一个类数组对象。该属性是 <em>废弃的</em>，不推荐使用，可以使用函数内部可用的 <code>arguments</code> 对象来访问函数的实参。</li><li><del><code>Function.prototype.caller</code></del>: 返回调用指定函数的函数。该属性是 <em>非标准的</em>，不推荐使用。可以使用 <code>arguments.callee.caller</code> 替代。</li><li><del><code>Function.prototype.displayName</code></del>: 返回函数的显示名称。该属性是 <em>非标准的</em>，不推荐使用。</li></ul><h3 id="原型方法（实例方法）"><a href="#原型方法（实例方法）" class="headerlink" title="原型方法（实例方法）"></a>原型方法（实例方法）</h3><ul><li><code>Function.prototype.apply(thisArg, argsArray)</code>: 调用一个具有给定 <code>this</code> 值的函数，以及以一个数组（或一个类数组对象）的形式提供的参数。</li><li><code>Function.prototype.bind(thisArg[, arg1[, arg2[, ...argN]]])</code>: 创建一个新的函数，在 <code>bind()</code> 被调用时，这个新函数的 <code>this</code> 被指定为 <code>bind()</code> 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</li><li><code>Function.prototype.call(thisArg[, arg1[, arg2[, ...argN]]])</code>: 使用一个指定的 <code>this</code> 值和单独给出的一个或多个参数来调用一个函数。</li><li><code>Function.prototype.toString()</code>: 返回一个表示当前函数源代码的字符串。</li></ul><h2 id="Function-构造函数与函数声明之间的不同"><a href="#Function-构造函数与函数声明之间的不同" class="headerlink" title="Function 构造函数与函数声明之间的不同"></a>Function 构造函数与函数声明之间的不同</h2><p>由 <code>Function</code> 构造函数创建的函数不会创建当前环境的闭包，它们总是被创建于全局环境，因此在运行时它们只能访问全局变量和自己的局部变量，不能访问它们被 Function 构造函数创建时所在的作用域的变量。这一点与使用 <code>eval()</code> 执行创建函数的代码不同。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> function </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS String 字符串</title>
      <link href="/blog/2022/11/22/JS-String-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/blog/2022/11/22/JS-String-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>在 js 中 String 对象是基本数据类型 string （称为 字符串 或 字符串字面量 或 模板字面量）的包装对象，称为字符串对象。String 对象提供了许多操作字符串相关的方法。</p><span id="more"></span><h2 id="String-的属性-amp-方法"><a href="#String-的属性-amp-方法" class="headerlink" title="String 的属性&amp;方法"></a>String 的属性&amp;方法</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li><code>String.prototype.length</code>: 只读属性，返回 String 的长度。</li></ul><h3 id="原型方法（实例方法）"><a href="#原型方法（实例方法）" class="headerlink" title="原型方法（实例方法）"></a>原型方法（实例方法）</h3><h4 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h4><ul><li><code>String.prototype.concat(str1[, str2[, ...[, strN]]]])</code>: 在原字符串之后连接一个或多个其他字符串，返回新的字符串。</li><li><code>String.prototype.repeat(countToRepeat)</code>: 返回一个将原字符串重复输出指定次数的新字符串。</li><li><code>String.prototype.slice(beginIndex[, endIndex])</code>: 提取原字符串的一部分，作为一个新的字符串返回。</li><li><code>String.prototype.split([separator[, limit]])</code>: 使用指定的分隔符将原字符串分割成字符串数组，返回这个字符串数组。</li><li><code>String.prototype.padStart(targetLength[, padString])</code>: 用一个字符串填充当前字符串（如果需要的话则重复填充），返回填充后达到指定长度的新字符串。从当前字符串的左侧开始填充。</li><li><code>String.prototype.padEnd(targetLength[, padString])</code>: 用一个字符串填充当前字符串（如果需要的话则重复填充），返回填充后达到指定长度的新字符串。从当前字符串的末尾（右侧）开始填充。</li><li><code>String.prototype.replace(regexp|substr, newSubStr|function)</code>: 返回一个将原字符串由替换值（replacement）替换部分或所有的模式（pattern）匹配项后的新字符串。</li><li><code>String.prototype.replaceAll(regexp|substr, newSubStr|function)</code>: 返回一个新字符串，新字符串将原字符串所有满足模式（pattern）的部分都已被替换值（replacement）替换。</li><li><code>String.prototype.toLowerCase()</code>: 将字符串中的所有字符转换为小写形式，并返回新的字符串（如果调用该方法的值不是字符串类型会被强制转换）。</li><li><code>String.prototype.toUpperCase()</code>: 将字符串中的所有字符转换为大写形式，并返回新的字符串（如果调用该方法的值不是字符串类型会被强制转换）。</li><li><code>String.prototype.trim()</code>: 将字符串两端的空白字符（空格、tab以及所有行终止符字符如 LF、CR 等）清除，返回新的字符串。</li><li><code>String.prototype.trimStart()</code>: 返回删除字符串开头的空白字符的新字符串，别名为 <code>trimLeft()</code>。</li><li><code>String.prototype.trimEnd()</code>: 返回删除字符串末尾的空白字符的新字符串，别名为 <code>trimRight()</code>。</li><li><code>String.prototype.substring(beginIndex[, endIndex])</code>: 返回字符串在开始索引到结束索引之间的一个子集，或从开始索引直到字符串的末尾的一个子集。</li><li><del><code>String.prototype.substr(beginIndex[, length])</code></del>: 返回一个字符串中从指定位置开始到指定字符数的字符，该方法是 <em>废弃的</em>，不推荐使用，可以使用 <code>substring()</code> 替代。</li><li><code>String.prototype.normalize([form])</code>: 按照指定的一种 Unicode 正规形式将当前字符串规范化。（如果该值不是字符串，则首先将其转换为一个字符串）。</li></ul><h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><ul><li><code>String.prototype.indexOf(searchString[, fromIndex])</code>: 给定一个要搜索的子字符串，从前往后搜索整个字符串，并返回指定子字符串第一次出现的索引。若给定第二个参数 fromIndex，该方法将返回指定子字符串在 fromIndex 之后第一次出现的索引。没有找到则返回 -1。</li><li><code>String.prototype.lastIndexOf(searchString[, fromIndex])</code>: 给定一个要搜索的子字符串，从后往前搜索整个字符串，并返回指定子字符串第一次出现的索引。若给定第二个参数 fromIndex，该方法将返回指定子字符串在 fromIndex 之前第一次出现的索引。没有找到则返回 -1。</li><li><code>String.prototype.match(regexp)</code>: 检索返回一个字符串匹配正则表达式的结果。</li><li><code>String.prototype.matchAll(regexp)</code>: 返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器。</li><li><code>String.prototype.search(search)</code>: 执行正则表达式和字符串之间的一个搜索匹配，返回第一个匹配位置的索引。</li></ul><h4 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h4><ul><li><code>String.prototype.startsWith(searchString[, fromIndex])</code>: 用来判断当前字符串是否以另外一个给定的子字符串开头。</li><li><code>String.prototype.endsWith(searchString[, fromIndex])</code>: 用来判断当前字符串是否是以另外一个给定的子字符串结尾。</li><li><code>String.prototype.includes(searchString[, fromIndex])</code>: 执行区分大小写的搜索，以确定字符串中是否可以找到要搜索的子字符串。</li></ul><h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><ul><li><code>String.prototype.at(index)</code>: 接受一个整数值，并返回一个新的字符串，该字符串由位于指定偏移量处的单个 UTF-16 码元组成。该方法允许正整数和负整数。负整数从字符串中的最后一个字符开始倒数。</li><li><code>String.prototype.charAt(index)</code>: 接受一个介于 0 和字符串长度减 1 之间的整数，并返回一个新的字符串。</li><li><code>String.prototype.charCodeAt(index)</code>: 返回 0 到 65535 之间的整数，表示给定索引处的 UTF-16 编码单元表示的 Unicode 码点，如果 Unicode 码点不能用一个 UTF-16 编码单元表示（因为它的值大于0xFFFF），则所返回的编码单元会是这个码点代理对的第一个编码单元。</li><li><code>String.prototype.codePointAt(index)</code>: 返回 一个 Unicode 编码点值的非负整数。</li><li><code>String.prototype.valueOf()</code>: 返回字符串的原始值。</li><li><code>String.prototype.toString()</code>: 返回一个字符串来表示这个对象，和 <code>String.prototype.valueOf()</code> 方法的返回值相同。</li></ul><h4 id="特定语言环境"><a href="#特定语言环境" class="headerlink" title="特定语言环境"></a>特定语言环境</h4><ul><li><code>String.prototype.localeCompare(compareString[, locales[, options]])</code>: 返回一个数字来指示一个参考字符串是否在排序顺序前面或之后或与给定字符串位置相同。</li><li><code>String.prototype.toLocaleLowerCase([locale1[, locale2[, ...[, localeN]]]])</code>: 根据任何指定区域语言环境设置的大小写映射，返回字符串被转换为小写的格式。</li><li><code>String.prototype.toLocaleUpperCase([locale1[, locale2[, ...[, localeN]]]])</code>: 根据任何指定区域语言环境设置的大小写映射，返回字符串被转换为大写的格式。</li></ul><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><ul><li><code>String.fromCharCode(num1[, ...[, numN]])</code>: 返回由指定的 UTF-16 代码单元序列创建的字符串。</li><li><code>String.fromCodePoint(num1[, ...[, numN]])</code>: 返回使用指定的代码点序列创建的字符串。</li><li><code>String.raw(callSite, ...substitutions)</code>: 用来获取一个模板字符串的原始字符串。可以通过：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">String</span>.<span class="property">raw</span><span class="string">`templateString`</span></span><br></pre></td></tr></table></figure>调用。</li></ul><h2 id="字符串字面量-和-字符串对象-的区别"><a href="#字符串字面量-和-字符串对象-的区别" class="headerlink" title="字符串字面量 和 字符串对象 的区别"></a>字符串字面量 和 字符串对象 的区别</h2><p>字符串字面量 (通过单引号或双引号定义) 和 直接调用 String 方法 (没有通过 new 生成字符串对象实例) 的字符串都是基本字符串。JavaScript 会自动将基本字符串转换为字符串对象，只有将基本字符串转化为字符串对象之后才可以使用字符串对象的方法。当基本字符串需要调用一个字符串对象才有的方法或者查询值的时候 (基本字符串是没有这些方法的)，JavaScript 会自动将基本字符串转化为字符串对象并且调用相应的方法或者执行查询。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="string">&#x27;字符串&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> y = <span class="title class_">String</span>(<span class="string">&#x27;字符串&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> z = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;字符串&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x === y); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x === z); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="部分中英文翻译对照参考"><a href="#部分中英文翻译对照参考" class="headerlink" title="部分中英文翻译对照参考"></a>部分中英文翻译对照参考</h2><p>字符串基本类型（string primitives）<br>字符串字面量（string literals）<br>字符串对象（string objects）<br>模板字面量（template literals）</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Monorepo</title>
      <link href="/blog/2022/11/16/CS-Monorepo/"/>
      <url>/blog/2022/11/16/CS-Monorepo/</url>
      
        <content type="html"><![CDATA[<p>Monorepo（Monolithic repositorie）是一种将多个项目存放在同一个代码仓库中的开发策略。传统的开发流程中，一个项目使用一个代码仓库，然而一个产品可能需要多个项目来支持，多个项目之间互相依赖，依赖关系、编译顺序、版本管理、发布顺序互相不明朗，多个项目可能存在重复的部分（例如，前后端接口定义，protobuf），由于不在一个代码仓库中，维护起来十分不方便。Monorepo 的核心观点是所有的项目在一个代码仓库中，使用一套编译脚本来处理互相之间的依赖关系，但大部分人实际仍旧在少数的几个仓库内文件夹工作。</p><span id="more"></span><h2 id="Monorepo-优势"><a href="#Monorepo-优势" class="headerlink" title="Monorepo 优势"></a>Monorepo 优势</h2><ul><li><p>可见性（Visibility）：每个人都可以看到其他人的代码，这样可以带来更好的协作和跨团队贡献——不同团队的开发人员都可以修复代码中的 bug，而你甚至都不知道这个 bug 的存在。</p></li><li><p>更简单的依赖关系管理（Simpler dependency management）：共享依赖关系很简单，因为所有模块都托管在同一个存储库中，因此都不需要包管理器。</p></li><li><p>唯一依赖源（Single source of truth）：每个依赖只有一个版本，意味着没有版本冲突，没有依赖地狱。</p></li><li><p>一致性（Consistency）：当你把所有代码库放在一个地方时，执行代码质量标准和统一的风格会更容易。</p></li><li><p>共享时间线（Shared timeline）：API 或共享库的变更会立即被暴露出来，迫使不同团队提前沟通合作，每个人都得努力跟上变化。</p></li><li><p>原子提交（Atomic commits）：原子提交使大规模重构更容易，开发人员可以在一次提交中更新多个包或项目。</p></li><li><p>隐式 CI（Implicit CI）：因为所有代码已经统一维护在一个地方，因此可以保证持续集成[3]。</p></li><li><p>统一的 CI/CD（Unified CI/CD）：可以为代码库中的每个项目使用相同的 CI/CD[4]部署流程。</p></li><li><p>统一的构建流程（Unified build process）：代码库中的每个应用程序可以共享一致的构建流程。</p></li></ul><h2 id="Monorepo-缺点"><a href="#Monorepo-缺点" class="headerlink" title="Monorepo 缺点"></a>Monorepo 缺点</h2><ul><li><p>性能差（Bad performance）：单一代码库难以扩大规模，像 <code>git blame</code> 这样的命令可能会不合理的花费很长时间执行，IDE 也开始变得缓慢，生产力受到影响，对每个提交测试整个 repo 变得不可行。</p></li><li><p>破坏主线（Broken main/master）：主线损坏会影响到在单一代码库中工作的每个人，这既可以被看作是灾难，也可以看作是保证测试既可以保持简洁又可以跟上开发的好机会。</p></li><li><p>学习曲线（Learning curve）：如果代码库包含了许多紧密耦合的项目，那么新成员的学习曲线会更陡峭。</p></li><li><p>大量的数据（Large volumes of data）：单一代码库每天都要处理大量的数据和提交。</p></li><li><p>所有权（Ownership）：维护文件的所有权更有挑战性，因为像 Git 或 Mercurial 这样的系统没有内置的目录权限。</p></li><li><p>Code reviews：通知可能会变得非常嘈杂。例如，GitHub 有有限的通知设置，不适合大量的 pull request 和 code review。</p></li></ul><h2 id="一些知名的-Monorepo-构建工具"><a href="#一些知名的-Monorepo-构建工具" class="headerlink" title="一些知名的 Monorepo 构建工具"></a>一些知名的 Monorepo 构建工具</h2><p><a href="https://github.com/bazelbuild/bazel">Bazel</a>: 由 Google 发布，部分基于他们自己的构建系统（Blaze）。Bazel 支持多种语言，并支持大规模构建和测试</p><p><a href="https://github.com/facebook/buck">Buck</a>: 由 Facebook 开源的快速构建系统，支持在多种语言和平台上进行不同的构建</p><p><a href="https://github.com/microsoft/rushstack">Rush</a>: Microsoft 用于 JavaScript 的可扩展的单一代码库管理器，能够从一个代码库构建和部署多个包</p><p><a href="https://github.com/lerna/lerna">Lerna</a>: JavaScript 的单一代码库管理器，可以与 React、Angular 或 Babel 等流行框架集成</p><p>Yarn workspace: 用一个命令在多个地方安装和更新 Node.js 的依赖项</p><p><a href="https://github.com/teambit/bit">Bit</a>: 用于可组合软件开发的工具链</p><p><a href="https://github.com/nrwl/nx">Nx</a>: 为 monorepo 设计的小巧快捷可扩展的编译系统</p><p><a href="https://github.com/vercel/turbo">Turbo</a>: 使用 Rust 开发的前端工具链，增量的打包和构建工具</p><p><a href="https://github.com/microsoft/lage">Lage</a>: Microsoft 研发的用于提高 monorepo 构建效率的工具</p><p><a href="https://github.com/folke/ultra-runner">ultra-runner</a>: JavaScript 单一代码库管理脚本，支持 Yarn、pnpm 和 Lerna 插件，支持并行构建</p><p><a href="https://github.com/symplify/monorepo-builder">monorepo-builder</a>: 通过单一代码库安装和更新 PHP 包</p>]]></content>
      
      
      
        <tags>
            
            <tag> monorepo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>富文本编辑器</title>
      <link href="/blog/2022/10/28/FE-%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"/>
      <url>/blog/2022/10/28/FE-%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>富文本编辑器是一种可内嵌于浏览器，所见即所得的文本编辑器。在普通的文本编辑器的基础上，富文本编辑器扩展支持了更多的功能，例如，改变字体字号、支持变粗下划线、支持改变字体颜色背景色等，使得编辑出的文本更像普通的网页一样。</p><span id="more"></span><p>以下列出了比较知名的多款富文本编辑器并列出了 Github 收藏数量及采用的授权协议，供参考：</p><h3 id="Quill-33-9k-BSD3"><a href="#Quill-33-9k-BSD3" class="headerlink" title="Quill 33.9k BSD3"></a>Quill 33.9k BSD3</h3><p>https://github.com/quilljs/quill</p><p>Quill 是一款现代化的所见即所得编辑器，侧重于兼容性和可扩展性。Quill 由 Jason Chen 和 Byron Milligan 开发，由 Slab 提供技术支持。</p><h3 id="Draft-js-22-2k-MIT"><a href="#Draft-js-22-2k-MIT" class="headerlink" title="Draft.js 22.2k MIT"></a>Draft.js 22.2k MIT</h3><p>https://github.com/facebook/draft-js</p><p>Draft.js 是一款基于 React 框架的文本编辑器。由 Facebook(Meta) 提供技术支持，目前处于维护（Maintenance）状态不再接受新的功能，预计于 2022-12-31 日归档不再维护。</p><h3 id="Slate-15-7k-MIT"><a href="#Slate-15-7k-MIT" class="headerlink" title="Slate 15.7k MIT"></a>Slate 15.7k MIT</h3><p>https://github.com/ianstormtaylor/slate</p><p>Slate 是一款可定制的用于构建富文本编辑器的框架。</p><h3 id="Tiptap-16-8k-MIT"><a href="#Tiptap-16-8k-MIT" class="headerlink" title="Tiptap 16.8k MIT"></a>Tiptap 16.8k MIT</h3><p>https://github.com/ueberdosis/tiptap</p><p>Tiptap 是一款无 header 的、不基于特定框架的可扩展的富文本编辑器，基于 ProseMirror。</p><h3 id="wangEditor-14-6k-MIT"><a href="#wangEditor-14-6k-MIT" class="headerlink" title="wangEditor 14.6k MIT"></a>wangEditor 14.6k MIT</h3><p>https://github.com/wangeditor-team/wangEditor</p><p>wangEditor 是一款开源的 Web 富文本编辑器，开箱即用，配置简单。支持 JS Vue React 。</p><h3 id="TinyMCE-12-1k-MIT"><a href="#TinyMCE-12-1k-MIT" class="headerlink" title="TinyMCE 12.1k MIT"></a>TinyMCE 12.1k MIT</h3><p>https://github.com/tinymce/tinymce</p><p>TinyMCE 是一款支持富文本编辑开源 js 库。 支持 React Vue Angular。</p><h3 id="lexical-12k-MIT"><a href="#lexical-12k-MIT" class="headerlink" title="lexical 12k MIT"></a>lexical 12k MIT</h3><p>https://github.com/facebook/lexical</p><p>Lexical 是一款可扩展的文本编辑器框架，提供了优异的可靠性、可访问性和性能。由 Facebook(Meta) 提供技术支持。</p><h3 id="Summernote-10-9k-MIT"><a href="#Summernote-10-9k-MIT" class="headerlink" title="Summernote 10.9k MIT"></a>Summernote 10.9k MIT</h3><p>https://github.com/summernote/summernote</p><p>Summernote是一款超级简单的所见即所得编辑器。</p><h3 id="CKEditor-6-4k-GPL2"><a href="#CKEditor-6-4k-GPL2" class="headerlink" title="CKEditor 6.4k GPL2"></a>CKEditor 6.4k GPL2</h3><p>https://github.com/ckeditor/ckeditor5</p><p>CKEditor 是一款强大的富文本编辑器框架，具有模块化架构、现代集成和协作编辑等功能。支持通过 Webpack 集成。</p><h3 id="ueditor-6-2k-MIT"><a href="#ueditor-6-2k-MIT" class="headerlink" title="ueditor 6.2k MIT"></a>ueditor 6.2k MIT</h3><p>https://github.com/fex-team/ueditor</p><p>UEditor是由百度 web 前端研发部开发的所见即所得富文本web编辑器，具有轻量，可定制，注重用户体验等特点。目前已经不再维护。</p><h3 id="prosemirror-6-2k-MIT"><a href="#prosemirror-6-2k-MIT" class="headerlink" title="prosemirror 6.2k MIT"></a>prosemirror 6.2k MIT</h3><p>https://github.com/ProseMirror/prosemirror</p><p>ProseMirror 是一个基于 <code>contentEditable</code> 的行为良好的富语义内容编辑器，支持协作编辑和自定义文档模式。</p><h3 id="Simditor-5k-MIT"><a href="#Simditor-5k-MIT" class="headerlink" title="Simditor 5k MIT"></a>Simditor 5k MIT</h3><p>https://github.com/mycolorway/simditor</p><p>Simditor 是一款简单和快速的所见即所得编辑器。Simditor 是 <a href="https://tower.im">Tower</a> 的富文本编辑器。</p><h3 id="Froala-Editor-5k-Private"><a href="#Froala-Editor-5k-Private" class="headerlink" title="Froala Editor 5k Private"></a>Froala Editor 5k Private</h3><p>https://github.com/froala/wysiwyg-editor</p><p>Froala 是一款强大的所见即所得 HTML 富文本编辑器。Froala 提供了商业版，需付费使用。支持 Angular React Vue Ember 等多种框架集成。</p><h3 id="Squire-4-4k-MIT"><a href="#Squire-4-4k-MIT" class="headerlink" title="Squire 4.4k MIT"></a>Squire 4.4k MIT</h3><p>https://github.com/neilj/Squire</p><p>Squire 是一款 HTML5 富文本编辑器，轻量（16.5kb），提供了很好的跨浏览器支持。</p><h3 id="KindEditor-1-8k-LGPL-2-1"><a href="#KindEditor-1-8k-LGPL-2-1" class="headerlink" title="KindEditor 1.8k LGPL-2.1"></a>KindEditor 1.8k LGPL-2.1</h3><p>https://github.com/kindsoft/kindeditor</p><p>KindEditor 是一款轻量级、开源的、跨浏览器的、基于 web 的所见即所得 HTML 编辑器。</p><h3 id="Jodit-Editor-1-3k-MIT"><a href="#Jodit-Editor-1-3k-MIT" class="headerlink" title="Jodit Editor 1.3k MIT"></a>Jodit Editor 1.3k MIT</h3><p>https://github.com/xdan/jodit</p><p>Jodit 是一款由纯 Typescript 编写的所见即所得编辑器。</p><h3 id="bootstrap-wysiwyg-647-MIT"><a href="#bootstrap-wysiwyg-647-MIT" class="headerlink" title="bootstrap-wysiwyg 647 MIT"></a>bootstrap-wysiwyg 647 MIT</h3><p>https://github.com/steveathon/bootstrap-wysiwyg</p><p>bootstrap-wysiwyg 是一款小巧的基于 Bootstrap 与 jQuery 的所见即所得富文本编辑器。实现基于浏览器函数 <code>document.execCommand</code>。</p><h3 id="FreeTextBox"><a href="#FreeTextBox" class="headerlink" title="FreeTextBox"></a>FreeTextBox</h3><p>http://www.freetextbox.com/</p><p>FreeTextBox 是一款仅支持 ASP.NET 的文本编辑器。</p>]]></content>
      
      
      
        <tags>
            
            <tag> editor </tag>
            
            <tag> rich-text </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web 访问 Windows 主机(RDP)方案</title>
      <link href="/blog/2022/10/21/FE-web-%E8%AE%BF%E9%97%AE-windows-%E4%B8%BB%E6%9C%BA-RDP-%E6%96%B9%E6%A1%88/"/>
      <url>/blog/2022/10/21/FE-web-%E8%AE%BF%E9%97%AE-windows-%E4%B8%BB%E6%9C%BA-RDP-%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>浏览器支持 HTTP(S) 协议和 Websocket 协议，部分浏览器支持 FTP 协议。通过浏览器无法直接使用 RDP 协议与 Windows 主机相连，需要构建一个 Web 端到目标主机的网关。这个网关，需要承载 RDP 客户端的功能用以连接 RDP 服务器也就是真正的主机，也需要承载 HTTP/Websocket 服务器的功能以同用户的浏览器相连，同时需要将 RDP 协议内容回流给 Web 端以渲染，将 Web 端的指令动作转译为 RDP 参数。</p><span id="more"></span><h2 id="Guacamole"><a href="#Guacamole" class="headerlink" title="Guacamole"></a>Guacamole</h2><p><a href="https://guacamole.apache.org/">Guacamole</a> <code>[ˌɡwækəˈməʊleɪ]</code> 是一个基于 HTML 5 和 JavaScript 的 远程桌面网关，支持 VNC、RDP、SSH 标准协议。目前该项目是 Apache 基金会的孵化项目，采用 Apache-2.0 开源协议。</p><p>Guacamole主要包含以下项目，分别是：</p><ul><li><a href="https://github.com/apache/guacamole-server">apache/guacamole-server</a></li></ul><p>guacamole-server 包括了一系列 Guacamole 最基础的软件包，包括 guacd、libguac 与多个协议支持库。</p><p>guacd 是 Guacamole web 应用程序与框架使用的 Gauacamole 代理守护进程。因为 Javascript 无法处理二进制协议（例如 VNC 和 RDP），一个新的基于文本的协议（Guacamole 协议）被开发来包括一个通用的有效率的远程桌面操作的超集，并且易于被 Javascript 程序访问。guacd 是在任意协议和 Guacamole 协议之间转换的代理。</p><ul><li><a href="https://github.com/apache/guacamole-client">apache/guacamole-client</a></li></ul><p>guacamole-client 包括了一系列的 Guacamole 需要的 基于 Maven 包的项目（Java 版的 web 应用），提供了一个 HTML5 web应用，提供对远程桌面协议桌面的访问。guacamole-client 包含了多个子项目，每个子项目之间互相独立可以独立编译。如果所有子项目均使用 guacamole-client 编译，Maven 将会控制编译顺序。</p><ul><li><a href="https://github.com/apache/guacamole-website">apache/guacamole-website</a></li></ul><p>guacamole-website 包含了 Guacamole 官网的代码，是由 Jekyll 生成的静态网站，包含了 Guacamole 相关的使用文档和更新日志。</p><ul><li><a href="https://github.com/apache/guacamole-manual">apache/guacamole-manual</a></li></ul><p>guacamole-manual 是整个 Guacamole 技术堆栈的基础文档。</p><p><img src="/blog/static/imgs/guacamole.jpeg" alt="guacamole"></p><h3 id="Guacamole-架构"><a href="#Guacamole-架构" class="headerlink" title="Guacamole 架构"></a>Guacamole 架构</h3><p><img src="/blog/static/imgs/guacamole_arch.png" alt="guacamole_inner"></p><p>Guacamole 的主要组成部分：</p><ul><li><p>guacd：远程协议连接网关，由 C/C++ 开发的网关库，目前只有 Linux 版本，因此 guacd 必须部署在 Linux 系统中。</p></li><li><p>guacamole-common（Java API）：这是 Java 实现的与 guacd 通信的 Java API，它基于 Servlet2.5+，是项目集成的主要API，所以它必须在 Servlet 容器中运行，比如 Tomcat，据官方使用的 API 情况，必须使用 Tomcat8.5 以上 Tomcat。</p></li><li><p>guacamole-common-js（JS API）：是 H5 中显示远程桌面连接的API。</p></li><li><p>guacamole（官方网页端和容器实现）：是官方基于 RestAPI 实现的 Web 管理端，包括认证、扩展、前端界面等，基于 Servlet2.5+，必须在 Tomcat8.5+ 等 Servlet 容器中运行。</p></li><li><p>guacamole-common-ext：是官方实现的网页登录认证、连接管理模块，基于 Java RestAPI。</p></li></ul><h3 id="对-RDP-的支持"><a href="#对-RDP-的支持" class="headerlink" title="对 RDP 的支持"></a>对 RDP 的支持</h3><p>libguac-client-rdp 库为 Guacamole 提供了对 RDP 协议的支持，如果构建过程中存在所需的依赖项，则该库将作为 guacamole-server 的一部分安装。</p><p>除了 RDP 特定参数外，Guacamole 还支持：</p><ul><li><a href="https://guacamole.apache.org/doc/gug/configuring-guacamole.html#disable-clipboard">禁用剪切板访问</a></li><li><a href="https://guacamole.apache.org/doc/gug/configuring-guacamole.html#common-sftp">通过SFTP进行文件传输</a></li><li><a href="https://guacamole.apache.org/doc/gug/configuring-guacamole.html#graphical-recording">图形会话录制</a></li><li><a href="https://guacamole.apache.org/doc/gug/configuring-guacamole.html#wake-on-lan">网络唤醒</a></li></ul><h2 id="Myrtille"><a href="#Myrtille" class="headerlink" title="Myrtille"></a>Myrtille</h2><p><a href="https://www.myrtille.io/">Myrtille</a> <code>[mirtij]</code> 通过 Web 浏览器提供对远程桌面、应用程序和 SSH 服务器的简单快速访问，无需任何插件、扩展或配置。Myrtille 基于 C# 开发，采用 Apache-2.0 开源协议。<a href="https://github.com/cedrozor/myrtille">Myrtille 源代码地址</a>。</p><h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><p>用户输入（键盘、鼠标、触摸屏）从 Web 浏览器转发到 HTTP(S) 网关（即 Myrtille），然后转发到 RDP（或 SSH）客户端，该客户端与 RDP（或 SSH）服务器保持会话。操作的显示结果（或不显示）从 RDP（或 SSH）客户端并通过网关流回浏览器。</p><h3 id="性能与资源要求"><a href="#性能与资源要求" class="headerlink" title="性能与资源要求"></a>性能与资源要求</h3><p>Myrtille 支持多个连接/选项卡。除了 RDP（或 SSH）服务器可以处理的（CAL 数量、CPU、RAM）之外，最大并发用户数没有限制。关于 Myrtille 网关，具有 4 GB RAM 的简单双核 CPU 最多可以同时处理 50 个会话（RDP 客户端进程大约占用 50MB RAM，SSH 甚至更少）。一个会话平均使用大约 200 KB/s 的带宽。对于大多数情况，每个用户 1 MB/s 是一个很好的规定。对 Myrtille 来说真正重要的是传出带宽，因为显示更新将占用大部分流量。</p><p>编译需要 Microsoft Visual Studio 2017 或更高版本。从 2.8.0 版本开始，Myrtille 可作为 Docker 映像使用。</p><h2 id="FreeRDP-WebConnect"><a href="#FreeRDP-WebConnect" class="headerlink" title="FreeRDP-WebConnect"></a>FreeRDP-WebConnect</h2><p><a href="https://github.com/FreeRDP/FreeRDP-WebConnect">FreeRDP-WebConnect</a> 是一个可以通过 Web 访问 RDP 会话的网关。FreeRDP-WebConnect 采用了 Websocket 协议与浏览器端进行通信，通过 Canvas 绘制画面，服务器端使用 C++ 编写，提供 HTTPS 服务并通过 FreeRDP 与主机通信。<br>FreeRDP-WebConnect 在 Github 中已被标注为 archived。</p><h3 id="FreeRDP"><a href="#FreeRDP" class="headerlink" title="FreeRDP"></a>FreeRDP</h3><p><a href="https://www.freerdp.com/">FreeRDP</a> 是一个 RDP 协议的开源实现，基于 C 语言，采用 Apache-2.0 开源协议发布。<a href="https://github.com/FreeRDP/FreeRDP">源代码地址</a>。</p><p>Guacamole、Myrtille、FreeRDP-WebConnect 的 RDP 部分均采用 FreeRDP 与主机连接。</p><h2 id="mstsc-js"><a href="#mstsc-js" class="headerlink" title="mstsc.js"></a>mstsc.js</h2><p><a href="https://github.com/citronneur/mstsc.js">Mstsc.js</a> 是一个纯 Javascript Microsoft RDP（远程桌面客户端）客户端，使用了 nodejs、<a href="https://github.com/citronneur/node-rdpjs">node-rdpjs</a> 和 socket.io。它允许用户通过 web 浏览器连接到任何终端服务器兼容的应用程序。mstsc.js 采用 GPL-3.0 协议发布。</p><h2 id="方案对比"><a href="#方案对比" class="headerlink" title="方案对比"></a>方案对比</h2><table><thead><tr><th>-</th><th>Guacamole</th><th>Myrtille</th><th>FreeRDP-WebConnect</th><th>mstsc.js</th><th>FreeRDP</th></tr></thead><tbody><tr><td>支持协议</td><td>VNC,RDP,SSH</td><td>SSH,RDP</td><td>RDP</td><td>RDP</td><td>RDP</td></tr><tr><td>开发语言</td><td>Java</td><td>C#</td><td>C++</td><td>Javascript</td><td>C</td></tr><tr><td>star数量</td><td>2.3k</td><td>1.4k</td><td>463</td><td>645</td><td>7.5k</td></tr><tr><td>最近更新</td><td>6 days ago</td><td>15 months ago</td><td>5 years ago(archived)</td><td>2 years ago</td><td>3 hours ago</td></tr></tbody></table><p>最近更新参考时间 2022-10-24 17:10:00</p><p>Guacamole：功能强大，文档（英文）丰富，社区活跃更新频繁，被多个开源堡垒机采用<br>Myrtille：小众，似乎不再更新，不推荐<br>FreeRDP-WebConnect：已停止更新，不推荐使用，可参考实现<br>mstsc.js：似乎不再更新，协议不友好，不推荐<br>FreeRDP：文档（英文）健全，社区活跃，需要自己开发 HTTP/Websocket 客户端，制定沟通协议</p><p>比较推荐方案：</p><ol><li>采用 Guacamole。后端需要部署 guacd 服务，用 golang 实现 guacamole-client 中的 guacamole-common 以及 guacamole 中的 RestAPI 部分。前端实现 guacamole 中的前端页面部分，调用 guacamole-common-js 渲染。</li></ol><p>好处在于 Guacamole 文档丰富，且被多数开源堡垒机接受，说明在一定程度上质量有保证。难点在于需要学习 Guacamole 协议及配置方法。</p><ol start="2"><li>采用 FreeRDP。后端已经比较熟悉 FreeRDP，前后端可定义 wss 接口，参考 web ssh 实现部分，自主实现。</li></ol><p>好处在于自定义程度高。难点在于前后端协议定义，按照支持功能的丰富程度，可能需要进一步解析 RDP 协议，定义包括音频支持、剪切板支持等多种 action，需要自己处理预连接 PDU 和负载均衡。</p>]]></content>
      
      
      
        <tags>
            
            <tag> rdp </tag>
            
            <tag> guacamole </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图灵完备</title>
      <link href="/blog/2022/10/18/CS-%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87/"/>
      <url>/blog/2022/10/18/CS-%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<h3 id="图灵完备（Turing-completeness）"><a href="#图灵完备（Turing-completeness）" class="headerlink" title="图灵完备（Turing completeness）"></a>图灵完备（Turing completeness）</h3><p>在可计算性理论中，如果一个数据操作规则系统（如计算机的指令集、编程语言或细胞自动机）可以用来模拟任何图灵机器（由英国数学家和计算机科学家阿兰·图灵（Alan Turing）设计），则称其为图灵完备（Turing-complete）或计算通用的。</p><h3 id="图灵等价（Turing-equivalence）"><a href="#图灵等价（Turing-equivalence）" class="headerlink" title="图灵等价（Turing equivalence）"></a>图灵等价（Turing equivalence）</h3><p>若P可以模拟Q，Q可以模拟P，那个么这两个数据操作规则系统P和Q就是图灵等价的。</p><h3 id="图灵机（Turing-machine）"><a href="#图灵机（Turing-machine）" class="headerlink" title="图灵机（Turing machine）"></a>图灵机（Turing machine）</h3><p>图灵机（Turing Machine）是图灵在1936年发表的 《论可计算数及其在判定性问题上的应用》（《On Computable Numbers, with an Application to the Entscheidungsproblem》）中提出的数学模型。</p><p>图灵机的结构包括以下几个部分：</p><ul><li>一条无限长的纸带（tape），纸带被分成一个个相邻的格子（square），每个格子都可以写上至多一个字符（symbol）。</li><li>一个字符表（alphabet），即字符的集合，它包含纸带上可能出现的所有字符。其中包含一个特殊的空白字符（blank），意思是此格子没有任何字符。</li><li>一个读写头（head），可理解为指向其中一个格子的指针。它可以读取/擦除/写入当前格子的内容，此外也可以每次向左/右移动一个格子。</li><li>一个状态寄存器（state register），它追踪着每一步运算过程中，整个机器所处的状态（运行/终止）。当这个状态从运行变为终止，则运算结束，机器停机并交回控制权。如果你了解有限状态机，它便对应着有限状态机里的状态。</li><li>一个有限的指令集（instructions table），它记录着读写头在特定情况下应该执行的行为。可以想象读写头随身有一本操作指南，里面记录着很多条类似于“当你身处编号53的格子并看到其内容为0时，擦除，改写为1，并向右移一格。此外，令下一状态为运行。”这样的命令。其实某种意义上，这个指令集就对应着程序员所写下的程序了。</li></ul><p><img src="/blog/static/imgs/turing_machine.png" alt="turing_machine_inner"></p><p>在计算开始前，纸带可以是完全空白，也可以在某些格子里预先就有写上部分字符作为输入。运算开始时，读写头从某一位置开始，严格按照此刻的配置（configuration），即：</p><ul><li>当前所处位置</li><li>当前格子内容</li></ul><p>来一步步的对照着指令集去进行操作，直到状态变为停止，运算结束。而后纸带上留下的信息，即字符的序列（比如类似“…011001…”）便作为输出，由人来解码为自然语言。</p><h3 id="停机问题（Halting-Problem）"><a href="#停机问题（Halting-Problem）" class="headerlink" title="停机问题（Halting Problem）"></a>停机问题（Halting Problem）</h3><p>在可计算性理论中，停机问题是根据对任意计算机程序和输入的描述，确定程序是否将完成运行，还是将永远继续运行的问题。阿兰·图灵在1936年证明，解决所有可能的程序输入对的停机问题的通用算法不存在。</p><h3 id="自动机（Automation）"><a href="#自动机（Automation）" class="headerlink" title="自动机（Automation）"></a>自动机（Automation）</h3><p>自动机是有限状态自动机（Finite State Machine，FSM）的数学模型。有限状态自动机是给定符号输入，依据（可表达为一个表格的）转移函数“跳转”过一系列状态的一种机器。</p><ol><li>有限状态自动机（Finite Automata，FA）<ol><li>确定有限自动机（Deterministic Finite Automata，DFA）<br>自动机的每个状态都有对字母表中所有符号的转移。</li><li>非确定有限自动机（Non-deterministic Finite Automata，NFA）<br>自动机的状态对字母表中的每个符号可以有也可以没有转移，对一个符号甚至可以有多个转移。<br>上述自动机接受的语言家族被称为<em>正规表达式</em>(Regular Expression)</li></ol></li><li>下推自动机（Pushdown Automation，PDA）<br>下推自动机额外的装备了栈形式的内存。下推自动机是一种实现<em>上下文无关语法</em>的方式。</li><li>线性有界自动机（Linear Bounded Automation，LBA）<br>线性有界自动机是有限制的 图灵机；不使用无限磁带，它的磁带有同输入字元串成正比的空间。线性有界自动机接受<em>上下文有关语言</em>。</li><li>图灵机（Turing Machine）<br>图灵机是最强力的自动机。图灵机拥有磁带形式的无限内存，和可以读取和变更磁带的磁头，它可在磁带上向任何方向移动。图灵机等价于演算法，可以用来判定<em>递归语言</em>并识别递归可枚举语言。</li></ol><h3 id="Brainfuck-语言"><a href="#Brainfuck-语言" class="headerlink" title="Brainfuck 语言"></a>Brainfuck 语言</h3><p>在1993年，Urban Müller 发明了 Brainfuck 语言。这门语言可以说是编程语言界的 helloworld 了——它一共只含有 8 个有效字符，每个有效字符就是一条指令。语言虽然极致轻量，它却是一门图灵完备的编程语言。</p><p>语言里的 8 个有效字符分别是：</p><ul><li><code>&gt;</code><br>指针向右移动一格</li><li><code>&lt;</code><br>指针向左移动一格</li><li><code>+</code><br>使指针当前格数值加一</li><li><code>-</code><br>使指针当前格数值减一</li><li><code>.</code><br>把当前格数值按 ASCII 表输出到终端</li><li><code>,</code><br>从终端接受 1 byte 的数据，存储其 ASCII 数值到当前格</li><li><code>[</code><br>当指针当前值为 0 时，程序跳转至与之对应的 <code>]</code> 之后；否则程序正常执行</li><li><code>]</code><br>程序跳转回与之对应的 <code>[</code> 处</li></ul><p><a href="https://github.com/usaikiran/brainfuck-visualizer">brainfuck-visualizer</a> 提供了 Brainfuck 的可视化解析过程。</p><p>Brainfuck 的 8 个指令可以等价的转换为 C/C++ 语言语法：</p><table><thead><tr><th>Brainfuck</th><th>C</th></tr></thead><tbody><tr><td><code>&gt;</code></td><td><code>++ptr;</code></td></tr><tr><td><code>&lt;</code></td><td><code>--ptr;</code></td></tr><tr><td><code>+</code></td><td><code>++*ptr;</code></td></tr><tr><td><code>-</code></td><td><code>--*ptr;</code></td></tr><tr><td><code>.</code></td><td><code>putchar(*ptr);</code></td></tr><tr><td><code>,</code></td><td><code>*ptr=getch();</code></td></tr><tr><td><code>[</code></td><td><code>while(*ptr)&#123;</code></td></tr><tr><td><code>]</code></td><td><code>&#125;</code></td></tr></tbody></table><figure class="highlight c++"><figcaption><span>Windows</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">translate</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;p++&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;p--&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;*p = *p + 1&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;*p = *p - 1&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;cout &lt;&lt; char(*p)&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;,&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;*p = getchar()&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;while(*p) &#123;&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> arr[<span class="number">1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">char</span>* p = arr + <span class="number">500</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">run</span>();</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;D:/out.text&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; c) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">translate</span>(c);</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> program </tag>
            
            <tag> language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见视频音频字幕文件类型</title>
      <link href="/blog/2022/10/08/CS-%E5%B8%B8%E8%A7%81%E8%A7%86%E9%A2%91%E9%9F%B3%E9%A2%91%E5%AD%97%E5%B9%95%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B/"/>
      <url>/blog/2022/10/08/CS-%E5%B8%B8%E8%A7%81%E8%A7%86%E9%A2%91%E9%9F%B3%E9%A2%91%E5%AD%97%E5%B9%95%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="视频音频标准化组织"><a href="#视频音频标准化组织" class="headerlink" title="视频音频标准化组织"></a>视频音频标准化组织</h3><p>视频音频的很多协议都是由标准化组织牵头设计与规范的，其中，比较知名的有以下组织：</p><ul><li><p><a href="https://www.iso.org/">国际标准化组织</a>（International Standardization Organization，ISO）<br>全球最大的国际标准化组织，负责了许多音视频相关协议的起草与制定。</p></li><li><p><a href="https://www.iec.ch/">国际电工委员会</a>（International Electrotechnical Commission，IEC）<br>世界上成立最早的国际性电工标准化机构，负责有关电气工程和电子工程领域中的国际标准化工作。</p></li><li><p><a href="https://www.mpeg.org/">动态图像专家组</a>（Moving Picture Experts Group，MPEG）<br>ISO 与 IEC 下属的针对运动图像与语音压缩制定国际标准的组织。</p></li><li><p><a href="https://www.ietf.org/">互联网工程任务组</a>（Internet Engineering Task Force，IETF）<br>全球互联网技术标准化组，负责了多数网络相关协议的制定。</p></li><li><p><a href="https://www.3gpp.org/">第三代合作伙伴项目计划</a>（3rd Generation Partnership Project，3GPP）<br>3GPP 是由一组电信合作伙伴建立的、成立于1998年12月的标准化组织或机构，其成员包括欧洲 ETSI 、日本 ARIB 和 TTC 、中国 CCSA 、韩国 TTA 和北美 ATIS 。其目标是在 ITU 的 IMT-2000 计划范围内制订和实现全球性的第三代移动通信电话系统技术规范和宽带标准，致力于 GSM 到 UMTS（WCDMA）的演进。</p></li><li><p><a href="https://www.itu.int/">国际电信联盟</a>（International Telecommunication Union，ITU）<br>国际电联是主管信息通信技术事务的联合国机构，负责分配和管理全球无线电频谱与卫星轨道资源，制定全球电信标准，向发展中国家提供电信援助，促进全球电信发展。</p></li><li><p><a href="https://www.dcimovies.com/">数字电影联盟</a>（Digital Cinema Initiatives，DCI）<br>DCI 成立于2002年3月，是迪斯尼（Disney）、派拉蒙（Paramount）、索尼影业娱乐（Sony Pictures Entertainment）、环球影业（Universal）和华纳兄弟影业（Warner Bros. Studios）的合资企业。DCI 的主要目的是建立和记录数字电影开放式架构的自愿规范，以确保统一和高水平的技术性能、可靠性和质量控制。</p></li><li><p><a href="https://www.smpte.org/">美国电影电视工程师协会</a>（The Society Of Motion Picture And Television Engineers，SMPTE）<br>电影电视工程师协会是美国的一个国际性组织，它成立于1916年，最初名称为电影工程师协会，1950年后改为现名。该组织制定了多项电影、电视行业的标准，在电影制作、电视制作、数字影院系统、医学影像及声音等领域共制定了超过400项标准。</p></li></ul><span id="more"></span><h3 id="视频文件类型"><a href="#视频文件类型" class="headerlink" title="视频文件类型"></a>视频文件类型</h3><!--mp4、mov、m4v、3gp 同属于 [MPEG-4](https://www.iso.org/obp/ui/#iso:std:iso-iec:14496:-14:ed-3:v1:en) 协议下mkv、webm 属于 [matroska](https://www.matroska.org/what_is_matroska.html) 格式下ts、m2ts 属于 [MPEG2-TS](https://www.iso.org/standard/67331.html) 协议mpg/mpeg 属于 MPEG2-PS 协议avi、wmv 均为微软提供的格式，wmv 常采用 asf 作为容器格式rm、rmvb 是 Real Networks 公司使用的格式--><h4 id="mp4"><a href="#mp4" class="headerlink" title="mp4"></a>mp4</h4><p>MP4（Moving Picture Experts Group 4）格式是指采用了 <a href="https://www.mpeg.org/standards/MPEG-4/14/">MPEG-4 Part 14</a> 标准的视频文件格式。MPEG-4 是一套用于音频、视频信息的压缩编码标准，由 MPEG 制定，第一版在1998年10月通过，第二版在1999年12月通过。MPEG-4 格式的主要用途在于网络传输、光盘、语音发送（视频电话），以及电视广播。</p><h4 id="mkv"><a href="#mkv" class="headerlink" title="mkv"></a>mkv</h4><p><a href="https://www.matroska.org">Matroska</a> 视频（Matroska Video，MKV）格式是一种开放标准的开源的多媒体容器文件格式。MKV 格式允许在一个文件中容纳无限数量的视频、音频、图片或字幕轨道。其目标是作为一种统一格式保存常见的电影、电视节目等多媒体内容。其在技术规程上完全开放，在实现上包含了很多开源软件。</p><h4 id="webm"><a href="#webm" class="headerlink" title="webm"></a>webm</h4><p>WEBM 是一个开放免费的媒体文件格式，由 Google 公司提出，以 Matroska 容器格式为基础开发的新容器格式，以 VP8 格式进行视频编码，以 Ogg Vorbis 格式进行音频编码。</p><h4 id="avi"><a href="#avi" class="headerlink" title="avi"></a>avi</h4><p>音频视频交错格式（Audio Video Interleaved，AVI）是 Microsoft 公司于1992年11月推出、作为其 Windows 视频软件一部分的一种多媒体容器格式。AVI 文件将音频和视频数据包含在一个文件容器中，允许音视频同步播放。</p><h4 id="wmv"><a href="#wmv" class="headerlink" title="wmv"></a>wmv</h4><p>视窗媒体视频（Windows Media Video，WMV）是 Microsoft 开发的一系列视频编解码和其相关的视频编码格式的统称，是微软视窗媒体（Microsoft Windows Media）框架的一部分。</p><h4 id="asf"><a href="#asf" class="headerlink" title="asf"></a>asf</h4><p>高级串流格式（Advanced Streaming Format，ASF）是 Microsoft 为 Windows 98 所开发的串流多媒体文件格式。利用 ASF 文件可以实现点播功能、直播功能以及远程教育，具有本地或网络回放、可扩充的媒体类型等优点。</p><h4 id="ts-m2ts"><a href="#ts-m2ts" class="headerlink" title="ts/m2ts"></a>ts/m2ts</h4><p>传输流（Transport Stream，TS）是一种多媒体封装格式，它的全称为 MPEG2-TS 。MPEG2-TS 是一种标准数据容器格式，传输与存储音视频、节目与系统信息协议数据，主要应用于数字广播系统，譬如 DVB、ATSC 与 IPTV。传输流最初是为广播而设计的，后来，通过在标准的188字节数据包中添加4字节的时间码（TC），从而使该数据包成为192字节的数据包，使其适用于数码摄像机，录像机和播放器，扩展后的 TS 使用 m2ts 文件后缀，常见于 Blu-ray 光盘文件。</p><h4 id="vob"><a href="#vob" class="headerlink" title="vob"></a>vob</h4><p>VOB（Video Object）是 DVD 视频媒体使用的容器格式，VOB 将数字视频、数字音频、字幕、DVD菜单和导航等多种内容复用在一个流格式中。</p><h4 id="mpeg-mpg"><a href="#mpeg-mpg" class="headerlink" title="mpeg/mpg"></a>mpeg/mpg</h4><p>MPEG（Moving Picture Experts Group，MPEG）是采用了 MPEG 标准的多媒体文件格式。MPEG 标准主要有以下五个，MPEG-1、MPEG-2、MPEG-4、MPEG-7 及 MPEG-21 。MPEG 标准的视频压缩编码技术主要利用了具有 <em>运动补偿</em> 的帧间压缩编码技术以减小时间冗余度，利用 <em>离散余弦变换</em>（Discrete Cosine Transform，DCT）技术以减小图像的空间冗余度，利用 <em>熵编码</em> 则在信息表示方面减小了统计冗余度。这几种技术的综合运用，大大增强了视频压缩性能。</p><h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><p>RM（Real Media）格式是 Real Networks 公司开发的一种流媒体视频文件格式，可以根据网络数据传输的不同速率制定不同的压缩比率，从而实现低速率的网络上进行视频文件的实时传送和播放。</p><h4 id="rmvb"><a href="#rmvb" class="headerlink" title="rmvb"></a>rmvb</h4><p>Real Media 可变比特率（Real Media Variable Bit Rate，RMVB）格式是 Real Networks 公司开发的 Real Media 多媒体数字容器格式的可变比特率（Variable Bit Rate，VBR）扩展版本。相对于更常见的按固定比特率（Constant Bit Rate，CBR）编码的流媒体 Real Media 容器，RMVB 典型应用于保存在本地的多媒体内容。</p><h4 id="3gp"><a href="#3gp" class="headerlink" title="3gp"></a>3gp</h4><p>3GP 格式是 3GPP 为 3G UMTS 多媒体服务定义的一种多媒体容器格式，主要应用于3G移动电话，是一种 MPEG-4 Part14（MP4）格式的简化版本。</p><h4 id="mov"><a href="#mov" class="headerlink" title="mov"></a>mov</h4><p>MOV 格式即 QuickTime 封装格式（也叫影片格式），它是 Apple 公司开发的一种音频、视频文件封装格式，用于存储常用数字媒体类型。MOV 格式是 QuickTime Player 的默认格式。</p><h4 id="m4v"><a href="#m4v" class="headerlink" title="m4v"></a>m4v</h4><p>M4V 格式是一种应用于网络视频点播网站和移动手持设备的多媒体格式，是 MP4 格式的一种特殊类型，其视频编码采用 H.264，音频编码采用 AAC。</p><p>M4V 格式由 Apple 公司开发，基于 MPEG-4 编码第二版。此种格式为 iPod 、 iPhone 和 PlayStation Portable 所使用。</p><h4 id="flv"><a href="#flv" class="headerlink" title="flv"></a>flv</h4><p>FLV（Flash Video）流媒体格式是 Sorenson Media 公司开发的一种视频格式。它的出现有效地解决了视频文件导入 Flash 后，使导出的 SWF 文件体积庞大，不能在网络上很好的使用等缺点。FLV 流媒体格式是随着 Flash MX 的推出发展而来的视频格式。</p><h3 id="音频文件类型"><a href="#音频文件类型" class="headerlink" title="音频文件类型"></a>音频文件类型</h3><h4 id="mp3"><a href="#mp3" class="headerlink" title="mp3"></a>mp3</h4><p>动态影像专家压缩标准音频层面3（Moving Picture Experts Group 1 Audio Layer III，MP3）是计算机、手机、MP3设备、随身数码设备（iPod）等常用的音频文件格式。MP3 是一种音频压缩技术，使用此格式来存储的音频文件，可以大幅度地降低音频数据量，并提供了较好的音质效果。</p><p>MP3 格式是一种有埙的音频压缩（文件编码）格式，但是它的优点是，文件容量较小，方便存储携带传播，尤其是网络收听，或者存储在手机，用来播放音乐。</p><h4 id="wma"><a href="#wma" class="headerlink" title="wma"></a>wma</h4><p>视窗媒体音频（Windows Media Audio，WMA）是 Microsoft 公司推出的一种音频文件格式。WMA 在压缩比和音质方面都有着出色的表现，可以媲美 MP3 文件，在较低的采样频率下也能产生较好的音质。WMA 也属于有损的音频文件压缩格式，但是因为其文件占用磁盘空间少，较为方便移动存储和传播。</p><h4 id="aac"><a href="#aac" class="headerlink" title="aac"></a>aac</h4><p>高级音频编码（Advanced Audio Coding，AAC）属于一种有埙压缩格式。与 MP3 不同的是，它采用了全新的算法进行编码，利用 AAC 编码，可使人感觉声音质量没有明显降低的前提下，文件更小。</p><h4 id="ogg"><a href="#ogg" class="headerlink" title="ogg"></a>ogg</h4><p>Ogg（Ogg Vorbis）是一种有损的音频压缩格式。Ogg 是完全免费、开放和没有专利限制的，支持多声道。</p><h4 id="midi"><a href="#midi" class="headerlink" title="midi"></a>midi</h4><p>乐器数字接口（Musical Instrument Digital Interface，MIDI）是一种编曲类的音频格式文件。是编曲界最广泛的音乐标准格式，可称为“计算机能理解的乐谱”。它用音符的数字控制信号来记录音乐，一首完整的 MIDI 音乐只有几 KB 或者几十 KB 大小，而能包含数十条音乐轨道。<br>我们听 MIDI 音乐的时候，它都是音乐（乐谱）的声音，而没有人声。它主要的作用是辅助音乐创作、乐曲演奏等。</p><h4 id="ac3"><a href="#ac3" class="headerlink" title="ac3"></a>ac3</h4><p>杜比数码环绕声（Dolby Surround Audio Coding-3，AC3）是一种有损的音频文件格式，可以对6个比特率最高为448kbps的单独声道进行编码，由日本先锋公司与美国杜比实验室合作研制。也被称为5.1声道。</p><h4 id="wav"><a href="#wav" class="headerlink" title="wav"></a>wav</h4><p>WAV（WaveForm）是 Microsoft 公司专门为 Windows 开发的一种标准数字音频文件，该文件能记录各种单声道或立体声的声音信息，并能保证声音不失真。WAV 文件还原的波形曲线十分逼真，音质也非常好，但是 WAV 文件占用的磁空间非常的大。</p><h4 id="flac"><a href="#flac" class="headerlink" title="flac"></a>flac</h4><p>无损音频压缩编码（Free Lossless Audio Codec，FLAC）是一种无损失音频文件压缩格式，使用此编码的音频数据几乎没有任何信息损失。该文件占用空间较大，适合存储于计算机，或者大容量手机之中，适合音乐发烧友用户使用。</p><h4 id="ape"><a href="#ape" class="headerlink" title="ape"></a>ape</h4><p>APE 是数字音乐无损压缩格式之一，由软件 <a href="https://monkeysaudio.com/">Monkey’s audio</a> 压制得到。</p><h3 id="字幕文件类型"><a href="#字幕文件类型" class="headerlink" title="字幕文件类型"></a>字幕文件类型</h3><h4 id="srt"><a href="#srt" class="headerlink" title="srt"></a>srt</h4><p>文本格式字幕（SubRip Text，SRT）是最为流行的字幕文件格式之一。其制作规范简单，仅需要一句时间代码加一句字幕，配合上 <code>.style</code> 文件还能让字幕自带一些字体上的特效等。</p><h4 id="sub-idx"><a href="#sub-idx" class="headerlink" title="sub+idx"></a>sub+idx</h4><p>SUB 是一种图形格式字幕，由 idx 和 sub 文件组成，有时也能看到 ifo 文件。idx 相当于索引文件，里面包括了字幕出现的时间码和字幕显示属性等。sub 文件存放字幕本身。</p><h4 id="ssa"><a href="#ssa" class="headerlink" title="ssa"></a>ssa</h4><p><a href="http://www.perlfu.co.uk/projects/asa/ass-specs.doc">SSA</a>（Sub Station Alpha）是由 CSLow（又称 Kotus）创建的一种字幕格式，用以实现比传统字幕诸如 srt 等格式更为复杂的功能。</p><h4 id="ass"><a href="#ass" class="headerlink" title="ass"></a>ass</h4><p>ASS（Advanced Sub Station Alpha）是比 SSA 更高级的字幕脚本。技术上讲，他是 SSA v4+，比普通的 SSA 有更多的规范，可以生成更丰富的字幕内容。</p><h4 id="vtt"><a href="#vtt" class="headerlink" title="vtt"></a>vtt</h4><p>Web 视频文本轨格式（WebVTT）是一种使用 <code>&lt;track&gt;</code> 元素显示定时文本轨道（例如字幕或者标题）的格式。WebVTT 文件的主要用途是将文本叠加到 <code>&lt;video&gt;</code> 中。WebVTT 是一种基于文本的格式，必须使用 UTF-8 进行编码。</p><h3 id="其他相关文件类型"><a href="#其他相关文件类型" class="headerlink" title="其他相关文件类型"></a>其他相关文件类型</h3><h4 id="nfo"><a href="#nfo" class="headerlink" title="nfo"></a>nfo</h4><p>nfo（information）是相当普遍的 ASCII 文字档案的副档名，它的内容包含主要档案的相关文字说明资讯。可以使用文字编辑器或是 NFO 专用的浏览器浏览 NFO 档案的内容。档案的内容还会包含精心制作的 ASCII 艺术图案。</p><h4 id="ifo"><a href="#ifo" class="headerlink" title="ifo"></a>ifo</h4><p>DVD 光盘中的 IFO（information）文件包含 DVD 播放器所需的 DVD 光盘的所有信息，这样用户可以导航播放正确的 DVD 内容。</p><h4 id="bup"><a href="#bup" class="headerlink" title="bup"></a>bup</h4><p>DVD 光盘中的 BUP（backup）文件是 IFO 文件的完整备份，用于容灾和灾备。</p><h3 id="视频文件清晰度"><a href="#视频文件清晰度" class="headerlink" title="视频文件清晰度"></a>视频文件清晰度</h3><h4 id="电视广播制式"><a href="#电视广播制式" class="headerlink" title="电视广播制式"></a>电视广播制式</h4><p>电视广播制式（television system）是指电视信号的标准，即用来实现电视图像或声音信号所采用的一种技术标准。<br>彩色电视机的制式一般只有三种，即 PAL、NTSC、SECAM。</p><ol><li>正交平衡调幅制（National Television Systems Committee，NTSC）。采用这种制式的主要国家有美国、加拿大和日本等。这种制式的帧速率为29.97fps（帧/秒），每帧525行，标准分辨率为 720x480。</li><li>正交平衡调幅逐行倒相制（Phase Alternative Line，PAL）。中国、德国、英国、印度、巴基斯坦和其它一些西北欧国家采用这种制式。这种制式帧速率为25fps，每帧625行，标准分辨率为 720×576。</li><li>行轮换调频制（Séquentiel couleur à mémoire，SECAM）。采用这种制式的有法国、俄罗斯和东欧一些国家。这种制式帧速率为25fps，每帧625行，标准分辨率 720×576。</li></ol><p>一般将 PAL 制式（分辨率 720x576，屏幕宽高比 4:3）或 NTSC 制式（分辨率 720x486，屏幕宽高比 4:3）的电视广播称为标准清晰度电视（Standard Definition TeleVision，SDTV），简称为标清或普清。</p><h4 id="HDTV"><a href="#HDTV" class="headerlink" title="HDTV"></a>HDTV</h4><p>高清晰度电视（High Definition Television，HDTV）根据 ITU 的定义，应是一个透明系统，一个正常视力的观众在距该系统显示屏高度的三倍距离上所看到的图像质量应具有观看原始景物或表演时所得到的印象。</p><p>HDTV 源于 数字电视（Digital Television，DTV）技术，与采用模拟信号传输的传统电视系统不同，HDTV 采用了数字信号传输。由于 HDTV 从电视节目的采集、制作到电视节目的传输，以及到用户终端的接收全部实现数字化，因此 HDTV 给我们带来了极高的清晰度。</p><p>根据各个国家使用电视制式的不同，各国家和地区定义的 HDTV 的标准分辨率也不尽相同。</p><p>在中国一般而言，HDTV 有三种显示格式，分别是：720p（1280×720分辨率，逐行扫描），1080i（1920×1080分辨率，交错式扫描），1080p（1920×1080分辨率，逐行扫描）。数字代表了垂直方向分辨率，扫描格式使用 p 或 i 来表示，p表示逐行扫描（progressive scan），i表示交错式扫描（interlaced scan）。同时，HDTV 的帧率达到了 60fps，屏幕宽高比变成了 16:9。</p><blockquote><p>美国电影电视工程师协会确定的高清标准格式，受限制于存储介质（一部 1080p 的影片需要10GB以上的存储空间），目前 1080p 的影片多数以蓝光（Blu-ray）方式发行。</p></blockquote><h4 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h4><p>分辨率又称为解析度，分辨率越高，像素越多，图像越清晰。</p><ul><li><p>SD（Stardard Definition 标清/普清）<br>分辨率为 720x576 或 720x486</p></li><li><p>720p = HD（High Definition 高清）<br>分辨率为 1280×720</p></li><li><p>1080i = HD<br>分辨率为 1920×1080</p><p>HD 是指垂直分辨率大于等于 720 的图像或视频。</p></li><li><p>1080p = HD / FHD（Full High Definition 全高清）<br>1080p 为 HD 下的最高分辨率，又被称为全高清。分辨率为 1920×1080</p></li><li><p>1440p（2K） = QHD（Quad High Definition 四倍HD）<br>分辨率为 2560×1440</p><p>2K 分辨率，指屏幕或者内容的水平分辨率达约2000像素的分辨率等级。DCI 定义的 2K 分辨率的标准为 2048×1080 ，数字影院放映机主要采用这种分辨率。</p></li><li><p>2160p（4K） = UHD（Ultra High Definition 超高清）<br>分辨率为 3840×2160</p><p>UHD 是指垂直分辨率达到 2160 以上的图像或视频。</p><p>DCI 定义的 4K 分辨率的标准为 4096×2160</p></li><li><p>4320p（8K） = UHD<br>分辨率为 7680×4320</p></li></ul><h4 id="片源"><a href="#片源" class="headerlink" title="片源"></a>片源</h4><p>BD（Blu-ray Disc）蓝光光盘</p><p>WEB-DL（Web download）是从 WEB 页面获取到的一种高清视频，WEB-DL 的来源是 iTunes 在线商店以及 Netflix 等各大视频网站，质量要比 HDTV 好，较之0day的录制版信号源也更清晰，相比 HDTV，无水印，无台标logo，无插播广告，所以无任何剪切较完整，但是不如 BD 的清晰度。</p><p>HDTV（High Definition Television）高清晰度电视</p><p>DVD（Digital Video Disk）数字视频光盘</p><p>HDRip/HDTVRip 是用 DivX/XviD/x264 等 MPEG4 压缩技术对 HDTV 的视频图像进行高质量压缩，然后将视频、音频部分封装成一个 <code>.avi</code> 或 <code>.mkv</code> 文件。实际上是对 HDTV 的2次压缩，将原来的 MPEG2、H264、AVC 或者 VC-1 编码重编码为 MPEG4 编码。</p><p>DVDRip 是 用 DVD 做为片源进行重新压缩编码的文件。一般使用 DivX、XviD 以及 x264 等MPEG4 压缩技术压缩视频，用 MP3 或 AC3 等压缩音频。</p><p>WEBRip 指的是至少经过一次转码的在线内容，包括使用有损抓取或录屏软件获得的内容，也包括基于 WEB-DL 的重编码。</p><h3 id="视频元数据"><a href="#视频元数据" class="headerlink" title="视频元数据"></a>视频元数据</h3><h4 id="码率"><a href="#码率" class="headerlink" title="码率"></a>码率</h4><p>码率，又叫比特率，是指单位时间内传输的数据量，单位一般为kbps(千位每秒)。<br>根据码率是否是固定的可以将码率分为两种，恒定码率 与 动态码率。</p><p>恒定码率（Constant Bit Rate，CBR），码率稳定可控，带宽要求不高，图像变化量比较大时方块效应比较明显。恒定码率(kbps) = 文件大小(kb) * 8 / 时间(s)。</p><p>动态码率（Variable Bit Rate，VBR），码率波动较大，带宽要求较高，图像变化量比较大时方块效应有所改善。发生网络抖动时，比较容易丢包，需要重传，或者 FEC 前向纠错，从而带来延时。动态码率(kbps) = 每秒传输数据量(kb/s) * 8。</p><h4 id="分辨率-1"><a href="#分辨率-1" class="headerlink" title="分辨率"></a>分辨率</h4><p>参见 <a href="/blog/2022/10/08/CS-常见视频音频字幕文件类型/#分辨率">分辨率</a></p><h4 id="帧率"><a href="#帧率" class="headerlink" title="帧率"></a>帧率</h4><p>视频帧率（Frames Per Second，FPS）为视频每秒传输的图片的量。每一帧都是静止的图象，由于人眼的视觉停留效果（人的大脑视觉处理中心，大约会将看到的画面在视觉里暂留100至400毫秒），快速连续地显示帧便形成了运动的假象。理论上，每秒十五帧以上即可使人看到连续的画面，高的帧率可以得到更流畅、更逼真的动作效果，但是更高的帧率也会带来存储上的问题。</p><p>史上第一部部分有声的电影《爵士歌手》在1927年上映，其最终成品在无声音片段时统一使用的是24帧，随着《爵士歌手》的成功，各大片厂便开始规定摄影师要遵守每秒24帧的速率。<br>2012 年 12 月 14 日上映的《霍比特人：意外之旅》预算1.8亿美元，在制作上《霍比特人：意外之旅》的每秒帧数达到了48帧，高制作的同时也因此获得了更震撼的画面感。<br>李安导演在2016年推出最高4K分辨率、120FPS及3D规格的电影——《比利·林恩的中场战事》，该片于2016年11月11日以120帧、60帧、24帧、3D规格在中国上映。</p><p>目前，绝大多数的数字电影拍摄帧率仍然是24fps，但更高帧率的电影也在不断涌现中。中国的电视广播制式是 PAL 制式，频率为 25fps。美国的电视广播制式是 NTSC 制式，频率为 30fps。</p><h4 id="时长"><a href="#时长" class="headerlink" title="时长"></a>时长</h4><p>视频所有图像播放所需要的时间称为视频时长。<br>时长(s) = 帧数 / 帧率(fps)</p><h4 id="色域"><a href="#色域" class="headerlink" title="色域"></a>色域</h4><p>指某种表色模式所能表达的颜色构成的范围区域，色域空间越大，所能表现的颜色越多。</p><p>SDR（Standard Dynamic Range）: 标准动态范围，指一种很常见的色彩显示方式。<br>HDR（High Dynamic Range）: 高动态范围，比普通数位图像技术更大曝光动态范围的一组技术。</p><h5 id="HDR-标准"><a href="#HDR-标准" class="headerlink" title="HDR 标准"></a>HDR 标准</h5><ul><li>HDR10: <a href="https://www.cta.tech/">消费者技术协会</a>（Consumer Technology Association，CTA）2015年8月27日宣布的开放标准，不需要支付任何版权费。这个标准要求必须使用宽色域 Rec.2020 色彩空间，10bit 色深，以及 SMPTE ST 2084（PQ）图像传输功能，但它的数据元全部是静态的，简单来说就是每一帧所输出的 HDR 图像效果是一样的。目前所有支持 4K HDR 的设备都必须达到这个标准</li><li>Dolby Vision HDR: 杜比视界 HDR 是由杜比实验室提出并定制的 HDR 当前最高级标准，与 HDR10 不同的是，它不是开放的标准，需要使用它必须交付一定的版权费用（据悉是每年每台设备3美元）。杜比视界要求必须使用宽色域 Rec.2020 色彩空间， SMPTE ST 2084（PQ）图像传输功能，与 HDR10 不同的是，它采用 12bit 色深，并且支持动态数据元结构，杜比视界允许 10000 尼特的最大亮度（目前在设备中最高只达到 4000 尼特）。</li><li>HDR10+: 于2017年4月20日由三星和亚马逊 Video 共同公布，由于杜比视界 HDR 极高的版权费用，三星等厂商不愿意支付，所以与松下、亚马逊和20世纪福斯创建了 HDR10 + 联盟，以推广HDR10 +标准。HDR10+ 通过添加动态元数据来更新 HDR10，动态元数据可用于在逐个场景或逐帧的基础上更精确地调整 HDR 的亮度级别，和杜比视界 HDR 类似，不过色深依旧是 10bit。</li><li>HLG（Hybrid Log-Gamma）: HLG 是由 BBC 和 NHK 联合开发的 HDR 标准，它与标准动态范围（SDR）显示兼容，但它需要 10bit 色深。HLG 定义了非线性电光传递函数（EOTF），其中信号值的下半部分使用伽马曲线，信号值的上半部分使用对数曲线。HLG 标准免版税，与 SDR 显示兼容。HLG 由 HDMI 2.0b、HEVC、VP9 和 H.264 / MPEG-4 AVC 提供支持。HLG 主要应用于广播以及部分流媒体，如 BBC iPlayer、DirecTV、Freeview Play 和 YouTube。</li></ul><h3 id="视频音频编码"><a href="#视频音频编码" class="headerlink" title="视频音频编码"></a>视频音频编码</h3><h4 id="视频编码"><a href="#视频编码" class="headerlink" title="视频编码"></a>视频编码</h4><p>视频编码方式就是指通过压缩技术，将原始视频格式的文件转换成另一种视频格式文件的方式。常见的视频编码格式有：</p><ul><li>H.264<br>H.264 是由 ITU-T 视频编码专家组与 MPEG 联合提出的高度压缩数字视频编解码器标准。这个标准也被称为 AVC（Advanced Video Coding），同时也是 MPEG4 标准的第十部分，参见 <a href="https://www.mpeg.org/standards/MPEG-4/10/">MPEG-4: Advanced Video Coding</a>。H.264 是目前嵌入式和移动设备中采用最多的视频编解码算法标准。H.264 通常使用 <a href="https://www.videolan.org/developers/x264.html">x264</a> 编码器进行编码。</li><li>H.265<br>H.265 是 ITU-T 发布的基于 H.264 优化的新的视频编码标准。H.265 也被称为 HEVC（High Efficiency Video Coding），参见 <a href="https://www.itu.int/rec/T-REC-H.265">H.265 : High efficiency video coding</a>。通常使用<a href="https://www.videolan.org/developers/x265.html">x265</a> 编码器进行编码。</li><li>VP8<br>VP8 是一个开放的图像压缩标准，最早由 On2 Technologiesis 开发，随后由 Google 发布。同时 Google 也发布了 VP8 的编解码器 <a href="https://github.com/webmproject/libvpx">libvpx</a>，以 BSD 授权条款的方式发布。VP8 是 Google 开发和推动的视频编解码标准，被 Chrome 很好的支持。VP8 目前是 WebRTC 的默认视频编解码标准，超过 90% 的 WebRTC 视频会话使用 VP8 来进行编解码。</li><li>VP9<br>VP9 是 Google 提供的开源的免费视频编解码器，是VP8的后续版本。2012年底，VP9的解码器被加入 Chrome 浏览器。</li><li>M-JPEG（Motion-Join Photographic Experts Group）<br>M-JPEG技术常用于闭合电路的电视摄像机的模拟视频信号转换成视频流，并存储在硬盘上。H.264的压缩比一般能达到 1：50 甚至 1：100 以上，而M-JPEG压缩比一般小于 1：20。但由于 M-JPEG 压缩率较小，所以能达到跟原图像接近的画质和清晰度。</li><li>VC-1（WMV3）<br>WMV（Windows Media Video）是 Microsoft 开发的一组数字视频编解码格式。2003年 Microsoft 公司基于 Windows Media Video 第 9 版编解码起草了视频编解码规范并且提交给 SMPTE 申请作为标准。这个标准在2006年3月作为 <a href="https://www.loc.gov/preservation/digital/formats/fdd/fdd000095.shtml">SMPTE 421M</a> 被正式批准，常被称为 VC-1。WMV1、WMV2、WMV3分别对应 Windows Media Player 的版本7、8和9，所以 VC-1 也会被称为 WMV3 或 WMV9（早期也被称为VC-9）。</li></ul><h4 id="音频编码"><a href="#音频编码" class="headerlink" title="音频编码"></a>音频编码</h4><ul><li>MP3<br>MP3（Moving Picture Experts Group-1 Audio Layer 3）是当前最流行的有损音频压缩格式。MP3文件是由帧（frame）构成的，帧是MP3文件最小的组成单位。MPEG音频文件是MPEG1标准中的声音部分，也叫MPEG音频层，它根据压缩质量和编码复杂程度划分为三层，即 Layer-1、Layer2、Layer3，且分别对应MP1、MP2、MP3这三种声音文件，并根据不同的用途，使用不同层次的编码。MPEG音频编码的层次越高，编码器越复杂，压缩率也越高，MP1和MP2的压缩率分别为4:1和6:1-8:1，而MP3的压缩率则高达10:1-12:1。</li><li>AAC<br>AAC（Advanced Audio Coding）是一种专为声音数据设计的文件压缩格式。与MP3不同，它采用了全新的算法进行编码，更加高效，具有更高的“性价比”。利用AAC格式，可使人感觉声音质量没有明显降低的前提下，更加小巧。AAC格式广泛用于苹果设备和系统，AAC通常压缩比为18:1，是最高效的音频有损编码格式</li><li>AC-3<br>1994年，日本先锋公司宣布与美国杜比实验室合作研制成功一种崭新的环绕声制式，并命名为“杜比AC-3”(Dolby Surround Audio Coding-3)。1997年初，杜比实验室正式将“杜比AC-3环绕声”改为“杜比数码环绕声”(Dolby Surround Digital)，我们常称为Dolby Digital。<br>AC3为有损编码格式，常见于DVD/BD，提供的环绕声系统由5个全频域声道和1个超低音声道组成，被称为5.1声道。码率最高为640k通常有640、448、384这几种码率。</li><li>DTS<br>数码影院系统（Digital Theatre System，DTS）是1996年底推出的一种源自剧院模式开发的数码环绕声系统。DTS 系统不仅具有 AC-3 相似功能，更加强了其纵深定位交叉效果。DTS属于DVD时代的音频标杆，有损音频压缩格式， DTS 最高码率为 1536kbps，压缩传输比为 4:1。</li><li>DTS-HD Master Audio<br>DTS-HD Master Audio是无损压缩音轨，DTS宣称它是“bit for bit”的完整再现录音母带效果，是完全无损压缩，在蓝光影碟中最高码率可达24.5Mbps。DTS HD内核也带有1.5Mbps码率的DTS 5.1音轨数据，因此也可以实现通过SPDIF传输到老功放实现5.1音频。</li><li>TRUE HD<br>TRUE HD是杜比专为高清影碟开发的无损压缩音轨格式，最高可支持多达八个分离的24bit/96 kHz全频带声道，在蓝光影碟中的码率最高为18Mbps。杜比宣称TRUE HD为100%无损音频，因此除了比同规格LPCM更节省带宽外，还可以加入对白和整体音量控制，实现比如夜间影院功能，它的内核还带有一条640K码率的AC3 5.1音轨数据，即便整部影片只有TRUE HD音轨，对老功放通过光纤传输也可以实现5.1音效。</li><li>PCM / LPCM / FLAC<br>PCM/LPCM常见于BD，是一种无损格式，不做压缩，类似wav。FLAC是最好用的音频无损压缩格式，编码器开源，在PC上兼容性好，压缩率优于DTS-HD MA和TrueHD，但是以上三种在高清电影中并不是很常见</li></ul><h3 id="其他音视频相关名词解释"><a href="#其他音视频相关名词解释" class="headerlink" title="其他音视频相关名词解释"></a>其他音视频相关名词解释</h3><p>TC（TELECINE）使用电视电影机从胶片直接数字拷贝，其图象和声音质量最好<br>Hi-Fi（High-Fidelity）高保真<br>CRT（Cathode Ray Tube）阴极射线显像管</p><h3 id="视频播放器"><a href="#视频播放器" class="headerlink" title="视频播放器"></a>视频播放器</h3><h4 id="多平台"><a href="#多平台" class="headerlink" title="多平台"></a>多平台</h4><ul><li><p><a href="https://player.qq.com/">QQ影音</a><br>QQ影音是由 腾讯 公司开发的一款免费、无广告的基于 ffmpeg 的视频播放器。</p></li><li><p><a href="http://www.baofeng.com/">暴风影音</a><br>暴风影音是北京暴风科技有限公司推出的一款视频播放器，该播放器兼容大多数的视频和音频格式。支持切换视频解码器和音频解码器。</p></li><li><p><a href="https://www.realplayer.cn/">Real Player</a><br>Real Player 是由 Real Networks 公司开发的跨平台播放器。</p></li></ul><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><ul><li><p><a href="https://support.microsoft.com/zh-cn/windows/%E8%8E%B7%E5%8F%96-windows-media-player-81718e0d-cfce-25b1-aee3-94596b658287">Windows Media Player</a><br>Windows Media Player 是 Microsoft 公司出品的一款免费的播放器，属于 Microsoft Windows 的一个组件，Windows 操作系统下默认的媒体播放器。</p></li><li><p><a href="https://www.kmplayer.com/">KMPlayer</a><br>韩国人姜龙喜开发的一款视频播放器，由 Delphi 编写。</p></li><li><p><a href="https://potplayer.org/">PotPlayer</a><br>PotPlayer 是 Daum 公司的一款网络播放器，使用 VC++ 编写。</p></li><li><p><a href="https://mpc-hc.org/">MPC-HC</a><br>MPC-HC（Media Player Classic - Home Cinema）是一款轻量级的、开源的 Windows 操作系统下的媒体播放器。源代码地址 <a href="https://github.com/mpc-hc/mpc-hc">mpc-hc</a></p></li></ul><h4 id="MacOS"><a href="#MacOS" class="headerlink" title="MacOS"></a>MacOS</h4><ul><li><p><a href="https://support.apple.com/zh-cn/guide/quicktime-player/welcome/mac">QuickTime Player</a><br>Apple 公司出品的播放器，MacOS 操作系统下默认的媒体播放器。</p></li><li><p><a href="https://www.iina.io/">IINA</a><br>MacOS 操作系统下的一款开源媒体播放器。源代码地址 <a href="https://github.com/iina/iina">iina</a></p></li></ul><h4 id="Android-iOS"><a href="#Android-iOS" class="headerlink" title="Android/iOS"></a>Android/iOS</h4><ul><li><a href="https://github.com/Bilibili/ijkplayer">ijkplayer</a><br>bilibili 开源的一款 Android/iOS 视频播放器，基于 FFmpeg。源代码地址 <a href="https://github.com/Bilibili/ijkplayer">ijkplayer</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> audio </tag>
            
            <tag> video </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker小抄</title>
      <link href="/blog/2022/09/09/Docker-Docker%E5%B0%8F%E6%8A%84/"/>
      <url>/blog/2022/09/09/Docker-Docker%E5%B0%8F%E6%8A%84/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker-是什么"><a href="#Docker-是什么" class="headerlink" title="Docker 是什么"></a>Docker 是什么</h2><p>Docker 是一个开源的应用容器平台（PaaS），基于 Go 语言开发并遵从 Apache2.0 协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何的宿主机器上。容器使用沙箱的机制，容器之间互相隔离，而且容器性能开销极低，并且可以在不同宿主环境之间互相迁移。</p><p>Docker 的优势在于：</p><ul><li>更高效的利用系统资源</li><li>更快的启用时间</li><li>一致的运行环境</li><li>持续交付和部署</li><li>更轻松的迁移</li><li>更轻松地维护和扩展</li></ul><span id="more"></span><h2 id="Docker-原理"><a href="#Docker-原理" class="headerlink" title="Docker 原理"></a>Docker 原理</h2><p>Docker 是基于 linux 内核实现的，它利用了多种 Linux 操作系统的机制来实现容器之间的互相隔离。</p><h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><p>linux 提供了一种叫 命名空间（Namespace）的机制，可以给进程、用户、网络等分配一个命名空间，这个命名空间下的资源都是独立命名的。</p><p>比如 PID namespace，也就是进程的命名空间，它会使命名空间内的这个进程 id 变为 1，而 linux 的初始进程的 id 就是 1，所以这个命名空间内它就是所有进程的父进程了。</p><p>IPC namespace 限制只有这个命名空间内的进程可以相互通信，不能和命名空间外的进程通信。</p><p>而 Mount namespace 会创建一个新的文件系统，命名空间内的文件访问都是在这个文件系统之上。</p><p>类似这样的 namespace 一共有 6 种：</p><ul><li>PID（Process Identification） namespace：进程 ID 的命名空间，提供进程隔离能力</li><li>IPC（Inter-Process Communication） namespace：进程通信的命名空间，提供进程间通信的隔离能力</li><li>MNT（Mount） namespace：文件系统挂载的命名空间，提供磁盘挂载点和文件系统的隔离能力</li><li>Net（Network） namespace：网络的命名空间，提供网络隔离能力</li><li>User namespace：用户和用户组的命名空间，提供用户隔离能力</li><li>UTS（UNIX Timesharing System） namespace：主机名和域名的命名空间，提供主机名隔离能力</li></ul><p>Docker 通过这 6 种命名空间，可以实现资源的隔离。</p><h3 id="Control-Group（CGroup）"><a href="#Control-Group（CGroup）" class="headerlink" title="Control Group（CGroup）"></a>Control Group（CGroup）</h3><p>linux 提供了一种叫 控制组（Control Group, CGroup）的机制可以通过给 控制组 指定参数，来限制控制组可以获取到的资源。比如 cpu 用多少、内存用多少、磁盘用多少。</p><p>创建容器的时候先创建一个 控制组，指定资源的限制，然后把容器进程加到这个 控制组 里，就不会有容器占用过多资源的问题了。</p><p>Docker 通过控制组的机制，可以限制容器对资源的访问，即资源访问限制。</p><h3 id="UnionFS"><a href="#UnionFS" class="headerlink" title="UnionFS"></a>UnionFS</h3><p>联合文件系统（Union File System，UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。镜像可以通过分层来进行继承，基于基础镜像，可以制作各种具体的应用容器。这样如果有多个容器内做了文件修改，只要创建不同的层即可，底层的基础镜像是一样的。</p><p>Docker 通过 UnionFS 的这种分层的镜像存储，写时复制（Copy-on-Write）的机制，极大的减少了文件系统的磁盘占用。</p><h2 id="Docker-的架构"><a href="#Docker-的架构" class="headerlink" title="Docker 的架构"></a>Docker 的架构</h2><p>Docker 的架构图如下：</p><!-- ![docker_structure_inner](/blog/static/imgs/docker_structure.png) --><p><img src="/blog/static/imgs/docker_architecture.svg" alt="docker_architecture_inner"><br>Docker 的一些基本概念：</p><ul><li>Docker 守护进程（Docker deamon, dockerd）： Docker 守护进程（dockerd）侦听 Docker API 请求并管理 Docker 对象，如镜像、容器、网络和 volumes。守护进程还可以与其他守护进程通信以管理 Docker 服务。</li><li>Docker 客户端（docker）： Docker 客户端（docker）是许多 Docker 用户与 Docker 交互的主要方式。当 Docker 用户使用诸如 <code>docker run</code> 之类的命令时，客户端将这些命令发送到 dockerd，dockerd 执行这些命令。Docker 命令使用 docker API 。Docker 客户端可以与多个守护进程通信。</li><li>Docker 对象（Docker objects）： Docker 对象是在使用 Docker 过程中控制与管理的一些对象。<ul><li>镜像（Docker images）： 镜像是一个只读的模板，包含创建 Docker 容器的说明。通常，一个镜像基于另一个镜像，并带有一些额外的定制内容。例如，Docker 用户可以构建一个基于 ubuntu 镜像的镜像，但是安装有 Apache web 服务器和应用程序，以及运行应用程序所需要的配置详细信息。Docker 用户可以创建自己的镜像，也可以只使用其他人创建并在 Docker registry 中发布的镜像。</li><li>容器（Docker containers）： 容器是镜像的可运行实例。Docker 用户可以使用 Docker API 或者 CLI 管理容器。默认情况下，容器与其他容器及其主机相对良好地隔离。Docker 用户可以控制容器的网络、存储或其他底层子系统与其他容器或主机的隔离程度。容器由其映像以及创建或启动时提供给它的任何配置选项定义。移除容器后，未存储在持久存储中的对其状态的任何更改都将消失。</li><li>Docker volumes： Volume 提供了将容器的特定文件系统路径连接回主机的能力（数据持久化的能力）。如果挂载（mounting）了容器中的目录，则在主机上也可以看到该目录中的更改。如果我们跨容器重新启动挂载相同的目录，我们将看到相同的文件。</li></ul></li><li>Docker 桌面端（Docker Desktop）： Docker Desktop 是一款适用于 Mac、Windows 或 Linux 环境的易于安装的应用程序，使 Docker 用户能够构建和共享容器化应用程序和微服务。Docker 桌面端包括 Docker 守护进程（dockerd）、Docker 客户端（docker）、Docker Compose、Docker Content Trust、Kubernetes 和凭证助手（Credential Helper）。</li><li>Docker 仓库（Docker repository）： Docker 仓库可看成一个 Docker 镜像的控制中心。每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</li><li>Docker registry： Docker registry 是 Docker 镜像存储的地方，Docker 用户可以在  Docker registry 获取和发布镜像。默认是 <a href="https://hub.docker.com">Docker Hub</a>。</li><li>主机（Docker Host）： 一个物理主机或者虚拟机，用于运行 Docker 守护进程和容器。</li><li>Docker Compose：Docker Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</li><li>Dockerfile 文件： Dockerfile 是一个基于文本的指令脚本，它使用简单的语法定义创建镜像并运行镜像所需的步骤。Dockerfile 中的每个指令在镜像中创建一个层（layer）。更改 Dockerfile 并重建镜像时，仅重建已更改的层。</li><li>docker-compose.yml 文件： docker-compose.yml 是 <code>docker compose</code> 命令的参数配置文件。</li><li>.dockerignore 文件： .dockerignore 文件表明了在 Dockerfile 文件 的 COPY 指令中需要缓存的文件。</li></ul><h3 id="Docker-和-虚拟机-的区别"><a href="#Docker-和-虚拟机-的区别" class="headerlink" title="Docker 和 虚拟机 的区别"></a>Docker 和 虚拟机 的区别</h3><p>虚拟机：虚拟机是通过 Hypervisor (虚拟机管理系统，常见的有 VMWare workstation、VirtualBox)，虚拟出网卡、cpu、内存等虚拟硬件，再在其上建立虚拟机，每个虚拟机是个独立的操作系统，拥有自己的系统内核。</p><p>容器：容器是利用 namespace 机制将文件系统、进程、网络、设备等资源进行隔离，利用 cgroup 机制对权限、cpu资源进行限制，最终让容器之间互不影响，容器无法影响宿主机。</p><p><img src="/blog/static/imgs/docker_virtual.jpeg" alt="docker_virtual_inner"></p><table><thead><tr><th>对比项</th><th>Docker（容器化）</th><th>虚拟机</th></tr></thead><tbody><tr><td>启动速度</td><td>秒级别</td><td>分钟级别</td></tr><tr><td>硬盘使用</td><td>一般为MB</td><td>一般为GB</td></tr><tr><td>性能</td><td>接近原生</td><td>弱于原生</td></tr><tr><td>系统支持量级</td><td>单机支持上千个容器</td><td>一般支持几十个</td></tr><tr><td>隔离性</td><td>进程级别的隔离</td><td>系统级别隔离</td></tr><tr><td>安全性</td><td>与宿主机共享内核、文件系统等资源，一旦容器内的用户从普通用户权限提升为 root 权限，有可能对其他容器、宿主机造成影响</td><td>虚拟机租户 root 权限和宿主机的 root 虚拟机权限是分离的，甚至使用了硬件隔离，可以防止虚拟机突破和彼此交互</td></tr></tbody></table><p>我们可以看到，Docker 的技术优势体现在 <em>效率</em> 、 <em>性能</em> 和 <em>资源消耗</em> 上，在 <em>安全性</em> 和 <em>隔离级别</em> 上与虚拟机相比较弱。</p><h2 id="Docker-开始教程"><a href="#Docker-开始教程" class="headerlink" title="Docker 开始教程"></a>Docker 开始教程</h2><p>在开始之前，首先需要先 <a href="https://docs.docker.com/get-started/#download-and-install-docker">下载并安装 Docker</a>。Docker 是 Docker Inc.（原 dotCloud 公司） 的产品，它包括了 Docker EE （企业版）和 Docker CE（社区版）。需要注意的是，Docker 的开源代码仓库叫做 <a href="https://github.com/moby/moby">Moby</a>。</p><h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><p><em>首先，克隆一个仓库</em></p><p><a href="https://github.com/docker/getting-started">Getting Started</a> 项目是一个简单的 Github 仓库，它包含了你需要编译镜像并作为容器运行的所有内容。</p><p>通过在一个容器中运行 Git 来克隆这个仓库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --name repo alpine/git clone https://github.com/docker/getting-started.git</span><br><span class="line">docker cp repo:/git/getting-started/ .</span><br></pre></td></tr></table></figure><h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><p><em>现在，编译镜像</em></p><p>一个 Docker 镜像是一个只为容器服务的私有的文件系统，它提供了容器所需要的所有文件与代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd getting-started</span><br><span class="line">docker build -t docker101tutorial .</span><br></pre></td></tr></table></figure><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p><em>运行你的第一个容器</em></p><p>基于你上一步编译的镜像启动一个容器。运行一个容器会以它私有的资源启动应用程序，与机器的其他部分安全的隔离开来。</p><p>Start a container based on the image you built in the previous step. Running a container launches your application with private resources, securely isolated from the rest of your machine.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80:80 --name docker-tutorial docker101tutorial</span><br></pre></td></tr></table></figure><p>你会发现我们使用了一些参数。这里包含了这些参数的一些信息：</p><p><code>-d</code> - 以独立模式（在后台中）运行容器。<br><code>-p 80:80</code> - 将容器中的80端口与主机的80端口一一映射。打开网络浏览器并导航到 http://localhost:80 来访问教程应用。如果已经有服务监听了 80 端口，你可以指定另一个端口。例如，指定 <code>-p 3000:80</code> 然后通过 http://localhost:3000 来访问应用。<br><code>--name docker-tutorial</code> - 给容器起一个名字 docker-tutorial<br><code>docker101tutorial</code> - 指出使用的镜像。</p><h3 id="share"><a href="#share" class="headerlink" title="share"></a>share</h3><p><em>现在保存并分享你的镜像</em></p><p>保存并分享你的镜像到 Docker Registry（默认 Registry 为 Docker Hub，需要通过 <code>docker login</code> 命令登录）来使其他用户可以容易地在任何目标机器下载和运行镜像。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker tag docker101tutorial  /docker101tutorial</span><br><span class="line">docker push /docker101tutorial</span><br></pre></td></tr></table></figure><h2 id="Docker-常用功能"><a href="#Docker-常用功能" class="headerlink" title="Docker 常用功能"></a>Docker 常用功能</h2><p>使用 <code>docker COMMAND --help</code> 可以查看具体 COMMAND 命令的用法和作用。</p><h3 id="镜像管理-image"><a href="#镜像管理-image" class="headerlink" title="镜像管理 image"></a>镜像管理 image</h3><p>Docker 中经常要做的是将镜像拉取到本地，和镜像相关的有一些常用的操作包括：</p><p>登录 Docker registry、拉取镜像、编译镜像、移除镜像 等。</p><p>管理镜像的命令都集合在 <code>docker image COMMAND</code> 命令下，包括 <code>build</code> <code>history</code> <code>import</code> <code>inspect</code> <code>save/load</code> <code>ls</code> <code>prune</code> <code>pull/push</code> <code>rm</code> <code>tag</code>。</p><ol><li><code>docker login [OPTIONS] [SERVER] [flags]</code></li></ol><p>登录 Docker registry 或者云后台。如果没有提供 registry 服务器，默认由守护进程定义。</p><table><thead><tr><th>参数</th><th>完整参数</th><th>作用</th></tr></thead><tbody><tr><td><code>-p</code></td><td><code>--password string</code></td><td>密码</td></tr><tr><td><code>-u</code></td><td><code>--username string</code></td><td>用户名</td></tr></tbody></table><ol start="2"><li><code>docker pull [OPTIONS] NAME[:TAG|@DIGEST]</code></li></ol><p>从 registry 拉取一个镜像或者一个仓库</p><table><thead><tr><th>参数</th><th>完整参数</th><th>作用</th></tr></thead><tbody><tr><td><code>-a</code></td><td><code>--all-tags</code></td><td>下载仓库中所有已打标签的镜像</td></tr><tr><td></td><td><code>--disable-content-trust</code></td><td>跳过镜像认证 (默认为 true)</td></tr><tr><td></td><td><code>--platform string</code></td><td>如果服务器支持多平台，则设置平台</td></tr><tr><td><code>-q</code></td><td><code>--quiet</code></td><td>不显示详细输出日志</td></tr></tbody></table><ol start="3"><li><code>docker build [OPTIONS] PATH | URL | -</code></li></ol><p>根据 Dockerfile 编译镜像</p><table><thead><tr><th>参数</th><th>完整参数</th><th>作用</th></tr></thead><tbody><tr><td><code>-f</code></td><td><code>--file string</code></td><td>Dockerfile的名字（默认是 ‘PATH/Dockerfile’）</td></tr><tr><td></td><td><code>--network string</code></td><td>设置运行实例在运行时的网络模式（默认为 default）</td></tr><tr><td></td><td><code>--no-cache</code></td><td>编译镜像时不使用缓存</td></tr></tbody></table><ol start="4"><li><code>docker rmi [OPTIONS] IMAGE [IMAGE...]</code></li></ol><p>移除一个或多个镜像</p><table><thead><tr><th>参数</th><th>完整参数</th><th>作用</th></tr></thead><tbody><tr><td><code>-f</code></td><td><code>--force</code></td><td>强制移除镜像</td></tr></tbody></table><ol start="5"><li><code>docker save [OPTIONS] IMAGE [IMAGE...]</code></li></ol><p>保存一个或多个镜像到一个 tar 包中（默认流式输出到 STDOUT）</p><table><thead><tr><th>参数</th><th>完整参数</th><th>作用</th></tr></thead><tbody><tr><td><code>-o</code></td><td><code>--output string</code></td><td>写入到文件中，而不是STDOUT</td></tr></tbody></table><ol start="6"><li><code>docker load [OPTIONS]</code></li></ol><p>从一个 tar 包或者 STDIN 加载一个镜像</p><table><thead><tr><th>参数</th><th>完整参数</th><th>作用</th></tr></thead><tbody><tr><td><code>-i</code></td><td><code>--input string</code></td><td>从 tar 包读取，而不是 STDIN</td></tr><tr><td><code>-q</code></td><td><code>--quiet</code></td><td>不显示详细输出日志</td></tr></tbody></table><ol start="7"><li><code>docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</code></li></ol><p>从一个 tar 包导入<em>容器</em>创建一个文件系统镜像</p><table><thead><tr><th>参数</th><th>完整参数</th><th>作用</th></tr></thead><tbody><tr><td><code>-c</code></td><td><code>--change list</code></td><td>对创建的镜像应用 Dockerfile 指令</td></tr><tr><td><code>-m</code></td><td><code>--message string</code></td><td>为导入的镜像设置提交消息</td></tr></tbody></table><ol start="8"><li><code>docker inspect [OPTIONS] NAME|ID [NAME|ID...]</code></li></ol><p>显示一个或多个 Docker 对象（包括镜像、容器、volume 等）的详细信息</p><table><thead><tr><th>参数</th><th>完整参数</th><th>作用</th></tr></thead><tbody><tr><td><code>-f</code></td><td><code>--format string</code></td><td>将输出字符串以给定的 Go 模板形式格式化</td></tr></tbody></table><ol start="9"><li><code>docker history [OPTIONS] IMAGE</code></li></ol><p>显示镜像的历史</p><table><thead><tr><th>参数</th><th>完整参数</th><th>作用</th></tr></thead><tbody><tr><td></td><td><code>--format string</code></td><td>使用 Go 模板优化显示镜像</td></tr><tr><td><code>-H</code></td><td><code>--human</code></td><td>以人类可读的格式打印大小和日期（默认为 true）</td></tr><tr><td><code>-q</code></td><td><code>--quiet</code></td><td>仅仅显示镜像 ID</td></tr></tbody></table><ol start="10"><li><code>docker image ls [OPTIONS] [REPOSITORY[:TAG]]</code></li></ol><p>列出所有镜像</p><table><thead><tr><th>参数</th><th>完整参数</th><th>作用</th></tr></thead><tbody><tr><td><code>-a</code></td><td><code>--all</code></td><td>显示所有镜像（默认隐藏中间的镜像）</td></tr><tr><td></td><td><code>--digests</code></td><td>显示摘要</td></tr><tr><td><code>-f</code></td><td><code>--filter filter</code></td><td>根据提供的条件过滤输出</td></tr><tr><td></td><td><code>--format string</code></td><td>使用 Go 模板优化显示镜像</td></tr></tbody></table><h3 id="容器管理-container"><a href="#容器管理-container" class="headerlink" title="容器管理 container"></a>容器管理 container</h3><p>管理容器是 Docker 中最常见的操作，包括 查看容器列表、查看容器详情、创建容器、在容器中运行命令、启动容器、暂停容器、停止容器、移除容器 等。</p><p>管理容器的命令都集合在 <code>docker container COMMAND</code> 命令下，常用的命令包括：<code>ps|ls|list</code> <code>create/rm</code> <code>exec</code> <code>run</code> <code>start/stop</code> <code>pause/unpause</code> <code>logs</code>、<code>export</code>、<code>inspect</code>、<code>kill</code> 等。</p><ol><li><code>docker ps [OPTIONS]</code></li></ol><p>查看所有容器</p><table><thead><tr><th>参数</th><th>完整参数</th><th>作用</th></tr></thead><tbody><tr><td><code>-a</code></td><td><code>--all</code></td><td>显示所有容器（默认只显示运行中的容器）</td></tr><tr><td><code>-f</code></td><td><code>--filter filter</code></td><td>基于提供的条件过滤输出</td></tr><tr><td><code>-n</code></td><td><code>--last int</code></td><td>显示最后创建的 n 个容器（包括所有状态）</td></tr><tr><td><code>-l</code></td><td><code>--lastest</code></td><td>显示最后创建的容器（包括所有状态）</td></tr><tr><td><code>-s</code></td><td><code>--size</code></td><td>显示总文件大小</td></tr></tbody></table><ol start="2"><li><code>docker create [OPTIONS] IMAGE [COMMAND] [ARG...]</code></li></ol><p>创建一个新的容器</p><table><thead><tr><th>参数</th><th>完整参数</th><th>作用</th></tr></thead><tbody><tr><td><code>-c</code></td><td><code>--cpu-shares int</code></td><td>CPU占用（相对比重）</td></tr><tr><td></td><td><code>--cpus decimal</code></td><td>CPU数量</td></tr><tr><td><code>-e</code></td><td><code>--env list</code></td><td>设置环境变量</td></tr><tr><td><code>-h</code></td><td><code>--hostname strin</code></td><td>容器主机名</td></tr><tr><td><code>-i</code></td><td><code>--interactive</code></td><td>保持 STDIN 打开，即使未连接（以交互模式运行容器）</td></tr><tr><td><code>-m</code></td><td><code>--memory bytes</code></td><td>内存限制</td></tr><tr><td><code>-p</code></td><td><code>--publish list</code></td><td>发布一个容器的端口到主机</td></tr><tr><td><code>-t</code></td><td><code>--tty</code></td><td>分配一个伪TTY</td></tr><tr><td><code>-u</code></td><td><code>--user string</code></td><td>用户名或者UID（格式：`&lt;name</td><td>uid&gt;[:group</td><td>gid]`）</td></tr><tr><td><code>-v</code></td><td><code>--volume list</code></td><td>绑定挂载一个 volume</td></tr></tbody></table><ol start="3"><li><code>docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</code></li></ol><p>在一个运行的容器中运行命令</p><table><thead><tr><th>参数</th><th>完整参数</th><th>作用</th></tr></thead><tbody><tr><td><code>-d</code></td><td><code>--detach</code></td><td>以后台模式执行命令</td></tr><tr><td><code>-e</code></td><td><code>--env list</code></td><td>设置环境变量</td></tr><tr><td><code>-i</code></td><td><code>--interactive</code></td><td>保持 STDIN 打开，即使未连接（以交互模式运行容器）</td></tr><tr><td><code>-t</code></td><td><code>--tty</code></td><td>分配一个伪TTY</td></tr><tr><td><code>-u</code></td><td><code>--user string</code></td><td>用户名或者UID（格式：`&lt;name</td><td>uid&gt;[:group</td><td>gid]`）</td></tr><tr><td><code>-w</code></td><td><code>--workdir string</code></td><td>在容器中的工作目录</td></tr></tbody></table><ol start="4"><li><code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code></li></ol><p>在一个新容器中运行命令（根据镜像生成新的容器并运行命令，相当于 <code>docker create</code> + <code>docker exec</code> ）</p><table><thead><tr><th>参数</th><th>完整参数</th><th>作用</th></tr></thead><tbody><tr><td><code>-c</code></td><td><code>--cpu-shares int</code></td><td>CPU占用（相对比重）</td></tr><tr><td></td><td><code>--cpus decimal</code></td><td>CPU数量</td></tr><tr><td><code>-d</code></td><td><code>--detach</code></td><td>以后台模式运行容器并打印容器 ID</td></tr><tr><td><code>-e</code></td><td><code>--env list</code></td><td>设置环境变量</td></tr><tr><td><code>-h</code></td><td><code>--hostname strin</code></td><td>容器主机名</td></tr><tr><td><code>-i</code></td><td><code>--interactive</code></td><td>保持 STDIN 打开，即使未连接（以交互模式运行容器）</td></tr><tr><td><code>-m</code></td><td><code>--memory bytes</code></td><td>内存限制</td></tr><tr><td></td><td><code>--name string</code></td><td>给容器起名</td></tr><tr><td><code>-p</code></td><td><code>--publish list</code></td><td>发布一个容器的端口到主机</td></tr><tr><td><code>-t</code></td><td><code>--tty</code></td><td>分配一个伪TTY</td></tr><tr><td><code>-u</code></td><td><code>--user string</code></td><td>用户名或者UID（格式：`&lt;name</td><td>uid&gt;[:group</td><td>gid]`）</td></tr><tr><td><code>-v</code></td><td><code>--volume list</code></td><td>绑定挂载一个 volume</td></tr></tbody></table><ol start="3"><li><code>docker start [OPTIONS] CONTAINER [CONTAINER...]</code></li></ol><p>启动一个或多个容器</p><ol start="4"><li><code>docker stop [OPTIONS] CONTAINER [CONTAINER...]</code></li></ol><p>停止一个或多个容器</p><table><thead><tr><th>参数</th><th>完整参数</th><th>作用</th></tr></thead><tbody><tr><td><code>-t</code></td><td><code>--time int</code></td><td>停止前等待的秒数（默认 10）</td></tr></tbody></table><ol start="5"><li><code>docker pause CONTAINER [CONTAINER...]</code></li></ol><p>暂停一个或多个容器的所有进程</p><ol start="6"><li><code>docker rm [OPTIONS] CONTAINER [CONTAINER...]</code></li></ol><p>移除一个或多个容器</p><table><thead><tr><th>参数</th><th>完整参数</th><th>作用</th></tr></thead><tbody><tr><td><code>-f</code></td><td><code>--force</code></td><td>强制移除一个运行着的容器（使用 SIGKILL）</td></tr><tr><td><code>-l</code></td><td><code>--link</code></td><td>移除特定的链接</td></tr><tr><td><code>-v</code></td><td><code>--volumes</code></td><td>移除与容器相关的匿名 volumes</td></tr></tbody></table><ol start="7"><li><code>docker logs [OPTIONS] CONTAINER</code></li></ol><p>获取一个容器的日志</p><table><thead><tr><th>参数</th><th>完整参数</th><th>作用</th></tr></thead><tbody><tr><td></td><td><code>--details</code></td><td>展示日志详情</td></tr><tr><td><code>-f</code></td><td><code>--follow</code></td><td>跟踪日志输出</td></tr><tr><td></td><td><code>--since string</code></td><td>需要展示日志的开始时间（例如，2013-01-02T13:23:37Z）或相对开始时间（例如，42m 代表42分钟内）</td></tr><tr><td><code>-n</code></td><td><code>--tail string</code></td><td>显示日志末尾的行数（默认 所有）</td></tr><tr><td><code>-t</code></td><td><code>--timestamps</code></td><td>展示时间戳</td></tr><tr><td></td><td><code>--until string</code></td><td>需要展示日志的截止时间（例如，2013-01-02T13:23:37Z）或相对截止时间（例如，42m 代表42分钟内）</td></tr></tbody></table><h3 id="发布镜像-pull-push"><a href="#发布镜像-pull-push" class="headerlink" title="发布镜像 pull/push"></a>发布镜像 pull/push</h3><ol><li><code>docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]</code></li></ol><p>创建一个标签 TARGET_IMAGE 指向 SOURCE_IMAGE</p><ol start="2"><li><code>docker push [OPTIONS] NAME[:TAG]</code></li></ol><p>将一个镜像或仓库 NAME 推送到 registry</p><table><thead><tr><th>参数</th><th>完整参数</th><th>作用</th></tr></thead><tbody><tr><td><code>-a</code></td><td><code>--all-tags</code></td><td>推送仓库中所有已打标签的镜像</td></tr><tr><td></td><td><code>--disable-content-trust</code></td><td>跳过镜像签名 (默认为 true)</td></tr><tr><td><code>-q</code></td><td><code>--quiet</code></td><td>不显示详细输出日志</td></tr></tbody></table><h3 id="数据持久化-volume"><a href="#数据持久化-volume" class="headerlink" title="数据持久化 volume"></a>数据持久化 volume</h3><p>默认的 Docker 引擎可以通过两种方式来将宿主的数据挂载到容器中 named volume、bind mounts。</p><p><img src="/blog/static/imgs/docker_mount_volume.png" alt="docker_mount_volume_inner"></p><h4 id="named-volume"><a href="#named-volume" class="headerlink" title="named volume"></a>named volume</h4><p>named volume 可以视为一个简单的数据桶，Docker 维护磁盘上的物理位置，Docker 用户只需要记住 volume 的名称。当使用 volume 时，Docker 会确保提供正确的数据。</p><p>我们需要首先通过 <code>docker volume create</code> 创建一个 volume，然后在 <code>docker create</code> 或者 <code>docker run</code> 创建容器的时候通过 <code>-v</code> 参数指定要使用的 volume 名称和路径。</p><ol><li><code>docker volume create [OPTIONS] [VOLUME]</code></li></ol><p>创建一个 volume</p><table><thead><tr><th>参数</th><th>完整参数</th><th>作用</th></tr></thead><tbody><tr><td><code>-d</code></td><td><code>-driver string</code></td><td>表明 volume 的驱动名（默认 local）</td></tr><tr><td></td><td><code>--label list</code></td><td>设置 volume 的元数据</td></tr><tr><td><code>-o</code></td><td><code>--opt map</code></td><td>设置驱动特殊参数（默认 map[]）</td></tr></tbody></table><ol start="2"><li><code>docker volume inspect [OPTIONS] VOLUME [VOLUME...]</code></li></ol><p>显示一个或多个 volume 的详细信息</p><table><thead><tr><th>参数</th><th>完整参数</th><th>作用</th></tr></thead><tbody><tr><td><code>-f</code></td><td><code>--format string</code></td><td>将输出字符串以给定的 Go 模板形式格式化</td></tr></tbody></table><h4 id="bind-mounts"><a href="#bind-mounts" class="headerlink" title="bind mounts"></a>bind mounts</h4><p>通过 bind mounts，我们可以控制主机上的确切的挂载点。bind mounts 可以用来持久化数据，但它通常用于向容器中提供额外的数据。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -dp 3000:3000 \</span><br><span class="line">  -w /app -v <span class="string">&quot;<span class="subst">$(pwd)</span>:/app&quot;</span> \</span><br><span class="line">  node:12-alpine \</span><br><span class="line">  sh -c <span class="string">&quot;yarn install &amp;&amp; yarn run dev&quot;</span></span><br></pre></td></tr></table></figure><p>bind mounts 也是通过在 <code>docker create</code> 或者 <code>docker run</code> 创建容器的时候通过 <code>-v</code> 参数来指定绑定的路径，如上所示 <code>&quot;$(pwd):/app&quot;</code> 即为需要绑定挂载的主机路径。使用 bind mounts 在本地开发设置中非常常见。优点是开发机器不需要安装所有的构建工具和环境。只需一个 docker 运行命令，开发环境就可以启动了。</p><h4 id="其他持久化方案"><a href="#其他持久化方案" class="headerlink" title="其他持久化方案"></a>其他持久化方案</h4><p>bind mounts 和 named volume 是 Docker 引擎附带的两种主要持久化方案。但是，还有其他 volume 驱动程序可用于支持其他用例（SFTP、Ceph、NetApp、S3等）。</p><h3 id="网络管理-network"><a href="#网络管理-network" class="headerlink" title="网络管理 network"></a>网络管理 network</h3><p>默认情况下，容器之间是互相隔离无法通信的，两个相关的容器只能通过 <em>网络</em> 来进行通信。</p><p>与 <em>网络</em> 相关的命令可以通过 <code>docker network COMMAND</code> 来调用，包括 <code>connect/disconnect</code> <code>create</code> <code>inspect</code> <code>ls</code> <code>prune</code> <code>rm</code></p><ol><li><code>docker network create [OPTIONS] NETWORK</code></li></ol><p>创建一个网络</p><table><thead><tr><th>参数</th><th>完整参数</th><th>作用</th></tr></thead><tbody><tr><td></td><td><code>--attachable</code></td><td>允许手动附加容器</td></tr><tr><td></td><td><code>--aux-address map</code></td><td>网络驱动使用的辅助 IPv4 或 IPv6（默认 map[]）</td></tr><tr><td><code>-d</code></td><td><code>--driver string</code></td><td>管理网络的驱动（默认 bridge）</td></tr><tr><td><code>-o</code></td><td><code>--opt map</code></td><td>设置驱动的特殊选项（默认 map[]）</td></tr></tbody></table><ol start="2"><li><code>docker network connect [OPTIONS] NETWORK CONTAINER</code></li></ol><p>将一个容器连接到一个网络</p><table><thead><tr><th>参数</th><th>完整参数</th><th>作用</th></tr></thead><tbody><tr><td></td><td><code>--ip</code></td><td>IPv4地址</td></tr><tr><td></td><td><code>--ip6</code></td><td>IPv6地址</td></tr></tbody></table><ol start="3"><li><code>docker network disconnect [OPTIONS] NETWORK CONTAINER</code></li></ol><p>将一个容器从一个网络断开</p><table><thead><tr><th>参数</th><th>完整参数</th><th>作用</th></tr></thead><tbody><tr><td><code>-f</code></td><td><code>--force</code></td><td>强制将一个容器从一个网络断开</td></tr></tbody></table><ol start="4"><li><code>docker network rm NETWORK [NETWORK...]</code></li></ol><p>移除一个或多个网络</p><h3 id="多镜像应用-compose"><a href="#多镜像应用-compose" class="headerlink" title="多镜像应用 compose"></a>多镜像应用 compose</h3><p>Docker Compose 是一个开发用于帮助定义和共享多容器应用程序的工具。使用 Compose，我们可以创建一个 YAML 文件来定义服务，并且使用一个命令，可以将所有容器同时启动或销毁。</p><p>Compose 需要使用 <code>docker-compose COMMAND</code> 或者 <code>docker compose COMMAND</code> 来调用，常用的命令有 <code>build</code> <code>config</code> <code>create/rm</code> <code>up/down</code> <code>start/stop/restart</code> <code>images</code> <code>kill</code> <code>pause/unpause</code> <code>pull/push</code> <code>exec</code> <code>run</code> <code>ps</code> <code>logs</code> <code>port</code> 等。</p><ol><li><code>docker compose up [OPTIONS] [SERVICE...]</code></li></ol><p>创建并启动所有容器</p><table><thead><tr><th>参数</th><th>完整参数</th><th>作用</th></tr></thead><tbody><tr><td></td><td><code>--build</code></td><td>在启动容器前先编译镜像</td></tr><tr><td><code>-d</code></td><td><code>--detach</code></td><td>独立模式，在后台运行容器</td></tr><tr><td></td><td><code>--no-recreate</code></td><td>如果容器已经存在，不重建。与 <code>--force-recrete</code>冲突</td></tr><tr><td><code>-V</code></td><td><code>--renew-anon-volumes</code></td><td>重新创建匿名volume而不是从之前的容器中检索数据</td></tr><tr><td><code>-t</code></td><td><code>--timeout int</code></td><td>在连接容器或容器已经运行时，使用此超时时间（以秒为单位）关闭容器。（默认值为10）</td></tr></tbody></table><ol start="2"><li><code>docker compose down [OPTIONS]</code></li></ol><p>停止并移除所有容器、网络</p><table><thead><tr><th>参数</th><th>完整参数</th><th>作用</th></tr></thead><tbody><tr><td></td><td><code>--remove-orphans</code></td><td>删除 Compose 文件中未定义的服务中的容器</td></tr><tr><td></td><td><code>rmi string</code></td><td>删除服务使用到的镜像，”local”仅仅删除没有指定tag的镜像（”local”</td><td>“all”）</td></tr><tr><td><code>-t</code></td><td><code>--timeout int</code></td><td>停止前等待的秒数（默认 10）</td></tr><tr><td><code>-v</code></td><td><code>--volumes volumes</code></td><td>删除在 Compose 文件的 volume 部分中声明的 named volumes 和附加到容器的匿名 volumes。</td></tr></tbody></table><h3 id="插件管理-plugin"><a href="#插件管理-plugin" class="headerlink" title="插件管理 plugin"></a>插件管理 plugin</h3><p>Docker 可以通过 <code>docker plugin COMMAND</code> 来管理插件，包括以下命令：</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>create</code></td><td>从 rootfs 和配置文件创建插件。插件数据目录必须包含 config.json 和 rootfs 目录。</td></tr><tr><td><code>disable</code></td><td>禁用一个插件</td></tr><tr><td><code>enable</code></td><td>启用一个插件</td></tr><tr><td><code>inspect</code></td><td>显示一个或多个插件的详细信息</td></tr><tr><td><code>install</code></td><td>安装一个插件</td></tr><tr><td><code>ls</code></td><td>列出所有插件</td></tr><tr><td><code>push</code></td><td>发布一个插件到 registry</td></tr><tr><td><code>rm</code></td><td>移除一个或多个插件</td></tr><tr><td><code>set</code></td><td>变更一个插件的设置项</td></tr><tr><td><code>upgrade</code></td><td>更新一个已存在的插件</td></tr></tbody></table><h3 id="安全管理-secret-scan"><a href="#安全管理-secret-scan" class="headerlink" title="安全管理 secret/scan"></a>安全管理 secret/scan</h3><p>Docker Scan 是一个安全扫描工具，可以扫描本地的镜像中的安全漏洞，Docker Scan 是与 <a href="https://snyk.io">Snyk</a> 合作来提供漏洞扫描服务的，所以必须登录 Docker Hub 账号。</p><p><code>docker scan [OPTIONS] IMAGE</code></p><p>对镜像进行安全漏洞扫描</p><table><thead><tr><th>参数</th><th>完整参数</th><th>作用</th></tr></thead><tbody><tr><td><code>-f</code></td><td><code>--file string</code></td><td>与镜像相关的 Dockerfile，提供更多详细的结果</td></tr><tr><td></td><td><code>--json</code></td><td>以 JSON 格式输出结果</td></tr></tbody></table><p>Docker Secret 用于在 Swarm mode 集群中安全的管理密码、密钥证书等敏感信息，并允许在多个 Docker 容器实例之间共享访问指定的秘密信息。<code>docker secret</code> 只能从 Docker Swarm 模式的 manager 节点调用，如果在本机进行试验，需要先执行 <code>docker swarm init</code> 命令。secret 创建之后可以在 <code>docker service create</code> 中通过 <code>--secret</code> 参数使用，或者在 Compose 文件中使用。</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>create</code></td><td>从文件或者 STDIN 创建一个 secret</td></tr><tr><td><code>inspect</code></td><td>显示一个或多个 secret 的详细信息</td></tr><tr><td><code>ls</code></td><td>列出所有的 secret</td></tr><tr><td><code>rm</code></td><td>移除一个或多个 secret</td></tr></tbody></table><h3 id="集群管理-swarm"><a href="#集群管理-swarm" class="headerlink" title="集群管理 swarm"></a>集群管理 swarm</h3><p><a href="https://github.com/docker-archive/classicswarm">Docker Swarm</a> 是 Docker 公司推出的用来管理 docker 集群的平台，</p><p><img src="/blog/static/imgs/docker_swarm.png" alt="docker_swarm_inner"></p><p>Swarm 包括几个基本的概念</p><ul><li>swarm ：集群管理工具</li><li>node：节点，一个节点就是docker集群中的一个实例，我们可以在单台服务器上运行一个或多个节点</li><li>service：应用编排</li><li>task：应用实例</li></ul><p>一个 Swarm 由一个或多个 Docker 节点组成。所有节点通过可靠的网络相连。节点会被配置为管理节点（Manager）或工作节点（Worker）。管理节点负责集群控制面（Control Plane），进行诸如监控集群状态、分发任务至工作节点等操作。工作节点接收来自管理节点的任务并执行。Swarm 的配置和状态信息保存在一套位于所有管理节点上的分布式 etcd 数据库中。该数据库运行于内存中，并保持数据的最新状态。关于该数据库最棒的是，它几乎不需要任何配置，作为 Swarm 的一部分被安装，无须管理。关于集群管理，最大的挑战在于保证其安全性。搭建 Swarm 集群时将不可避免地使用 TLS，因为它被 Swarm 紧密集成。关于应用编排，Swarm 中的最小调度单元是服务。它是随 Swarm 引入的，在 API 中是一个新的对象元素，它基于容器封装了一些高级特性，是一个更高层次的概念。当容器被封装在一个服务中时，我们称之为一个任务或一个副本，服务中增加了诸如扩缩容、滚动升级以及简单回滚等特性。</p><p>与 Swarm 相关的 docker 命令包括 <code>docker swarm</code> <code>docker node</code> <code>docker service</code> <code>docker stack</code> 等。</p><h4 id="Docker-Swarm-与-Kubernetes-对比"><a href="#Docker-Swarm-与-Kubernetes-对比" class="headerlink" title="Docker Swarm 与 Kubernetes 对比"></a>Docker Swarm 与 Kubernetes 对比</h4><p>Docker Swarm 是 Docker 公司于 2015 年初发布的一款容器编排工具。Kubernetes 是 2014年中发布的一款容器编排工具，并得到了 Google 和 RedHat 的支持。</p><p>Docker Swarm 优势：</p><ol><li>架构简单，部署运维成本较低</li><li>启动速度快</li></ol><p>Docker Swarm 劣势：</p><ol><li>无法提供更精细的管理</li><li>网络问题</li><li>容器可靠性</li></ol><p>Kubernetes 优势：</p><ol><li>管理更趋于完善稳定</li><li>健康机制完善</li><li>轻松应对复杂的网络问题</li></ol><p>Kubernetes 劣势：</p><ol><li>配置、搭建稍显复杂，学习成本高</li><li>启动速度稍逊</li></ol><h2 id="Dockerfile-参考"><a href="#Dockerfile-参考" class="headerlink" title="Dockerfile 参考"></a>Dockerfile 参考</h2><p>Dockerfile 的用法详见 <a href="https://docs.docker.com/engine/reference/builder/">Dockerfile reference</a>。<br>镜像是通过 Dockerfile 来描述的，Dockerfile 遵循以下格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># parser directive</span></span><br><span class="line"><span class="comment"># Comment</span></span><br><span class="line">INSTRUCTION arguments</span><br></pre></td></tr></table></figure><h3 id="解析指令（parser-directive）"><a href="#解析指令（parser-directive）" class="headerlink" title="解析指令（parser directive）"></a>解析指令（parser directive）</h3><p>解析器指令是可选的，并且会影响后续处理 Dockerfile 的方式。解析器指令不会将层添加到构建中，并且不会显示为构建步骤。解析器指令以<code># directive=value</code> 的方式使用。 一个指令只能使用一次。</p><ul><li>syntax：定义用于构建 Dockerfile 的 Dockerfile 语法的位置，仅在使用BuildKit后端时可用，在使用经典构建器后端时被忽略。</li><li>escape：设置用于转义 Dockerfile。 如果未指定，则默认转义字符为 <code>\</code> 。</li></ul><h3 id="指令（INSTRUCTION）"><a href="#指令（INSTRUCTION）" class="headerlink" title="指令（INSTRUCTION）"></a>指令（INSTRUCTION）</h3><p>Dokcer 是分层存储的，修改的时候会创建一个新的层，所以这里的每一行（每个指令）都会创建一个新的层。</p><ul><li>ENV: 用于声明环境变量</li><li>ARG：必须在 FROM 指令之前声明，指定镜像参数，相当于 <code>docker build</code> 命令中的 <code>--build-arg &lt;varname&gt;=&lt;value&gt;</code> 参数</li><li>ONBUILD：向镜像添加一个触发指令，当镜像用作另一个构建的基础时，该触发指令将在以后执行。触发器将在下游构建的上下文中执行，就像它是在下游 Dockerfil e中的 FROM 指令之后立即插入的一样。</li><li>FROM：初始化一个新的构建阶段并为后续指令设置 <em>基本镜像</em>，一个 Dockerfile 文件必须以 FROM 指令开始。</li><li>WORKDIR：为 RUN、CMD、ENTRYPOINT、COPY、ADD 指令指定当前工作目录</li><li>USER：设置用户名（或UID）和可选的用户组（或GID），以用作当前阶段剩余时间的默认用户和组。给定的用户将作为 RUN 、ENTRYPOINT、CMD 指令的用户</li><li>VOLUME：创建具有指定名称的装载点，并将其标记为保存来自本地主机或其他容器的外部装载 volume。</li><li>LABEL：为镜像添加元数据</li><li>ADD：复制新文件，目录或者远程文件 URL，将其从原地址添加到镜像中的地址</li><li>COPY：复制新文件，目录，将其从原地址添加到镜像中的地址</li><li>EXPOSE：声明当前容器要监听的网络端口</li><li>RUN：将在当前镜像之上的新层中执行任何命令并提交结果</li><li>CMD：容器启动的时候执行的命令，一个 Dockerfile 文件只有最后一个 CMD 指令会生效。</li><li>ENTRYPOINT：将一个容器配置为可执行的运行</li><li>STOPSIGNAL：设置退出时将会被发送到容器的系统调用信号</li><li>HEALTHCHECK：告知 Docker 如何检测一个容器是否运行</li><li>SHELL：可以覆盖默认使用的 SHELL 类型。Linux 默认的 shell 为 <code>[&quot;/bin/sh&quot;, &quot;-c&quot;]</code> Windows 默认为 <code>[&quot;cmd&quot;, &quot;/S&quot;, &quot;/C&quot;]</code></li></ul><p>一个常见的 nodejs 应用的 Dockerfile 如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># build stage</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">10</span> AS build_image</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm install &amp;&amp; npm run build</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># production stage</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=build_image /app/dist ./dist</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm i -g http-server</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> http-server ./dist</span></span><br></pre></td></tr></table></figure><p>我们把两个镜像的生成过程写到了一个 Dockerfile 里，这是 Docker 支持的多阶段构建。</p><ol><li><code>FROM node:10</code> 表示这个镜像是基于 <code>node:10</code> 来构建的，<code>AS build_image</code>，这是把第一个镜像命名为 build_image。</li><li><code>WORKDIR /app</code> 表示当前工作目录是 /app 。</li><li><code>COPY . /app</code> 表示将当前路径下的内容复制到 /app 路径下</li><li><code>EXPOSE 8080</code> 表示当前容器要访问的网络端口为 8080 端口</li><li><code>RUN npm install &amp;&amp; npm run build</code> 表示在编译的时候（<code>docker build</code>）执行 <code>npm install &amp;&amp; npm run build</code></li><li><code>COPY --from=build_image /app/dist ./dist</code> 表示将来自 build_image 镜像的 <code>/app/dist</code> 路径下的内容复制到 <code>./dist</code> 路径下</li><li><code>RUN npm i -g http-server</code> 表示在变异的时候运行 <code>npm i -g http-server</code></li><li><code>CMD http-server ./dist</code> 表示在创建容器（<code>docker create</code>）的时候执行 <code>http-server ./dist</code></li></ol><p>一个常见的 前端 项目的 Dockerfile 如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># build stage</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">14.15</span>.<span class="number">0</span> as build-stage</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> package.json ./</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm install</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm run build</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># production stage</span></span><br><span class="line"><span class="keyword">FROM</span> nginx:stable-perl as production-stage</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=build-stage /app/dist /usr/share/nginx/html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=build-stage /app/default.conf /etc/nginx/conf.d/default.conf</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>与 nodejs 项目类似也是编译阶段一个镜像，发布阶段一个镜像。 <code>npm install</code> 和 <code>npm run build</code> 分开的好处是可以在 .dockerignore 文件中添加 node_moudules 从而对依赖包进行缓存。</p><p>如果是公网开放的服务，可以在编译后将前端静态资源文件（js、css、ttf、png、jpg、jpeg、gif、svg文件等）上传到云存储服务器，并开启 CDN 服务，这样用户端下载静态资源文件会更快，体验会更好。</p><h3 id="Dockerfile-最佳实践"><a href="#Dockerfile-最佳实践" class="headerlink" title="Dockerfile 最佳实践"></a>Dockerfile 最佳实践</h3><ul><li>不要安装无效软件包</li><li>应简化镜像中同时运行的进程数，理想状况下，每个镜像应该只有一个进程</li><li>当无法避免同一镜像运行多进程时，应选择合理的初始化进程（init process）</li><li>最小化层级<ul><li>最新的 docker 只有 RUN COPY ADD 创建新层，其他指令创建临时层，不会增加镜像大小<ul><li>比如 EXPOSE 指令就不会生成新层</li></ul></li><li>多条 RUN 指令可通过连接符成一条指令集以减少层数</li><li>通过多端构建减少镜像层数</li></ul></li><li>把多行参数按字母排序，可减少可能出现的重复参数，并且提高可读性</li><li>编写 Dockerfile 的时候，应该把变更频率低的编译指令优先构建以便放在镜像底层以有效利用 build cache</li><li>复制文件时，每个文件应独立复制，这确保某个文件变更时，只影响该文件对应的缓存</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结合附加符号</title>
      <link href="/blog/2022/08/30/TIPS-%E7%BB%93%E5%90%88%E9%99%84%E5%8A%A0%E7%AC%A6%E5%8F%B7/"/>
      <url>/blog/2022/08/30/TIPS-%E7%BB%93%E5%90%88%E9%99%84%E5%8A%A0%E7%AC%A6%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<p><a href="https://unicode-table.com/cn/blocks/combining-diacritical-marks/">结合附加符号</a>（combining diacritical marks）是指一类比较特殊的字符，这些字符一般不会单独存在，而是结合其他字符一同出现来表达不同的含义。汉语环境下，比较典型的例子就是汉语拼音的声调。</p><p>结合附加符号的 Unicode 范围是 0300-036F，字符数量总共有 112 个。其中，汉语声调字符包括：</p><table><thead><tr><th>名字</th><th>样式</th><th>Unicode编号</th><th>HTML实体代码</th><th>汉语声调</th></tr></thead><tbody><tr><td>组合用长音符</td><td>̄</td><td>U+0304</td><td><code>&amp;#772;</code></td><td>阴平</td></tr><tr><td>组合用锐音符</td><td>́</td><td>U+0301</td><td><code>&amp;#769;</code></td><td>阳平</td></tr><tr><td>组合用抑扬符</td><td>̌</td><td>U+030C</td><td><code>&amp;#780;</code></td><td>上声</td></tr><tr><td>组合用抑音符</td><td>̀</td><td>U+0300</td><td><code>&amp;#768;</code></td><td>去声</td></tr></tbody></table><p>Javascript 中使用 <code>String.fromCharCode()</code> 可以返回由指定的 UTF-16 代码单元序列创建的字符串。例如，<code>String.fromCharCode(98, 97, 768, 32, 98, 97)</code> 返回  <code>bà ba</code>，而 <code>bà ba</code> 的长度为 6。</p><p>结合附加符号有一个特点是可以附加在前一个字符上，这就导致前一个字符的实际显示高度可能会变化，例如：</p><p><img src="/blog/static/imgs/cdm.png" alt="cdm_inner"></p><p>考虑到这种情况，在渲染文本的时候，如果文本有可能含有结合附加符号最好限制一下行高度和文本渲染区域的高度，防止影响区域外的内容。</p>]]></content>
      
      
      
        <tags>
            
            <tag> encode </tag>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx小抄</title>
      <link href="/blog/2022/08/25/CS-nginx%E5%B0%8F%E6%8A%84/"/>
      <url>/blog/2022/08/25/CS-nginx%E5%B0%8F%E6%8A%84/</url>
      
        <content type="html"><![CDATA[<h2 id="nginx-介绍"><a href="#nginx-介绍" class="headerlink" title="nginx 介绍"></a>nginx 介绍</h2><p>nginx [engine x] 是一款 HTTP 和反向代理服务器、邮件代理服务器和通用 TCP/UDP 代理服务器，最初由 Igor Sysoev 编写。根据 Netcraft 提供的数据，截止2022年7月，nginx 服务或者代理了 21.55% 最繁忙的站点，包括 Dropbox、Netflix、Yandex 等知名网站和应用。nginx 的源代码和文档以 2-clause BSD 许可分发，对开发者十分友好。</p><p>nginx 最常用的功能之一是作为 HTTP 服务器使用，nginx 可以提供的 HTTP 服务器功能包括：</p><ol><li>提供静态文件路由、文件描述符缓存</li><li>带缓存的加速反向代理、负载均衡和容错</li><li>模块化结构。支持包括 gzipping 、XSLT 、SSI 和 图像转换 过滤</li><li>SSL 和 TLS 支持</li><li>支持 HTTP/2</li><li>基于名称和基于 IP 的虚拟服务器</li><li>基于 客户端IP地址、 密码（HTTP基本认证）和 子请求结果 的访问控制</li><li>验证 HTTP referer</li><li>限制 来自一个地址 的同时连接 或 请求的数量</li><li>基于IP的地理定位</li><li>A/B 测试<br>…</li></ol><p>可以看到 nginx 是十分强大的，支持 HTTP 服务器的几乎所有功能，而且 nginx 的配置也十分简单灵活，支持的操作系统亦十分广泛，包括 FreeBSD、Linux、Solaris、macOS、Windows Server 等常见的服务器系统都支持。</p><p>nginx 有一个主进程和几个工作进程。主进程的主要目的是读取和评估配置，并维护工作进程。工作进程对请求进行实际处理。nginx 采用基于事件的模型和依赖于操作系统的机制来有效地在工作进程之间分配请求。工作进程的数量在配置文件中定义，并且可以针对给定的配置进行固定或自动调整为可用 CPU 内核的数量。</p><p>nginx 及其模块的工作方式在配置文件中确定。默认情况下，配置文件被命名为 nginx.conf 并放置在目录 <code>/usr/local/nginx/conf</code>、 <code>/etc/nginx</code> 或 <code>/usr/local/etc/nginx</code> 中。</p><h2 id="nginx-安装"><a href="#nginx-安装" class="headerlink" title="nginx 安装"></a>nginx 安装</h2><p>nginx 的安装过程如下，以 macOS 为例：</p><ol><li>通过 Homebrew 安装</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install nginx</span><br></pre></td></tr></table></figure><p>nginx 默认被安装在 <code>/usr/local/Cellar/nginx/</code><br>conf文件默认被安装在 <code>/usr/local/etc/nginx/nginx.conf</code></p><ol start="2"><li>将 nginx 命令添加到系统环境变量 Path 中</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=&quot;$PATH:/usr/local/Cellar/nginx/1.23.1/bin&quot;</span><br></pre></td></tr></table></figure><ol start="3"><li>开启 nginx</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure><ol start="4"><li>访问 Web 页面</li></ol><p>nginx 默认开启 8080 端口的 http 服务，可以通过 <code>http://localhost:8080</code> 访问 nginx 的默认页面。默认页面的位置在 <code>/usr/local/Cellar/nginx/1.23.1/html/index.html</code>。</p><ol start="5"><li>查看 nginx 日志</li></ol><p>日志存放在 <code>/usr/local/var/log/nginx/*.log</code>，其中 access.log 是访问日志，error.log 是错误日志。</p><h2 id="nginx-命令"><a href="#nginx-命令" class="headerlink" title="nginx 命令"></a>nginx 命令</h2><p>要启动 nginx，直接运行 nginx 可执行文件即可，nginx 一旦启动，就可以通过 -s 参数调用可执行文件来控制它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s [signal]</span><br></pre></td></tr></table></figure><p>signal 包括：</p><ul><li>stop 快速关闭</li><li>quit 优雅的关闭</li><li>reload 重载配置文件</li><li>reopen 重新打开日志文件</li></ul><p>执行 <code>ps -ax | grep nginx</code> 可以查看所有正在运行的 nginx 进程的列表。</p><p>nginx 的主进程 ID 默认记录在 <code>/usr/local/nginx/logs/nginx.pid</code> 中</p><h2 id="nginx-配置"><a href="#nginx-配置" class="headerlink" title="nginx 配置"></a>nginx 配置</h2><p>nginx.conf 配置文件的结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include mime.types;</span><br><span class="line">    default_type application/octet-stream;</span><br><span class="line">    # access_log logs/access.log main;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       8080 backlog=4096;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        #...</span><br><span class="line">    &#125;</span><br><span class="line">    include servers/*;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nginx 配置由模块（moudle）组成，这些模块由配置文件中指定的指令（directive）控制。指令分为 <em>简单指令</em> 和 <em>块指令</em> 。一个简单的指令由 <em>名称</em> 和 <em>参数</em> 组成，由空格分隔并以分号结尾。块指令与简单指令具有相同的结构，但它不是以分号结尾，而是以一组由大括号包围的附加指令。如果块指令可以在大括号内包含其他指令，则称为上下文（context）（例如： events、 http、 server 和 location）。<br>放置在任何上下文之外的配置文件中的指令被认为是在 主上下文（main context） 中。例如，<code>events</code> 和 <code>http</code> 指令包括在 主上下文 中，<code>server</code> 指令在 <code>http</code> 中，而 <code>location</code> 在 <code>server</code> 中。<code>#</code> 符号之后的是注释。</p><p>nginx 处理连接的速度非常快，一般规则是当连接建立时，它被放入监听套接字的“监听”队列中。</p><p>显示当前监听队列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -Lan</span><br></pre></td></tr></table></figure><p>结果类似如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Current listen queue sizes (qlen/incqlen/maxqlen)</span><br><span class="line">Listen         Local Address</span><br><span class="line">0/0/128        *.12345</span><br><span class="line">10/0/128        *.80</span><br><span class="line">0/0/128        *.8080</span><br></pre></td></tr></table></figure></p><p>为了获得最佳性能，需要增加在操作系统和 nginx 配置中排队等待 nginx 接受的最大连接数，将 <code>net.core.somaxconn</code> 内核参数的值从其默认值 (128) 增加到一个足够高的值以应对大量流量。</p><p>对于 FreeBSD，运行命令 <code>sudo sysctl kern.ipc.somaxconn=4096</code>；对于 Linux，运行命令 <code>sudo sysctl -w net.core.somaxconn=4096</code>，使用文本编辑器将 <code>net.core.somaxconn = 4096</code> 添加到 <code>/etc/sysctl.conf</code> 。同时，将 listen 指令的 backlog 参数改为匹配的最大连接数。</p><h2 id="nginx-功能"><a href="#nginx-功能" class="headerlink" title="nginx 功能"></a>nginx 功能</h2><h3 id="静态资源访问"><a href="#静态资源访问" class="headerlink" title="静态资源访问"></a>静态资源访问</h3><p>nginx 最主要的一个功能是提供静态内容的访问。nginx 通过 <em>指令匹配</em> 来指定返回的内容，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root /data/www;</span><br><span class="line">            index index.html index.htm;</span><br><span class="line">            try_files $uri $uri/ $uri.html /index.html =404;</span><br><span class="line">        &#125;</span><br><span class="line">        location ~ \.(gif|jpg|png|jpeg|svg)$ &#123;</span><br><span class="line">            root /data/images;</span><br><span class="line">            valid_referers none blocked server_names *.example.com ~\.google\.;</span><br><span class="line">            if ($invalid_referer) &#123;</span><br><span class="line">                rewrite ^/ http://www.example.com/403.html break;</span><br><span class="line">                # return 403;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        location /directory/ &#123;</span><br><span class="line">            root /data/directory;</span><br><span class="line">            autoindex on;</span><br><span class="line">        &#125;</span><br><span class="line">        location /mp3 &#123;</span><br><span class="line">            sendfile on;</span><br><span class="line">            sendfile_max_chunk 1m;</span><br><span class="line">        &#125;</span><br><span class="line">        location /wrong/url &#123;</span><br><span class="line">            return 404;</span><br><span class="line">        &#125;</span><br><span class="line">        location /permanently/moved/url &#123;</span><br><span class="line">            return 301 http://www.example.com/moved/here;</span><br><span class="line">        &#125;</span><br><span class="line">        location /old/path.html &#123;</span><br><span class="line">            error_page 404 =301 http://www.example.com/new/path.html;</span><br><span class="line">        &#125;</span><br><span class="line">        error_page 404 /404.html;</span><br><span class="line">        error_page 500 502 503 504 /50x.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个 location 块指令指定 <code>/</code> 前缀 与来自请求的 URI 相匹配。如果匹配上了，那么 URI 将添加到 <code>root</code> 指令中指定的路径，即 <code>/data/www</code>，以形成本地文件系统上请求文件的路径。例如，URI 请求了 <code>/index.html</code>，与 <code>/</code> 匹配，那么就会返回本地的 <code>/data/www/index.html</code> 资源。如果有多个匹配的 location 块，nginx 会选择具有最长前缀的块。上面的第一个 location 块提供了最短的前缀，长度为 1，因此只有当所有其他 location 块都无法提供匹配时，才会使用这个块。<br>第二个 location 块指令以 <code>~</code> 开始是一个正则表达式匹配。它可以匹配所有 以 .gif，.jpg 或 .png 结尾的 URI。</p><p><code>location</code> 指令支持 前缀字符串（路径名）和 正则表达式 两种匹配方式。前缀字符串匹配必须以前缀字符串开头，正则表达式以 <code>~</code> 或者 <code>~*</code> （表示不区分大小写）开头。nginx 对正则表达式使用 Perl 语法。如果请求以斜线结尾，nginx 会将其视为对目录的请求，并尝试在目录中查找索引文件。</p><p><code>root</code> 指令指定将用于搜索文件的根目录。</p><p><code>index</code> 指令定义索引文件的名称（默认值为 index.html ），可以在指令中列出多个文件，nginx 以指定的顺序搜索文件并返回它找到的第一个。</p><p><code>valid_referers</code> 指令用于根据请求 <code>Referer</code> 的内容对请求进行限制，通常用来进行静态资源的防盗链。参数 <code>none</code> 表示 <code>Referer</code> 不存在（从浏览器地址栏直接打开链接时的情况）；参数 <code>blocked</code> 表示 <code>Referer</code> 在请求头中存在，但是被防火墙或代理服务器删除了（例如值是字符串但并不是以 <code>http://</code> 或 <code>https://</code> 开头）；参数 <code>server_names</code> 表示 <code>Referer</code> 应当包含列出的服务器之一，列出的服务器地址支持以 * 通配符来匹配，或者以 <code>~</code> 开头的正则表达式。当匹配不通过时，<code>$invalid_referer</code> 变量的值将为 1，可以通过该字段来进行之后的处理。</p><p><code>autoindex</code> 指令表明 nginx 配置为返回自动生成的目录列表。</p><p><code>try_files</code> 指令用于检查指定的文件或目录是否存在，nginx 会进行内部重定向，否则会返回指定的状态码。</p><p>默认情况下，nginx 自己处理文件传输，并在发送之前将文件复制到缓冲区中。<code>sendfile</code> 指令消除了将数据复制到缓冲区的步骤，并允许将数据从一个文件描述符直接复制到另一个文件描述符。<code>sendfile_max_chunk</code> 指令来限制在单个 <code>sendfile()</code> 调用中传输的数据量，防止一个快速连接完全占用工作进程。</p><p><code>return</code> 指令用于返回特定的响应码。对于某些响应码，例如 301 重定向响应，可以通过额外的参数来指定重定向的地址。</p><p><code>rewrite</code> 指令用于重定向。当指定的正则表达式与请求 URI 匹配时，URL 将按照 <code>rewrite</code> 指定的字符串进行更改。第一个参数为 URI 需要匹配的正则表达式，第二个参数为替换的字符串，第三个参数为可选的标志参数，可以为 <code>last</code> 表示停止当前 <code>redirect</code> 指令的匹配，开始新的 <code>location</code> 匹配； <code>break</code> 表示停止当前的 <code>redirect</code> 指令的匹配，在此位置继续对请求进行进一步处理； <code>redirect</code> 表示返回 302 响应码； <code>permanent</code> 表示返回 301 响应码。</p><p><code>error_page</code> 指令用于对特定的响应码返回相应的内容。</p><h3 id="代理请求（请求转发）"><a href="#代理请求（请求转发）" class="headerlink" title="代理请求（请求转发）"></a>代理请求（请求转发）</h3><p>nginx 的常见用途之一是将其设置为请求代理，这意味着 nginx 服务器接收请求，将请求传递给代理服务器，然后 nginx 服务器从代理服务器接受响应，并将响应发送给客户端。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line">    root /data/up1;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>请注意，该 root 指令放置在 server 上下文中，这样，当 location 块没有提供自己的 root 指令时就会直接使用 server 上下文中的 root。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://localhost:8080;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header Accept-Encoding &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    location /some/path1/ &#123;</span><br><span class="line">        proxy_buffers 16 4k;</span><br><span class="line">        proxy_buffer_size 2k;</span><br><span class="line">        proxy_pass http://localhost:8000;</span><br><span class="line">        proxy_bind $server_addr;</span><br><span class="line">    &#125;</span><br><span class="line">    location /some/path2/ &#123;</span><br><span class="line">        proxy_buffering off;</span><br><span class="line">        proxy_pass http://localhost:8000;</span><br><span class="line">        proxy_bind 127.0.0.1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 location 块中添加 <code>proxy_pass</code> 指令，就可以将请求转发到对应的地址。如上，就是将 <code>http://localhost:80</code> 的请求转发到了 <code>http://localhost:8080</code> 上。</p><p>nginx 也支持将请求传递给非 HTTP 代理服务器，<code>**_pass</code> 应使用适当的指令：</p><ul><li><code>fastcgi_pass</code> 将请求传递给 FastCGI 服务器</li><li><code>uwsgi_pass</code> 将请求传递给 uwsgi 服务器</li><li><code>scgi_pass</code> 将请求传递给 SCGI 服务器</li><li><code>memcached_pa​​ss</code> 将请求传递给了一个 memcached 服务器</li></ul><p>在代理请求时，默认情况下，nginx 会重新定义代理请求中的两个 header 字段，“Host” 和 “Connection”，并消除值为空字符串的 header 字段。“Host” 设置为 <code>$proxy_host</code> 变量，“Connection” 设置为 close。</p><p><code>proxy_set_header</code> 指令可以更改默认的 header 设置以及修改其他 header 字段。要防止标头字段被传递到代理服务器，可以将其设置为空字符串。</p><p><code>proxy_buffering</code> 用于启用和禁用缓冲。默认情况下，nginx 缓冲来自代理服务器的响应，这有助于优化慢速客户端的性能。<code>proxy_buffers</code> 指令控制为请求分配的缓冲区的数量和大小。来自代理服务器的响应的第一部分存储在单独的缓冲区中，其大小由<code>proxy_buffer_size</code> 指令设置。</p><p><code>proxy_bind</code> 指令用于指定代理服务器的 IP 地址。IP 地址也可以用变量指定，<code>$server_addr</code> 变量传递接受请求的服务器的 IP 地址</p><h3 id="负载均衡（反向代理）"><a href="#负载均衡（反向代理）" class="headerlink" title="负载均衡（反向代理）"></a>负载均衡（反向代理）</h3><p>使用 nginx 可以将 HTTP 流量负载均衡到一组服务器上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream backend &#123;</span><br><span class="line">        zone backend 32k;</span><br><span class="line">        hash $request_uri consistent; # least_conn ip_hash</span><br><span class="line">        server backend1.example.com weight=5;</span><br><span class="line">        server backend2.example.com max_fails=3 fail_timeout=30s;</span><br><span class="line">        server backend3.example.com down;</span><br><span class="line">        server 192.0.0.1 backup;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://backend;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>upstream</code> 指令定义了一组服务器，其中 <code>server</code> 指令指项了每一个具体的服务器。如上，定义了一个名为 backend 的服务器组，这个组由三个服务器组成，两台主服务器，一台备份服务器，通过 <code>proxy_pass</code> 指令，可以将请求传递到 backend 组中。</p><p>nginx 支持四种负载均衡方法：</p><ol><li>Round Robin – 请求在服务器之间均匀分布，并考虑服务器权重。默认采用此种方法。</li><li>Least Connections – 向具有最少活动连接数的服务器发送请求，再次考虑服务器权重。指令为 <code>least_conn</code> 。</li><li>IP Hash – 请求发送到的服务器由客户端 IP 地址确定。在这种情况下，使用 IPv4 地址的前三个八位字节或整个 IPv6 地址来计算哈希值。该方法保证来自同一地址的请求到达同一服务器，除非它不可用。指令为 <code>ip_hash</code> 。</li><li>Generic Hash - 请求发送到的服务器由用户定义的键确定，该键可以是文本字符串、变量或组合。指令为 <code>hash</code> 。例如，哈希密钥可能是配对的源 IP 地址和端口，或者是例子中的 URI。可选的 <code>consistent</code> 参数标志启用 <a href="https://www.last.fm/user/RJ/journal/2007/04/10/rz_libketama_-_a_consistent_hashing_algo_for_memcache_clients">ketama</a> 一致哈希算法进行负载均衡。</li></ol><p><code>weight</code> 参数代表了服务器的权重，nginx 默认采用 <em>轮询调度</em>（Round Robin）方法根据权重在组中的服务器之间分配请求。<code>weight</code> 的默认值为1，值越高请求占比越多。</p><p><code>backup</code> 参数表示该服务器为备份服务器，除非其他服务器均不可用，否则不会接收请求。</p><p><code>down</code> 参数 表示暂时从负载均衡轮换中删除该服务器。</p><p><code>zone</code> 指令表示将 <code>upstream</code> 的配置保存在所有工作进程（work process）共享的内存区域中。例子中的 32k 表示分配的内存大小。</p><p><code>max_fails</code> 参数设置在将服务器标记为不可用之前需要发生的失败尝试次数（默认为 1 次尝试）。</p><p><code>fail_timeout</code> 参数设置将服务器标记为不可用的时间（默认为 10 秒）。</p><h3 id="压缩和解压"><a href="#压缩和解压" class="headerlink" title="压缩和解压"></a>压缩和解压</h3><p>压缩响应通常会显着减小传输数据的大小。但是，由于压缩发生在运行时，它也会增加相当大的处理开销，从而对性能产生负面影响。nginx 支持在向客户端发送响应之前执行压缩。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_types      text/plain application/xml;</span><br><span class="line">    gzip_proxied    no-cache no-store private expired auth;</span><br><span class="line">    gzip_min_length 1000;</span><br><span class="line">    gunzip on;</span><br><span class="line">    gzip_static on;</span><br><span class="line">    #...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gzip</code> 指令指定参数 <code>on</code> 即开启压缩。默认情况下，nginx 仅压缩 MIME 类型为 text/html 的响应。</p><p><code>gzip_types</code> 指令指定除了 text/html 外还需要压缩的类型。</p><p><code>gzip_min_length</code> 指令指定要压缩的响应的最小长度，默认为 20 字节。</p><p><code>gzip_proxied</code> 指令指定来自代理服务器的请求如何进行压缩。默认情况下，nginx 不会压缩对代理请求（来自代理服务器的请求）的响应。</p><p><code>gunzip</code> 指令用于在 http 客户端不支持 gzip 解压时即时解压缩。 <code>gunzip</code> 指令包含在 ngx_http_gunzip_module 中，默认情况下可能不包含在 nginx 的开源构建中，需要额外的构建参数 <code>--with-http_gunzip_module</code>。</p><p><code>gzip_static</code> 指令用于将文件的压缩版本而不是常规版本发送到客户端。开启后，当请求 /path/to/file 文件时，nginx 尝试查找并发送文件 /path/to/file.gz。如果文件不存在，或者客户端不支持 gzip，nginx 会发送文件的未压缩版本。<code>gzip_static</code> 指令包含在 ngx_http_gzip_static_module 中，默认情况下可能不包含在 nginx 的开源构建中，需要额外的构建参数 <code>--with-http_gzip_static_module</code>。</p><h3 id="https-支持"><a href="#https-支持" class="headerlink" title="https 支持"></a>https 支持</h3><p>nginx 支持通过添加 HTTPS 服务器的相关配置将 SSL 流量转换为非加密的流量，减轻上游 Web 和应用程序服务器的负载。</p><p>要设置 HTTPS 服务器，需要在 nginx.conf 文件中将 <code>ssl</code> 参数包含到 server 块指令中的 listen 指令中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    ssl_session_cache   shared:SSL:10m;</span><br><span class="line">    ssl_session_timeout 10m;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen              443 ssl;</span><br><span class="line">        server_name         www.example.com;</span><br><span class="line">        ssl_certificate     www.example.com.crt;</span><br><span class="line">        ssl_certificate_key www.example.com.key;</span><br><span class="line">        ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        ssl_ciphers         HIGH:!aNULL:!MD5;</span><br><span class="line">        #...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ssl_certificate</code> 指令指定了服务器证书的位置。</p><p><code>ssl_certificate_key</code> 指令指定了私钥的位置。私钥应存储在访问受限的文件，但 nginx 主进程必须能够读取此文件。</p><p><code>ssl_protocols</code> 和 <code>ssl_ciphers</code> 指令可用于要求客户端在建立连接时仅使用 SSL/TLS 的指定版本和密码。</p><blockquote><p>由于历史原因，nginx 默认 采用<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">ssl_ciphers         HIGH:!aNULL:!MD5;</span><br></pre></td></tr></table></figure><br>以下是TLS/SSL协议中的主要漏洞，它们都会影响协议的旧版本（TLSv1.2及更早版本），所以目前为止，考虑客户端兼容情况，建议仅支持 TLSv1.2 及以上版本。<br>POODLE（Padding Oracle On Downgraded Legacy Encryption）(<a href="https://nvd.nist.gov/vuln/detail/CVE-2014-3566">CVE-2014-3566</a>)<br>BEAST（Browser Exploit Against SSL/TLS ）(<a href="https://nvd.nist.gov/vuln/detail/CVE-2011-3389">CVE-2011-3389</a>)<br>CRIME (Compression Ratio Info-leak Made Easy) (<a href="https://nvd.nist.gov/vuln/detail/CVE-2012-4929">CVE-2012-4929</a>)<br>BREACH（Browser Reconnaissance and Exfiltration via Adaptive Compression of Hypertext） (<a href="https://nvd.nist.gov/vuln/detail/CVE-2013-3587">CVE-2013-3587</a>)<br>Heartbleed (<a href="https://nvd.nist.gov/vuln/detail/CVE-2014-0160">CVE-2014-0160</a>)</p></blockquote><p>nginx 是通过 OpenSSL 来支持 https 的，所以 <code>TLSv1.2</code> 参数需要 OpenSSL 1.0.1 以上版本。</p><p>SSL 操作会消耗额外的 CPU 资源，其中最占用 CPU 的操作是 SSL 握手。</p><p><code>ssl_session_cache</code> 指令配置将会话存储在工作进程之间共享的 SSL 会话缓存中。1M 字节的缓存可以包含 4000 个会话，默认缓存超时时间为5分钟。</p><p><code>ssl_session_timeout</code> 指令可以修改 SSL 缓存超时时间。</p><h2 id="nginx-常用指令说明"><a href="#nginx-常用指令说明" class="headerlink" title="nginx 常用指令说明"></a>nginx 常用指令说明</h2><p>nginx 指令目录参见 <a href="https://nginx.org/en/docs/dirindex.html">dirindex</a> 。</p><ul><li>woker_processes</li></ul><p>worker 角色的工作进程的个数，master 进程是接收并分配请求给 worker 处理。这个数值简单一点可以设置为 cpu 的核数，例如 4核 cpu 设置为 <code>woker_processes 4;</code> 。如果开启了 ssl 和 gzip 更应该设置成与逻辑 CPU 数量一样甚至为2倍，可以减少 I/O 操作。如果nginx服务器还有其它服务，可以考虑适当减少。</p><ul><li>worker_cpu_affinity</li></ul><p>在高并发情况下，通过设置 cpu 粘性来降低由于多 CPU 核切换造成的寄存器等现场重建带来的性能损耗。例如，4核 cpu 可以设置 <code>worker_cpu_affinity 0001 0010 0100 1000;</code>。</p><ul><li>events.worker_connections</li></ul><p>每一个 worker 进程能并发处理（发起）的最大连接数（包含与客户端或后端被代理服务器间等所有连接数）。</p><ul><li>events.use</li></ul><p>事件模型。在 Linux 操作系统下，nginx 默认使用 epoll 事件模型，得益于此，nginx 在 Linux 操作系统下效率相当高。同时 nginx 在 OpenBSD 或 FreeBSD 操作系统上采用类似于 epoll 的高效事件模型 kqueue。在操作系统不支持这些高效模型时使用 select。</p><ul><li>http.sendfile</li></ul><p>开启高效文件传输模式，sendfile 指令指定 nginx 是否调用 sendfile 函数来输出文件，减少用户空间到内核空间的上下文切换。对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，以平衡磁盘与网络 I/O 处理速度，降低系统的负载。</p><ul><li>http.keepalive</li></ul><p>长连接超时时间，单位是秒。长连接请求大量小文件的时候，可以减少重建连接的开销。如果设置时间过长，用户又多，长时间保持连接会占用大量资源。</p><ul><li>http.send_timeout</li></ul><p>用于指定响应客户端的超时时间。这个超时仅限于两个连接活动之间的时间，如果超过这个时间，客户端没有任何活动，nginx 将会关闭连接。</p><ul><li>http.client_max_body_size</li></ul><p>允许客户端请求的最大单文件字节数。</p><ul><li>http.client_body_buffer_size</li></ul><p>缓冲区代理缓冲用户端请求的最大字节数。</p><ul><li>http.server.listen</li></ul><p>http服务器的监听端口。默认80，小于1024的要以root启动。</p><ul><li>http.server.server_name</li></ul><p>服务器名，如 <code>localhost</code>、<code>www.example.com</code>，可以通过正则匹配。</p><ul><li>http.upstream</li></ul><p>设置服务器上游模块。通过调度算法来实现客户端IP到后端服务器的负载均衡。</p><ul><li>http.server.location</li></ul><p>通过 前缀字符串（路径名）和 正则表达式 两种匹配方式匹配 URI 以进行配置。</p><ul><li>http.server.location.root</li></ul><p>定义服务器的默认网站根目录位置。</p><ul><li>http.server.location.index</li></ul><p>定义目录路径下默认访问的文件名。</p><ul><li>http.server.location.proxy_pass</li></ul><p>请求转向 <code>http.upstream</code> 预先定义的服务器列表（即反向代理）或者 代理服务器。</p><ul><li>http.server.location.proxy_set_header</li></ul><p>在代理请求过程中重写 header 字段。</p><ul><li>http.server.location.allow</li></ul><p>访问控制，允许特定 ip 段进行访问。</p><ul><li>http.server.location.deny</li></ul><p>访问控制，禁止特定 ip 段进行访问。</p><ul><li>http.server.location.autoindex</li></ul><p>列出整个目录。默认 <code>off</code>。</p><ul><li>http.server.location.autoindex_exact_size</li></ul><p>列出整个目录时是否显示文件的确切大小。默认为 <code>on</code>。</p><ul><li>http.server.location.autoindex_localtime</li></ul><p>列出整个目录时是否显示本地时间。默认为 <code>off</code>，显示 GMT 时间。开启时显示为文件的服务器时间。</p>]]></content>
      
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编码格式</title>
      <link href="/blog/2022/08/22/CS-%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/"/>
      <url>/blog/2022/08/22/CS-%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>在计算机中，所有的数据在存储和运算时都要使用二进制数表示，例如，像a、b、c、d这样的52个字母（包括大写）以及0、1等数字还有一些常用的符号（例如*、#、@等）在计算机中存储时也要使用二进制数来表示，而具体用哪些二进制数字表示哪个符号，这就是编码。如果不同的计算机系统要想互相通信而不造成混乱，那么每个计算机系统就必须使用相同的编码规则。<br>编码是用预先规定的方法将文字、数字或其它对象编成数码，或将信息、数据转换成规定的电脉冲信号的过程。为了保证编码一致性，需要有标准的编码格式规范，中文编码环境中常见的编码格式有 ASCII、GBK、UTF-8、Unicode 等。</p><p>8位 = 1字节<br>1字符 = 1~4字节（根据编码方式不同）</p><span id="more"></span><h2 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h2><p>美国信息交换标准代码（American Standard Code for Information Interchange，ASCII）是一套基于拉丁字母的电脑编码系统，是由美国国家标准学会（American National Standard Institute，ANSI）制定的。它最初是美国国家标准，供不同计算机在相互通信时用作共同遵守的西文字符编码标准，后来它被国际标准化组织（International Organization for Standardization，ISO）定为国际标准 ISO/IEC646。</p><p>ASCII 由电报码发展而来。第一版标准发布于1963年，1967年经历了一次主要修订，最后一次更新则是在1986年，至今为止共定义了128个字符（character），包括33个控制字符和95个可显示字符。</p><p>ASCII 码使用指定的 7 位或 8 位二进制数组合来表示 128 或 256 种可能的字符。标准ASCII 码也叫基础 ASCII 码，使用 7 位二进制数（剩下的1位二进制为0）来表示所有的大写和小写字母，数字0到9、标点符号，以及在美式英语中使用的特殊控制字符。ASCII控制字符的编号范围是 0-31 和 127（0x00-0x1F 和 0x7F），可显示字符编号范围是 32-126（0x20-0x7E）。</p><p>ASCII 的局限在于只能显示52个基本拉丁字母（包括大小写）、阿拉伯数字和英式标点符号，因此只能用于显示现代美国英语，对更多其他语言无能为力。</p><h2 id="Latin1-ISO-8859-1"><a href="#Latin1-ISO-8859-1" class="headerlink" title="Latin1/ISO-8859-1"></a>Latin1/ISO-8859-1</h2><p>ISO-8859-1，正式编号为 ISO/IEC8859-1:1998，又称 Latin1 或 Latin-1，是国际标准化组织内 ISO/IEC8859 的第一个8位字符集。其编码范围是 0x00-0xFF，0x00-0x7F 之间完全和 ASCII 一致，0x80-0x9F 之间是控制字符，0xA0-0xFF 之间是文字符号。</p><p>ISO-8859-1 收录的字符除 ASCII 收录的字符外，还包括西欧语言、希腊语、泰语、阿拉伯语、希伯来语对应的文字符号。</p><p>ISO-8859-1 的特点是，它的编码范围使用了单字节内的所有空间，在支持 ISO-8859-1 的系统中传输和存储其他任何编码的字节流都不会被抛弃（会乱码，但数据不会丢弃）。</p><blockquote><p>MySQL数据库默认编码是 Latin1。</p></blockquote><blockquote><p>HTML4.01 支持 Latin1 字符集。</p></blockquote><blockquote><p>Javascript 中的 <code>window.atob()</code> 入参必须是 Latin1 字符集。</p></blockquote><h2 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h2><p><a href="https://openstd.samr.gov.cn/bzgk/gb/newGbInfo?hcno=5664A728BD9D523DE3B99BC37AC7A2CC">《信息交换用汉字编码字符集 基本集》推荐性国家标准 GB/T 2312-1980</a> 是 1980 年制定的中国汉字编码国家标准。自2017年3月23日起，该标准转化为推荐性标准，不再强制执行。</p><p>GB2312 共收录 7445 个字符，包括汉字 6763 个，其中一级汉字 3755 个，二级汉字 3008 个；同时收录了包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的 682 个字符。</p><p>GB2312 兼容标准 ASCII 码，采用扩展 ASCII 码的编码空间进行编码，一个汉字占用两个字节，每个字节的最高位为 1。</p><p>GB2312 编码通行于中国大陆，新加坡等地也采用此编码。中国大陆几乎所有的中文系统和国际化的软件都支持 GB2312。</p><p>GB2312 的出现，基本满足了汉字的计算机处理需要，它所收录的汉字已经覆盖中国大陆99.75% 的使用频率。</p><p>对于人名、古汉语等方面出现的罕用字，GB2312 不能处理，这导致了后来 GBK 及 GB18030 汉字字符集的出现。</p><h2 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h2><p>汉字内码扩展规范，英文全称 Chinese Internal Code Extension Specification，简称GBK，全名为《汉字内码扩展规范(GBK)》1.0版，由中华人民共和国全国信息技术标准化技术委员会（China National Information Technology Standardization Network，信标委）1995年12月1日制订，国家技术监督局标准化司和电子工业部科技与质量监督司1995年12月15日联合以《技术标函[1995]229号》文件的形式公布。GBK的K为“扩展”的汉语拼音（kuòzhǎn）第一个声母。GBK 只为“指导性技术文件”，不属于国家标准。</p><p>GBK 共收录21886个汉字和图形符号，其中汉字（包括部首和构件）21003个，图形符号883个。GBK 收录了包括：GB2312 中的全部汉字、非汉字符号，BIG5 中的全部汉字，与 ISO10646 相应的国家标准 GB13000 中的其它 CJK 汉字，以上合计 20902 个汉字。以及其它汉字、部首、符号，共计 984 个。</p><p>GBK 向下与 GB2312 完全兼容，向上支持 ISO10646 国际标准。</p><p>GBK 采用双字节表示。</p><h2 id="GB18030"><a href="#GB18030" class="headerlink" title="GB18030"></a>GB18030</h2><p>GB18030 是国家强制性标准规范中文编码字符集，它包括以下几个国家标准：</p><p>2000-03-17 发布的 <a href="https://openstd.samr.gov.cn/bzgk/gb/newGbInfo?hcno=4F885660EB8B3AC463C2ED336DB3B67B">《信息技术 信息交换用汉字编码字符集 基本集的扩充》强制性国家标准 GB 18030-2000</a>，目前已废弃。</p><p>2005-11-08 发布的 <a href="https://openstd.samr.gov.cn/bzgk/gb/newGbInfo?hcno=C344D8D120B341A8DD328954A9B27A99">《信息技术 中文编码字符集》强制性国家标准 GB 18030-2005</a>，为现行标准。</p><p>2022-07-19 发布的 <a href="https://openstd.samr.gov.cn/bzgk/gb/newGbInfo?hcno=A1931A578FE14957104988029B0833D3">《信息技术 中文编码字符集》强制性国家标准 GB 18030-2022</a>，为即将实施的标准，2023-08-01实施</p><p>GB 18030-2005 与 GB/T 2312-1980 和 GBK 兼容，共收录汉字70244个。</p><p>GB 18030-2005 采用多字节编码，每个字可以由1个、2个或4个字节组成。编码空间庞大，最多可定义 161 万个字符。支持中国国内少数民族的文字，不需要动用造字区。汉字收录范围包含繁体汉字以及日韩汉字。</p><h2 id="Big5"><a href="#Big5" class="headerlink" title="Big5"></a>Big5</h2><p>大五码（英语：Big5，又称为五大码）是使用繁体中文（正体中文）社区中最常用的电脑汉字字符集标准，共收录13060个汉字。</p><p>Big5虽普及于台湾、香港、澳门等繁体中文区域，但长期以来并非当地的国家/地区标准或官方标准，而只是业界标准。2003年，Big5 收录到 CNS11643 中文标准交换码的附录当中，获取了较正式的地位。这个最新版本称为 Big5-2003。</p><h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>通用编码字符集（Universal Coded Character Set，Unicode or UCS），是一种信息技术标准，用于对世界上大多数书写系统中表达的文本进行一致的编码、表示和处理。该标准由 Unicode 联盟（Unicode Consortium）维护，Unicode 联盟于 1991年1月3日在加利福尼亚成立，并于1991年10月出版了 Unicode 标准的第一卷。当前版本 (14.0) 定义了144697个字符。</p><p>Unicode 字符库与 ISO/IEC 10646 同步。</p><p>Unicode 有超过 110 万个可能的代码点可供使用/分配，其中前 65536（2^16）个，被称为基本多语言平面（Basic Multilingual Plane，BMP）。</p><p>可以通过以下三种方式之一对这一原始 ISO/IEC 10646 标准的字符进行编码：</p><ul><li>UCS-4，每个字符四个字节，实现所有字符的简单编码；例如 UTF-32 编码</li><li>UCS-2，每个字符两个字节，通过ISO/IEC 2022转义序列切换到第一个平面，0x20，基本多语言平面，直接包含前 36864 个代码点，以及其他平面和组的编码；例如 UTF-16 编码</li><li>UTF-1，它将所有字符编码为不同长度的字节序列（1 到 5 个字节，每个字节不包含控制代码）。</li></ul><p>Unicode 可以使用几种不同的编码来存储，这些编码将字符代码转换为字节序列。最常见的编码是兼容 ASCII 的 UTF-8、兼容 UCS-2 的 UTF-16 和 GB18030。</p><h2 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h2><p>UTF-8（8-bit Unicode Transformation Format）是一种针对 Unicode 的可变长度字符编码。它可以用一至四个字节对 Unicode 字符集中的所有有效编码点进行编码，属于 Unicode 标准的一部分。UTF-8 兼容 ASCII，Unicode 的前 128 个字符与 ASCII 一一对应，使用与 ASCII 具有相同二进制值的单个字节进行编码，因此有效的 ASCII 文本也是有效的采用 UTF-8 编码的 Unicode 文本。Ken Thompson 和 Rob Pike 于1992年9月为 Plan 9 操作系统制作了第一个 UTF-8 实现。UTF-8 是万维网（和互联网技术）的主要编码，截至 2022 年，占所有网页的 98%。</p><p>由于 2003 年将 Unicode 代码空间限制为 21 位值，UTF-8 被定义为将代码点编码为1到4个字节，具体取决于代码点数值中的有效位数。下表显示了编码的结构，其中x字符用于替换代码点位。</p><p>代码点 ↔ UTF-8 转换</p><table><thead><tr><th>第一个代码点</th><th>最后一个代码点</th><th>字节 1</th><th>字节 2</th><th>字节 3</th><th>字节 4</th></tr></thead><tbody><tr><td>U+0000</td><td>U+007F</td><td>0xxxxxxx</td><td></td><td></td><td></td></tr><tr><td>U+0080</td><td>U+07FF</td><td>110xxxx</td><td>10xxxxxx</td><td></td><td></td></tr><tr><td>U+0800</td><td>U+FFFF</td><td>1110xxxx</td><td>10xxxxxx</td><td>10xxxxxx</td><td></td></tr><tr><td>U+10000</td><td>U+10FFFF</td><td>11110xxx</td><td>10xxxxxx</td><td>10xxxxxx</td><td>10xxxxxx</td></tr></tbody></table><p>前 128 个代码点 (ASCII) 需要一个字节。接下来的 1920 个代码点需要两个字节来编码，这涵盖了几乎所有拉丁字母的其余部分，以及IPA 扩展、希腊语、西里尔语、科普特语、亚美尼亚语、希伯来语、阿拉伯语、叙利亚语、塔阿纳和 N’Ko 字母，以及组合变音符号。基本多语言平面的其余部分需要三个字节，其中包含几乎所有常用的代码点，包括大多数中文、日文和韩文字符。Unicode 的其他平面中的代码点需要四个字节，其中包括不太常见的 CJK 字符、各种历史文字、数学符号和表情符号（象形符号）。</p><h2 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h2><p>UTF-16（16 位 Unicode转换格式）是一种字符编码，能够对 Unicode 的所有 1112064 个有效字符代码点进行编码（实际上，代码点的数量由 UTF-16 的设计决定）。编码是可变长度的，因为代码点是用一个或两个16位代码单元编码的。UTF-16 源于早期过时的固定宽度16位编码，现在称为 UCS-2（用于2字节通用字符集），一旦明确需要超过2^16（65536）个代码点的情况。</p><p>UTF-16 中每个 Unicode 代码点都被编码为一个或两个16位代码单元。这些16位代码如何存储为字节取决于文本文件或通信协议的“字节顺序”。一个“字符”（character）可能需要从少至两个字节到十四个(<code>&quot;🤦🏼‍♂️&quot;.length == 7</code>)甚至更多字节来记录。</p><p>UTF-16 是唯一与 ASCII 不兼容的 Web 编码，并且从未在 Web 上流行过，它被低于 0.002%（略高于 1% 的千分之一）的网页使用。</p><blockquote><p>Python 从 2.0 版本开始官方只在内部使用 UCS-2，但 UTF-8 解码器到“Unicode”会产生正确的 UTF-16。从 Python 2.2 开始，支持使用 UTF-32 的“宽” Unicode 版本，主要用于 Linux。Python 3.3 不再使用 UTF-16，而是从 ASCII/Latin-1、UCS-2 和 UTF-32 中选择为给定字符串提供最紧凑表示的编码。<br>Java 最初使用 UCS-2，并在 J2SE 5.0 中添加了 UTF-16 补充字符支持。<br>Javascript 默认编码格式为 UTF-16。从 ES2015 开始，字符串方法和正则表达式标志已添加到语言中，允许从与编码无关的角度处理字符串。</p></blockquote><h2 id="字节顺序标记（BOM）"><a href="#字节顺序标记（BOM）" class="headerlink" title="字节顺序标记（BOM）"></a>字节顺序标记（BOM）</h2><p>字节顺序标记（Byte Order Mark，BOM）是特殊 Unicode 字符 U+FEFF BYTE ORDER MARK 的一种特殊用法，它在文本流开头作为 魔数（magic number）出现可以向读取文本的程序发出几个信号：</p><ul><li>在 16 位和 32 位编码的情况下，文本流的字节顺序（byte order）或字节序（endianness）</li><li>文本流的编码是 Unicode 的事实，具有很高的可信度</li><li>使用哪种 Unicode 字符编码</li></ul><p>BOM 的使用是可选的。它的存在会影响软件对 UTF-8 的使用，这些软件在文件开头不期望非 ASCII 字节，但可以处理文本流。</p><p>BOM 的字节序列因 Unicode 编码而异（包括 Unicode 标准之外的编码），并且没有任何序列可能出现在以其他编码存储的文本流的开头。因此，将编码的 BOM 放在文本流的开头可以指示文本是 Unicode 并识别使用的编码方案。BOM 字符的这种使用称为“Unicode 签名”。</p><p>Unicode 标准允许使用 UTF-8 的 BOM ，但不要求或推荐使用它，因为字节顺序在 UTF-8 中没有意义，所以它在 UTF-8 中的唯一用途是在开始时表示文本流以 UTF-8 编码。该标准也不建议在 BOM 存在时删除它，以便编码之间的往返不会丢失信息。</p><blockquote><p>Microsoft 编译器和解释器，以及 Microsoft Windows 上的许多软件（如记事本、Microsoft Word、Microsoft Excel）将 BOM 视为必需的魔数，这些工具在将文本保存为 UTF-8 时会添加 BOM，并且除非 BOM 存在或文件仅包含 ASCII，否则无法解释 UTF-8。</p></blockquote><table><thead><tr><th>编码</th><th>表现 (十六进制)</th><th>表现 (十进制)</th><th>CP1252 字符的字节</th></tr></thead><tbody><tr><td>UTF-8</td><td>EF BB BF</td><td>239 187 191</td><td>ï»¿</td></tr><tr><td>UTF-16 (BE)</td><td>FE FF</td><td>254 255</td><td>þÿ</td></tr><tr><td>UTF-16 (LE)</td><td>FF FE</td><td>255 254</td><td>ÿþ</td></tr><tr><td>UTF-32 (BE)</td><td>00 00 FE FF</td><td>0 0 254 255</td><td>^@^@þÿ (^@ 表示null字符)</td></tr><tr><td>UTF-32 (LE)</td><td>FF FE 00 00</td><td>255 254 0 0</td><td>ÿþ^@^@ (^@ 表示null字符)</td></tr><tr><td>GB-18030</td><td>84 31 95 33</td><td>132 49 149 51</td><td>„1•3</td></tr></tbody></table><h2 id="乱码"><a href="#乱码" class="headerlink" title="乱码"></a>乱码</h2><p>乱码指的是电脑系统不能显示正确的字符，而显示其他无意义的字符或空白。</p><p>常见的乱码情况如下</p><table><thead><tr><th>名称</th><th>示例</th><th>特点</th><th>原因</th></tr></thead><tbody><tr><td>古文码</td><td>甯歌鐨勪贡鐮�</td><td>大部分为不认识的古文或不常用汉字</td><td>以 GBK 方式读取 UTF-8 编码的中文</td></tr><tr><td>方块码</td><td>����������</td><td>大部分字符为小方块</td><td>以 UTF-8 方式读取了 GBK 编码的中文</td></tr><tr><td>符号码</td><td>å¸¸è§çš„ä¹±ç </td><td>大部分字符为各种符号或空白字符</td><td>以 ISO 8859-1 方式读取了 UTF-8 编码的中文</td></tr><tr><td>拼音码</td><td>³£¼ûµÄÂÒÂë</td><td>大部分字符为带有声调符号的字母</td><td>以 ISO 8859-1 方式读取了 GBK 编码的中文</td></tr><tr><td>半乱码</td><td>好好学�_天天___</td><td>部分字符显示正确，部分字符显示乱码</td><td>以 GBK 方式读取了 UTF-8 编码的中文，保存为 GBK 形式，然后又用 UTF-8 的格式再次读取</td></tr><tr><td>锟斤拷码</td><td>锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷</td><td>全中文字符，且大部分字符为“锟斤拷”这几个字符</td><td>以 UTF-8 方式读取 GBK 编码的中文，保存为 UTF-8 形式，然后又用 GBK 的格式再次读取</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> encode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件系统</title>
      <link href="/blog/2022/08/10/CS-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/blog/2022/08/10/CS-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>文件系统（File System，FS）是操作系统用来控制数据存储和检索方式的方法和抽象数据结构。如果没有文件系统，存储介质中的数据将是一大组数据，无法判断其中一个数据在哪里停止，下一个数据在哪里开始。通过将数据分成多个片段并为每个片段命名，数据很容易被隔离和识别。文件系统使用文件和树形目录的抽象逻辑概念代替了硬盘和光盘等物理设备使用数据块的概念，用户使用文件系统来保存数据不必关心数据实际保存在硬盘（或者光盘）的地址为多少的数据块上，只需要记住这个文件的所属目录和文件名。得名于纸质数据管理系统的命名方式，每组数据称为“文件”。用于管理数据组及其名称的结构和逻辑规则称为“文件系统”。</p><span id="more"></span><h2 id="分区与格式化"><a href="#分区与格式化" class="headerlink" title="分区与格式化"></a>分区与格式化</h2><p>存储设备在首次使用前必须进行 <em>分区</em>（partition）和 <em>格式化</em>（format）。</p><p>分区就是将一个存储设备分割成若干个逻辑区域，这样它们就可以像单独的存储设备一样单独管理。我们通常通过操作系统提供的 <em>磁盘管理工具</em> 或者使用系统固件提供的 <em>命令行工具</em> 来进行分区。</p><p>一个基本的 Linux 安装有三个分区：一个专用于操作系统的分区，一个用于用户文件的分区，以及一个可选的交换分区。当 RAM 空间不足时，交换分区用作 RAM 扩展。操作系统可能会将一块数据（临时）从 RAM 移动到交换分区，以释放 RAM 上的一些空间。操作系统不断使用各种内存管理技术来确保每个进程都有足够的内存空间来运行。</p><p>Windows 设法在安装操作系统的分区内进行交换。</p><p>在具有多个分区的计算机上，你可以安装多个操作系统，并且每次都选择不同的操作系统来启动你的系统。</p><p>恢复和诊断实用程序也驻留在专用分区中。例如，要在恢复模式下启动 MacBook，你需要在  Command + R 重新启动（或打开）MacBook 后立即按住。通过这样做，你可以指示系统固件使用包含恢复程序的分区启动。</p><p>某些操作系统（如 Windows）会为分区分配驱动器号（A、B、C 或 D）。然而，在类 Unix 操作系统中，分区显示为根目录下的普通目录。</p><p>在对存储设备进行分区时，我们有两种分区方法</p><ul><li>主引导记录 (MBR) 方案</li><li>GUID 分区表 (GPT) 方案</li></ul><p>无论选择哪种分区方案，存储设备上的前几个块将始终包含有关分区的关键数据。系统的 <em>固件</em> 使用这些数据结构来启动分区上的操作系统。</p><p>分区完成后，分区应格式化。</p><p>如果在 Windows 上格式化分区，可以在 FAT32、NTFS 和 exFAT 文件系统之间进行选择。格式化涉及创建用于管理分区内文件的各种 <em>数据结构</em> 和 <em>元数据</em> 。以 NTFS 文件系统为例，将分区格式化为 NTFS 时，格式化过程会将关键的 NTFS 数据结构和主文件表（MFT）放在分区上。</p><h2 id="系统固件与引导程序"><a href="#系统固件与引导程序" class="headerlink" title="系统固件与引导程序"></a>系统固件与引导程序</h2><p><em>固件</em>（firmware）是嵌入到电子设备中以操作设备或引导另一个程序来执行此操作的低级软件。在计算机中，固件为操作系统等复杂软件提供了一个标准接口，用于启动和使用硬件组件。</p><p>硬件制造商根据两个规范制作固件：</p><ul><li>基本输入/输出 (BIOS)</li><li>统一可扩展固件接口 (UEFI)</li></ul><p>固件（无论是基于 BIOS 的还是基于 UEFI 的）驻留在非易失性内存中，当按下计算机上的电源按钮时，固件是第一个运行的程序。固件的主要任务是启动计算机，运行操作系统，并将整个系统的控制权交给它。固件还运行预操作系统环境（具有网络支持），例如恢复或诊断工具，甚至是运行基于文本的 shell 命令。</p><h3 id="MBR-分区和基于-BIOS-的固件"><a href="#MBR-分区和基于-BIOS-的固件" class="headerlink" title="MBR 分区和基于 BIOS 的固件"></a>MBR 分区和基于 BIOS 的固件</h3><p>MBR 分区方案是 BIOS 规范的一部分，由基于 BIOS 的固件使用。在 MBR 分区的磁盘上，存储设备上的第一个扇区包含启动系统所需的基本数据。这个扇区称为 MBR。</p><p>MBR 包含以下信息：</p><ul><li>引导加载程序 —— 它是一个 简单的程序（使用机器码），用于启动引导过程的第一阶段</li><li>分区表 —— 其中包含有关分区的信息。  </li></ul><p>以下是它的工作原理：</p><ol><li>系统通电后，BIOS 固件启动并将引导加载程序（包含在 MBR 中）加载到内存中。<br>一旦程序在内存中，CPU 就开始执行它。</li><li>将引导加载程序和分区表放在 MBR 等预定义位置使 BIOS 无需处理任何文件即可启动系统。<br>MBR 中的引导加载程序代码占用 MBR 空间的 434 到 446 字节（共 512b）。此外，分区表分配了 64 个字节，其中最多可以包含有关四个分区的信息。不过，446 字节不足以容纳太多代码。也就是说， Linux 上的 GRUB（GRand Unified Bootloader）等复杂的引导加载程序将其功能拆分为多个部分或阶段。称为 <em>第一阶段引导加载程序</em> 的最小代码段存储在 MBR 中。它通常是一个简单的程序，不需要太多空间。第一阶段引导加载程序的职责是启动引导过程的下一个（和更复杂的）阶段。在 MBR 之后，第一个分区开始之前，有一个小空间，大约 1MB，称为 <em>MBR 间隙</em>（MBR gap）。引导加载程序（例如 GRUB）使用 MBR 间隙 来存储其功能的另一个阶段。GRUB 将此称为 <em>1.5阶段引导加载程序</em>，其中包含一个文件系统驱动程序。</li><li>能够处理文件的 <em>第二阶段引导加载程序</em> 可以加载操作系统的引导加载程序文件以启动相应的操作系统。</li></ol><p>MBR 分区存储设备的布局如下：</p><p><img src="/blog/static/imgs/filesystem/mbr-partition.jpeg" alt="mbr_partition_inner"></p><p>MBR 的布局如下：</p><p><img src="/blog/static/imgs/filesystem/mbr.jpeg" alt="mbr_inner"></p><p>MBR 简单且得到广泛支持，但它有一些限制：</p><ol><li>MBR 的数据结构将分区数量限制为只有四个主分区</li><li>MBR 每个分区最多只可以有2TB</li><li>MBR 扇区的内容没有备份</li></ol><h3 id="GPT-分区和基于-UEFI-的固件"><a href="#GPT-分区和基于-UEFI-的固件" class="headerlink" title="GPT 分区和基于 UEFI 的固件"></a>GPT 分区和基于 UEFI 的固件</h3><p>GPT分区方案 是 UEFI 规范的一部分，它比 MBR 更复杂，但没有 MBR 的诸多限制。</p><ol><li>在 GPT 分区方案中，出于与基于 BIOS 的系统的兼容性原因，存储设备的第一个扇区被保留。原因是某些系统可能仍使用基于 BIOS 的固件，但具有 GPT 分区的存储设备。该扇区称为 <em>保护MBR</em>。</li><li>在第一个扇区之后，存储了 GPT 数据结构，包括 <em>GPT标头</em> 和 <em>GPT分区条目</em></li><li>GPT分区条目 和 GPT标头 在存储设备的末尾有备份，因此如果主区损坏，可以从副本恢复。此备份称为 <em>辅助GPT</em></li></ol><p>GPT 分区存储设备的布局如下：</p><p><img src="/blog/static/imgs/filesystem/GUID_Partition_Table_Scheme.svg" alt="GUID_Partition_Table_Scheme_inner"></p><p>在 GPT 中，所有引导服务（引导加载程序、引导管理器、预操作系统环境和 shell）都位于一个名为 EFI 系统分区（ESP）的专用分区中，UEFI 固件可以使用该分区。</p><p>如果进行了相应的配置，UEFI 固件也可以进行 BIOS 式引导（从 MBR 磁盘引导系统）。</p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>文件系统是一组数据结构、接口、抽象和 API，它们协同工作以一致的方式管理任何类型的存储设备上的任何类型的文件。每个操作系统都使用特定的文件系统来管理文件。</p><p>早期，Microsoft 在 MS-DOS 和 Windows 9x 家族中使用 FAT（FAT12、FAT16 和 FAT32）。从 WindowsNT 3.1 开始，Microsoft 开发了 新技术文件系统 (NTFS)，它与 ​​FAT32 相比具有许多优势，例如支持更大的文件、允许更长的文件名、数据加密、访问管理、日志等等。从那时起，NTFS 一直是 WindowNT 系列（2000、XP、Vista、7、10 等）的默认文件系统。不过，NTFS 不适合非 Windows 环境。在 MacOS 上，只能读取 NTFS 格式的存储设备（如闪存）的内容，但无法向其中写入任何内容 - 除非安装了具有写入支持的 NTFS 驱动程序。扩展文件分配表（exFAT）是 Microsoft 在 2006 年创建的 NTFS 的轻量级版本。exFAT 专为大容量可移动设备而设计，是 SDXC 卡使用的默认文件系统。与 NTFS 不同，exFAT 在包括 MacOS 在内的非 Windows 环境中也具有 <em>读写</em> 支持。</p><p>多年来，Apple 还开发和使用了各种文件系统，包括 Hierarchical File System (HFS)、 HFS+ 以及最近的 Apple File System (APFS)。与 NTFS 一样，APFS 是一个日志文件系统，自 2017 年 OS X High Sierra 推出以来一直在使用。</p><p>在 Linux 发行版中，普遍使用 扩展文件系统（ext）系列文件系统。ext 的第一个版本于 1991 年发布，但不久之后，它在 1993 年被第二版扩展文件系统 ext2 取代。在 2000 年代，为具有日志功能的 Linux 开发了第三版扩展文件系统（ext3）和第四版扩展文件系统 (ext4) 。ext4 现在是许多 Linux 发行版的默认文件系统，包括 Debian 和 Ubuntu。</p><table><thead><tr><th>文件系统</th><th>版本</th><th>适用于</th><th>特点</th><th>单文件最大大小</th><th>文件名最大长度</th></tr></thead><tbody><tr><td>RAW</td><td></td><td>磁盘未经处理或者未经格式化产生的文件系统</td><td></td><td></td><td></td></tr><tr><td>FAT（File Allocation Table）</td><td>1977 年被开发用于软盘；<br>FAT12、FAT16、FAT32</td><td>MS-DOS， Windows 9x 系列</td><td>Micosoft 早期文件系统；<br>文件名不能超过8个字符；<br>扩展名（例如.exe）不能超过3个字符</td><td>FAT12单文件最大32MB；FAT16单文件最大2GB；FAT32单文件最大4GB</td><td>8.3 文件名</td></tr><tr><td>NTFS（New Technology File System）</td><td>从1993年被用于 WindowsNT 3.1 开始；<br>最新的为2001年10月发布的 NTFS 3.1</td><td>WindowNT 系列（2000、XP、Vista、7、10 等）的默认文件系统</td><td>支持更长的文件名、文件系统加密、访问控制列表（ACL）、透明压缩、稀疏文件、文件系统日志；<br>不适合非 Windows 环境<br>在 Linux 和 BSD 中也受支持（通过 NTFS-3G 驱动程序/通过 <code>convert</code> 命令）</td><td>MBR分区最大可以达到2TB；GPT分区不限制文件大小</td><td>255个字符</td></tr><tr><td>exFAT（Extensible File Allocation Table）</td><td>Microsoft 在2006年11月随 Windows Embedded CE 6.0 推出的文件系统</td><td>适用于外部硬盘、USB 驱动器和存储卡；<br>SDXC 卡使用的默认文件系统</td><td>NTFS 的轻量级版本，专为大容量可移动设备而设计；<br>在包括 MacOS 在内的非 Windows 环境中也具有 <em>读写</em> 支持；<br>同一目录下最大文件数可达65 536个；<br>支持访问控制；<br>exFAT 是唯一在 macOS 和 Windows 上完全支持的文件系统；<br>2019年8月28日，微软宣布公开 <a href="https://docs.microsoft.com/zh-cn/windows/win32/fileio/exfat-specification">exFAT 的技术规范</a>，以便它可以在 Linux 内核和其他操作系统中使用</td><td>单文件最大16EB</td><td>255个 UTF-16 字符</td></tr><tr><td>APFS（Apple File System）</td><td>2016 年 macOS Sierra（10.12.4）</td><td>macOS Sierra（10.12.4）以上版本的默认文件系统</td><td>支持加密、压缩、碰撞保护、日志文件系统</td><td>单文件最大8EB</td><td>255个 UTF-8 字符</td></tr><tr><td>ext</td><td>ext1 于 1991 年发布；ext2 于 1993 年发布；ext3 于 1999 年发布；ext4 于 2006 年发布</td><td>Linux 发行版的默认文件系统，包括 Debian 和 Ubuntu</td><td>ext3、 ext4 具有日志功能；<br>ext3 支持32000个子目录，ext4 支持无限子目录</td><td>ext2 最大2TB；<br>ext3 支持的最大 16TB 文件系统和最大 2TB 文件；<br>ext4 支持 1EB 的文件系统以及 16TB 的文件</td><td>255个字节</td></tr></tbody></table><p>完整的文件系统比较参见 <a href="https://en.wikipedia.org/wiki/Comparison_of_file_systems">文件系统比较</a>。</p><h2 id="文件系统架构"><a href="#文件系统架构" class="headerlink" title="文件系统架构"></a>文件系统架构</h2><p>安装在操作系统上的文件系统由三层组成：</p><ul><li>物理文件系统</li><li>虚拟文件系统</li><li>逻辑文件系统</li></ul><p>物理文件系统是文件系统的具体实现；它负责存储设备（或准确地说：分区）上的数据存储和检索以及空间管理。物理文件系统通过 设备驱动程序 与存储硬件交互。</p><p>虚拟文件系统（VFS）提供安装在同一操作系统上的各种文件系统的一致视图。一个操作系统可以同时使用多个文件系统。VFS 定义了一个 契约（contract），所有物理文件系统都必须实现该契约才能得到该操作系统的支持。</p><p>逻辑文件系统是文件系统中面向用户的部分，它提供了一个 API 使用户程序能够执行各种文件操作，例如  OPEN、READ 和 WRITE，而无需处理任何存储硬件。</p><p><img src="/blog/static/imgs/filesystem/filesystem.jpeg" alt="filesystem_inner"></p><h2 id="文件元数据"><a href="#文件元数据" class="headerlink" title="文件元数据"></a>文件元数据</h2><p>文件元数据（File metadata）是一种数据结构，其中包含 有关文件的数据，例如：</p><ul><li>文件大小</li><li>时间戳，例如创建日期、上次访问日期和修改日期</li><li>文件的所有者</li><li>文件的模式（谁可以对文件做什么）</li><li>分区上的哪些块分配给文件</li><li>等等</li></ul><p>元数据不与文件内容一起存储。相反，它存储在磁盘上的不同位置 - 但与文件相关联。<br>在类 Unix 系统中，元数据采用的数据结构形式称为 索引（inode）。<br>存储设备上的每个文件都有一个 索引，其中包含有关它的信息，包括创建修改时间、分配给文件的块地址、在存储设备上的确切位置等等。<br>在 Linux 系统中可以使用 <code>df -i</code> 来查看分区中的 索引（总数、已使用和空闲）。<br>要查看与目录中的文件关联的 索引，可以使用 <code>ls -li</code> ，第一列就是与每个文件关联的索引号。<br>在大多数操作系统上，可以通过图形用户界面获取元数据。例如，在 MacOS 上右键单击文件并选择获取信息，或在 Windows 上右键单击文件并选择属性。</p><h2 id="空间管理"><a href="#空间管理" class="headerlink" title="空间管理"></a>空间管理</h2><p>存储设备被划分为称为 <em>扇区</em>（sector）的固定大小的区域。扇区是存储设备上的 <em>最小存储单元</em> ，介于 512 字节和 4096 字节之间。文件系统使用高级概念作为存储单元，称为 <em>块</em>（block）。块是对物理扇区的抽象；每个块通常由多个扇区组成。根据文件大小，文件系统为每个文件分配一个或多个块。为了便于管理，将连续的块分组为 <em>块组</em>（block group）。每个块组都有自己的数据结构和数据块。在块组级别管理文件可以显着提高文件系统的性能，而不是将文件组织为一个单元。</p><p>文件资源管理器为每个文件显示两种不同的大小： <em>大小</em>（size） 和 <em>磁盘大小</em>（size on disk）。这是因为一个块是可以分配给文件的最小空间，这意味着部分填充块的剩余空间不能被另一个文件使用，最后一个块可能会被部分使用，剩余的空间将保持未使用状态 - 或者将被零填充。所以“大小”基本上是实际文件大小，而“磁盘大小”是它占用的空间，即使它没有全部使用。</p><h2 id="目录-文件夹"><a href="#目录-文件夹" class="headerlink" title="目录/文件夹"></a>目录/文件夹</h2><p>目录（direcotry，Windows 中的文件夹（folder））是一种特殊文件，用作逻辑文件系统中的 逻辑容器，用于对文件系统中的文件和目录进行分组。目录只是具有自己的 inode（在 Ext4 上）或 MFT 条目（在 NTFS 上）的文件。目录的 inode 或 MFT 条目包含有关该目录的信息，以及指向该目录“下”文件的条目集合。这些条目称为 目录条目（directory entries）。除了目录条目之外，还有两个条目。<code>.</code> 指向目录本身的条目和指向该目录 <code>..</code> 的父目录的条目。</p><h2 id="文件规则"><a href="#文件规则" class="headerlink" title="文件规则"></a>文件规则</h2><p>一些文件系统对文件名实施限制，包括文件名的长度和是否区分大小写。在 NTFS (Windows) 和 APFS (MacOS) 文件系统中 <code>MyFile</code> ， <code>myfile</code> 它们指向同一个文件，而在 ext4 (Linux) 中，它们指向不同的文件。</p><p>一些文件系统对文件大小实施限制，FAT32 不能存储超过 4GB 的文件，NTFS 允许文件大小高达 16EB，exFAT 也允许文件大小为 16EB。Linux 的 ext4 和 Apple 的 APFS 分别支持高达 16TB 和 8EB 的文件。</p><blockquote><p>注: 1B=8bit 1KB=1024B 1MB=1024KB 1GB=1024MB 1TB=1024GB 1PB=1024TB 1EB=1024PB</p></blockquote><p>大多数现代文件系统允许文件名包含 Unicode/UTF-8/UTF-16 字符集中的各种字符，但是，它们可能对某些特殊字符的使用有限制，不允许在文件名中使用它们。</p><h2 id="文件管理程序"><a href="#文件管理程序" class="headerlink" title="文件管理程序"></a>文件管理程序</h2><p>文件系统的逻辑层提供了一个 API，使用户应用程序能够执行文件操作，例如 读、写、删除 与 执行 操作。不过，文件系统的 API 是一种低级机制，专为计算机程序、运行时环境和 shell 而设计。操作系统为日常文件管理提供了开箱即用的便捷文件管理实用程序，例如，Windows 上的 文件资源管理器（File Explorer）、MacOS 上的 访达（Finder）和 Ubuntu 上的 Nautilus。这些实用程序在后台使用逻辑文件系统的 API。除了这些 GUI 工具之外，操作系统还通过命令行界面公开文件系统的 API，例如 Windows 上的 命令提示符（Command Prompt）以及 Mac 和 Linux 上的 终端（Terminal）。</p><h2 id="文件访问管理"><a href="#文件访问管理" class="headerlink" title="文件访问管理"></a>文件访问管理</h2><p>现代文件系统提供了控制用户对文件的访问和能力的机制。有关用户权限和文件所有权的数据存储在 Windows 上称为 访问控制列表 (ACL) 或类 Unix 操作系统（Linux 和 MacOS）上的 访问控制条目 (ACE) 的数据结构中。此功能在 命令行界面（CLI，即命令提示符或终端）中也可用，用户可以从命令行界面更改文件所有权或限制每个文件的权限。例如，在类Unix操作系统中可以通过 <code>chmod</code> 修改文件权限。</p><h2 id="维护数据完整性"><a href="#维护数据完整性" class="headerlink" title="维护数据完整性"></a>维护数据完整性</h2><p>现代文件系统使用了一种称为 日志（journaling） 的技术来防止因数据操作正在进行时而崩溃所导致的数据损坏。日志文件系统记录物理层中即将发生但尚未发生的每一个操作。日志是磁盘上的特殊分配，每次写入尝试首先存储为 事务（transaction）。一旦数据物理地放置在存储设备上，更改就会提交到文件系统。如果发生系统故障，文件系统将检测到不完整的事务并将其 回滚（rollback），就好像它从未发生过一样。<br>NTFS、APFS 和 ext4（甚至 ext3）均使用日志来避免系统故障时数据损坏。</p><h2 id="数据库文件系统"><a href="#数据库文件系统" class="headerlink" title="数据库文件系统"></a>数据库文件系统</h2><p>典型的文件系统应用将文件组织为目录树。但在数据库文件系统中，没有路径和目录的概念。它根据各种 属性（attributes）和 维度（dimensions）对文件进行分组。数据库文件系统不能替代典型的文件系统。它只是为了在某些系统上更轻松的文件管理而进行的高级抽象。例如，MacOS 上的 iTunes 应用程序，可以将 MP3 文件按艺术家、流派、发行年份和专辑列出。</p>]]></content>
      
      
      
        <tags>
            
            <tag> file-system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域名系统A记录和CNAME记录</title>
      <link href="/blog/2022/08/08/FE-%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9FA%E8%AE%B0%E5%BD%95%E5%92%8CCNAME%E8%AE%B0%E5%BD%95/"/>
      <url>/blog/2022/08/08/FE-%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9FA%E8%AE%B0%E5%BD%95%E5%92%8CCNAME%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="域名系统（DNS）"><a href="#域名系统（DNS）" class="headerlink" title="域名系统（DNS）"></a>域名系统（DNS）</h2><p>域名系统（Domain Name System，DNS）是一种分层和分散的命名系统，用于识别可通过互联网或其他互联网协议（IP）网络访问的计算机。DNS 中包含的资源记录将域名与其他形式的信息相关联，从而将人类友好的域名映射到计算机使用底层网络协议定位的服务和设备 IP 地址。最新的 DNS 规范记录于 <a href="https://datatracker.ietf.org/doc/html/rfc1034">RFC 1034</a> 与 <a href="https://datatracker.ietf.org/doc/html/rfc1035">RFC 1035</a>。<br>DNS 反映了互联网中的管理责任结构。每个子域都是委托给管理者的管理自治区域。对于由注册管理机构运营的区域，管理信息通常由注册管理机构的 RDAP（Registration Data Access Protocol）和 <a href="https://datatracker.ietf.org/doc/html/rfc3912">WHOIS</a> 服务补充。该数据可用于深入了解互联网上的给定主机并跟踪其责任。</p><h2 id="地址解析机制"><a href="#地址解析机制" class="headerlink" title="地址解析机制"></a>地址解析机制</h2><p>域名解析器通过从最右边（顶级）域标签开始的一系列查询来确定负责相关域名的域名服务器。为了正确操作其域名解析器，网络主机配置有根名称服务器的已知地址的初始缓存。管理员通过从可靠来源检索数据集定期更新提示。假设解析器没有缓存记录来加速该过程，则解析过程从查询其中一个根服务器开始。在典型的操作中，根服务器不直接回答，而是通过对更权威的服务器的引用进行响应，例如，对 “<a href="">www.wikipedia.org</a>” 的查询被引用到 org 服务器。解析器现在查询引用的服务器，并反复重复此过程，直到收到权威答案。如果互联网上的每个解析都需要从根开始，那么这种机制会给根服务器带来很大的流量负担。实际上，DNS 服务器中使用缓存来减轻根服务器的负载，因此，根名称服务器实际上只参与了所有请求的一小部分。</p><p><img src="/blog/static/imgs/Example_of_an_iterative_DNS_resolver.png" alt="dns_inner"></p><p>为了提高效率、减少互联网上的 DNS 流量并提高最终用户应用程序的性能，域名系统支持 DNS 缓存服务器。这些服务器将 DNS 查询结果存储在配置中确定的生存时间（Time To Live，TTL）更新有问题的域名记录。互联网服务提供商（ISP）通常为客户提供递归和缓存名称服务器。另外，许多路由器也实现了 DNS 缓存和递归以提高本地网络的效率。某些应用程序（例如 Web 浏览器）也会维护内部 DNS 缓存以避免通过网络重复查找。</p><p>主机名和 IP 地址不需要以一对一的关系匹配。多个主机名可能对应于一个 IP 地址，这在虚拟主机中很有用，其中许多网站都由一个主机提供服务。或者，单个主机名可以解析为多个 IP 地址，以促进容错并将负载分配到企业或全球互联网上的多个服务器实例。</p><p>全球 DNS 的顶层，存在 13 组根名称服务器，它们的附加“副本”通过泛播（Anycast）寻址在全球范围内分布。</p><h2 id="资源记录（RR）"><a href="#资源记录（RR）" class="headerlink" title="资源记录（RR）"></a>资源记录（RR）</h2><p>DNS 为网络资源指定了一个信息元素数据库。信息元素的类型通过 DNS 记录类型列表（List of DNS reocrd types）、资源记录（Resource Record，RR）进行分类和组织。每条记录都有一个类型（名称和编号）、一个过期时间（生存时间）、一个类和特定于类型的数据。相同类型的资源记录被描述为一个资源记录集（RRset），没有特殊的排序。DNS 解析器在查询时返回整个集合，但服务器可能会执行循环排序以实现负载平衡。相比之下，域名系统安全扩展（DNSSEC) 以规范顺序处理完整的资源记录集。当通过互联网协议网络发送时，所有记录都使用 RFC 1035 中指定的通用格式：</p><p>资源记录的域如下：</p><table><thead><tr><th>域</th><th>描述</th><th>长度（八位字节）</th></tr></thead><tbody><tr><td>NAME</td><td>此记录所属的节点的名称</td><td>变量</td></tr><tr><td>TYPE</td><td>数字形式的 RR 类型（例如，MX RR 为 15）</td><td>2</td></tr><tr><td>CLASS</td><td>CLASS代码</td><td>2</td></tr><tr><td>TTL</td><td>RR 保持有效的秒数（最大值为 2^31-1，约 68 年）</td><td>4</td></tr><tr><td>RDLENGTH</td><td>RDATA 字段的长度</td><td>2</td></tr><tr><td>RDATA</td><td>其他 RR 特定数据</td><td>变量，根据RDLENGTH</td></tr></tbody></table><p>DNS 记录类型列表中最常见的有如下类型：</p><table><thead><tr><th>类型</th><th>Type id</th><th>定义文档</th><th>描述</th><th>方法</th></tr></thead><tbody><tr><td>A</td><td>1</td><td>RFC 1035</td><td>地址记录</td><td>返回一个 32 位IPv4地址，最常用于将主机名映射到主机的 IP 地址</td></tr><tr><td>NS</td><td>2</td><td>RFC 1035</td><td>名称服务器记录</td><td>委托 DNS 区域（DNS zone）使用给定的权威名称服务器（Authoritative name server）</td></tr><tr><td>CNAME</td><td>5</td><td>RFC 1035</td><td>规范名称记录</td><td>一个名称到另一个名称的别名：DNS 查找将通过使用新名称重试查找来继续</td></tr><tr><td>MX</td><td>15</td><td>RFC 1035 与 RFC 7505</td><td>邮件交换记录</td><td>将域名映射到该域的邮件 传输代理列表（Message Transfer Agents，MTA）</td></tr><tr><td>TXT</td><td>16</td><td>RFC 1035</td><td>文字记录</td><td>最初用于 DNS 记录中的任意人类可读文本。然而，自 1990 年代初以来，该记录更多地携带机器可读数据，例如 RFC 1464 规范声明的，OE、SPF、DKIM、DMARC、DNS-SD等</td></tr><tr><td>AAAA</td><td>28</td><td>RFC 3596</td><td>IPv6地址记录</td><td>返回一个 128 位IPv6地址，最常用于将主机名映射到主机的 IP 地址</td></tr><tr><td>SRV</td><td>33</td><td>RFC 2782</td><td>服务定位器</td><td>通用服务位置记录，用于较新的协议，而不是创建特定于协议的记录，例如 MX</td></tr></tbody></table><h2 id="规范名称记录（CNAME）"><a href="#规范名称记录（CNAME）" class="headerlink" title="规范名称记录（CNAME）"></a>规范名称记录（CNAME）</h2><p>规范名称记录（Canonical NAME record，CNAME）是域名系统（DNS）中的一种资源记录（RR）类型，它将一个域名（别名）映射到另一个域名（规范名称）。<br>当从一个 IP 地址运行多个服务（如 FTP 服务器 和 Web 服务器，每个都在不同的端口上运行）时，使用 CNAME 是十分方便的。例如，可以使用 CNAME 记录将 ftp.example.com 和 <a href="http://www.example.com">www.example.com</a> 指向 example.com 的 DNS 条目，该条目又具有指向 IP 地址的 A 记录。然后，如果 IP 地址发生变化，只需在网络内的一处记录更改：即在 DNS A 记录中，例如 example.com。ftp.example.com 和 <a href="http://www.example.com">www.example.com</a> 都属于 example.com 的别名，而 example.com 则称为 ftp.example.com 和 <a href="http://www.example.com">www.example.com</a> 的规范名称。</p><p>有两点需要注意：</p><ol><li>CNAME 记录必须始终指向另一个域名，而不是直接指向 IP 地址。</li><li>由于效率低下，应避免指向其他 CNAME 记录的 CNAME 记录（但即使这样做了也不算是个错误）。</li></ol><h2 id="内容分发网络（CDN）"><a href="#内容分发网络（CDN）" class="headerlink" title="内容分发网络（CDN）"></a>内容分发网络（CDN）</h2><p>内容分发网络（Content Delivery Network or Content Distribution Network，CDN）是是一组分布式服务器，共同组成的一个对内容传输的覆盖网络（Overlay Network），用来加速用户对网络的内容访问。<br>CDN 最常见的调度方式就是 DNS 调度形式。对于 CDN 客户来说，不需要改动网站架构，只需要修改自己的 DNS 解析，设置一个 CNAME 指向 CDN 服务商即可。<br>CDN 节点通常部署在多个位置，通常在多个互联网主干上。好处包括降低带宽成本、缩短页面加载时间以及提高内容的全球可用性。对内容的请求通常通过算法定向到以某种方式优化的节点。在优化性能时，可以选择最适合向用户提供内容的位置。这可以通过选择跳数最少、距请求客户端的网络秒数最少或服务器性能（根据当前和历史）可用性最高的位置来衡量，以优化跨本地网络的交付。在优化成本时，可以选择成本最低的位置。在最佳情况下，这两个目标趋于一致，因为靠近网络边缘的最终用户的 边缘服务器 可能在性能或成本方面具有优势。</p>]]></content>
      
      
      
        <tags>
            
            <tag> cname </tag>
            
            <tag> dns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储的形式与硬盘的选择</title>
      <link href="/blog/2022/07/25/CS-%E4%B8%AA%E4%BA%BA%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88/"/>
      <url>/blog/2022/07/25/CS-%E4%B8%AA%E4%BA%BA%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>以下收集总结一些存储相关的知识以供个人在寻找存储方案时进行参考。</p><span id="more"></span><h2 id="存储介质"><a href="#存储介质" class="headerlink" title="存储介质"></a>存储介质</h2><p>存储介质指的是存储数据的物理载体，包括硬盘、磁带、内存等设备。根据使用材料和存储原理的不同，可以分为光存储介质（例如光盘）、磁存储介质（例如机械硬盘、软盘）、电存储介质（也叫半导体存储介质，例如固态硬盘）三种。光学存储器利用激光在磁光材料上进行读写，数据不易失且耐用性好；磁性存储器是在金属或者塑料表面上涂上磁性材料作为记录介质，工作时利用磁头在磁层上运动进行读写操作；电存储器通过改变电压来对存储器中的数据进行擦除和改写。</p><h3 id="磁存储介质-机械硬盘-HDD"><a href="#磁存储介质-机械硬盘-HDD" class="headerlink" title="磁存储介质-机械硬盘 HDD"></a>磁存储介质-机械硬盘 HDD</h3><p>机械硬盘（Hard Disk Drive，HDD）即是传统普通硬盘。机械硬盘采用磁性碟片来存储数据，主要由：磁盘、磁头、磁盘转轴及控制电机、磁头控制器、数据转换器、接口、缓存等几个部分组成。</p><p>常见的硬盘尺寸有三种，分别是3.5英寸硬盘、2.5英寸硬盘、1.8英寸硬盘。1.8英寸硬盘主要是在微型机上用（已停产），2.5英寸硬盘主要用于笔记本，3.5英寸硬盘主要用于台式机。</p><h3 id="电存储介质-固态硬盘-SSD"><a href="#电存储介质-固态硬盘-SSD" class="headerlink" title="电存储介质-固态硬盘 SSD"></a>电存储介质-固态硬盘 SSD</h3><p>固态硬盘（Solid State Drive or Solid State Disk，SSD）由控制单元和存储单元（一般是 FLASH 芯片，也有 DRAM 芯片、3D XPoint 芯片）、缓存（非必须）等组成，</p><p>存储单元通常采用 NAND Flash（闪存）芯片作为存储介质的固态硬盘，可以被制作成多种样式，例如 2.5英寸硬盘、存储卡、U盘等样式。这种 SSD 固态硬盘最大的优点就是可以移动，而且数据保护不受电源控制，能适应于各种环境，寿命长，适合于个人用户使用。</p><p>NAND Flash 闪存芯片又分为 SLC（Single-Level Cell，单层单元）、MLC（Multi-Level Cell，双层单元）、TLC（Trinary-Level Cell，三层单元）、QLC（Quad-Level Cell，四层单元）这四种规格。SLC 闪存普遍能达到上万次的 P/E（闪存完全擦写一次叫做1次 P/E ，因此闪存的寿命就以 P/E 作单位），最新的 QLC 也能确保300次 P/E 的寿命。普通用户一年的写入量不超过硬盘的50倍总尺寸，即便最廉价的 QLC 闪存，也能提供6年的写入寿命。</p><h3 id="光存储介质-光盘"><a href="#光存储介质-光盘" class="headerlink" title="光存储介质-光盘"></a>光存储介质-光盘</h3><p>光盘（Optical Disc，又称作光碟）于1965年由美国发明家詹姆斯·拉塞尔（James Russell）发明，它是用激光扫描来记录和读取信息的一种介质。光盘根据读写特性可分为只读光盘（例如 CD-ROM、DVD-ROM 等）和读写光盘（例如 CR-RW、DVD-RAM 等）。以 CD 为例，光盘主要由基板、记录层、反射层、保护层、印刷层等组成，厚度为1.2mm。根据数据存储结构不同，光盘可以分为 CD、DVD、蓝光（Blu-ray）等多种类型。容量上，CD 的容量有700MB左右，DVD 则可以达到4.7GB，而蓝光光盘更是可以达到25GB。</p><table><thead><tr><th>类型</th><th>全称</th><th>介绍</th></tr></thead><tbody><tr><td>CD</td><td>Compact-Disc</td><td>光盘，代表小型镭射盘，是一个用于所有CD媒体格式的一般术语。是由 Lead-In（资料开始记录的位置）；而后是 Table-of-Contents 区域，由内及外记录资料；在记录之后加上一个 Lead-Out 的资料轨结束记录的标记。</td></tr><tr><td>CD-ROM</td><td>Compact-Disc-Read-Only-Memory</td><td>只读光盘。1986年， SONY、Philips 一起制定的黄皮书标准，定义档案资料格式。定义了用于电脑数据存储的 MODE1 和用于压缩视频图象存储的 MODE2 两类型，使 CD 成为通用的储存介质。并加上侦错码及更正码等位元，以确保电脑资料能够完整读取无误。</td></tr><tr><td>VCD</td><td>Video-CD</td><td>激光视盘。是由 SONY、Philips、JVC、Matsushita 等共同制定，属白皮书标准。是指全动态、全屏播放的激光影视光盘。</td></tr><tr><td>DVD</td><td>Digital-Versatile-Disk</td><td>数字多用光盘，以 MPEG-2 为标准，拥有4.7G的大容量，可储存133分钟的高分辨率全动态影视节目，包括数个杜比数字环绕声音轨道，图像和声音质量是 VCD 所不及的。</td></tr><tr><td>BD-ROM</td><td>Blu-ray Disc-Read-Only-Memory</td><td>蓝光只读光盘，能够存储大量数据的外部存储媒体，中文语境下常被称为“蓝光光盘”。蓝光光盘的命名是由于其采用波长405纳米（nm）的蓝色激光光束来进行读写操作（DVD采用650纳米波长的红光读写器，CD则是采用780纳米波长）。</td></tr></tbody></table><h3 id="机械硬盘与固态硬盘对比"><a href="#机械硬盘与固态硬盘对比" class="headerlink" title="机械硬盘与固态硬盘对比"></a>机械硬盘与固态硬盘对比</h3><ul><li>防震抗摔性：机械硬盘都是磁碟型的，数据储存在磁碟扇区里。而固态硬盘是使用闪存颗粒制作而成，所以 SSD 固态硬盘内部不存在任何机械部件，这样即使在高速移动甚至伴随翻转倾斜的情况下也不会影响到正常使用，而且在发生碰撞和震荡时能够将数据丢失的可能性降到最小。相较机械硬盘，固态硬盘占有绝对优势。</li><li>数据存储/读取速度：机械硬盘的速度约为120MB/S，SATA 协议的固态硬盘速度约为500MB/S，NVMe 协议(PCIe 3.0 x2)的固态硬盘速度约为1800MB/S，NVMe 协议(PCIe 3.0 x4)的固态硬盘速度约为3500MB/S。固态硬盘的读写速度有绝对的优势，而且由于不需要寻道，固态硬盘在随机读写速度上更具有优势。</li><li>功耗：由于固态硬盘内部没有机械部件，没有高速旋转的磁盘，所以功耗较小，更加节能省电。通常不超过3W，而机械硬盘则是5-10W</li><li>噪音：机械硬盘工作时需要高速转动磁盘，马达的高速转动不可避免地带来噪音和发热。由于固态硬盘属于无机械部件及闪存芯片，所以具有了发热量小、散热快等特点，而且没有机械马达和风扇，噪音值为0分贝。</li><li>使用寿命：固态硬盘的寿命是按读写次数算的，一般在10万次左右。机械硬盘的寿命则是按小时计算的，一般在3-5万小时左右。</li><li>数据恢复：数据删除时，机械硬盘只是移动指针，而固态硬盘会将数据擦除。所以机械硬盘损坏后，一般仍旧可以进行数据恢复，但固态硬盘无法进行恢复。</li><li>工作温度范围：典型的机械硬盘只能在5~55摄氏度范围内工作。而大多数固态硬盘可在-10~70摄氏度工作。</li><li>体积与重量：固态硬盘比同容量机械硬盘体积小、重量轻。与常规1.8英寸硬盘相比，固态硬盘重量轻20-30克。</li><li>价格：同容量固态硬盘价格约是机械硬盘的3～5倍。</li></ul><h3 id="硬盘接口与协议"><a href="#硬盘接口与协议" class="headerlink" title="硬盘接口与协议"></a>硬盘接口与协议</h3><p>这里的硬盘接口指的是用于连接主板和大容量存储设备的端口，包括 IDE 接口、SATA 接口、SCSI 接口、光纤通道、SAS 接口、mSATA 接口、M.2 接口。硬盘接口协议指的是硬盘接口上层对接的系统控制与通信协议，包括 AHCI、NVMe。</p><p>早期的硬盘接口 包括 ST506/ST412、ESDI、IPI、SMD 等不再赘述。</p><h4 id="IDE-接口"><a href="#IDE-接口" class="headerlink" title="IDE 接口"></a>IDE 接口</h4><p>IDE（Integrated Drive Electronics，电子集成驱动器，相对于SATA常被称为“并口”）硬盘接口也称作 “ATA（Advanced Technology Attachment）接口” 或 “PATA接口（Parallel Advanced Technology Attachment，以同 SATA 区别）”，是由 IBM 开发的早期机械硬盘的主要接口，ATA133 硬盘的理论速度可以达到 133MB/s。IDE 硬盘接口如下图所示：</p><p><img src="/blog/static/imgs/disk/IDE.jpeg" alt="ide_inner"></p><h4 id="SATA-接口"><a href="#SATA-接口" class="headerlink" title="SATA 接口"></a>SATA 接口</h4><p>SATA（Serial Advanced Technology Attachment，常被称为“串口”）硬盘接口，是由 Intel、 IBM、Dell、APT、Maxtor 和 Seagate 组成的 SATA-IO 提出的硬盘接口规范。它采用串行方式传输数据，结构简单，支持热插拔，具备了更高的传输速度和更强的纠错能力。SATA 1.0定义的数据传输率即可达 150MB/s，SATA2.0 的数据传输率将达到 300MB/s，目前最新的版本已经是 SATA Revision 3.0，传输速度可达到 600MB/s。SATA 接口如下图所示：</p><p><img src="/blog/static/imgs/disk/SATA.jpeg" alt="sata_inner"></p><h4 id="SCSI-接口"><a href="#SCSI-接口" class="headerlink" title="SCSI 接口"></a>SCSI 接口</h4><p>SCSI（Small Computer System Interface，小型计算机系统接口）接口，被广泛应用于计算机及其周边设备（尤其是存储设备）之间进行连接。它具有应用范围广、多任务、带宽大、CPU 占用率低及支持热插拔等优点，但是由于成本问题，主要用于中高端服务器与工作站上。最初的 SCSI 标准为 SCSI-1，又名 Narrow SCSI，于1986年发布，最大支持7个设备，最大同步传输速率为5MB/s。1994年 发布了 SCSI-2，又名 Fast SCSI，时钟频率提升了一倍，最大同步传输速率为10MB/s，之后又另一种提高速度的选择，传输频率提高一倍的同时也增大数据通路的宽度，由8位增至16位，这个标准被称为 Wide SCSI，它的最大同步传输速率为20MB/s。1995年左右出现了第三代 SCSI，被称为 Ultra SCSI。SCSI-3 有很多型号，其中传输速率最快的为 2003 年发布的 Ultra 640 SCSI，最大传输速度达到 640MB/s。SCSI 接口如下图所示：</p><p><img src="/blog/static/imgs/disk/SCSI.jpeg" alt="scsi_inner"></p><h4 id="光纤通道"><a href="#光纤通道" class="headerlink" title="光纤通道"></a>光纤通道</h4><p>光纤通道（Fibre Channel，FC）是一种高速数据传输协议，可提供原始块数据的有序、无损传输。光纤通道由信息技术标准国际委员会（INCITS）的T11技术委员会负责标准化。光纤通道主要是用于连接计算机的数据存储到服务器在存储区域网络（SAN）中的商业数据中心。光纤通道交换机最初的最大的传输速率为1Gbps，现在它已经发展到128Gbps 约合 16GB/s，且仍然可以使用8Gbps、16Gbps、32Gbps版本。</p><h4 id="SAS-接口"><a href="#SAS-接口" class="headerlink" title="SAS 接口"></a>SAS 接口</h4><p>SAS 接口 (Serial Attached SCSI，即串行连接SCSI）是新一代的 SCSI 技术，连接小型计算机系统接口，采用串行技术以获得更高的传输速度，并通过缩短连结线改善了内部空间。由 ANSI INCITS <a href="https://www.t10.org">T10 committee</a> 负责维护。SAS 是并行 SCSI 接口之后开发出的全新接口。此接口的设计是为了改善存储系统的效能、可用性和扩充性，并且提供与 SATA 硬盘的兼容性。最新的于2017年发布 SAS4 标准可提供 24Gbps 的全双工传输速率。</p><h4 id="PCIe-接口"><a href="#PCIe-接口" class="headerlink" title="PCIe 接口"></a>PCIe 接口</h4><p>PCIe（Peripheral Component Interconnect Express）是一种高速串行计算机扩展总线规范，它原来的名称为“3GIO”，是由 Intel 在2001年提出的，旨在替代旧的 PCI，PCI-X 和 AGP 总线标准。PCI-E 是一项不断发展和完善的技术，由 PCI-SIG 组织负责开发与发布。PCI-E 提供了4种接口尺寸 X1/X4/X8/X16。截止目前（2022年7月25日），最新一版是于2022年6月22日发布的 PCIe 7.0，在一条通道 (x1) 上单向实现了 128GT / s 或 128Gbps 总吞吐量。</p><h4 id="mSATA-接口"><a href="#mSATA-接口" class="headerlink" title="mSATA 接口"></a>mSATA 接口</h4><p>mSATA (mini-SATA)是迷你版本SATA接口，由 SATA-IO(Serial ATA International Organization)开发，外型和针脚排布与 mini PCI-E 完全相同，提供跟 SATA 接口标准一样的速度和可靠度。</p><h4 id="M-2-NGFF-接口"><a href="#M-2-NGFF-接口" class="headerlink" title="M.2(NGFF) 接口"></a>M.2(NGFF) 接口</h4><p>M.2 接口，是 Intel 推出的一种替代 mSATA 的新的接口方案。M.2 接口有两种类型：Socket 2（B key——ngff）和Socket 3（M key——nvme），其中 Socket2 支持 SATA、PCI-E x2 接口，而如果采用 PCI-E x2 接口标准，最大的读取速度可以达到700MB/s，写入也能达到550MB/s。而其中的 Socket 3 可支持 PCI-E x4 接口，理论带宽可达4GB/s。<br>M.2标准的 SSD 同 mSATA 一样可以进行单面 NAND 闪存颗粒的布置，也可以进行双面布置，其中单面布置的总厚度仅有2.75mm，而双面布置的厚度也仅为3.85mm。</p><p>资料传输方式：</p><ul><li>M.2接口 SATA通道：硬盘→内存→CPU→内存→硬盘</li><li>M.2接口 PCI-E通道 NVMe规范：硬盘→CPU→硬盘</li></ul><h4 id="AHCI-规范"><a href="#AHCI-规范" class="headerlink" title="AHCI 规范"></a>AHCI 规范</h4><p><a href="https://www.intel.com/content/www/us/en/io/serial-ata/ahci.html">AHCI</a>（Advanced Host Controller Interface，高级主机控制器接口）是由 Intel 制定的技术标准，由 SATA-IO 组织负责维护。该规范描述了一种系统内存结构，供计算机硬件供应商在主机系统内存和附加存储设备之间交换数据。该规范被广泛应用于 SATA 硬盘，也被称为 SATA 协议。</p><h4 id="NVMe-规范"><a href="#NVMe-规范" class="headerlink" title="NVMe 规范"></a>NVMe 规范</h4><p><a href="https://nvmexpress.org/">NVMe</a>（Non Volatile Memory Express），或称非易失性内存主机控制器接口规范（Non Volatile Memory Host Controller Interface Specification，NVMHCIS），是一个逻辑设备接口规范，定义了主机软件如何跨 PCI-E、RDMA、TCP 等多种传输方式与非易失性存储器进行通信。它是所有外形尺寸（U.2、M.2、AIC、EDSFF）的固态硬盘 (SSD) 的行业标准。最新的版本是 NVMe 2.0，包括了一系列的文档。</p><h3 id="硬盘排查软件"><a href="#硬盘排查软件" class="headerlink" title="硬盘排查软件"></a>硬盘排查软件</h3><p>CrystalDiskInfo</p><p>CrystalDiskMark</p><p>QuickBench</p><p>DiskSpeedTest</p><p>DiskGenius</p><p>victoria</p><h3 id="机械硬盘中的叠瓦盘和垂直盘"><a href="#机械硬盘中的叠瓦盘和垂直盘" class="headerlink" title="机械硬盘中的叠瓦盘和垂直盘"></a>机械硬盘中的叠瓦盘和垂直盘</h3><p>垂直盘（CMR）和叠瓦盘（SMR）是机械硬盘的两种磁盘分布方式。</p><p>传统的垂直盘的磁道是水平排列的，而叠瓦盘不会将磁道分开，而是将磁道像瓦片一样叠起来，利用这种方式可以增加磁道数量，提高数据密度。</p><p>由于叠瓦盘的磁道是叠在一起的，改写数据时，就会影响到相邻磁道，为了避免影响，增加读写性能，叠瓦盘就需要大的缓存。</p><h3 id="MTBF-MTTR-MTTF的区别和联系"><a href="#MTBF-MTTR-MTTF的区别和联系" class="headerlink" title="MTBF MTTR MTTF的区别和联系"></a>MTBF MTTR MTTF的区别和联系</h3><p>MTBF（Mean Time Between Failures），平均故障时间，又称平均无故障时间，指产品出现两次相邻故障之间的平均时间，当然，MTBF越长，表示故障出现的越不频繁。</p><p>MTTR（Mean Time To Repair），平均恢复时间，指从出现故障到恢复的时间，当然，MTTR越短，表示易恢复性越好。</p><p>MTTF（Mean Time To Failures），平均失效时间，指系统正常工作到出现故障的时间，当然，MTTF越长，表示系统可靠性越高。</p><p><img src="/blog/static/imgs/disk/mttf.png" alt="mttf_inner"></p><h3 id="RPM"><a href="#RPM" class="headerlink" title="RPM"></a>RPM</h3><p>RPM（Revolutions Per Minute），转/每分钟，是表示机械硬盘盘片转速的单位。RPM值越大，盘片转速就越快，硬盘寻找文件的速度也就越快，相对的硬盘的传输速度也就得到了提高，但同时，高转速带来了更高的功耗、噪声和故障率。家用的普通硬盘的转速一般有5400rpm、7200rpm，对于笔记本硬盘则是4200rpm、5400rpm为主。服务器用户对硬盘性能要求最高，服务器中使用的SCSI硬盘转速基本都采用10000rpm，甚至还有15000rpm的。<br>硬盘电机的功耗与转速的2.8次方成正比，与盘片直径的4.6次方成正比，功耗越大则故障率越高</p><h2 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h2><h3 id="磁带"><a href="#磁带" class="headerlink" title="磁带"></a>磁带</h3><p>磁带（Tape）是一种用于记录声音、图像、数字或其他信号的载有磁层的带状材料，是产量最大和用途最广的一种磁记录材料。通常是在塑料薄膜带基（支持体）上涂覆一层颗粒状磁性材料或蒸发沉积上一层磁性氧化物或合金薄膜而成。曾使用纸和赛璐珞等作带基，现主要用强度高、稳定性好和不易变形的聚酯薄膜。</p><h3 id="软盘"><a href="#软盘" class="headerlink" title="软盘"></a>软盘</h3><p>软盘（Floppy Disk）是个人计算机（PC）中最早使用的可移动介质。1967年，IBM 公司推出世界上第一张软盘，直径达32英寸，发明者是艾伦・舒加特（Alan Shugart，希捷创始人）。软盘的读写是通过软盘驱动器完成的。软盘驱动器设计成能接收可移动式软盘，常用的就是容量为1.44MB的3.5英寸软盘。一个1.44M的软盘，它有80个磁道，每个磁道有18个扇区，两面都可以存储数据，每个扇区存储512个字节。我们可以这样计算它的容量：80×18×2×512≈1440KB≈1.44MB。软盘中的数据一般可保存5－8年的时间，盘片不能变形、不能受高温、不能受潮、不能靠近磁性物质，而且每次存储数据都需要先格式化，存取速度慢，最主要的是容量太小，所以现在已经被淘汰了。</p><h3 id="U盘"><a href="#U盘" class="headerlink" title="U盘"></a>U盘</h3><p>U盘是 USB 盘（USB flash disk）的简称，由朗科发明。U盘与硬盘的最大不同是，它不需物理驱动器，即插即用，且其存储容量远超过软盘，极便于携带。</p><h3 id="光盘"><a href="#光盘" class="headerlink" title="光盘"></a>光盘</h3><p>见上 <a href="/blog/2022/07/25/CS-个人存储方案/#光盘">光盘</a> 所述。</p><h3 id="存储卡"><a href="#存储卡" class="headerlink" title="存储卡"></a>存储卡</h3><p>常见的存储卡有 SD 卡、CF 卡、CFast 卡、XQD 卡、CFexpress 卡、MS 卡（记忆棒）、XD 卡、MMC 卡和 SM 卡等，其中最常用的是 SD 卡，CFast 卡、XQD 卡、CFexpress 卡兼顾了单反和微单的高速摄像的应用。</p><h4 id="SD卡"><a href="#SD卡" class="headerlink" title="SD卡"></a>SD卡</h4><p>SD 存储卡（Secure Digital Memory Card）是一种基于半导体快闪存储器的高速存储设备，1999年8月由 Panasonic、Toshiba、SanDisk 3家公司共同开发，在推出 SD 存储卡的同时，成立安全储存数码卡协会（Secure Digital Card Association，SDA）制订相关规范，并负责 SD 存储卡的推广工作。SD 卡的数据传送和物理规范由 MMC（MulTI Media Card）发展而来，大小和 MMC 卡差不多，尺寸为 32mm x 24mm x 2.1mm，长宽和 MMC 卡一样，只是比 MMC 卡厚了0.7mm，以容纳更大容量的存贮单元。</p><ol><li>尺寸</li></ol><p>SD 卡家族有 SD、Mini SD、Micro SD 共3位成员，尺寸依次减小。标准 SD 卡用于绝大多数相机、摄像机，本体带有一个写保护开关——但它并不影响存储卡的内部，而是影响读卡设备的识别。Mini SD 卡已经退出历史舞台，Micro SD 卡又称作 TF 卡，主要用于手机、运动相机、无人机等产品。</p><ol start="2"><li>容量</li></ol><p>我们统称的 SD 卡，其实在最大容量方面有多种版本。最初的 SD 卡使用 FAT16 文件系统，最大容量只能达到2GB，现在已经退出主流应用。最常见的 SDHC（SD High Capacity）存储卡和 SDXC（SD eXtended Capacity）存储卡，分别使用 FAT32 文件系统和 EXFAT 文件系统，最大容量分别为32GB和2TB。新推出的 SDUC 存储卡，理论容量可以达到128TB，值得一提的是，64GB以上的SD卡（SDXC及SDUC）采用 EXFAT 格式，单个文件的尺寸可以大于4GB，是需要长时间连续记录4K高码率视频拍摄的用户选择。</p><ol start="3"><li>速度</li></ol><p>速度等级是 SD 卡联盟指定的性能规范，同时也是 SD 卡生产商需要在产品本体、外包装上印刷的标志。速度等级通常只能体现 SD 卡的最低性能水平，不代表实际性能。</p><ul><li><p>无UHS：单排触点，最高标准C10（持续写入速度不低于10MB/s），理论速度不超过25MB/s（通常指读取速度，写入速度会稍低一些）。这种卡目前已经基本退出市场了。</p></li><li><p>UHS-I：单排触点，最高标准C10、U3、V30（持续写入速度30MB/s），理论速度104MB/s。这是目前市场的最主力产品。</p></li><li><p>UHS-II：双排触点，最高标准C10，U3，V90（持续写入速度90MB/s）。全双工模式理论速度156MB/s（大多数相机）、半双工模式理论速度312MB/s（读卡器等）。</p></li><li><p>UHS-III：双排触点，最高标准C10，U3，V90，全双工模式即可达到624MB/s。不过，目前还没有实际产品。</p></li><li><p>SD Express：双排触点，采用 PCIe 3.0 总线且支持 NVMe，可以达到985MB/s的超高速度。目前，闪迪（西部数据）已经推出了原型产品。需要说明的是，SD Express 只能向下兼容 UHS-I，不支持 UHS-II 或 UHS-III —— 也就是当存储卡、设备中有一个不支持 SD Express 时，系统能达到的最高速度是104MB/s。</p></li></ul><h4 id="CF卡"><a href="#CF卡" class="headerlink" title="CF卡"></a>CF卡</h4><p>CF（Compact Flash）卡最初是一种用于便携式电子设备的数据存储设备。作为一种存储设备，它革命性的使用了闪存，于1994年首次由 SanDisk 公司生产并制定了相关规范。CF卡内部控制器设计完全模拟硬盘，使用标准的并行 ATA/IDE 接口界面，国际 CFA 协会（Compact Flash Association） 最新规范 CF6.0，总线速度最高可达167 MB/s。</p><h4 id="CFast卡"><a href="#CFast卡" class="headerlink" title="CFast卡"></a>CFast卡</h4><p>CFast 卡是由 CFA（CompactFlash AssociaTIon，CFA）2008年制定的标准和规范，是 CF 阵营开发出 CF 规范的新升级标准，使用的传输协议是 SATA，早期使用 SATA2，现在已经普遍使用 SATA3。同时外形和 CF 卡一样，号称是世界上最小的 SATA 固态硬盘。CFast2.0 规范支持 SATA3，总线速度可达600MB/s。基于 CFast 2.0 规范的 CFast 卡适用于工业以及专业成像和视频市场。</p><p>随着闪存产品的不断进阶演化，该协会已于2017年发布了 PCI-E 传输信号的 CFexpress* 1.0规格。CFast 卡和 CF 卡是两种不同等级的产品，可以说 CFast 卡是 CF 卡的进阶演化和“变异升级”，但不能想当然的认为 CF 卡就是 CFast 卡，或者以为两者就是更新换代的关系。CF 卡和 CFast 卡不能通用。</p><h4 id="XQD卡"><a href="#XQD卡" class="headerlink" title="XQD卡"></a>XQD卡</h4><p>XQD 卡规范最初由 Sony、SanDisk 和 Nikon 在2010年11月发表，并立刻被 Compact Flash协会提取作为发展目标。2011年12月8日，CFA 协会（Compact Flash Association）公布了新开发的 XQD 存储卡格式，随后第一批样品也于2012年2月在日本“CP+ 2012”展会上展示。XQD 是一种采用快闪存储器的存储卡格式，是针对 CF 卡的缺点而进行设计的，拥有更小的体积、更快的写入以及更大的容量、更为出色的可靠性及稳定性等等优势。基于 PCI-E 规范，最初只有125MB/s的持续写入速度、最大容量32GB；新一代 XQD 卡则是440MB/s读取、400MB/s写入速度，最大容量240GB，高速写入可持续拍摄长达200张的 RAW 图片，视频录制方面可实现稳定高帧4K录制的同时又能避免速度的下降。</p><h4 id="CFexpress卡"><a href="#CFexpress卡" class="headerlink" title="CFexpress卡"></a>CFexpress卡</h4><p>在 CP+2019 上，CFA协会（Compact Flash Association）公布了 CFexpress 2.0 规范。CFexpress 卡是新一代存储卡标准，目前已有尼康的Z系列微单、松下的S系列、佳能的R系列微单支持该标准，它将 CFexpress 卡划分三种类型。</p><ul><li><p>Type A：尺寸是20mm<em>28mm</em>2.8mm，略小于 SD 卡，1条 PCI-E 通道，理论传输速度1GB/s，主要针对普通数码相机设计；</p></li><li><p>Type B：尺寸是38.5mm<em>29.8mm</em>2.8mm，与 XQD 卡相同，2条 PCI-E 通道，理论传输速度2GB/s，主要针对高端数码相机设计；</p></li><li><p>Type C：尺寸是54mm<em>74mm</em>4.8mm，外形类似2.5英寸 SSD，4条 PCI-E 通道，理论传输速度4GB/s，主要针对台式机、笔记本电脑、平板电脑设计，以取代固态硬盘。</p></li></ul><h3 id="移动硬盘"><a href="#移动硬盘" class="headerlink" title="移动硬盘"></a>移动硬盘</h3><p>移动硬盘，主要指采用 USB 等接口，支持热插拔，小巧而便于携带的硬盘存储器。移动硬盘主要由外壳、电路板（包括控制芯片以及数据和电源接口）和硬盘三部分组成。硬盘通常采用2.5英寸机械硬盘或固态硬盘，数据接口通常采用 USB 或者 IEEE1394。</p><h3 id="网盘"><a href="#网盘" class="headerlink" title="网盘"></a>网盘</h3><p>网盘，是指由互联网公司推出的在线存储 SaaS 服务。服务器机房为用户划分一定的磁盘空间，为用户免费或收费提供文件的存储、访问、备份、共享等文件管理等功能，并且提供容灾备份的能力。<br>目前国内市场占有率最高的就是百度网盘（百度），几乎占据了80%以上的市场。另外还有 腾讯微云（腾讯）、天翼云盘（中国电信）、和彩云网盘（中国移动）、阿里云盘（阿里巴巴）。国外还有 Dropbox、iCloud Drive（Apple）等网盘。</p><h3 id="NAS"><a href="#NAS" class="headerlink" title="NAS"></a>NAS</h3><p>网络附加存储（Network Attached Storage，NAS）是指连接到计算机网络的文件级（与块级存储相反）计算机数据存储服务器，提供对异构客户端组的数据访问。NAS 被定义为一种特殊的专用数据存储服务器，由存储器件（例如磁盘阵列、CD/DVD 驱动器、磁带驱动器或可移动的存储介质）和内嵌系统软件构成，可提供跨平台文件共享功能。</p><h3 id="SAN"><a href="#SAN" class="headerlink" title="SAN"></a>SAN</h3><p>存储区域网络（Storage Area Network，SAN）是企业常用的存储网络架构。存储区域网络是一种连接外接存储设备和服务器的架构。人们采用包括光纤通道技术、磁盘阵列、磁带柜、光盘柜的各种技术进行实现。该架构的特点是，连接到服务器的存储设备，将被操作系统视为直接连接的存储设备。</p><p>存储区域网络部署通常用于支持性能要求较高的业务关键型应用，例如：</p><ul><li>Oracle 数据库</li><li>Microsoft SQL Server 数据库</li><li>采用 VMware、KVM 或 Microsoft Hyper-V 的大型虚拟化部署</li><li>大型虚拟桌面基础架构 (Virtual Vesktop Infrastructure, VDI)</li><li>SAP 或其他大型 ERP 或 CRM 环境</li></ul><h4 id="SAN-与-NAS-区别"><a href="#SAN-与-NAS-区别" class="headerlink" title="SAN 与 NAS 区别"></a>SAN 与 NAS 区别</h4><p>SAN 和 NAS 都可以用于集中管理存储，并与多个主机（服务器）共享该存储。但是，NAS 基于以太网，而 SAN 可使用以太网和光纤通道。此外，SAN 注重高性能和低延迟，NAS 则注重易用性、易管理性、可扩展性和更低的总拥有成本 (TCO，Total Cost Of Ownership)。不同于 SAN，NAS 存储控制器会对存储进行分区，并拥有文件系统所有权。实际上，对于使用存储的服务器来说，这使 NAS 服务器看起来就像一台 Windows 或 UNIX/Linux 服务器。</p><p>SAN协议包括：</p><ul><li>光纤通道协议 (FCP)</li><li>Internet 小型计算机系统接口 (iSCSI)</li><li>以太网光纤通道 (FCoE)</li><li>基于光纤通道的非易失性内存标准 (FC-NVMe)</li></ul><p>NAS协议包括：</p><ul><li>公共 Internet 文件服务/服务器消息块 (Common Internet File Services / Server Message Block, CIFS/SMB)</li><li>网络文件系统 (NFS)</li></ul><p>相对于 NAS 与 SAN ，直接将存储设备通过 SCSI 或光纤通道连接到主机上的存储方式，被称为 直接附加存储（Direct Attached Storage，DAS）。</p><h2 id="品牌商与产品"><a href="#品牌商与产品" class="headerlink" title="品牌商与产品"></a>品牌商与产品</h2><h3 id="机械硬盘品牌"><a href="#机械硬盘品牌" class="headerlink" title="机械硬盘品牌"></a>机械硬盘品牌</h3><h4 id="希捷"><a href="#希捷" class="headerlink" title="希捷"></a>希捷</h4><p><a href="https://www.seagate.com/cn/zh/">希捷</a>（Seagate Technology Corp）成立于1979年，是全球最大的硬盘、磁盘和读写磁头制造商，总部位于美国加州 Scotts Valley 市。</p><p>2006年5月 希捷收购迈拓（Maxtor）公司。</p><table><thead><tr><th></th><th><a href="https://www.seagate.com/files/www-content/datasheets/pdfs/3-5-barracudaDS1900-14-2007CN-zh_CN.pdf">酷鱼（BarraCuda）</a></th><th><a href="https://www.seagate.com/files/www-content/datasheets/pdfs/ironwolf-18tb-DS1904-20-2111CN-zh_CN.pdf">酷狼（IronWolf）</a></th><th><a href="https://www.seagate.com/files/www-content/datasheets/pdfs/ironwolf-pro-20tb-DS1914-20-2204CN-zh_CN.pdf">酷狼 Pro</a></th><th><a href="https://www.seagate.com/files/www-content/datasheets/pdfs/skyhawk-3-5-hdd-china-DS1902-16C-2107CN-zh_CN.pdf">酷鹰（SkyHawk）</a></th><th><a href="https://www.seagate.com/files/www-content/datasheets/pdfs/skyhawk-ai-china-DS1960-13S-2201CN-zh_CN.pdf">酷鹰 AI（SkyHawk AI）</a></th><th><a href="https://www.seagate.com/files/www-content/datasheets/pdfs/exos-x20-channel-DS2080-2111CN-zh_CN.pdf">银河 X20（Exos X20）</a> <a href="https://www.seagate.com/files/www-content/datasheets/pdfs/exos-x18-channel-DS2045-4-2106CN-zh_CN.pdf">银河X18 (Exo X18)</a></th></tr></thead><tbody><tr><td>用途</td><td>家用</td><td>NAS</td><td>商用NAS</td><td>监控</td><td>视频</td><td>企业级</td></tr></tbody></table><h4 id="西部数据"><a href="#西部数据" class="headerlink" title="西部数据"></a>西部数据</h4><p><a href="https://www.westerndigital.com/zh-cn">西部数据公司</a>（Western Digital Corp，WDC），是一家全球知名的硬盘厂商，成立于1970年，总部位于美国加州，在世界各地设有分支机构，为全球用户提供存储产品。</p><p>2011年，西数以43亿美元收购日立环球存储技术公司（HGST），后者曾于2002年以20亿美元并购 IBM 的硬盘部门。<br>2016年5月，西数以160亿美元完成对 SanDisk 的收购。<br>2017年9月，西数以183亿美元收购东芝的半导体业务。</p><p>西数的机械硬盘按照颜色分为不同的用途有细微的优化，参见 <a href="https://www.westerndigital.com/zh-cn/solutions/color-drives">WD彩色硬盘</a>：</p><table><thead><tr><th></th><th>绿盘</th><th>蓝盘</th><th>黑盘</th><th>红盘</th><th>紫盘</th><th>金盘</th></tr></thead><tbody><tr><td>用途</td><td>最适合日常轻型计算</td><td>专为创意专业人士打造，旨在提供最大容量的存储设备</td><td>专为游戏而优化的高性能硬盘</td><td>NAS环境</td><td>专为 24×7 全天候智慧视频录制而打造的大容量存储设备</td><td>适用于企业应用程序的可靠、高性能硬盘</td></tr><tr><td>优势</td><td>低价格，低功耗，适合存储照片、视频、音频</td><td>性能较强，价格较低，性价比高，适合普通家用</td><td>高性能，大缓存（两倍 DRAM 高速缓存），适合游戏</td><td>提高了兼容性、可升级性和可靠性，支持 24×7 全天候环境，适合NAS系统</td><td>对主流监控应用中典型的写入密集型、低比特率、高流数工作负载进行了优化，防锈蚀，适合视频监控存储</td><td>最高支持22T，5年质保，适合数据中心和邮件服务器</td></tr></tbody></table><h4 id="东芝"><a href="#东芝" class="headerlink" title="东芝"></a>东芝</h4><p><a href="https://toshiba-semicon-storage.com/cn/storage.html">东芝</a>（Toshiba Corp）原名东京芝浦电气株式会社，1939年由株式会社芝浦制作所和东京电气株式会社合并而成。</p><p>2019年10月1日东芝存储器株式会社正式更名为“Kioxia”，中文名为“铠侠株式会社”。</p><table><thead><tr><th></th><th><a href="https://toshiba-semicon-storage.com/cn/canvio/product/internal/n300.html">N300</a></th><th><a href="https://toshiba-semicon-storage.com/cn/canvio/product/internal/p300.html">P300</a></th><th><a href="https://toshiba-semicon-storage.com/cn/canvio/product/internal/x300.html">X300</a></th></tr></thead><tbody><tr><td>用途</td><td>NAS</td><td>一体计算机，桌上计算机</td><td>专业系统，家用多媒体计算机，游戏用计算机</td></tr><tr><td>规格</td><td>4TB 6TB 8TB 10TB 12TB 14TB 16TB</td><td>500GB 1TB 2TB 3TB 4TB 6TB</td><td>4TB 5TB 6TB</td></tr><tr><td>尺寸</td><td>3.5-inch</td><td>3.5-inch</td><td>3.5-inch</td></tr><tr><td>接口</td><td>SATA 6.0Gbit/s</td><td>SATA 6.0Gbit/s</td><td>SATA 6.0Gbit/s</td></tr><tr><td>转速</td><td>7,200RPM</td><td>7,200RPM（对应型号：HDWD130、HDWD120、HDWD110、HDWD105）<br>5,400RPM（对应型号：HDWD260、HDWD240、HDWD220）</td><td>7,200RPM</td></tr><tr><td>缓存</td><td>256MB（对应型号：HDWG440、HDWG460、HDWG480、HDWG11A、HDWG21C)<br>512MB（对应型号：HDWG31E、HDWG31G)</td><td></td><td>128MB</td></tr><tr><td>MTTF</td><td>1,000,000小时（对应型号：HDWG440、HDWG460、HDWG480、HDWG11A、HDWG21C）<br>1,200,000小时（对应型号：HDWG31E、HDWG31G）</td><td></td><td>600,000小时</td></tr><tr><td>加载／卸载次数</td><td>300,000次</td><td>600,000次</td><td></td></tr><tr><td>记录技术</td><td>CMR</td><td>CMR（对应型号：HDWD130、HDWD120、HDWD110、HDWD105）SMR（对应型号：HDWD260、HDWD240、HDWD220）</td><td>CMR</td></tr><tr><td>其他</td><td>内置旋转震动（RV）感应器；<br>24x7运行（Workloads），支持（180TB／每年）</td><td>内置冲击传感器，用于检测冲击力，屏蔽相邻磁道数据</td><td>支持震动感应器</td></tr><tr><td>质量保证</td><td>3年有限质保</td><td>2年有限质保</td><td>2年有限质保</td></tr></tbody></table><h3 id="固态硬盘品牌"><a href="#固态硬盘品牌" class="headerlink" title="固态硬盘品牌"></a>固态硬盘品牌</h3><p>固态硬盘的性能主要在于 NAND 闪存。主要的 NAND Flash 生产商包括 三星 Samsung、铠侠 Kioxia、西部数据 WestDigital、美光 Micron、海力士 Hynix、英特尔 Intel，市场占有率超过95%。国产的有 长江存储 Yangtze。</p><p>成品固态硬盘主要厂商有：三星 Samsung、铠侠 Kioxia（原东芝 Toshiba）、英特尔 Intel、西部数据 WestDigital、英睿达 Crucial(美光 Micron)、闪迪 SanDisk（也属于西部数据）、海力士 Hynix（原现代内存）</p><p>国产的有：光威 Gloway、影驰 Galaxy、致钛 ZhiTai</p><h3 id="NAS-品牌"><a href="#NAS-品牌" class="headerlink" title="NAS 品牌"></a>NAS 品牌</h3><p>群晖（Synology），成立于2000年，是台湾的网络存储服务器(NAS)品牌。</p><p>威联通（QNAP），2004年成立于台湾，专注储存、网络及智能影音产品创。QNAP命名源自于高质量网络设备制造商（Quality Network Appliance Provider）。</p><p>绿联（UGREEN），成立于2012年深圳，是一家集研发、设计、生产、销售于一体的国家级高新技术企业，致力于为用户提供全方位数码解决方案。</p><p>海康威视（HIKVISION），杭州海康威视数字技术股份有限公司旗下品牌，2001年成立。</p><p>新华三（H3C），2016年成立于杭州，是全球领先的高科技和电子设备供应商。</p><p>亿格瑞（Egreat）隶属于深圳市亿格瑞科技有限公司旗下，是一家致力于高清播放产品自主研发、生产、营销、服务的高科技企业。</p>]]></content>
      
      
      
        <tags>
            
            <tag> storage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust学习笔记</title>
      <link href="/blog/2022/07/08/Rust-Rust%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/blog/2022/07/08/Rust-Rust%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.rust-lang.org/">Rust</a> 是一门比较新的系统编程语言。Rust 在语法上和 C++ 与 Haskell 比较类似，支持函数式和命令式以及泛型等多种编程范式，在保证性能的同时提供更好的内存安全策略。Rust 最初由 Mozilia 研究院的 Graydon Hoare 设计创造，然后在 Dave Herman, Brendan Eich 以及很多人的贡献下逐步完善。第一个有版本号的 Rust 编译器于2012 年1月发布。Mozilla 在2014年10月宣布发布 Rust 编译器和工具的0.12版。Rust 1.0 是第一个稳定版本，于 2015年5月15日发布。当前（2022年7月8日）的最新版本是 1.62.0。</p><span id="more"></span><h2 id="Rust-工具箱"><a href="#Rust-工具箱" class="headerlink" title="Rust 工具箱"></a>Rust 工具箱</h2><p>不同于其他编程语言需要由开发者来共建生态，Rust 社区提供了一揽子的生态工具和 Rust 语言配合，这个工具相当于是官方支持的，所以被广泛接受。</p><table><thead><tr><th>工具</th><th>作用</th><th>类比</th></tr></thead><tbody><tr><td>Rustup</td><td>Rust 的安装器和版本管理工具。可以通过 <code>rustup update</code> 来更新 Rust 的版本。</td><td>nvm</td></tr><tr><td>Cargo</td><td>Rust 的构建工具和包管理器。可以通过 <code>cargo --version</code> 来查看 Rust 和 Cargo 的版本，他们的版本始终是保持一致的。</td><td>npm/yarn</td></tr><tr><td><a href="https://crates.io/">crates.io</a></td><td>Rust 包的仓库</td><td>npmjs.com</td></tr><tr><td>Rustfmt</td><td>Rust 的代码风格格式化工具。</td><td>prettier</td></tr><tr><td>Clippy</td><td>Rust 的代码风格检查工具。</td><td>eslint/standard</td></tr><tr><td>Rust Language Server(LSP)</td><td>为 Rust 提供编辑器和IDE支持</td><td></td></tr><tr><td>Rustdoc</td><td>Rust 的文档生成器</td><td></td></tr><tr><td><a href="https://discord.gg/rust-lang">Rust 官方 Discord</a></td><td>Rust 相关问题的讨论区</td><td></td></tr><tr><td><a href="https://stackoverflow.com/questions/tagged/rust">Rust stackoverflow tag</a></td><td>Rust 相关问题提问区</td><td></td></tr><tr><td><a href="https://users.rust-lang.org/">Rust 官方用户论坛</a></td><td>Rust 用户论坛</td><td>-</td></tr><tr><td><a href="https://toml.io/">TOML</a></td><td>Cargo 配置文件格式</td></tr></tbody></table><h2 id="开始-Hello-World"><a href="#开始-Hello-World" class="headerlink" title="开始 Hello World!"></a>开始 Hello World!</h2><p>首先，需要安装 Rust 及相关生态工具，以下均以类 Linux 系统为例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh <span class="comment"># 安装 Rustup &amp; Cargo</span></span><br><span class="line">cargo --version <span class="comment"># 查看 Rust 版本，验证是否正确安装</span></span><br></pre></td></tr></table></figure><p>创建一个新的 Rust 项目</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cargo new hello-rust <span class="comment"># 生成一个新的“Hello, world!”项目</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含以下文件</span></span><br><span class="line"><span class="comment"># hello-rust</span></span><br><span class="line"><span class="comment"># |- Cargo.toml # Rust 的清单文件。其中包含了项目的元数据和依赖库。</span></span><br><span class="line"><span class="comment"># |- src</span></span><br><span class="line"><span class="comment">#   |- main.rs # 编写应用代码的地方。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> hello-rust</span><br><span class="line">cargo run <span class="comment"># 执行程序</span></span><br></pre></td></tr></table></figure><p>这样就可以在控制台看到 Hello, world! 的提示语。<br>在 Cargo.toml 文件中添加以下信息</p><figure class="highlight toml"><figcaption><span>Cargo.toml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">ferris-says</span> = <span class="string">&quot;0.2&quot;</span></span><br></pre></td></tr></table></figure><p>在 main.rs 中添加以下代码</p><figure class="highlight rust"><figcaption><span>main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> ferris_says::say;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;stdout, BufWriter&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">stdout</span> = <span class="title function_ invoke__">stdout</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">message</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello fellow Rustaceans!&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">width</span> = message.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">count</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">writer</span> = BufWriter::<span class="title function_ invoke__">new</span>(stdout.<span class="title function_ invoke__">lock</span>());</span><br><span class="line">    <span class="title function_ invoke__">say</span>(message.<span class="title function_ invoke__">as_bytes</span>(), width, &amp;<span class="keyword">mut</span> writer).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cargo build <span class="comment"># 安装依赖。此命令会创建一个新文件 Cargo.lock，该文件记录了本地所用依赖库的精确版本。</span></span><br><span class="line">cargo run <span class="comment"># 执行程序</span></span><br><span class="line"><span class="comment"># 执行结果：</span></span><br><span class="line"><span class="comment">#  __________________________</span></span><br><span class="line"><span class="comment"># &lt; Hello fellow Rustaceans! &gt;</span></span><br><span class="line"><span class="comment">#  --------------------------</span></span><br><span class="line"><span class="comment">#         \</span></span><br><span class="line"><span class="comment">#          \</span></span><br><span class="line"><span class="comment">#             _~^~^~_</span></span><br><span class="line"><span class="comment">#         \) /  o o  \ (/</span></span><br><span class="line"><span class="comment">#           &#x27;_   -   _&#x27;</span></span><br><span class="line"><span class="comment">#           / &#x27;-----&#x27; \</span></span><br></pre></td></tr></table></figure><h2 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h2><p>Rust 是 静态类型（statically typed）语言，也就是说在编译时就必须知道所有变量的类型。<br>main 函数是 Rust 程序的入口。<br>Rust 不关心函数定义所在的位置，只要函数被调用时出现在调用之处可见的作用域内就行。<br>Rust 是一门基于表达式（expression-based）的语言。<br>Rust 并不会尝试自动地将非布尔值转换为布尔值。必须总是显式地使用布尔值作为 if 的条件。</p><p><a href="https://kaisery.github.io/trpl-zh-cn/appendix-01-keywords.html">关键字</a></p><p><a href="https://kaisery.github.io/trpl-zh-cn/appendix-02-operators.html">运算符与符号</a></p><p><a href="https://kaisery.github.io/trpl-zh-cn/appendix-03-derivable-traits.html">可派生的trait</a></p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><table><thead><tr><th>关键字与标志符</th><th>用法</th><th>作用</th><th>类比</th></tr></thead><tbody><tr><td><code>use</code></td><td><code>use std::io;</code></td><td>显示的引入</td><td><code>import</code></td></tr><tr><td><code>fn</code></td><td><code>fn main()&#123;&#125;</code></td><td>函数声明</td><td><code>function</code></td></tr><tr><td><code>let</code></td><td><code>let guess = 5;</code></td><td>变量声明，在 Rust 中，变量默认是不可变的</td><td><code>const</code></td></tr><tr><td><code>const</code></td><td><code>const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;</code></td><td>常量声明</td><td><code>const</code></td></tr><tr><td><code>mut</code></td><td><code>let mut guess = 5</code></td><td>可变变量声明</td><td><code>var</code></td></tr><tr><td><code>::</code></td><td><code>let mut guess = String::new();</code></td><td>关联函数(associated function)， 也就是类的静态方法（static method）</td><td><code>.</code></td></tr><tr><td><code>&amp;</code></td><td><code>io::stdin().read_line(&amp;mut guess)</code></td><td>引用（reference），它允许多处代码访问同一处数据，而无需在内存中多次拷贝。</td><td></td></tr><tr><td><code>match</code></td><td><code>match guess.cmp(&amp;secret_number) &#123; Ordering::Less =&gt; println!(&quot;Too small!&quot;), Ordering::Greater =&gt; println!(&quot;Too big!&quot;), Ordering::Equal =&gt; println!(&quot;You win!&quot;), &#125;</code></td><td>一个 match 表达式由 分支（arms） 构成。一个分支包含一个 模式（pattern）和表达式开头的值与分支模式相匹配时应该执行的代码。Rust 获取提供给 match 的值并挨个检查每个分支的模式。</td><td><code>switch ($&#123;cmp&#125;) &#123; case $&#123;condition&#125;: $&#123;action&#125;&#125;</code></td></tr><tr><td><code>loop</code></td><td><code>loop &#123;&#125;</code></td><td>循环</td><td><code>while(true) &#123;&#125;</code></td></tr></tbody></table><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="预导入-prelude"><a href="#预导入-prelude" class="headerlink" title="预导入 prelude"></a>预导入 prelude</h3><p>默认情况下，Rust 设定了若干个会自动导入到每个程序作用域中的标准库内容，这组内容被称为 <a href="https://doc.rust-lang.org/std/prelude/index.html">预导入</a> （prelude）内容。</p><h3 id="隐藏-shadow"><a href="#隐藏-shadow" class="headerlink" title="隐藏 shadow"></a>隐藏 shadow</h3><p>Rust 允许用一个新值来 隐藏 （shadow）变量之前的值。这个功能常用在需要转换值类型之类的场景。</p><h3 id="数据类型-data-type"><a href="#数据类型-data-type" class="headerlink" title="数据类型 data type"></a>数据类型 data type</h3><p>在 Rust 中，每一个值都属于某一个 数据类型（data type），这告诉 Rust 它被指定为何种数据，以便明确数据处理方式。</p><p>Rust 有两种数据类型子集 标量(scalar) 和 复合(compound)。</p><h3 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h3><p>Rust 有四种基本的标量类型：整数（integers）、浮点数（floating-point numbers）、布尔类型（booleans）和字符类型(characters)。</p><p>整数包括：</p><table><thead><tr><th>长度</th><th>有符号</th><th>无符号</th></tr></thead><tbody><tr><td>8-bit</td><td>i8</td><td>u8</td></tr><tr><td>16-bit</td><td>i16</td><td>u16</td></tr><tr><td>32-bit</td><td>i32</td><td>u32</td></tr><tr><td>64-bit</td><td>i64</td><td>u64</td></tr><tr><td>128-bit</td><td>i128</td><td>u128</td></tr><tr><td>arch</td><td>isize</td><td>usize</td></tr></tbody></table><p>Rust 也有两个原生的浮点数类型 f32 与 f64。</p><p>Rust 中的布尔类型有两个可能的值：true 和 false。Rust 中的布尔类型使用 bool 表示。</p><p>Rust的 char 类型是语言中最原生的字母类型。单引号声明字面量，双引号声明字符串字面量。Rust 的 char 类型的大小为四个字节(four bytes)，并代表了一个 Unicode 标量值（Unicode Scalar Value）。Unicode 标量值包含从 U+0000 到 U+D7FF 和 U+E000 到 U+10FFFF 在内的值。</p><h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><p>Rust 有两个原生的复合类型：元组（tuple）和数组（array）。</p><p>元组是一个将多个其他类型的值组合进一个复合类型的主要方式。元组长度固定：一旦声明，其长度不会增大或缩小。不带任何值的元组有个特殊的名称，叫做 单元（unit） 元组。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>); <span class="comment">// 元组的声明</span></span><br><span class="line"><span class="built_in">println!</span>(tup.<span class="number">0</span>) <span class="comment">// 打印 500。 使用 . 操作符来访问元组的值</span></span><br><span class="line"><span class="keyword">let</span> (x, y, z) = tup; <span class="comment">// 使用模式匹配（pattern matching）来解构（destructure）元组值</span></span><br><span class="line"><span class="built_in">println!</span>(y) <span class="comment">// 打印 6.4</span></span><br></pre></td></tr></table></figure><p>Rust 中的数组与一些其他语言中的数组不同，Rust中的数组长度是固定的。但是数组并不如 vector 类型灵活。vector 类型是标准库提供的一个 <em>允许</em> 增长和缩小长度的类似数组的集合类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; <span class="comment">// 数组声明</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span>: [<span class="number">3</span> ; <span class="number">5</span>]; <span class="comment">// 每个元素都为相同值的数组声明</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">first</span> = a[<span class="number">0</span>]; <span class="comment">// 使用索引来访问数组的元素</span></span><br></pre></td></tr></table></figure><h3 id="循环标签-loop-label"><a href="#循环标签-loop-label" class="headerlink" title="循环标签 loop label"></a>循环标签 loop label</h3><p>如果存在嵌套循环，break 和 continue 应用于此时最内层的循环。你可以选择在一个循环上指定一个 循环标签（loop label），然后将标签与 break 或 continue 一起使用，使这些关键字应用于已标记的循环而不是最内层的循环。循环标签以 单引号 开始， 冒号 结束，例如 <code>&#39;counting_up:</code> 。</p><h3 id="所有权-ownership"><a href="#所有权-ownership" class="headerlink" title="所有权 ownership"></a>所有权 ownership</h3><ol><li>Rust 中的每一个值都有一个被称为其 所有者（owner）的变量。</li><li>值在任一时刻有且只有一个所有者。</li><li>当所有者（变量）离开作用域，这个值将被丢弃。</li></ol><p>针对于内存与分配，Rust 采取了一个不同的策略：内存在拥有它的变量离开作用域后就被自动释放。当变量离开作用域，Rust 为我们调用一个特殊的函数。这个函数叫做 <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop">drop</a>。Rust 有一个叫做 Copy trait 的特殊注解，可以用在类似整型这样的存储在栈上的类型上。如果一个类型实现了 Copy trait，那么一个旧的变量在将其赋值给其他变量后仍然可用，否则，赋值操作会使旧的变量无效，这个操作被称为 <em>移动</em>（move）。如果我们 确实 需要深度复制未实现 Copy trait 的类型，可以使用一个叫做 clone 的通用函数。</p><p>以下类型实现了 Copy trait:</p><ul><li>所有整数类型，比如 u32。</li><li>布尔类型，bool，它的值是 true 和 false。</li><li>所有浮点数类型，比如 f64。</li><li>字符类型，char。</li><li>元组，当且仅当其包含的类型也都实现 Copy 的时候。比如，(i32, i32) 实现了 Copy，但 (i32, String) 就没有。</li></ul><p>将值传递给函数在语义上与给变量赋值相似。向函数传递值可能会 <em>移动</em> 或者 <em>复制</em> ，就像赋值语句一样。返回值也可以转移所有权。</p><h3 id="引用与借用-references-amp-borrowing"><a href="#引用与借用-references-amp-borrowing" class="headerlink" title="引用与借用 references &amp; borrowing"></a>引用与借用 references &amp; borrowing</h3><p>在 Rust 中， <code>&amp;</code> 符号就是 引用，它们允许你使用值但不获取其所有权。与使用 <code>&amp;</code> 引用相反的操作是 解引用（dereferencing），它使用解引用运算符 <code>*</code>。我们将创建一个引用的行为称为 借用（borrowing），（默认）不允许修改引用的值。</p><p><code>&amp;mut</code> 为可变引用（mutable reference），可变引用允许我们修改一个借用的值，但在同一时间只能有一个对某一特定数据的可变引用。</p><h3 id="作用域-scope"><a href="#作用域-scope" class="headerlink" title="作用域 scope"></a>作用域 scope</h3><p>作用域是一个项（item）在程序中有效的范围。变量作用域就是变量在程序中有效的范围。</p><p>一个引用的作用域从声明的地方开始一直持续到最后一次使用为止。</p><h3 id="非词法作用域生命周期-NLL"><a href="#非词法作用域生命周期-NLL" class="headerlink" title="非词法作用域生命周期 NLL"></a>非词法作用域生命周期 NLL</h3><p>编译器在作用域结束之前判断不再使用的引用的能力被称为 <a href="https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html#non-lexical-lifetimes">非词法作用域生命周期</a>（Non-Lexical Lifetimes，简称 NLL）</p><h3 id="泛型-generics"><a href="#泛型-generics" class="headerlink" title="泛型 generics"></a>泛型 generics</h3><p>泛型是具体类型或其他属性的抽象替代。我们可以表达泛型的属性，比如他们的行为或如何与其他泛型相关联，而不需要在编写和编译代码时知道他们在这里实际上代表什么。</p><h3 id="单态化-monomorphization"><a href="#单态化-monomorphization" class="headerlink" title="单态化 monomorphization"></a>单态化 monomorphization</h3><p>单态化是一个通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程。我们可以使用泛型来编写不重复的代码，而 Rust 将会为每一个实例编译其特定类型的代码。</p><h3 id="特质-trait"><a href="#特质-trait" class="headerlink" title="特质 trait"></a>特质 trait</h3><p>一种定义泛型行为的方法。特质可以与泛型结合来将泛型限制为拥有特定行为的类型，而不是任意类型。</p><h3 id="生命周期-lifetimes"><a href="#生命周期-lifetimes" class="headerlink" title="生命周期 lifetimes"></a>生命周期 lifetimes</h3><p>生命周期是一类允许我们向编译器提供引用如何相互关联的泛型。Rust 的生命周期功能允许在很多场景下借用值的同时仍然使编译器能够检查这些引用的有效性。</p><h3 id="相干性-coherence-孤儿规则-orphan-rule"><a href="#相干性-coherence-孤儿规则-orphan-rule" class="headerlink" title="相干性 coherence(孤儿规则 orphan rule)"></a>相干性 coherence(孤儿规则 orphan rule)</h3><p>只有当至少一个 trait 或者要实现 trait 的类型位于 crate 的本地作用域时，才能为该类型实现 trait。这个限制是被称为 相干性（coherence） 的程序属性的一部分，或者更具体的说是 孤儿规则（orphan rule），其得名于不存在父类型。这条规则确保了其他人编写的代码不会破坏你代码，反之亦然。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="不可变变量和常量有什么区别？"><a href="#不可变变量和常量有什么区别？" class="headerlink" title="不可变变量和常量有什么区别？"></a>不可变变量和常量有什么区别？</h3><ul><li>不允许对常量使用 mut。</li><li>常量不光默认不能变，它总是不能变。</li><li>声明常量使用 const 关键字而不是 let，并且 <em>必须</em> 注明值的类型。</li><li>常量可以在任何作用域中声明，包括全局作用域，这在一个值需要被很多部分的代码用到时很有用。</li><li>常量只能被设置为常量表达式，而不可以是其他任何只能在运行时计算出的值。</li></ul><h3 id="隐藏-shadow-和将变量标记为-mut-有什么区别？"><a href="#隐藏-shadow-和将变量标记为-mut-有什么区别？" class="headerlink" title="隐藏(shadow)和将变量标记为 mut 有什么区别？"></a>隐藏(shadow)和将变量标记为 mut 有什么区别？</h3><ul><li>当不小心尝试对变量重新赋值时，如果没有使用 let 关键字，就会导致编译时错误。通过使用 let，我们可以用这个值进行一些计算，不过计算完之后变量仍然是不可变的。</li><li>当再次使用 let 时，实际上创建了一个新变量，我们可以改变值的类型，并且复用这个名字。</li></ul><h3 id="整型溢出会发生什么？"><a href="#整型溢出会发生什么？" class="headerlink" title="整型溢出会发生什么？"></a>整型溢出会发生什么？</h3><p>有一个 u8 ，它可以存放从 0 到 255 的值。当你将其修改为 256 时就会发生 “整型溢出”（“integer overflow”）。当在 debug 模式编译时，Rust 检查这类问题并使程序 panic（程序因错误而退出）。在 release 构建中，Rust 不检测溢出，相反会进行一种被称为二进制补码包装（two’s complement wrapping）的操作。简而言之，值 256 变成 0，值 257 变成 1，依此类推。</p><h3 id="数组下标越界会发生生么？"><a href="#数组下标越界会发生生么？" class="headerlink" title="数组下标越界会发生生么？"></a>数组下标越界会发生生么？</h3><p>当尝试用索引访问一个元素时，Rust 会检查指定的索引是否小于数组的长度。如果索引超出了数组长度，Rust 会 panic。</p><h3 id="语句与表达式有什么区别？"><a href="#语句与表达式有什么区别？" class="headerlink" title="语句与表达式有什么区别？"></a>语句与表达式有什么区别？</h3><p>语句（Statements）是执行一些操作但不返回值的指令。表达式（Expressions）计算并产生一个值。表达式的结尾没有分号。如果在表达式的结尾加上分号，它就变成了语句，而语句不会返回值。</p><h3 id="为什么在同一时间内对某一特定数据不能存在多个可变引用？"><a href="#为什么在同一时间内对某一特定数据不能存在多个可变引用？" class="headerlink" title="为什么在同一时间内对某一特定数据不能存在多个可变引用？"></a>为什么在同一时间内对某一特定数据不能存在多个可变引用？</h3><p>这个限制的好处是 Rust 可以在编译时就避免数据竞争。数据竞争（data race）类似于竞态条件，它可由这三个行为造成：</p><p>两个或更多指针同时访问同一数据。<br>至少有一个指针被用来写入数据。<br>没有同步数据访问的机制。</p><p>数据竞争会导致未定义行为，难以在运行时追踪，并且难以诊断和修复；Rust 避免了这种情况的发生。</p><h3 id="Rust是否会存在悬垂引用（Dangling-References）的问题"><a href="#Rust是否会存在悬垂引用（Dangling-References）的问题" class="headerlink" title="Rust是否会存在悬垂引用（Dangling References）的问题?"></a>Rust是否会存在悬垂引用（Dangling References）的问题?</h3><p>在具有指针的语言中，很容易通过释放内存时保留指向它的指针而错误地生成一个 悬垂指针（dangling pointer），所谓悬垂指针是其指向的内存可能已经被分配给其它持有者。相比之下，在 Rust 中编译器确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域。</p><h3 id="Rust的模块系统（the-module-system）包含哪些部分？"><a href="#Rust的模块系统（the-module-system）包含哪些部分？" class="headerlink" title="Rust的模块系统（the module system）包含哪些部分？"></a>Rust的模块系统（the module system）包含哪些部分？</h3><ul><li>包（Packages）： Cargo 的一个功能，它允许你构建、测试和分享箱（crate）。</li><li>箱（Crates）：一个模块的树形结构，它形成了库或二进制项目。</li><li>模块（Modules）和 use： 允许你控制作用域和路径的私有性。</li><li>路径（path）：一个命名例如结构体、函数或模块等项的方式。</li></ul><h3 id="为什么-Rust-不允许使用索引获取-String-字符？"><a href="#为什么-Rust-不允许使用索引获取-String-字符？" class="headerlink" title="为什么 Rust 不允许使用索引获取 String 字符？"></a>为什么 Rust 不允许使用索引获取 String 字符？</h3><ol><li>String 是一个 <code>Vec&lt;u8&gt;</code> 的封装，每个 Unicode 标量值需要两个字节存储，因此一个字符串字节值的索引并不总是对应一个有效的 Unicode 标量值</li><li>索引操作预期总是需要常数时间 (O(1))。但是对于 String 不可能保证这样的性能，因为 Rust 必须从开头到索引位置遍历来确定有多少有效的字符</li></ol><h3 id="如何决定何时应该使用-panic-以及何时应该返回-Result-呢"><a href="#如何决定何时应该使用-panic-以及何时应该返回-Result-呢" class="headerlink" title="如何决定何时应该使用 panic! 以及何时应该返回 Result 呢?"></a>如何决定何时应该使用 <code>panic!</code> 以及何时应该返回 <code>Result</code> 呢?</h3><p><code>panic!</code> 宏代表一个程序无法处理的状态，并停止执行而不是使用无效或不正确的值继续处理。Rust 类型系统的 Result 枚举代表操作可能会在一种可以恢复的情况下失败。可以使用 <code>Result</code> 来告诉代码调用者他需要处理潜在的成功或失败。</p><h3 id="写出三种方法给定-vector-列表返回出其中的最大值"><a href="#写出三种方法给定-vector-列表返回出其中的最大值" class="headerlink" title="写出三种方法给定 vector 列表返回出其中的最大值"></a>写出三种方法给定 vector 列表返回出其中的最大值</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T: <span class="built_in">PartialOrd</span> + <span class="built_in">Clone</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">  <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> list &#123;</span><br><span class="line">    <span class="keyword">if</span> item &gt; &amp;largest &#123;</span><br><span class="line">      largest = item.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">largest1</span>&lt;T: <span class="built_in">PartialOrd</span> + <span class="built_in">Copy</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list &#123;</span><br><span class="line">    <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">      largest = item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">largest2</span>&lt;T: <span class="built_in">PartialOrd</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = &amp;list[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> list &#123;</span><br><span class="line">    <span class="keyword">if</span> &amp;item &gt; &amp;largest &#123;</span><br><span class="line">      largest = &amp;item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">number_list</span> = <span class="built_in">vec!</span>[<span class="number">34</span>, <span class="number">50</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">65</span>];</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest2</span>(&amp;number_list);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;The largest number is &#123;&#125;&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">char_list</span> = <span class="built_in">vec!</span>[<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;q&#x27;</span>];</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest2</span>(&amp;char_list);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;The largest char is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 仓库代码统计</title>
      <link href="/blog/2022/07/05/TIPS-git%E4%BB%A3%E7%A0%81%E7%BB%9F%E8%AE%A1/"/>
      <url>/blog/2022/07/05/TIPS-git%E4%BB%A3%E7%A0%81%E7%BB%9F%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>代码统计一般是对某一个或者多个代码仓库的开发人员在某段时间内或所有历史时间段内进行代码提交次数、代码提交行数等进行统计，以反映人员对代码仓库的贡献量的一种手段。<br>通过 git 进行代码管理的项目，通常使用 <code>git log</code> 命令的输出进行统计。</p><span id="more"></span><h2 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h2><p>可以使用 <code>git --help log</code> 查看 <code>git log</code> 的完整用法。</p><p><code>git log</code> 常见参数说明：</p><h3 id="不带参数"><a href="#不带参数" class="headerlink" title="不带参数"></a>不带参数</h3><p>列出所有的历史记录，最近的排在最上方，显示提交对象的哈希字符串、作者、修订日期和提交说明。<br>如果记录过多，可以按照 Page Up/Page Down 键来控制滑动翻阅，按 q 键可以退出。</p><p><img src="/blog/static/imgs/git/shortcut3.png" alt="shortcut_inner"></p><h3 id="显示参数"><a href="#显示参数" class="headerlink" title="显示参数"></a>显示参数</h3><p><code>-p</code> 展开每次提交的内容差异<br><code>--stat</code> 显示每次更新的文件修改统计信息，列出具体的文件列表<br><code>--shortstat</code> 统计每个 commit 的文件修改行数，包括增加、删除，但不列出文件列表<br><code>--numstat</code> 统计每个 commit 的文件修改行数，包括增加、删除，并列出文件列表<br><code>--name-only</code> 仅在提交信息后显示已修改的文件清单<br><code>--name-status</code> 显示新增、删除、修改的文件清单<br><code>--abbrev-commit</code> commit 显示为短 id 形式，仅展示前7个字符<br><code>--relative-date</code> 使用相对较短的时间显示（例如，显示为“2 weeks ago”）<br><code>--graph</code> 显示 ASCII 图形表示的分支合并历史<br><code>--pretty</code> 使用其他格式显示历史提交信息。可用的选项包括 <code>oneline</code> <code>short</code> <code>medium</code> <code>full</code> <code>fuller</code> <code>email</code> <code>raw</code> 和 <code>format:&lt;string&gt;</code>，例如：<code>git --pretty=format:</code> 可以定制要显示的记录格式，这样输出便于后期提取分析<br>例如 <code>git log --pretty-format: &quot;%h - %an, %ar : %s</code> 显示为：</p><p><img src="/blog/static/imgs/git/shortcut1.png" alt="shortcut_inner"></p><p>下面列出了常用的格式占位符的写法及其代表的意义：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>%H</td><td>提交对象(commit)的完整哈希字符串</td></tr><tr><td>%h</td><td>提交对象的简短哈希字符串</td></tr><tr><td>%T</td><td>树对象(tree)的完整哈希字符串</td></tr><tr><td>%t</td><td>树对象的简短哈希字符串</td></tr><tr><td>%P</td><td>父对象(parent)的完整哈希字符串</td></tr><tr><td>%p</td><td>父对象的简短哈希字符串</td></tr><tr><td>%an</td><td>作者(author)的名字</td></tr><tr><td>%ae</td><td>作者的电子邮件地址</td></tr><tr><td>%ad</td><td>作者修订日期，可以用 <code>-date=</code> 选项定制日期格式</td></tr><tr><td>%ar</td><td>作者修订日期，按照多久之前的方式显示</td></tr><tr><td>%cn</td><td>提交者(committer)的名字</td></tr><tr><td>%ce</td><td>提交者的电子邮件地址</td></tr><tr><td>%cd</td><td>提交日期</td></tr><tr><td>%cr</td><td>提交日期，按照多久之前的方式显示</td></tr><tr><td>%s</td><td>提交说明</td></tr></tbody></table><p>format 参数支持通过以 <code>%C</code> 开头来控制显示的颜色和字体，例如： <code>git log --pretty=format:&quot;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;&quot;</code> 显示为：</p><p><img src="/blog/static/imgs/git/shortcut2.png" alt="shortcut_inner"></p><h3 id="筛选参数"><a href="#筛选参数" class="headerlink" title="筛选参数"></a>筛选参数</h3><p>按数量：<br><code>-&#123;n&#125;</code> 仅展示最近 n 次 commit 的更新， 例如 <code>git log -2</code> 显示最近2次的 commit 。<br>按作者：<br><code>--author</code> 指定作者，不需要精确匹配，只需要包含即可。可以使用正则表达式。包含电子邮箱的匹配。<br>按日期：<br><code>--after=</code> 标志指定日期之后，同 <code>--until</code><br><code>--before=</code> 标志指定日期之前，同 <code>--since</code><br>按 commit 描述：<br><code>--grep=&lt;string&gt;</code> 可以传入 <code>-i</code> 忽略大小写。同时使用 <code>--author</code> 和 <code>--grep</code> 时，必须附加 <code>--all-match</code> 来表示全匹配<br>按文件：<br><code>-- &lt;filepath&gt;</code> 例如 <code>git log -- ./src/utils/</code> 只展示 <code>./src/utils/</code> 路径下的变更<br>按分支：<br><code>&lt;branchname&gt;</code> 例如 <code>git log origin/master</code><br>按范围：<br><code>&lt;since&gt;...&lt;until&gt;</code> 例如 <code>git log master...feature</code> 展示 feature 分支到 master 分支的变化，包含了所有在 feautre 分支但不在 master 分支的 commit<br>过滤掉 merge commit<br><code>--no-merges</code> 过滤掉 merge commit<br>按标签tag：<br><code>&lt;tagname&gt;</code> 例如 <code>git log v1.0</code> 查询标签 v1.0 之前的 commit，<code>git log v1.0..</code> 查询标签 v1.0 之后的 commit<br>按 commit：<br><code>&lt;commit&gt;</code> 查看 commit 之前的记录，包括 commit<br><code>&lt;commit1&gt; &lt;commit2&gt;</code> 查看 commit1 与 commit2 之间的记录，不包括 commit1<br><code>&lt;commit1&gt;...&lt;commit2&gt;</code> 查看 commit1 与 commit2 之间的记录，包括 commit1<br>commit 表示一次提交的哈希字符串或简短哈希字符串，<code>HEAD</code> 表示最后一次提交，<code>HEAD^</code> 表示最后一次提交的父提交，相当于 <code>HEAD~1</code>，也就是倒数第二次的提交，<code>HEAD~2</code> 表示倒数第三次提交</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="统计代码行数"><a href="#统计代码行数" class="headerlink" title="统计代码行数"></a>统计代码行数</h3><p>根据用户名统计每个作者的增删代码行数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git log --format=&#x27;%an&#x27; | sort -u | while read name; </span><br><span class="line">do echo -en &quot;$name\t&quot;; </span><br><span class="line">git log --author=&quot;$name&quot; --numstat | awk &#x27;&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s\n&quot;, add, subs, loc &#125;&#x27; -; </span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><em>根据电子邮箱统计每个作者的增删代码行数</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git log --format=&#x27;%an&#x27; | sort -u | while read name;</span><br><span class="line">do echo -en &quot;$name\t&quot;;</span><br><span class="line">git log --author=&quot;$name&quot; --numstat | awk &#x27;&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s\n&quot;, add, subs, loc &#125;&#x27; -;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>根据用户名统计每个作者在 <code>startTime</code> 到 <code>endTime</code> 时间之内的增删代码行数（可以统计最近半年、最近一年的数据）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git log  --format=&#x27;%an&#x27; | sort -u | while read name;</span><br><span class="line">do echo -en &quot;$name\t&quot;;</span><br><span class="line">git log --author=&quot;$name&quot; --since=$&#123;startTime&#125; --until=$&#123;endTime&#125; --numstat | awk &#x27;&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s\n&quot;, add, subs, loc &#125;&#x27; -;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>查看总共的代码增删行数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --numstat | awk &#x27;&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s\n&quot;, add, subs, loc &#125;&#x27;</span><br></pre></td></tr></table></figure><p>查看作者用户名为 <code>username</code> 总共的代码增删行数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --author=&quot;$&#123;username&#125;&quot; --numstat | awk &#x27;&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s\n&quot;, add, subs, loc &#125;&#x27;</span><br></pre></td></tr></table></figure><h3 id="统计提交次数"><a href="#统计提交次数" class="headerlink" title="统计提交次数"></a>统计提交次数</h3><p>查看所有作者用户名数量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=&#x27;%an&#x27; | sort -u | wc -l</span><br></pre></td></tr></table></figure><p>查看总提交次数统计</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline | wc -l</span><br></pre></td></tr></table></figure><p>查看作者所有提交次数排名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=&#x27;%an&#x27; | sort | uniq -c | sort -k1 -n -r</span><br></pre></td></tr></table></figure><p><em>根据电子邮箱查看作者所有提交次数排名</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=&#x27;%ae&#x27; | sort | uniq -c | sort -k1 -n -r</span><br></pre></td></tr></table></figure><p>查看仓库提交次数排名前5</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=&#x27;%an&#x27; | sort | uniq -c | sort -k1 -n -r | head -n 5</span><br></pre></td></tr></table></figure><p>查看用户 <code>username</code> 从 <code>startTime</code> 时间开始的提交（不包含 merge commit）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --author=$&#123;username&#125; --since=&quot;$&#123;startTime&#125;&quot; --no-merges | grep -e &#x27;commit [a-zA-Z0-9]*&#x27;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> javascript </tag>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端依赖管理npm</title>
      <link href="/blog/2022/07/01/FE-%E5%89%8D%E7%AB%AF%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86npm/"/>
      <url>/blog/2022/07/01/FE-%E5%89%8D%E7%AB%AF%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86npm/</url>
      
        <content type="html"><![CDATA[<p>2009年，Ryan Dahl 写了 Node.js 以后，缺少包管理器，Isaac Z. Schlueter 苦于如何推广自己的包管理器，于是俩人一拍即合，最终 Node.js 内置了 npm 。后来，随着 Node.js 的流行, npm 也跟着流行了起来。</p><span id="more"></span><h2 id="npm-v1-v2"><a href="#npm-v1-v2" class="headerlink" title="npm v1-v2"></a>npm v1-v2</h2><p>早期 npm 的处理依赖的设计比较简单，以递归的形式，严格按照 package.json 结构以及子依赖包的 package.json 结构将依赖安装到他们各自的 node_modules 中，直到有子依赖包不再依赖其他模块。</p><p>这样的 node_modules 结构简单明了符合预期，但是在遇到大型项目时，可能会有很多重复依赖的包，在遇到相互依赖的情况时甚至会形成“嵌套地狱”的情况。</p><p><img src="/blog/static/imgs/npm/npm.png" alt="npmp_inner"></p><p>总结一下此时遇到的问题：</p><ol><li>嵌套过深，安装太慢</li><li>多个子依赖包依赖相同的包时，会有重复安装的情况</li><li>相互依赖时会形成“嵌套地狱”的情况</li><li>目录层级太深导致文件路径太长，在 Windows 系统下删除 node_modules 文件夹会出现失败的情况</li></ol><h2 id="npm-v3-amp-yarn"><a href="#npm-v3-amp-yarn" class="headerlink" title="npm v3+ &amp; yarn"></a>npm v3+ &amp; yarn</h2><p>2016年，yarn 诞生，从结构上解决了 npm 存在的问题：</p><ol><li>嵌套过深，冗余安装 -》 扁平化安装依赖</li><li>安装太慢 -》 添加缓存、多线程安装</li></ol><p>随后，在 npm v3 中，也实现了相关的功能。</p><h3 id="扁平化"><a href="#扁平化" class="headerlink" title="扁平化"></a>扁平化</h3><p>npm 官网有介绍扁平化相关的 <a href="https://docs.npmjs.com/cli/v7/commands/npm-install#algorithm">算法</a> </p><p><img src="/blog/static/imgs/npm/npm3.png" alt="npm3_inner"></p><p>扁平化后，实际需要安装的包数量大大减少，再加上相应的缓存机制，依赖的安装速度也得到了极大的提升。</p><h3 id="冗余问题"><a href="#冗余问题" class="headerlink" title="冗余问题"></a>冗余问题</h3><p>依据 npm v3 的扁平化规则。按照上述例子，如果我们又安装了新的依赖 D 和 E，D 和 E 都依赖于 C v2.0。 结构如下：</p><p><img src="/blog/static/imgs/npm/npm3_dup.png" alt="npm3_dup_inner"></p><p>为什么不能将 C v1.0 和 C v2.0 都安装在顶层目录？这是因为 C v1.0 和 C v2.0 的结构是类似的，包名是完全相同的，所以不能安装在同一目录下。</p><p>那么此时， C v2.0 依然存在了两次。那么为什么 C v1.0 出现在项目顶层 node_modules 而不是 C v2.0 出现在 node_modules 顶层呢？这取决于 A 和 D 的安装顺序，A 先安装，A 的依赖 C v1.0 就先安装，所以后面的 D 和 E 依赖的 C v2.0 只能重复安装于子目录。</p><p>同样的 package.json，不同的安装顺序可能影响 node_modules 内的文件结构。</p><p>接下来我们要升级 B 变为 B v2.0 ，B v2.0 也依赖 C v2.0 。此时，npm 会删除 C v1.0 ，安装 C v2.0 。变成下面的结构：</p><p><img src="/blog/static/imgs/npm/npm3_dup_1.png" alt="npm3_dup_1_inner"></p><p>明显，D 和 E 下面的 C v2.0 是多余的，这时我们就可以使用 <a href="#npm-dedupe">npm dedupe</a> 来消除重复模块。</p><p><img src="/blog/static/imgs/npm/npm3_dup_2.png" alt="npm3_dup_2_inner"></p><h3 id="依赖锁"><a href="#依赖锁" class="headerlink" title="依赖锁"></a>依赖锁</h3><p>我们在执行 <code>npm install</code> 的时候，npm 会根据 package.json 中的依赖进行安装和升级。安装模块的时候，会根据 <em>模块版本是否符合新模块的版本范围</em> 来进行判断是否更新版本。</p><p>判断模块是否符合版本范围的标准是根据 <a href="https://semver.org">语义化版本</a> 约定的。</p><p>简单来说，a.b.c 代表一个版本，每个位置代表的含义如下：</p><ol><li>主版本号：当你做了不兼容的 API 修改</li><li>次版本号：当你做了向下兼容的功能性新增</li><li>修订号：当你做了向下兼容的问题修正</li></ol><p>先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。</p><p>在 package.json 中，我们可以看到 ~ 和 ^ 这种标识，就是用来判断如何更新版本模块的。</p><ol><li><code>~</code> 会匹配最近的小版本依赖包，比如 <code>~1.2.3</code> 会匹配所有 1.2.x 版本，但是不包括 1.3.0</li><li><code>^</code> 会匹配最新的大版本依赖包，比如 <code>^1.2.3</code> 会匹配所有 1.x.x 的包，包括 1.3.0 ，但是不包括 2.0.0</li></ol><p>此时如果有个包没有遵守约定，在提供了不兼容的功能时未升级版本，那么当其他人安装依赖的时候，会导致非常大的不确定性。</p><p>于是在2016年 yarn 提出了 yarn.lock 依赖锁的概念：</p><p>每次安装依赖的时候，将依赖精确地将版本号锁定在一个值，并且在安装时通过计算哈希值校验文件一致性，从而保证每次构建使用的依赖都是完全一致的。</p><p>17年， npm 也提供了该功能，也就是 package-lock.json。</p><h2 id="npm-v5-8"><a href="#npm-v5-8" class="headerlink" title="npm v5-8"></a>npm v5-8</h2><p>npm 之后的版本也提供了很多新的特性，例如 scope, npx, workspaces 能力支持等。</p><h2 id="常用npm命令"><a href="#常用npm命令" class="headerlink" title="常用npm命令"></a>常用npm命令</h2><p>以下介绍比较常用的几个命令</p><h3 id="npm-config"><a href="#npm-config" class="headerlink" title="npm config"></a>npm config</h3><p><a href="https://docs.npmjs.com/cli/v8/commands/npm-config">npm config</a> 可以管理 npm 配置文件。</p><p>常见用法： </p><p><code>npm config ls -l</code> 列出当前目录所有的配置<br><code>npm config get &lt;key&gt;</code> 获取单条配置信息<br><code>npm config set &lt;key&gt;=&lt;value&gt; [&lt;key&gt;=&lt;value&gt; ...]</code> 设置配置信息</p><p>例如：</p><p><code>npm config set registry https://registry.npm.taobao.org</code> 将默认的官方 npm 源 <code>https://registry.npmjs.org/</code> 改为 <code>https://registry.npm.taobao.org</code><br><code>npm config set user.email example@example.com</code></p><h3 id="npm-install"><a href="#npm-install" class="headerlink" title="npm install"></a>npm install</h3><p><a href="https://docs.npmjs.com/cli/v8/commands/npm-install">npm install</a> 安装特定的 npm 包或者安装项目所有依赖的 npm 包。</p><p><img src="/blog/static/imgs/npm/npm_install.png" alt="npm_install_inner"></p><h3 id="npm-init"><a href="#npm-init" class="headerlink" title="npm init"></a>npm init</h3><p><a href="https://docs.npmjs.com/cli/v8/commands/npm-init">npm init</a> 创建 package.json 文件。</p><h3 id="npm-ls"><a href="#npm-ls" class="headerlink" title="npm ls"></a>npm ls</h3><p><a href="https://docs.npmjs.com/cli/v8/commands/npm-ls">npm ls</a> 列出所有已安装的包。</p><h3 id="npm-dedupe"><a href="#npm-dedupe" class="headerlink" title="npm dedupe"></a>npm dedupe</h3><p><a href="https://docs.npmjs.com/cli/v8/commands/npm-dedupe">npm dedupe</a> 减少包树的重复依赖。</p><h3 id="npm-publish"><a href="#npm-publish" class="headerlink" title="npm publish"></a>npm publish</h3><p><a href="https://docs.npmjs.com/cli/v8/commands/npm-publish">npm publish</a> 发布一个包。</p><h3 id="npm-start"><a href="#npm-start" class="headerlink" title="npm start"></a>npm start</h3><p><a href="https://docs.npmjs.com/cli/v8/commands/npm-start">npm start</a> 开始一个包。</p><p><code>npm start</code> 将会运行 package.json 中 script 里的 start 命令，如果没有 start 命令，npm 将会运行 <code>node server.js</code> 。</p><h3 id="npm-run-script"><a href="#npm-run-script" class="headerlink" title="npm run-script"></a>npm run-script</h3><p><a href="https://docs.npmjs.com/cli/v8/commands/npm-run-script">npm run-script</a> 将会运行任意的包脚本（在 package.json 的 script 当中定义）。</p><p>更常见的是它的别名 <code>npm run</code> 。</p><h3 id="npx"><a href="#npx" class="headerlink" title="npx"></a>npx</h3><p><a href="https://docs.npmjs.com/cli/v8/commands/npx">npx</a> 支持从远程或者本地的 npm 包里执行一个命令。npx 命令是 <code>npm exec</code> 的别名，如果命令在本地项目的依赖中不存在，则会将命令安装到 npm 缓存中的文件夹。</p><h3 id="npm-link"><a href="#npm-link" class="headerlink" title="npm link"></a>npm link</h3><p><a href="https://docs.npmjs.com/cli/v8/commands/npm-link">npm link</a> 支持将某个依赖指向一个本地的 npm 包。这对于本地调试 npm 包而言非常方便，不需要发布即可以通过 npm 依赖。</p>]]></content>
      
      
      
        <tags>
            
            <tag> npm </tag>
            
            <tag> front-end </tag>
            
            <tag> yarn </tag>
            
            <tag> package.json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认证、授权与单点登录</title>
      <link href="/blog/2022/06/24/HTTP-%E8%AE%A4%E8%AF%81-%E6%8E%88%E6%9D%83%E4%B8%8E%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
      <url>/blog/2022/06/24/HTTP-%E8%AE%A4%E8%AF%81-%E6%8E%88%E6%9D%83%E4%B8%8E%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="认证与授权"><a href="#认证与授权" class="headerlink" title="认证与授权"></a>认证与授权</h2><ul><li>认证（Authentication）即确认该用户的身份是他所声明的那个人</li><li>授权（Authorization）即根据用户身份授予他访问特定资源的权限</li></ul><p>也就是说，当用户登录应用系统时，系统需要先认证用户身份，然后依据用户身份再进行授权。认证与授权需要联合使用，才能让用户真正登入并使用应用系统。</p><span id="more"></span><h2 id="单系统登录"><a href="#单系统登录" class="headerlink" title="单系统登录"></a>单系统登录</h2><p>相对于单点登录（SSO），单系统登录是指单个应用系统的登录/注销机制。</p><h3 id="HTTP-无状态协议"><a href="#HTTP-无状态协议" class="headerlink" title="HTTP 无状态协议"></a>HTTP 无状态协议</h3><p>web 应用一般采用 B/S 架构，使用 HTTP 作为通信协议。HTTP 是无状态协议，浏览器的每一次请求，服务器会独立处理，不与之前或之后的请求产生关联。但这也同时意味着，任何用户都能通过浏览器访问服务器资源，如果想保护服务器的某些资源，必须限制浏览器请求；要限制浏览器请求，必须鉴别浏览器请求，响应合法请求，忽略非法请求；要鉴别浏览器请求，必须清楚浏览器请求状态。既然 HTTP 协议无状态，就需要服务器和浏览器之间共同维护一个状态，这就是会话机制。</p><p><img src="/blog/static/imgs/sso/login_http.png" alt="login_http_inner"></p><h3 id="会话机制"><a href="#会话机制" class="headerlink" title="会话机制"></a>会话机制</h3><p>浏览器第一次请求服务器，服务器创建一个会话（session），并将会话的 id 作为响应的一部分发送给浏览器，浏览器存储会话 id ，并在后续第二次和第三次请求中带上会话 id，服务器取得请求中的会话 id 就知道是否是同一个用户。</p><p><img src="/blog/static/imgs/sso/login_session.png" alt="login_session_inner"></p><p>web 应用一般通过 cookie 来实现会话机制，在浏览器第一次访问服务器时生成带 sessionid（在 tomcat 服务器中默认是 JSESSIONID） 的 cookie，并随请求返回到浏览器端，之后，浏览器会在每次发送 http 请求时自动附带 cookie 信息。</p><p><img src="/blog/static/imgs/sso/login_session_cookie.png" alt="login_session_cookie_inner"></p><h3 id="登录状态"><a href="#登录状态" class="headerlink" title="登录状态"></a>登录状态</h3><p>有了会话机制，再加上认证机制，我们就可以识别出浏览器每次访问时的 <em>登录状态</em>。首先，我们要求浏览器第一次请求服务器需要输入 <em>用户名</em> 与 <em>密码</em> 验证身份，然后服务器拿到用户名与密码去数据库进行比对，正确的话说明当前持有这个会话的用户是合法用户，应该将这个会话标记为 <em>已登录</em> 的状态，并保存到会话对象（通常在内存数据库中，例如 Redis ）中，同时将会话 id 返回给浏览器。当下一次浏览器访问时会带上会话 id ，服务器就可以在会话对象中查看是否是 <em>已登录</em> 状态。</p><p><img src="/blog/static/imgs/sso/login.png" alt="login_inner"></p><h3 id="Basic-认证"><a href="#Basic-认证" class="headerlink" title="Basic 认证"></a>Basic 认证</h3><p>HTTP 提供了一个基础的用于权限控制和认证的通用框架，即 HTTP Basic 认证（HTTP Basic authentication）。<a href="https://datatracker.ietf.org/doc/html/rfc7617">RFC 7617</a> 定义了 HTTP Basic 认证的框架规则。服务器可以用来针对客户端的请求发送质询信息（challenge），客户端则可以用来提供身份验证凭证。</p><p>HTTP Basic 认证 的工作流程如下：</p><ol><li>客户端发起资源请求。</li><li>服务器端向客户端返回 401（Unauthorized，未被授权的）状态码，并在 <code>WWW-Authenticate</code> 首部提供如何进行验证的信息，其中至少包含有一种质询方式。</li><li>有意向证明自己身份的客户端可以在新的请求中添加 <code>Authorization</code> 首部字段进行验证，字段值为身份验证凭证信息。通常客户端会弹出一个密码框让用户填写，然后发送包含有恰当的 <code>Authorization</code> 首部的请求。客户端使用 utf-8 编码用户名和密码，并进行 base64 编码返回给服务器端。</li><li>当服务器端收到一个合法认证信息时，若该认证不能获取请求资源的权限，服务器端会返回 403（Forbidden，拒绝访问）状态码，说明用户权限不够。</li></ol><p><img src="/blog/static/imgs/sso/basic.png" alt="basic_inner"></p><p>在上图所示的基本身份验证过程中，信息交换须通过 HTTPS(TLS) 连接来保证安全。</p><p><code>WWW-Authenticate</code> 首部的格式如下：<br><code>WWW-Authenticate: &lt;type&gt; realm=&lt;realm&gt;</code></p><p><code>Authorization</code> 首部的格式如下：<br><code>Authorization: &lt;type&gt; &lt;credentials&gt;</code></p><ul><li><code>type</code> 代表了认证的方式，对于 Basic 认证，<code>type</code> 为 <code>Basic</code>。</li><li><code>realm</code> 用来描述进行保护的区域，或者指代保护的范围。它可以是类似于 “访问xxx平台” 的消息，这样用户就可以知道他们正在试图访问哪一空间。</li><li><code>credentials</code> 代表了用户凭证，对于 Baisc 认证，用冒号将用户名和密码进行拼接（如：<code>username:password</code>），然后用 base64 方式编码。</li></ul><p>Basic 认证足够简单，但是有许多的问题：</p><ol><li>由于用户名与密码是是以明文的形式在网络中进行传输的（尽管采用了 base64 编码，但是 base64 算法是可逆的），所以 Basic 认证方案并不安全。Basic 认证方案应与 HTTPS/TLS 协议搭配使用。</li><li>即使密码被强加密，第三方仍可通过加密后的用户名和密码进行重放攻击。</li><li>如果想再进行一次 BASIC 认证时，一般的浏览器却无法实现认证注销操作。</li><li>登录界面无法定制，依赖客户端实现，通常浏览器会弹出密码框让用户填写。</li><li>不支持双因子认证，容易被破解。</li><li>有些客户端支持避免弹出登录框，可以使用包含用户名和密码的经过编码的 URL（例如：<code>https://username:password@www.example.com/</code>），十分不安全。</li></ol><h2 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h2><p>如今，web 应用早已从久远的单系统发展成为由多系统组成的应用群，面对如此众多的系统，用户难道要一个一个登录，然后一个一个注销吗？虽然单系统的登录解决方案很完美，但对于多系统应用群已经不再适用了，为什么呢？单系统登录解决方案的核心是 cookie，cookie 携带会话 id 在浏览器与服务器之间维护会话状态。但 cookie 是有限制的，这个限制就是 cookie 的作用域（通常对应网站的域名，参见 <a href="/blog/2021/12/29/HTTP-Cookie/#Cookie-作用域">Cookie-作用域</a> ），浏览器发送 http 请求时会自动携带与该域匹配的 cookie ，而不是所有 cookie 。</p><p><img src="/blog/static/imgs/sso/login_domain.png" alt="login_domain_inner"></p><p>既然这样，为什么不将 web 应用群中所有子系统的域名统一在一个顶级域名下？例如 “*.baidu.com” ，可以将它们的 cookie 域设置为 “baidu.com” 。</p><p>这种做法理论上是可以的，甚至早期很多多系统登录就采用这种同域名共享 cookie 的方式。然而，可行并不代表好，共享 cookie 的方式存在众多局限。首先，应用群域名得统一；其次，应用群各系统使用的技术（至少是 web 服务器）要相同，不然 cookie 的 key 值（在 tomcat 服务器中为 JSESSIONID ）不同，无法维持会话，共享 cookie 的方式是无法实现跨语言技术平台登录的，比如 Java、PHP、.NET 系统之间；第三，cookie 共享要求顶级域名和子域名之间互相信任，在现实 web 系统设计中中有诸多限制，并不是十分安全。</p><p>因此，我们需要一种全新的登录方式来实现多系统应用群的登录，这就是单点登录。</p><p>单点登录（ Single Sign On，简称 SSO ）是指通过一次认证鉴权可以登录多个系统的一种认证授权方式。</p><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>相比于单系统登录，SSO 需要一个独立的认证中心，只有认证中心能接受用户的用户名密码等安全信息，其他系统不提供登录入口，只接受认证中心的间接授权。间接授权通过令牌实现，SSO 认证中心验证用户的用户名密码没问题，创建授权令牌，在接下来的跳转过程中，授权令牌作为参数发送给各个子系统，子系统拿到令牌，即得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。这个过程，也就是单点登录的原理，用下图说明:</p><p><img src="/blog/static/imgs/sso/sso.png" alt="sso_inner"></p><p>下面对上图简要描述：</p><ul><li>用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数</li><li>sso认证中心发现用户未登录，将用户引导至登录页面</li><li>用户输入用户名密码提交登录申请</li><li>sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话，同时创建授权令牌</li><li>sso认证中心带着令牌跳转会最初的请求地址（系统1）</li><li>系统1拿到令牌，去sso认证中心校验令牌是否有效</li><li>sso认证中心校验令牌，返回有效，注册系统1</li><li>系统1使用该令牌创建与用户的会话，称为局部会话，返回受保护资源</li><li>用户访问系统2的受保护资源</li><li>系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数</li><li>sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌</li><li>系统2拿到令牌，去sso认证中心校验令牌是否有效</li><li>sso认证中心校验令牌，返回有效，注册系统2</li><li>系统2使用该令牌创建与用户的局部会话，返回受保护资源</li></ul><p>用户登录成功之后，会与sso认证中心及各个子系统建立会话，用户与sso认证中心建立的会话称为全局会话，用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过sso认证中心，全局会话与局部会话有如下约束关系:</p><ul><li>局部会话存在，全局会话一定存在</li><li>全局会话存在，局部会话不一定存在</li><li>全局会话销毁，局部会话必须销毁</li></ul><h3 id="注销"><a href="#注销" class="headerlink" title="注销"></a>注销</h3><p>单点登录自然也要单点注销，在一个子系统中注销，所有子系统的会话都将被销毁，用下面的图来说明:</p><p><img src="/blog/static/imgs/sso/sso_logout.png" alt="sso_logout_inner"></p><p>sso认证中心一直监听全局会话的状态，一旦全局会话销毁，监听器将通知所有注册系统执行注销操作</p><p>下面对上图简要说明：</p><ul><li>用户向系统1发起注销请求</li><li>系统1根据用户与系统1建立的会话id拿到令牌，向sso认证中心发起注销请求</li><li>sso认证中心校验令牌有效，销毁全局会话，同时取出所有用此令牌注册的系统地址</li><li>sso认证中心向所有注册系统发起注销请求</li><li>各注册系统接收sso认证中心的注销请求，销毁局部会话</li><li>sso认证中心引导用户至登录页面</li></ul><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>单点登录涉及sso认证中心与众子系统，子系统与sso认证中心需要通信以交换令牌、校验令牌及发起注销请求，因而子系统必须集成sso的客户端，sso认证中心则是sso服务端，整个单点登录过程实质是sso客户端与服务端通信的过程，用下图描述</p><p><img src="/blog/static/imgs/sso/sso_server.png" alt="sso_server_inner"></p><p>sso认证中心与sso客户端通信方式有多种，这里以简单好用的 httpClient 为例，实际上 web service、rpc、restful api 都可以</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>sso采用 C/S 架构，我们先看 sso-client 与 sso-server 要实现的功能(以下 sso-server 即指sso认证中心）</p><p>　sso-client</p><ul><li>拦截子系统未登录用户请求，跳转至sso认证中心</li><li>接收并存储sso认证中心发送的令牌</li><li>与sso-server通信，校验令牌的有效性</li><li>建立局部会话</li><li>拦截用户注销请求，向sso认证中心发送注销请求</li><li>接收sso认证中心发出的注销请求，销毁局部会话</li></ul><p>　sso-server</p><ul><li>验证用户的登录信息</li><li>创建全局会话</li><li>创建授权令牌</li><li>与sso-client通信发送令牌</li><li>校验sso-client令牌有效性</li><li>系统注册</li><li>接收sso-client注销请求，注销所有会话</li></ul><ol><li><p>sso-client拦截未登录请求</p><p>java 拦截请求的方式有 servlet、filter、listener 三种方式，我们采用 filter 。在sso-client中新建 <code>LoginFilter.java</code> 类并实现 <code>Filter</code> 接口，在 <code>doFilter()</code> 方法中加入对未登录用户的拦截</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest) request;</span><br><span class="line">    <span class="type">HttpServletResponse</span> <span class="variable">res</span> <span class="operator">=</span> (HttpServletResponse) response;</span><br><span class="line">    <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (session.getAttribute(<span class="string">&quot;isLogin&quot;</span>)) &#123;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//跳转至sso认证中心</span></span><br><span class="line">    res.sendRedirect(<span class="string">&quot;sso-server-url-with-system-url&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>sso-server拦截未登录请求</p><p>拦截从sso-client跳转至sso认证中心的未登录请求，跳转至登录页面，这个过程与sso-client完全一样</p></li><li><p>sso-server验证用户登录信息</p><p>用户在登录页面输入用户名密码，请求登录，sso认证中心校验用户信息，校验成功，将会话状态标记为“已登录”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(String username, String password, HttpServletRequest req)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.checkLoginInfo(username, password);</span><br><span class="line">    req.getSession().setAttribute(<span class="string">&quot;isLogin&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>sso-server创建授权令牌</p><p>授权令牌是一串随机字符，以什么样的方式生成都没有关系，只要不重复、不易伪造即可，下面是一个例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br></pre></td></tr></table></figure></li><li><p>sso-client取得令牌并校验</p><p>sso认证中心登录后，跳转回子系统并附上令牌，子系统（sso-client）取得令牌，然后去sso认证中心校验，在 <code>LoginFilter.java</code> 的 <code>doFilter()</code> 中添加几行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求附带token参数</span></span><br><span class="line"><span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;token&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (token != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 去sso认证中心校验token</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">verifyResult</span> <span class="operator">=</span> <span class="built_in">this</span>.verify(<span class="string">&quot;sso-server-verify-url&quot;</span>, token);</span><br><span class="line">    <span class="keyword">if</span> (!verifyResult) &#123;</span><br><span class="line">        res.sendRedirect(<span class="string">&quot;sso-server-url&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>verify()</code> 方法使用 httpClient 实现，这里仅简略介绍， httpClient 详细使用方法请参考官方文档</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HttpPost</span> <span class="variable">httpPost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(<span class="string">&quot;sso-server-verify-url-with-token&quot;</span>);</span><br><span class="line"><span class="type">HttpResponse</span> <span class="variable">httpResponse</span> <span class="operator">=</span> httpClient.execute(httpPost);</span><br></pre></td></tr></table></figure></li><li><p>sso-server接收并处理校验令牌请求</p><p>用户在sso认证中心登录成功后，sso-server创建授权令牌并存储该令牌，所以，sso-server对令牌的校验就是去查找这个令牌是否存在以及是否过期，令牌校验成功后sso-server将发送校验请求的系统注册到sso认证中心。</p><p>令牌与注册系统地址通常存储在key-value数据库（如 redis ）中，redis 可以为 key 设置有效时间也就是令牌的有效期。redis 运行在内存中，速度非常快，正好 sso-server 不需要持久化任何数据。</p><p>令牌与注册系统地址可以用下图描述的结构存储在redis中，可能你会问，为什么要存储这些系统的地址？如果不存储，注销的时候就麻烦了，用户向sso认证中心提交注销请求，sso认证中心注销全局会话，但不知道哪些系统用此全局会话建立了自己的局部会话，也不知道要向哪些子系统发送注销请求注销局部会话。</p><p><img src="/blog/static/imgs/sso/sso_redis.png" alt="sso_redis_inner"></p></li><li><p>sso-client校验令牌成功创建局部会话</p><p>令牌校验成功后，sso-client将当前局部会话标记为“已登录”，修改 <code>LoginFilter.java</code>，添加几行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (verifyResult) &#123;</span><br><span class="line">    session.setAttribute(<span class="string">&quot;isLogin&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sso-client还需将当前会话 id 与令牌绑定，表示这个会话的登录状态与令牌相关，此关系可以用 java 的 hashmap 保存，保存的数据用来处理sso认证中心发来的注销请求</p></li><li><p>注销过程</p><p>用户向子系统发送带有“logout”参数的请求（注销请求），sso-client拦截器拦截该请求，向sso认证中心发起注销请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">logout</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;logout&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (logout != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.ssoServer.logout(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sso认证中心也用同样的方式识别出sso-client的请求是注销请求（带有“logout”参数），sso认证中心注销全局会话</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/logout&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">logout</span><span class="params">(HttpServletRequest req)</span> &#123;</span><br><span class="line">    <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">    <span class="keyword">if</span> (session != <span class="literal">null</span>) &#123;</span><br><span class="line">        session.invalidate(); <span class="comment">//触发LogoutListener</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sso认证中心有一个全局会话的监听器，一旦全局会话注销，将通知所有注册系统注销</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogoutListener</span> <span class="keyword">implements</span> <span class="title class_">HttpSessionListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sessionCreated</span><span class="params">(HttpSessionEvent event)</span> &#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sessionDestroyed</span><span class="params">(HttpSessionEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">//通过httpClient向所有注册系统发送注销请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="常见单点登录协议"><a href="#常见单点登录协议" class="headerlink" title="常见单点登录协议"></a>常见单点登录协议</h2><p>单点登录实现中，sso-client 与 sso-server 系统之间的协议对接是非常重要的一环，一般涉及的标准协议类型有 CAS、OAuth、OIDC、SAML 与 Kerberos。</p><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p><a href="https://apereo.github.io/cas/6.2.x/protocol/CAS-Protocol-Specification.html">Central Authentication Service</a> 简称 CAS ，是一种常见的 B/S 架构的 SSO 协议。和其他任何 SSO 协议一样，用户仅需登录一次，访问其他应用则无需再次登录。</p><p>CAS 认证流程包括三部分的参与者：</p><ul><li>Client: 通常为使用浏览器的用户</li><li>CAS Client: 实现CAS协议的web应用</li><li>CAS Server: 作为统一认证的CAS服务器</li></ul><p>认证流程为：</p><p><img src="/blog/static/imgs/sso/cas.png" alt="cas_inner"></p><ol><li>Client (终端用户)在浏览器里请求访问 Web 应用 example ；</li><li>浏览器发起一个 GET 请求访问 example 应用的主页 https://www.example.com；</li><li>应用 example 发现当前用户处于未登录状态，重定向（ Redirect ）用户至 CAS 服务器进行认证；</li><li>用户请求 CAS 服务器；</li><li>CAS 发现当前用户在 CAS 服务器中处于未登录状态, 要求用户必须得先登录；</li><li>CAS 服务器返回登录页面至浏览器；</li><li>用户在登录界面中输入用户名和密码（或者其他认证方式）；</li><li>用户把用户名和密码通过 POST 请求提交至 CAS 服务器；</li><li>CAS 对用户身份进行认证，若用户名和密码正确，则生成 SSO 会话, 且把会话 ID 通过 Cookie 的方式返回至用户的浏览器端（此时，用户在 CAS 服务端处于登录状态）；</li><li>CAS 服务器同时也会把用户重定向至 CAS Client , 且同时发送一个 Service Ticket ；</li><li>CAS Client 收到这个 Service Ticket 以后，请求 CAS Server 对该 ticket 进行校验；</li><li>CAS Server 把校验结果返回给 CAS Client , 校验结果包括该 ticket 是否合法，以及该 ticket 中包含对用户信息；</li><li>至此，CAS Client 根据 Service Ticket 得知当前登录用户的身份，CAS Client 处于登录态。</li></ol><p>经过上述流程以后，CAS Server 和 CAS Client 都处于登录态，当用户如果访问另外一个 CAS Client 2 的时候，用户不需要再次认证，即会跳过5、6、7、8、9这几步，从而达到 SSO 的效果。</p><h3 id="OAuth"><a href="#OAuth" class="headerlink" title="OAuth"></a>OAuth</h3><p><a href="https://tools.ietf.org/html/rfc6749">Open Authorization</a>，简称 OAuth ，一般指的是 OAuth2 协议。</p><p>OAuth2 解决的主要场景是: 第三方应用如何被授权访问资源服务器。整个流程参与者包括几个组成部分:</p><ul><li>Resource Owner: 资源拥有者，通常为终端用户</li><li>Resource Server: 资源提供者</li><li>Authorization Server: 授权服务器</li><li>Client: 请求访问服务器的应用</li></ul><p>抽象的授权流程大致为:</p><p><img src="/blog/static/imgs/sso/oauth2.0.png" alt="oauth2_inner"></p><p>假定一个在线音乐服务，用户 zhangsan 想通过某音视频播放软件来播放在线音乐, 但是在播放音乐之前，该音视频软件必须得通过 OAuth server 认证授权，得到 zhangsan 的同意之后才能访问在线音乐。</p><p>在这个场景中，zhangsan 为 Resource Owner, 在线音乐服务为 Resource Server , 某音视频播放软件为 Client，OAuth server 作为 Authorization Server。</p><p>授权流程如下：</p><ol><li>音视频软件向 zhangsan 发起授权请求，请求 zhangsan 同意访问在线音乐服务；</li><li>根据不同的授权模式， zhangsan 同意该授权，且返回一个”授权”给音视频服务；</li><li>音视频服务携带 zhangsan 的授权，请求 OAuth Server 颁发一个 Access Token, 用于访问在线音乐；</li><li>OAuth Server 校验音视频服务自身的合法性之后，颁发 Access Token；</li><li>音视频服务携带 Access Token, 代表 zhangsan 请求访问在线音乐；</li><li>在线音乐服务校验完 Access Token 以后，提供音乐服务. 播放器开始播放音乐。</li></ol><p>上述是一个抽象的授权流程，而在具体实现中，在前三步中会有几个变种，即不同的授权模式，常见的授权模式包括:</p><ul><li>Authorization Code Grant: 认证码授权，最为常用，相对更安全<br><img src="/blog/static/imgs/sso/oauth_acg.png" alt="oauth_acg_inner"></li><li>Implicit Grant: 隐式授权，适用于SPA应用，不推荐，被<a href="https://tools.ietf.org/html/rfc7636">PKCE</a>模式所替代<br><img src="/blog/static/imgs/sso/oauth_ig.png" alt="oauth_ig_inner"></li><li>Resource Owner Password Credentials Grant: 资源拥有者密码授权，需要把用户的用户名和密码暴露给Client，只有在 Authorization Server 完全信任 Client 时才能采用，不推荐<br><img src="/blog/static/imgs/sso/oauth_ropcg.png" alt="oauth_ropcg_inner"></li><li>Client Credential Grant：客户端认证授权，没有用户概念，适用于服务端与服务端的调用<br><img src="/blog/static/imgs/sso/oauth_ccg.png" alt="oauth_ccg_inner"></li></ul><h3 id="OIDC"><a href="#OIDC" class="headerlink" title="OIDC"></a>OIDC</h3><p><a href="https://openid.net/specs/openid-connect-core-1_0.html">OpenID Connect</a> 简称 OIDC，是基于 OAuth2 扩展出来的一个协议。OAuth2 只定义了授权（Authorization）场景，OIDC 额外定义了认证（Authentication）的场景。</p><p>相比 OAuth2，OIDC 引入了 ID Token 等和 UserInfo 相关的概念：</p><ul><li>OAuth2 协议，只是定义了 Access Token/Refresh Token，但这两个 token 是指为了保护 Resource Server，并没有 Resource Owner 的身份信息；</li><li>OIDC 引入了 ID Token 的概念，用这个 token 来表示这是 Resource Owner 的身份信息：<ul><li>标准化 ID Token 的格式，即 <a href="/blog/2021/05/17/FE-JWT-JSON-WEB-TOKEN/">JWT</a></li><li>标准化 ID Token 的内容，即 <a href="https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims">Standard Claims</a></li></ul></li><li>OIDC 引入了关于如何获取详细的 UserInfo Endpoint ；</li><li>OIDC 定义了类似于 SAML Metadata 的 <a href="https://openid.net/specs/openid-connect-discovery-1_0.html">Discovery接口</a>，俗称 Well-known 接，使客户端可以动态的获取 OIDC 服务相关的元数据描述信息</li></ul><p>OIDC 协议的登录授权流程和 OAuth2 基本类似, 整个流程的参与者也类似，只不过换了个术语：</p><ul><li>OpenID Provider：简称 OP，负责认证和授权</li><li>Relying Party：简称 RP，类似 OAuth2 中的 Client</li><li>End User: 终端用户</li></ul><p><img src="/blog/static/imgs/sso/oidc.png" alt="oidc_inner"></p><p>认证与授权流程如下：</p><ol><li>RP 发送一个认证请求给 OP；</li><li>OP 对 EU 进行身份认证，然后提供授权；</li><li>OP 把 ID Token 和 Access Token （需要的话）返回给 RP；</li><li>RP 使用 Access Token 发送一个请求 UserInfo EndPoint；</li><li>UserInfo EndPoint 返回 EU 的 Claims。</li></ol><p>OIDC 的授权模式有以下三种：</p><ol><li>Authorization Code Flow：使用 OAuth2 的授权码来换取 Id Token 和 Access Token 。</li><li>Implicit Flow：使用 OAuth2 的 Implicit 流程获取 Id Token 和 Access Token 。</li><li>Hybrid Flow：混合 Authorization Code Flow + Implici Flow 。</li></ol><p>OIDC 并不包含 OAuth2 中的 Resource Owner Password Credentials Grant 模式 和 Client Credential Grant 模式，主要是因为 Resource Owner Password Credentials Grant 模式中，用户名和密码完全提供给了 Client(Relying Party) 不需要 ID Token 进行认证，而 Client Credential Grant 模式中没有 User 的角色，所以不需要认证。</p><h3 id="SAML"><a href="#SAML" class="headerlink" title="SAML"></a>SAML</h3><p>Security Assertion Markup Language，简称 SAML，是一个基于 XML 的、用于实现不同业务实体（即系统或服务）之间，交换安全信息（例如认证信息、授权信息、主体属性信息等）的标准协议。SAML 标准定义了身份提供者（Identity Provider）和服务提供者（Service Provider）之间，如何通过 SAML 规范，采用加密和签名的方式来建立互信，从而交换用户身份信息。SAML 协议于2002年由 OASIS （结构化信息标准促进组织，Organization for the Advancement of Structured Information Standards) 组织提出，已经经历了 1.0，1.1，2.0 三个版本，在早期 B/S 架构的企业级应用中非常流行。</p><p>SAML 流程的参与者包括：</p><ul><li>Asserting Party，即断言签发方，是签发断言的业务系统</li><li>Relying Party，即断言依赖方，是消费断言的业务系统</li><li>User，即用户，一般通过 Web 浏览器与两个业务系统进行交互</li></ul><p>SAML 协议可以应用于多种不同的业务场景，在一些业务场景中，SAML 会定义不同的角色，各个业务系统在不同的场景中可以扮演不同的角色。以 Web 单点登录场景为例，在该场景下，SAML 协议中定义了 IdP（Identity Provider）和 SP（Service Provider）两种角色。</p><p>下面是大致的认证流程(SP Initiated)：</p><p><img src="/blog/static/imgs/sso/saml.png" alt="saml_inner"></p><ol><li>End User 从浏览器中请求访问某 SP：https://www.example.com ；</li><li>https://www.example.com 发现用户未登录，则发起 SAML 的 AuthNRequest 请求至 IdP, 用户浏览器跳转至 IdP 页面；</li><li>IdP 发现用户处于未登录状态，重定向用户至 IdP 的登录界面，请求用户进行身份验证</li><li>用户在登录页面中进行身份认证, 通常情况下需要校验用户名和密码；</li><li>IdP 校验用户身份，若成功，则把包含着用户身份信息的校验结果，以 SAML Response 的形式，签名/加密发送给 SP；</li><li>SP 拿到用户身份信息以后，进行签名验证/解密，拿到明文的用户身份信息，此时 SP 处于登录状态，可以对用户提供服务。</li></ol><p>可以看到，在整个流程中，IdP 是负责颁发用户身份，SP 负责信任 IdP 颁发的用户身份, SP 和 IdP 之间的信任关系是需要提前建立的，即 SP 和 IdP 需要提前把双方的信息预先配置到对方，通过证书信任的方式来建立互信。</p><h3 id="Kerberos"><a href="#Kerberos" class="headerlink" title="Kerberos"></a>Kerberos</h3><p><a href="https://www.rfc-editor.org/rfc/rfc4120.html">Kerberos</a> 身份验证协议起源于麻省理工学院，是由“Athena”项目的工程师开发的。第一个公开发行的版本是于1980年末发布的 Kerberos 版本4。在被广泛的使用后，协议的开发者于1993年发布了 Kerberos 第五版本。Kerberos V5 现在成为 IETF 的标准，Windows Server 2003 中 Kerberos V5 的实现严格的遵循了<a href="https://www.rfc-editor.org/rfc/rfc1510.html">RFC 1510</a>定义的标准，另外，Kerberos 消息中的安全令牌（security tokens）的格式和机制遵循 <a href="https://www.rfc-editor.org/rfc/rfc1964">RFC 1964</a> 定义的标准。Kerberos 仅包含认证部分，不包括授权部分。</p><p>Kerberos 并不是一个 Web SSO 协议，它主要被应用于客户端与服务器认证。Windows2000 和后续的操作系统都默认 Kerberos 为其默认认证方法，苹果的 Mac OS X 也使用了 Kerberos 的客户和服务器版本，Red Hat Enterprise Linux4 和后续的操作系统使用了 Kerberos 的客户端和服务器版本。</p><p>Kerberos 认证流程的参与者主要包括：</p><ul><li>AS（Authentication Server）= 认证服务器</li><li>KDC（Key Distribution Center）= 密钥分发中心</li><li>TGT（Ticket Granting Ticket）= 票据授权票据，票据的票据</li><li>TGS（Ticket Granting Server）= 票据授权服务器</li><li>SS（Service Server）= 特定服务提供端</li></ul><h3 id="其他协议"><a href="#其他协议" class="headerlink" title="其他协议"></a>其他协议</h3><p>其他 SSO 相关协议还包括 OpenID、LID(Light-Weight Identity) 、Yadis、I-name、WS-Federation 等。</p><p><a href="https://en.wikipedia.org/wiki/OpenID">OpenID</a> 最初是由大型社区 LiveJournal (建立于开源软件基础之上)的创办人 Brad Fitzpatrick 在2005年6月27日开发推出的一套身份识别系统，它采用分布式认证系统用于用户留言身份认证。</p><p><a href="https://en.wikipedia.org/wiki/Light-weight_Identity">Light weight Identity</a> （LID）或 Light Identity Management（LIdM）是一种用于在线数字身份的身份管理系统，部分由 NetMesh 开发。它于2005年初首次发布，是最初的基于 URL 的身份系统，随后被 OpenID 采用。LID 使用 URL 验证用户身份，并被几种开源协议采用，如 OpenID 、 Yadis 和 PGP/GPG 。</p><p><a href="https://en.wikipedia.org/wiki/Yadis">Yadis</a> 是一种用于发现连接到 YadisID 的 OpenID 、 OAuth 和 XDI 等服务的通信协议。虽然 Yadis 旨在发现数字身份服务，但并不限于这些服务，可以很容易地包括其他服务。</p><p><a href="https://en.wikipedia.org/wiki/I-name">I-name</a> 是 XRI 的一种形式，XRI 是一种针对数字标识符的 OASIS 开放标准，旨在跨域和应用程序共享资源和数据。</p><p><a href="https://en.wikipedia.org/wiki/WS-Federation">WS-Federation</a>，全称 Web Services Federation，简称 WS-Fed，属于 Web Services Security 框架的一部分，是由 <a href="https://www.oasis-open.org">OASIS</a> 发布的标准协议，其主要贡献者是 Microsoft 和 IBM。WS-Fed 1.1 版本发布于2003年，最新的1.2版本标准发布于2009年。WS-Federation 标准基于 SOAP，定义了允许不同安全领域来协商 <em>身份</em>、<em>身份属性</em> 和 <em>认证</em> 信息的机制，主要应用在企业服务。</p><h2 id="协议对比"><a href="#协议对比" class="headerlink" title="协议对比"></a>协议对比</h2><p>上面简单介绍了主流的几种 SSO 协议，本质上它们大同小异，都是基于中心信任的机制，服务提供者和身份提供者之间通过互信来交换用户信息，只是每个协议信息交换的细节不同，或者概念上有些不同。</p><p>以下列举了常用 Web SSO 协议的比较：</p><table><thead><tr><th>功能</th><th>CAS</th><th>OAuth</th><th>OIDC</th><th>SAML</th></tr></thead><tbody><tr><td>支持认证(Authentication)</td><td>是</td><td>否</td><td>是</td><td>是</td></tr><tr><td>支持授权(Authorization)</td><td>否</td><td>是</td><td>是</td><td>否</td></tr><tr><td>协议最新版本</td><td>3.0</td><td>2.0</td><td>1.0</td><td>2.0</td></tr><tr><td>传输方式</td><td>HTTP</td><td>HTTP</td><td>HTTP</td><td>HTTP</td></tr><tr><td>票据格式</td><td>Service ticket，Proxy ticket <br/> 没有标准格式</td><td>Access Token，Refresh Token <br/> 没有标准格式</td><td>Access Token，Refresh Token，ID Token <br/> Access Token，Refresh Token 没有标准格式，ID Token采用 JWT 格式</td><td>Assertion，AuthNRequest，基于XML协议</td></tr><tr><td>主要应用场景</td><td>B/S架构，浏览器单点登录</td><td>B/S架构，浏览器单点登录，PKCE模式可用来实现移动端单点登录</td><td>B/S架构，浏览器单点登录</td><td>B/S架构，浏览器单点登录</td></tr><tr><td>优势</td><td>协议简单</td><td>1.协议简单，解决场景较多 <br/> 2.成熟度高，社区支持广泛</td><td>基于 OAuth2，完全兼容 OAuth2</td><td>协议功能强大，涵盖场景多</td></tr><tr><td>劣势</td><td>场景单一</td><td>1.各厂商实现细节有差异 <br/> 2.只定义了授权，未定义认证</td><td></td><td>1.协议过于庞大，可选实现过多 <br/> 2.基于XML的签名&amp;加密，技术复杂度更高</td></tr><tr><td>实践</td><td>玉符IDaaS</td><td>微信、企业微信、钉钉、QQ、玉符IDaaS</td><td>腾讯云IDaaS、玉符IDaaS</td><td>阿里云IDaaS、腾讯云IDaaS、玉符IDaaS</td></tr></tbody></table><h2 id="其他与认证授权相关的概念与术语"><a href="#其他与认证授权相关的概念与术语" class="headerlink" title="其他与认证授权相关的概念与术语"></a>其他与认证授权相关的概念与术语</h2><table><thead><tr><th>简称</th><th>全称</th><th>含义</th></tr></thead><tbody><tr><td>AAA</td><td>Authentication, Authorization &amp; Accounting</td><td>AAA是认证（Authentication）、授权（Authorization）和账号（Accounting）的简称，是网络安全中进行访问控制的一种安全管理机制，提供认证、授权和账号管理三种安全服务</td></tr><tr><td>4A</td><td>Authentication, Authorization, Account &amp; Audit</td><td>认证、授权、账号与审计</td></tr><tr><td>IAM</td><td>Identity and Access Management</td><td>身份识别与访问管理</td></tr><tr><td>KMS</td><td>Key Management Service</td><td>密钥管理服务</td></tr><tr><td>IdP</td><td>Identity Provider</td><td>身份提供商，是一种存储和管理用户数字身份的服务</td></tr><tr><td>DaaS</td><td>Directory as a Service</td><td>目录即服务</td></tr><tr><td>IDaaS</td><td>Identity as a Service</td><td>身份即服务</td></tr><tr><td>PAM</td><td>Pluggable Authentication Modules</td><td>可插拔认证模块，是由 Sun 公司提出的一种认证机制，通过提供一些动态链接库和一套统一的API，将系统提供的服务和该服务的认证方式分开，使得系统管理员可以灵活地根据需要给不同的服务配置不同的认证方式而无需更改服务程序，同时也便于向系统中添加新的认证手段</td></tr><tr><td>SASL</td><td>Simple Authentication and Security Layer</td><td>简单验证和安全层</td></tr><tr><td>GSS-API</td><td>The Generic Security Services Application Program Interface</td><td>通用安全服务应用程序接口</td></tr><tr><td>LDAP</td><td>Lightweight Directory Access Protocol</td><td>轻型目录访问协议</td></tr><tr><td>openLDAP</td><td>openLDAP</td><td>一个开源的LDAP服务器实现</td></tr><tr><td>AD</td><td>Active Directory</td><td>Microsoft 公司提供的LDAP实现</td></tr><tr><td>RADIUS</td><td>Remote Authentication Dial In User Service</td><td>远程用户拨号认证系统，是应用最广泛的AAA协议，由<a href="https://www.rfc-editor.org/rfc/rfc2865.html">RFC2865</a>，<a href="https://www.rfc-editor.org/rfc/rfc2866.html">RFC2866</a>定义</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> SSO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM中的高度、宽度与距离</title>
      <link href="/blog/2022/06/14/HTML-DOM%E4%B8%AD%E7%9A%84%E9%AB%98%E5%BA%A6%E3%80%81%E5%AE%BD%E5%BA%A6%E4%B8%8E%E8%B7%9D%E7%A6%BB/"/>
      <url>/blog/2022/06/14/HTML-DOM%E4%B8%AD%E7%9A%84%E9%AB%98%E5%BA%A6%E3%80%81%E5%AE%BD%E5%BA%A6%E4%B8%8E%E8%B7%9D%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="HTMLElement-Element-属性"><a href="#HTMLElement-Element-属性" class="headerlink" title="HTMLElement/Element 属性"></a>HTMLElement/Element 属性</h2><h3 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h3><p><code>HTMLElement.offsetWidth</code> 属性表示元素的布局宽度。该属性包括元素的内容宽度（content-width）、竖直方向滚动条宽度（scrollbar-width）（如果存在的话）、水平方向的内边距（padding-left padding-right）以及水平方向的边框（border-left-width border-right-width）。</p><p><code>HTMLElement.offsetHeight</code> 属性表示元素的布局高度。该属性包括元素的内容高度（content-height）、水平方向滚动条高度（scrollbar-height）（如果存在的话）、竖直方向的内边距（padding-top padding-bottom）以及竖直方向的边框（border-top-width border-bottom-width）。</p><p>offsetWidth = 水平方向content-width + 左右padding + 左右border + 竖直方向滚动条scrollbar-width（如果存在的话）<br>offsetHeight = 竖直方向content-height + 上下padding + 上下border + 水平方向滚动条scrollbar-height（如果存在的话）</p><p><img src="/blog/static/imgs/dom/offset.png" alt="offset_inner"></p><p><em>offsetWidth 和 offsetHeight 可以理解为一个 边框盒（border box） 的 width 和 height。</em></p><p><code>HTMLElement.offsetTop</code> 属性表示元素的左上角相对于其 offsetParent 元素的顶部边框的距离。<br><code>HTMLElement.offsetLeft</code> 属性表示元素左上角相对于其 offsetParent 元素的左边框的距离。</p><p><code>HTMLElement.offsetParent</code> 返回一个指向最近的（指包含层级上的最近）包含该元素的定位元素或者最近的 <code>table,td,th,body</code> 元素。当元素的 <code>style.display</code> 设置为 “none” 时，或者该元素的 <code>style.position</code> 被设为 “fixed” 时，<code>offsetParent</code> 返回 <code>null</code>。</p><h3 id="client"><a href="#client" class="headerlink" title="client"></a>client</h3><p><code>Element.clientWidth</code> 属性表示元素的内部宽度。该属性包括元素的内容宽度（content-width）和内边距（padding），但不包括竖直方向滚动条宽度（scrollbar-width）（如果存在的话），边框（border）和外边距（margin）。</p><p><code>Element.clientHeight</code> 属性表示元素的内部高度。该属性包括元素的内容宽度（content-width）和内边距（padding），但不包括水平方向滚动条高度（scrollbar-height）（如果存在的话），边框（border）和外边距（margin）。</p><p>clientWidth = 水平方向content-width + 左右padding<br>clientHeight = 竖直方向content-height + 上下padding</p><p><img src="/blog/static/imgs/dom/client.png" alt="client_inner"></p><p><em>offsetWidth 和 offsetHeight 可以理解为一个 内边距盒（padding box） 的 width 和 height。</em><br><em>padding-box 并不是一个标准的盒模型选项，这里只是为了方便理解</em></p><p><code>Element.clientTop</code> 属性表示元素顶部边框的宽度。该属性仅包括元素的顶部边框宽度<br>（border-top-width）。</p><p><code>Element.clientLeft</code> 属性表示元素的左边框宽度。该属性包括元素的左边框 （border-left-width），如果元素的文本方向是从右向左（RTL, right-to-left），并且由于内容溢出导致左边出现了一个垂直滚动条，则该属性包括滚动条的宽度。</p><h3 id="scroll"><a href="#scroll" class="headerlink" title="scroll"></a>scroll</h3><p><code>Element.scrollWidth</code> 属性表示元素在不使用滚动条的情况下适合视口中的所有内容所需的最小宽度。scrollWidth 的测量方式与 clientWidth 相同：包含元素的内边距（padding），但不包括边框（border），外边距（margin）或垂直滚动条（如果存在）。scrollWidth 也包括伪元素的宽度，例如 ::before 或 ::after 。如果元素的内容可以正常展示而不需要水平滚动条，则其 scrollWidth 等于 clientWidth 。</p><p><code>Element.scrollHeight</code> 属性表示元素在不使用滚动条的情况下为了适应视口中所用内容所需的最小高度。scrollHeight 的测量方式与 clientHeight 相同：包括元素的内边距（padding），但不包括元素的边框（border）和外边距（margin）。scrollHeight 也包括 ::before 和 ::after 这样的伪元素的高度。 如果元素的内容不需要垂直滚动条就可以正常展示，则其 scrollHeight 等于 clientHeight。</p><p><img src="/blog/static/imgs/dom/scrollheight.png" alt="scroll-height_inner"></p><p><code>Element.scrollTop</code> 属性可以获取或<em>设置</em>（和前面的属性不同，scrollTop 是一个可读写的属性）元素的顶部到可视内容顶部的距离。如果一个元素的内容没有产生垂直方向的滚动条，那么它的 scrollTop 值为 0 。</p><p><code>Element.scrollLeft</code> 属性可以获取或<em>设置</em>元素的左边到可视内容左边的距离。如果一个元素的内容没有产生水平方向的滚动条，那么它的 scrollLeft 值为 0 。</p><h3 id="style-属性"><a href="#style-属性" class="headerlink" title="style 属性"></a>style 属性</h3><p>通过 <code>HTMLElement.style</code> 可以获取或<em>设置</em>元素的样式属性。但大部分时候，样式并不是直接存在于元素上而是通过继承等原因体现到的。我们可以通过 <code>window.getComputedStyle(element, [pseudoElt])</code> 获取到已经解析的 CSS 样式，该方法返回一个 <code>CSSStyleDeclaration</code> 对象，当元素的样式更改时，它会自动更新。</p><p><code>HTMLElement.style.&#123;top|left|right|bottom&#125;</code> 属性定义了定位元素的外边距边界与其包含块边界或正常位置之间的距离，非定位元素设置此属性无效。</p><p>以 top 为例，top 的效果取决于元素的 position 属性：</p><ul><li>当 position 设置为 absolute 或 fixed 时，top 属性指定了定位元素上外边距边界与其包含块上边界之间的偏移。</li><li>当 position 设置为 relative 时，top 属性指定了元素的上边界离开其正常位置的偏移。</li><li>当 position 设置为 sticky 时，如果元素在 viewport 里面，top 属性的效果和  position 为 relative 等同；如果元素在 viewport 外面，top 属性的效果和 position 为 fixed 等同。</li><li>当 position 设置为 static 时，top 属性无效。</li></ul><p><code>HTMLElement.style.margin&#123;Left|Top|Right|Bottom&#125;</code> 属性定义了元素的外边距<br><code>HTMLElement.style.padding&#123;Left|Top|Right|Bottom&#125;</code> 属性定义了元素的内边距<br><code>HTMLElement.style.border&#123;Left|Top|Right|Bottom&#125;Width</code> 属性定义了元素边框的宽度</p><h3 id="getBoundingClientRect-方法"><a href="#getBoundingClientRect-方法" class="headerlink" title="getBoundingClientRect 方法"></a>getBoundingClientRect 方法</h3><p><code>Element.getBoundingClientRect()</code> 方法返回一个 <code>DOMRect</code> 对象，其提供了元素的大小及其相对于视口的位置。值得注意的是，以上像 <code>offsetWidth</code> 等只读属性返回的都是四舍五入（round）之后的整数数值，<code>getBoundingClientRect</code> 可以返回精确的小数数值。</p><p>该方法返回的 <code>DOMRect</code> 对象中的 <code>width</code> 和 <code>height</code> 属性是包含了 <code>padding</code> 和 <code>border-width</code> 的，而不仅仅是内容部分的宽度和高度。在 <code>content-box</code> 模型中，这两个属性值分别与元素的 width/height + padding + border-width 相等。而如果是 border-box，两个属性则直接与元素的 width 或 height 相等。</p><p><img src="/blog/static/imgs/dom/element-box-diagram.png" alt="element-box_inner"></p><h3 id="getClientRects-方法"><a href="#getClientRects-方法" class="headerlink" title="getClientRects 方法"></a>getClientRects 方法</h3><p><code>Element.getClientRects()</code> 方法返回一个 <code>DOMRect</code> 集合，其包括元素内所有<br>边框盒（border box）的边界矩形（bounding rectangles）。大多数元素只有一个边框盒（border box），但是诸如一个多行的内联元素（例如多行的 span 元素）每行都有一个边框盒（border box）。</p><h2 id="window-属性"><a href="#window-属性" class="headerlink" title="window 属性"></a>window 属性</h2><p><code>window.innerWidth</code> 属性表示以像素为单位的窗口的视口（viewport）宽度。如果垂直滚动条存在，则这个属性将包括它的宽度。</p><p><code>window.innerHeight</code> 属性表示以像素为单位的窗口的视口（viewport）高度。如果水平滚动条存在，则这个属性将包括它的高度。</p><p><code>window.outerWidth</code> 属性表示整个浏览器外部窗口的宽度。包括侧边栏（如果存在）、窗口镶边和调整窗口大小的边框。</p><p><code>window.outerHeight</code> 属性表示整个浏览器外部窗口的高度。包括工具栏（如果存在）、窗口镶边和调整窗口大小的边框。</p><p><img src="/blog/static/imgs/dom/inner-outer.png" alt="inner-outer_inner"></p><p>一个显著的区分 inner 和 outer 的例子就是打开浏览器的 开发者工具，outerHeight 将会计算上开发者工具的高度，而 innerHeight 不会。</p><h3 id="screen-属性"><a href="#screen-属性" class="headerlink" title="screen 属性"></a>screen 属性</h3><p><code>window.screen.width</code> 属性表示屏幕的宽度。</p><p><code>window.screen.height</code> 属性表示屏幕的高度。</p><p><code>window.screen.availWidth</code> 属性表示浏览器窗口在屏幕上可占用的最大宽度。</p><p><code>window.screen.availHeight</code> 属性表示浏览器窗口在屏幕上可占用的最大高度。小工具（Widgets），如任务栏或其他特殊的程序窗口，可能会减少浏览器窗口和其他应用程序能够利用的空间。</p><h2 id="document-属性"><a href="#document-属性" class="headerlink" title="document 属性"></a>document 属性</h2><p><code>document.documentElement</code> 返回的是整个 html 文档<br><code>document.body</code> 返回的是 body 元素</p><p>html 文档 与 body 元素都是有效的 HTMLElement ， 所以，他们的属性也符合对应属性的定义：</p><p><code>document.documentElement.clientWidth</code> 浏览器窗口可视区宽度（不包括浏览器控制台、菜单栏、工具栏、滚动条）<br><code>document.documentElement.clientHeight</code> 浏览器窗口可视区高度（不包括浏览器控制台、菜单栏、工具栏、滚动条）</p><p><code>document.documentElement.offsetHeight</code> 获取整个文档的高度（包含 body 的 margin ）<br><code>document.documentElement.offsetWidth</code> 获取整个文档的宽度（包含 body 的 margin ）</p><p><code>document.documentElement.scrollTop</code> 返回文档的滚动 top 方向的距离（当窗口发生滚动时值改变）<br><code>document.documentElement.scrollLeft</code> 返回文档的滚动 left 方向的距离（当窗口发生滚动时值改变）</p><p><code>document.body.offsetHeight</code> 获取整个 body 的高度（不包含 body 的 margin ）<br><code>document.body.offsetWidth</code> 获取整个 body 的宽度（不包含 body 的 margin ）</p><p><img src="/blog/static/imgs/dom/distance.webp" alt="distance_inner"></p>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> Web API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分辨率，屏幕比例与设备像素比</title>
      <link href="/blog/2022/06/10/TIPS-%E5%88%86%E8%BE%A8%E7%8E%87-%E5%B1%8F%E5%B9%95%E6%AF%94%E4%BE%8B%E4%B8%8E%E8%AE%BE%E5%A4%87%E5%83%8F%E7%B4%A0%E6%AF%94/"/>
      <url>/blog/2022/06/10/TIPS-%E5%88%86%E8%BE%A8%E7%8E%87-%E5%B1%8F%E5%B9%95%E6%AF%94%E4%BE%8B%E4%B8%8E%E8%AE%BE%E5%A4%87%E5%83%8F%E7%B4%A0%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<p>首先需要理解一些屏幕分辨率相关的概念:</p><h2 id="屏幕分辨率与PPI"><a href="#屏幕分辨率与PPI" class="headerlink" title="屏幕分辨率与PPI"></a>屏幕分辨率与PPI</h2><h3 id="屏幕分辨率（Screen-Resolution）"><a href="#屏幕分辨率（Screen-Resolution）" class="headerlink" title="屏幕分辨率（Screen Resolution）"></a>屏幕分辨率（Screen Resolution）</h3><p>屏幕上面的像素点数，以 水平像素数 * 垂直像素数 来表示，分辨率越高，像素数越多，图像越细腻。分辨率的单位为px（像素），例如 1920 * 1080 分辨率，指的是水平像素为 1920 像素，垂直像素为 1080 像素。</p><h3 id="DPI（每英寸点数-Dots-Per-Inch）"><a href="#DPI（每英寸点数-Dots-Per-Inch）" class="headerlink" title="DPI（每英寸点数 Dots Per Inch）"></a>DPI（每英寸点数 Dots Per Inch）</h3><p>DPI（Dots Per Inch，每英寸点数）是一个量度单位，用于点阵数码影像，指每一英寸长度中，取样、可显示或输出点的数目。</p><h3 id="PPI（每英寸像素数-Pixels-Per-Inch）"><a href="#PPI（每英寸像素数-Pixels-Per-Inch）" class="headerlink" title="PPI（每英寸像素数 Pixels Per Inch）"></a>PPI（每英寸像素数 Pixels Per Inch）</h3><p>PPI（Pixels Per Inch，每英寸像素数）所表示的是每英寸对角线上所拥有的像素数目。假设 X 代表长度像素数；Y 代表宽度像素数；Z 代表屏幕大小（屏幕对角线长度单位是英寸），那么 PPI=√（X^2+Y^2）/ Z。PPI 越高，人视觉上看到的屏幕就越清晰。当屏幕的 PPI 达到一定数值时，人眼就几乎分辨不出颗粒感了。</p><span id="more"></span><h2 id="常见屏幕比例与分辨率"><a href="#常见屏幕比例与分辨率" class="headerlink" title="常见屏幕比例与分辨率"></a>常见屏幕比例与分辨率</h2><h3 id="16：9屏幕比例"><a href="#16：9屏幕比例" class="headerlink" title="16：9屏幕比例"></a>16：9屏幕比例</h3><p>16：9的屏幕比例，常见的分辨率有 1920 * 1080（Full HD全高清）、1280 * 720（高清）、2560 * 1440（四高清晰度，超清）、1366 * 768（WXGA）分辨率。</p><p>1920 * 1080（1080P）主要应用于电脑PC显示屏、笔记本高清屏和一些电视显示设备。</p><p>1280 * 720 和 1366 * 768 主要应用在一些小屏幕商务笔记本（例14寸）、超级本、高清播放器等显示设备。</p><p>2560 * 1440 分辨率为超高清显示分辨率，与 2048 * 1080、2048 * 1536(QXGA)等分辨率，常被称为2K分辨率。经常在一些大屏显示器、设计用显示器、高清电视中可以见到。</p><h3 id="16：10屏幕比例"><a href="#16：10屏幕比例" class="headerlink" title="16：10屏幕比例"></a>16：10屏幕比例</h3><p>也就是宽荧幕比例。常见的分辨率有 1280 * 800（WXGA）、1440 * 900（WXGA+）、1920 * 1200（WUXGA）等分辨率，被应用于宽荧幕笔记本电脑显示屏、宽屏电视、宽屏显示器等设备。</p><h3 id="4：3屏幕比例"><a href="#4：3屏幕比例" class="headerlink" title="4：3屏幕比例"></a>4：3屏幕比例</h3><p>4：3屏时代较为久远，在未出现宽荧幕前，4：3屏为最为常见的显示比例。常见的分辨率有640x480（VGA）、800x600（SVGA）、1024x768（XGA）等分辨率。尤其在一些CRT显示器、比较老的4：3方屏LCD显示器、比较老的电视上面，这种分辨率比较常见。尤其在15寸CRT显示器，比较通用的 800 * 600 ，17寸显示器最为通用的，则为 1024 * 768，如果屏幕分辨率再高，字体显示会特别小。</p><h2 id="Retina屏幕"><a href="#Retina屏幕" class="headerlink" title="Retina屏幕"></a>Retina屏幕</h2><p>所谓 “Retina” 是一种显示标准，是把更多的像素点压缩至一块屏幕里，从而达到更高的分辨率并提高屏幕显示的细腻程度。该技术最初由摩托罗拉公司研发，被用于 Moto Aura 上。这种分辨率在正常观看距离下足以使人肉眼无法分辨其中的单独像素，所以也被称为视网膜显示屏。</p><p>第三代iPad发布会上，苹果给出了 Retina 设计标准的公式：α＝2tan-1（h/2d）</p><p>其中 a 代表人眼视角，h 代表像素间距，d 代表肉眼与屏幕的距离。符合一定像素间距的屏幕，在足够长的距离上可以使肉眼看不见单个物理像素点。这样的屏幕就可被苹果称作 “Retina显示屏” 。将 <em>通常使用距离</em> 代入上公式可知：移动电话显示器的像素密度达到或高于 300ppi 就不会再出现颗粒感；手持平板类电器显示器的像素密度达到或高于 260ppi 就不会再出现颗粒感，而苹果电脑的 Retina 显示器像素密度只要超过 200ppi 就无法区分出单独的像素。</p><p>使用 Retina 屏幕的设备拥有的物理像素点数比非高清屏幕高4倍甚至更多，如果仍旧按照设备独立像素来进行绘制的话，同一张图片在 Retina 屏幕上显示的区域只有非高清屏的 1/4。</p><h2 id="设备像素比（DPR）"><a href="#设备像素比（DPR）" class="headerlink" title="设备像素比（DPR）"></a>设备像素比（DPR）</h2><p>设备像素比（Device Pixel Ratio，DPR）。在浏览器中，可以通过 <code>window.devicePixelRatio</code> 获取 设备物理像素 和 设备独立像素(CSS像素) 的比例。在 devicePixelRatio &gt; 1 的浏览器或手机上使用 canvas 画图，你就会发现绘制模糊。这是因为图片被放大了 devicePixelRatio 倍， 我们处理的时候对其进行像素压缩（在小的屏幕范围内渲染更多的像素）即可实现图片不模糊。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;canvas&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 1000px;height: 500px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get display size (css pixels).</span></span><br><span class="line"><span class="keyword">const</span> canvasComputedStyle = <span class="title function_">getComputedStyle</span>(canvas, <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">const</span> elementWidth = <span class="built_in">parseInt</span>(canvasComputedStyle[<span class="string">&#x27;width&#x27;</span>])</span><br><span class="line"><span class="keyword">const</span> elementHeight = <span class="built_in">parseInt</span>(canvasComputedStyle[<span class="string">&#x27;height&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scaled to account for extra pixel density.</span></span><br><span class="line">canvas.<span class="property">width</span> = <span class="title class_">Math</span>.<span class="title function_">floor</span>(elementWidth * devicePixelRatio)</span><br><span class="line">canvas.<span class="property">height</span> = <span class="title class_">Math</span>.<span class="title function_">floor</span>(elementHeight * devicePixelRatio)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Normalize coordinate system to use css pixels.</span></span><br><span class="line">canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>).<span class="title function_">scale</span>(devicePixelRatio, devicePixelRatio)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>script 标签中的 async/defer</title>
      <link href="/blog/2022/05/17/HTML-script%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/blog/2022/05/17/HTML-script%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>HTML <code>&lt;script&gt;</code> 元素用于嵌入或引用可执行脚本。</p><h2 id="script-元素的属性"><a href="#script-元素的属性" class="headerlink" title="script 元素的属性"></a>script 元素的属性</h2><p>script 有以下常见属性：  </p><ul><li>src</li></ul><p>这个属性定义引用外部脚本的 URI，这可以用来代替直接在文档中嵌入脚本。指定了 src 属性的 script 元素标签内不应该再有嵌入的脚本。</p><ul><li>type</li></ul><p>该属性定义 script 元素包含或 src 引用的脚本语言类型。属性的值为 MIME 类型; 支持的 MIME 类型包括 <code>text/javascript</code>, <code>text/ecmascript</code>, <code>application/javascript</code>, 和 <code>application/ecmascript</code> 。如果没有定义这个属性，脚本会被视作 JavaScript。</p><p>如果 type 属性为 module ，代码会被当作 JavaScript 模块（模块脚本）。</p><ul><li>async（异步）</li></ul><p>对于普通脚本，如果存在 async 属性，那么普通脚本会被并行请求，并尽快解析和执行。<br>对于模块脚本，如果存在 async 属性，那么脚本及其所有依赖都会在延缓队列中执行，因此它们会被并行请求，并尽快解析和执行。<br>该属性能够消除解析阻塞的 Javascript。解析阻塞的 Javascript 会导致浏览器必须加载并且执行脚本，之后才能继续解析。defer 在这一点上也有类似的作用。</p><ul><li>defer（推迟）</li></ul><p>这个布尔属性被设定用来通知浏览器该脚本将在文档完成解析后，触发 DOMContentLoaded 事件前执行。<br>有 defer 属性的脚本会阻止 DOMContentLoaded 事件，直到脚本被加载并且解析完成。<br>如果缺少 src 属性（即内嵌脚本），该属性不应被使用，因为这种情况下它不起作用。<br>defer 属性对模块脚本没有作用 —— 他们默认 defer。</p><h2 id="如何理解-async-defer-和默认的脚本加载执行行为"><a href="#如何理解-async-defer-和默认的脚本加载执行行为" class="headerlink" title="如何理解 async / defer 和默认的脚本加载执行行为"></a>如何理解 async / defer 和默认的脚本加载执行行为</h2><p>如下图所示：<br><img src="/blog/static/imgs/script.png" alt="script_inner"></p><ol><li>当没有 defer 或 async 的时候，浏览器会立即 <em>加载</em> 并 <em>执行</em> 指定的脚本，也就是说不会再解析 script 元素之后的文档元素，读到该脚本就 <em>加载</em> 并 <em>执行</em> 。<em>执行</em> 之后才会去解析该 script 元素之后的文档元素。</li><li>async 脚本将在不阻止解析页面的情况下 <em>下载</em> 脚本，并在脚本完成 <em>下载</em> 后立即 <em>执行</em> 它。也就是说，浏览器会开启新的线程加载 async 脚本，同时在原有线程中解析文档元素。我们无法保证 async 脚本将以任何特定顺序运行，只是 async 的脚本不会阻止页面文档元素的解析。所以 async 最好是当脚本在页面中相互独立运行的并且不依赖页面上的其他脚本时使用。比如 Google Analytics、百度统计 等就适合此种情况。</li><li>defer 脚本将在不阻止解析页面的情况下 <em>下载</em> 脚本，但只会在文档元素解析结束后，DOMContentLoaded 事件 之前按照defer 出现的顺序 <em>执行</em>，</li><li>同时使用 defer 和 async ，如果浏览器两个属性都支持，则会忽视 defer 属性，按照 async 的方式执行</li></ol><h2 id="script元素最佳实践"><a href="#script元素最佳实践" class="headerlink" title="script元素最佳实践"></a>script元素最佳实践</h2><ol><li>将 stylesheet 元素放到 head 中，避免加载 css 文件后引起重绘。</li><li>将 script 元素放到 body 的最后，这样不会因为下载 js 文件阻塞页面的渲染</li><li>对 Google Analytics、百度统计 等与页面元素无关的第三方的 script 元素 添加 async，不阻塞页面的解析</li><li>对于 应用脚本 如果放到了 head 中，可以按照脚本依赖顺序添加 defer，避免因为下载 js 文件阻塞页面的渲染</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Fetch API小抄</title>
      <link href="/blog/2022/03/09/JS-Fetch-API%E5%B0%8F%E6%8A%84/"/>
      <url>/blog/2022/03/09/JS-Fetch-API%E5%B0%8F%E6%8A%84/</url>
      
        <content type="html"><![CDATA[<p>Fetch API 提供了一个 <code>window.fetch()</code> 接口来获取资源（包括网络资源）。Fetch API 可以用来替代 XMLHttpRequest ，可以在 Web Workers 中使用( <code>WorkerGlobalScope.fetch()</code> )。</p><span id="more"></span><h2 id="Fetch-API-用法"><a href="#Fetch-API-用法" class="headerlink" title="Fetch API 用法"></a>Fetch API 用法</h2><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchResponsePromise = <span class="title function_">fetch</span>(resource [, init])</span><br></pre></td></tr></table></figure><h3 id="resource-参数"><a href="#resource-参数" class="headerlink" title="resource 参数"></a>resource 参数</h3><p><code>fetch()</code> 方法接受一个必填参数 <code>resource</code> ，即要获取的资源（可以是一个字符类型的资源地址，包括 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL">URL 对象</a>，或者是一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Request">Request 对象</a>）。它返回一个 Promise ，resolve 为对该请求的 Response ，只要服务器返回带 headers 响应——即使服务器响应的是 HTTP 错误状态（比如404 或 500）。如果遇到网络错误（比如权限或者其他问题）则会 reject 并传回 TypeError 。如果被中断，则会 reject 传回 AbortError。</p><p><code>fetch()</code> 方法获取资源的权限由 内容安全策略（Content Security Policy) 的 connect-src 指令控制。</p><p><code>fetch()</code> 的一般用法如下：</p><figure class="highlight js"><figcaption><span>Promise用法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> res.<span class="title function_">json</span>();</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err)).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err));</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>async/await用法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getRequestData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">      <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">      <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">await</span> res.<span class="title function_">json</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="init-参数"><a href="#init-参数" class="headerlink" title="init 参数"></a>init 参数</h3><p><code>fetch()</code> 方法第二个参数为可选的 <code>init</code> 参数，作为请求的额外参数。</p><p>init 选项类似一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Request">Request 对象</a>，你可以直接使用 Request 构造器创建一个 request。它包括以下选项：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="comment">// 请求使用的方法，如 GET, POST, PUT, DELETE 等等.</span></span><br><span class="line">    <span class="attr">headers</span>: &#123; <span class="comment">// 请求的头信息，可以是一个 Headers 对象或包含 ByteString 值的对象字面量</span></span><br><span class="line">      <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>, <span class="comment">// &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;,</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">body</span>: <span class="literal">undefined</span>, <span class="comment">// 请求的 body 信息：可能是一个 Blob、BufferSource、FormData、URLSearchParams、USVString 或者 ReadableStream 对象。GET 和 HEAD 请求没有 body。</span></span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;cors&#x27;</span>, <span class="comment">// 请求的模式，如 no-cors（请求方法只限于 GET、POST 和 HEAD，并且只能使用有限的几个简单标头，不能添加跨域的复杂标头，相当于提交表单所能发出的请求）, cors（默认值，允许跨域请求）, same-origin（只允许同源请求）</span></span><br><span class="line">    <span class="attr">cache</span>: <span class="string">&#x27;no-cache&#x27;</span>, <span class="comment">// 请求对 cache 的处理模式，如 default（默认值，先在缓存里面寻找匹配的请求）, no-store（直接请求远程服务器，并且不更新缓存）, reload（直接请求远程服务器，并且更新缓存）, no-cache（将服务器资源跟本地缓存进行比较，有新的版本才使用服务器资源，否则使用缓存）, force-cache（缓存优先，只有不存在缓存的情况下，才请求远程服务器）, only-if-cached（只检查缓存，如果缓存里面不存在，将返回504错误）</span></span><br><span class="line">    <span class="attr">credentials</span>: <span class="string">&#x27;same-origin&#x27;</span>, <span class="comment">// 请求跨域是否带认证信息（cookes 和 HTTP authentication 字段），如 include（一律包括认证信息）, same-origin（默认值，同源带认证信息）, omit（删掉所有认证信息）</span></span><br><span class="line">    <span class="attr">redirect</span>: <span class="string">&#x27;follow&#x27;</span>, <span class="comment">// 请求对重定向的处理模式，如 manual（手动处理）, follow（默认值，fetch跟随浏览器对HTTP请求的处理自动重定向）, error（如果产生重定向将自动终止并且抛出一个错误）</span></span><br><span class="line">    <span class="attr">referrer</span>: <span class="string">&#x27;about:client&#x27;</span>, <span class="comment">// 请求的referrer地址，可以是一个 同源URL 或者 about:client 或留空</span></span><br><span class="line">    <span class="attr">referrerPolicy</span>: <span class="string">&#x27;no-referrer&#x27;</span>, <span class="comment">// 指定了 HTTP 的 referer 策略，如 no-referrer（不发送Referer标头）, no-referrer-when-downgrade（默认值，总是发送Referer标头，除非从 HTTPS 页面请求 HTTP 资源时不发送）, origin（Referer标头只包含域名，不包含完整的路径）, origin-when-cross-origin（同源请求Referer标头包含完整的路径，跨域请求只包含域名）, same-origin（跨域请求不发送Referer，同源请求发送）, strict-origin（Referer标头只包含域名，HTTPS 页面请求 HTTP 资源时不发送Referer标头）, strict-origin-when-cross-origin（同源请求时Referer标头包含完整路径，跨域请求时只包含域名，HTTPS 页面请求 HTTP 资源时不发送该标头）, unsafe-url（不管什么情况，总是发送Referer标头）</span></span><br><span class="line">    <span class="attr">integrity</span>: <span class="string">&#x27;sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE=&#x27;</span>, <span class="comment">// 请求的子资源完整性（SRI）值</span></span><br><span class="line">    <span class="attr">keepalive</span>: <span class="literal">null</span>, <span class="comment">// 用于允许请求保活，一个典型场景是用户离开页面的行为统计。带 keepalive 的 Fetch 请求是为了替代 Navigator.sendBeacon()</span></span><br><span class="line">    <span class="attr">signal</span>: <span class="literal">null</span>, <span class="comment">// 一个 AbortSignal 实例，用来通过 AbortController 中止 fetch 请求</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Headers-对象"><a href="#Headers-对象" class="headerlink" title="Headers 对象"></a>Headers 对象</h3><p>init 选项的 headers 可以是一个 Http headers 健值对，也可以为一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Headers">Headers 对象</a>。<br>Fetch API 的 Headers 接口允许对 HTTP 请求和响应头执行各种操作，出于安全考虑，<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Forbidden_header_name">某些 headers 字段</a> 只能由用户代理（浏览器）控制，可以操作的 header 必须是 <a href="https://fetch.spec.whatwg.org/#concept-header-name">有效的 HTTP headers 字段</a>。<br>一个 Headers 对象也有一个关联的 guard ，它具有不可变的值，<code>request</code>，<code>request-no-cors</code>，<code>response</code> 或 <code>none</code> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myHeaders = <span class="keyword">new</span> <span class="title class_">Headers</span>(&#123;</span><br><span class="line">  <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;Cache-Control&#x27;</span>: <span class="string">&#x27;no-cache&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;X-Requested-With&#x27;</span>: <span class="string">&#x27;XMLHttpRequest&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line">myHeaders.<span class="title function_">append</span>(<span class="string">&#x27;X-Customer-Header&#x27;</span>, <span class="string">&#x27;abcd&#x27;</span>); <span class="comment">// 给现有的 header 添加一个值, 或者添加一个未存在的 header 并赋值</span></span><br><span class="line"><span class="keyword">let</span> customerHeader = myHeaders.<span class="title function_">get</span>(<span class="string">&#x27;X-Customer-Header&#x27;</span>); <span class="comment">// 以 ByteString 的形式从 Headers 对象中返回指定 header 的全部值</span></span><br><span class="line">myHeaders.<span class="title function_">set</span>(<span class="string">&#x27;X-Customer-Header&#x27;</span>, <span class="string">&#x27;efgh&#x27;</span>); <span class="comment">// 替换现有的 header 的值, 或者添加一个未存在的 header 并赋值</span></span><br><span class="line"><span class="keyword">let</span> isCustomerHeaderExisted = myHeaders.<span class="title function_">has</span>(<span class="string">&#x27;X-Customer-Header&#x27;</span>); <span class="comment">// 以 布尔值 的形式从 Headers 对象中返回是否存在指定的 header</span></span><br><span class="line">myHeaders.<span class="title function_">delete</span>(<span class="string">&#x27;X-Customer-Header&#x27;</span>); <span class="comment">// 从 Headers 对象中删除指定 header</span></span><br><span class="line">myHeaders.<span class="title function_">entries</span>(); <span class="comment">// 以 迭代器 的形式返回 Headers 对象中所有的键值对</span></span><br><span class="line">myHeaders.<span class="title function_">keys</span>(); <span class="comment">// 以 迭代器 的形式返回 Headers 对象中所有存在的 header 名</span></span><br><span class="line">myHeaders.<span class="title function_">values</span>(); <span class="comment">// 以 迭代器 的形式返回 Headers 对象中所有存在的 header 值</span></span><br></pre></td></tr></table></figure><h3 id="Response-对象"><a href="#Response-对象" class="headerlink" title="Response 对象"></a>Response 对象</h3><p>Fetch API 的 Response 接口呈现了对一次请求的响应数据。<code>fetch()</code> 方法在网络返回后会 resolve 一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response">Response 对象</a>。</p><p>Response 对象 有以下的属性和方法(Response 实现了 Body 接口，所以也可访问 Body 的属性和方法)</p><table><thead><tr><th>属性/方法</th><th>是否只读</th><th>含义</th></tr></thead><tbody><tr><td>Response.headers</td><td>只读</td><td>包含此 Response 所关联的 Headers 对象。</td></tr><tr><td>Response.ok</td><td>只读</td><td>包含了一个布尔值，标示该 Response 成功（HTTP 状态码的范围在 200-299）。</td></tr><tr><td>Response.redirected</td><td>只读</td><td>表示该 Response 是否来自一个重定向，如果是的话，它的 URL 列表将会有多个条目。</td></tr><tr><td>Response.status</td><td>只读</td><td>包含 Response 的状态码 （例如 200 表示成功）。</td></tr><tr><td>Response.statusText</td><td>只读</td><td>包含了与该 Response 状态码一致的状态信息（例如，OK对应 200）。</td></tr><tr><td>Response.type</td><td>只读</td><td>包含 Response 的类型（例如，basic、cors）。</td></tr><tr><td>Response.url</td><td>只读</td><td>包含 Response 的URL。</td></tr><tr><td>Response.useFinalURL</td><td></td><td>包含了一个布尔值，来标示这是否是该 Response 的最终 URL。</td></tr><tr><td>Body.body</td><td>只读</td><td>一个简单的 getter，用于暴露一个 ReadableStream 类型的 body 内容。</td></tr><tr><td>Body.bodyUsed</td><td>只读</td><td>包含了一个布尔值来标示该 Response 是否读取过 Body。</td></tr><tr><td>Response.clone()</td><td></td><td>创建一个 Response 对象的克隆。</td></tr><tr><td>Response.error()</td><td></td><td>返回一个绑定了网络错误的新的 Response 对象。</td></tr><tr><td>Response.edirect()</td><td></td><td>用另一个 URL 创建一个新的 Response。</td></tr><tr><td>Body.arrayBuffer()</td><td></td><td>读取 Response 对象并且将它设置为已读，并返回一个被解析为 ArrayBuffer 格式的 Promise 对象。</td></tr><tr><td>Body.blob()</td><td></td><td>读取 Response 对象并且将它设置为已读，并返回一个被解析为 Blob 格式的 Promise 对象。</td></tr><tr><td>Body.formData()</td><td></td><td>读取 Response 对象并且将它设置为已读，并返回一个被解析为 FormData 格式的 Promise 对象。</td></tr><tr><td>Body.text()</td><td></td><td>读取 Response 对象并且将它设置为已读，并返回一个被解析为 USVString 格式的 Promise 对象。</td></tr><tr><td>Body.json()</td><td></td><td>读取 Response 对象并且将它设置为已读，并返回一个被解析为 JSON 格式的 Promise 对象。</td></tr></tbody></table><h2 id="AbortController-阻止请求"><a href="#AbortController-阻止请求" class="headerlink" title="AbortController 阻止请求"></a>AbortController 阻止请求</h2><p>fetch()请求发送以后，如果中途想要取消，需要使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/AbortController">AbortController 对象</a>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line"><span class="keyword">let</span> signal = controller.<span class="property">signal</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> downloadBtn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.download&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> abortBtn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.abort&#x27;</span>);</span><br><span class="line"></span><br><span class="line">downloadBtn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, fetchVideo);</span><br><span class="line"></span><br><span class="line">abortBtn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  controller.<span class="title function_">abort</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Download aborted&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fetchVideo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="title function_">fetch</span>(url, &#123;signal&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="与-XMLHttpRequest-差异"><a href="#与-XMLHttpRequest-差异" class="headerlink" title="与 XMLHttpRequest 差异"></a>与 XMLHttpRequest 差异</h2><ol><li><code>fetch()</code> 使用 Promise，而 XMLHttpRequest 使用回调函数</li><li><code>fetch()</code> 采用模块化设计，API 分散在多个对象上（Response 对象、Request 对象、Headers 对象）</li><li><code>fetch()</code> 通过数据流（Stream 对象）处理数据，可以分块读取，有利于提高网站性能表现，减少内存占用，对于请求大文件或者网速慢的场景相当有用。XMLHttpRequest 对象不支持数据流，所有的数据必须放在缓存里，不支持分块读取，必须等待全部拿到后，再一次性访问</li></ol><h2 id="与-jQuery-ajax-差异"><a href="#与-jQuery-ajax-差异" class="headerlink" title="与 jQuery.ajax 差异"></a>与 jQuery.ajax 差异</h2><ol><li>当接收到一个代表错误的 HTTP 状态码时，从 <code>fetch()</code> 返回的 Promise 不会被标记为 reject，即使响应的 HTTP 状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （如果响应的 HTTP 状态码不在 200 - 299 的范围内，则设置 resolve 返回值的 ok 属性为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject。</li><li><code>fetch()</code> 不会发送跨域 cookies，除非你使用了 credentials 的初始化选项。<ol><li>自2018 年 8 月以后，默认的 credentials 政策变更为 same-origin。Firefox 也在 61.0b13 版本中进行了修改。</li><li>如果你打算支持浏览器的旧版本，请确保在所有可能受 Cookie/用户 登录状态影响的api请求上包含<code>credentials: &#39;same-origin&#39;</code> 初始化选项。</li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> Web API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字体 font</title>
      <link href="/blog/2022/03/03/CSS-%E5%AD%97%E4%BD%93/"/>
      <url>/blog/2022/03/03/CSS-%E5%AD%97%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h2 id="字体格式类型"><a href="#字体格式类型" class="headerlink" title="字体格式类型"></a>字体格式类型</h2><p>字体格式类型有 TrueType、OpenType、EOT、WOFF/WOFF2 以及 SVG 等。</p><span id="more"></span><h3 id="PostScript"><a href="#PostScript" class="headerlink" title="PostScript"></a>PostScript</h3><p>PostScript 是由 Adobe 在1985年开发的页面描述语言，也被称为 Type1，文件扩展名为 <strong>.eps</strong>。PostScript 避免了版面制作对使用设备的依赖性，使得显示和打印可以跨平台。</p><h3 id="TrueType"><a href="#TrueType" class="headerlink" title="TrueType"></a>TrueType</h3><p>TrueType 是由 Apple 和 Microsoft 在1991年左右共同开发的一种电脑轮廓字体，文件扩展名为 <strong>.ttf</strong> 。Windows 和 Mac 系统最常用的字体格式就是 TrueType，其最大的特点就是它是由一种数学模式来进行定义的基于轮廓技术的字体，这使得它们比基于矢量的字体更容易处理，保证了屏幕与打印输出的一致性。同时，这类字体和矢量字体一样可以随意缩放、旋转而不必担心会出现锯齿。</p><h3 id="OpenType"><a href="#OpenType" class="headerlink" title="OpenType"></a>OpenType</h3><p>OpenType 是 Microsoft 和 Adobe 在1995年左右共同开发的字体，文件扩展名为 <strong>.otf</strong> 。OpenType 也被称为 Type2 字体，它也是一种轮廓字体，而且可以把 PostScript 字体嵌入到 TrueType 的软件中。并且还支持多个平台，支持很大的字符集，支持在字符集中加入数字签名。Microsoft 从 Windows 2000 系统开始兼容 OpenType 字库，Apple 公司也从 MAC OS X 开始完全兼容 OpenType 字库。</p><h3 id="E0T-Embedded-Open-Type"><a href="#E0T-Embedded-Open-Type" class="headerlink" title="E0T - Embedded Open Type"></a>E0T - Embedded Open Type</h3><p>EOT 是一种嵌入式字体，是 Microsoft 在1997年开发的技术，文件扩展名为 <strong>.eot</strong> 。允许 OpenType 字体用 <code>@font-face</code> 嵌入到网页并下载至浏览器渲染，存储在临时安装文件夹下。</p><h3 id="WOFF-Web-Open-Font-Format"><a href="#WOFF-Web-Open-Font-Format" class="headerlink" title="WOFF - Web Open Font Format"></a>WOFF - Web Open Font Format</h3><p>WOFF 是一种专门为了 Web 而设计的字体格式标准，由 Mozilla、Opera、Microsoft 在2009年提案给， 由 W3C 的 Web字体工作组 负责标准化，文件扩展名为 <strong>.woff</strong> 。它实际上是对于 TrueType / OpenType 等字体格式的封装，每个字体文件中含有字体以及针对字体的元数据（Metadata），同时字体文件被压缩，以便于网络传输，同时不加密，不受DRM（数字著作权）限制。 Mozilla Firefox 3.6 开始支持 WOFF，Microsoft 从 IE9 开始支持，Safari 自 5.1 起支持WOFF，Google Chrome 自 6.0 起支持WOFF，Presto 自 2.7.81 起支持 WOFF。<br>2014年，Web字体工作组 发布了 WOFF2 草案，文件扩展名为 <strong>.woff2</strong> 。2018年，WOFF2标准成为 W3C 推荐标准。</p><h3 id="SVG-Scalable-Vector-Graphics"><a href="#SVG-Scalable-Vector-Graphics" class="headerlink" title="SVG - Scalable Vector Graphics"></a>SVG - Scalable Vector Graphics</h3><p>SVG 是由 W3C 制定的开放标准的图形格式，文件扩展名为 <strong>.svg</strong> 。SVG 字体就是使用 SVG 技术来呈现字体。</p><h2 id="通过-font-face-指定自定义字体"><a href="#通过-font-face-指定自定义字体" class="headerlink" title="通过 @font-face 指定自定义字体"></a>通过 <code>@font-face</code> 指定自定义字体</h2><p><code>@font-face</code> CSS at规则指定了一种用于显示文本的自定义字体；字体可以从远程服务器或用户自己计算机上本地安装的字体加载。</p><p>一个最常见的用法是，通过 <code>font-family</code> 指定自定义字体族名；通过 <code>src</code> 指定字体文件来源，通常可以通过 URL 加载远程字体文件，或者通过 dataURL 将需要的字体 data 信息包括进来，src 每个字体文件可以包括一个 <code>format()</code> 方法标志字体格式类型，format 的入参只能是 “woff”, “woff2”, “truetype”, “opentype”, “embedded-opentype” 或者 “svg”，和上文提到的字体格式类型是一一对应的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&quot;Open Sans&quot;</span>;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&quot;/fonts/OpenSans-Regular-webfont.woff2&quot;</span>) <span class="built_in">format</span>(<span class="string">&quot;woff2&quot;</span>),</span><br><span class="line">       <span class="built_in">url</span>(<span class="string">&quot;/fonts/OpenSans-Regular-webfont.woff&quot;</span>) <span class="built_in">format</span>(<span class="string">&quot;woff&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@font-face</code> 也有许多其他的参数，可以通过 <code>font-style</code> 设置字体样式类型，通过 <code>font-weight</code> 设置字体粗细等。</p><h2 id="通过-font-family-设置字体族"><a href="#通过-font-family-设置字体族" class="headerlink" title="通过 font-family 设置字体族"></a>通过 <code>font-family</code> 设置字体族</h2><h3 id="font-family-取值"><a href="#font-family-取值" class="headerlink" title="font-family 取值"></a><code>font-family</code> 取值</h3><div><dl><dt id="family-name"><code>&lt;family-name&gt;</code></dt><dd>一个字体族的名字。例如 “Times” 和 “Helvetica” 都是字体族名。字体族名可以包含空格，但包含空格时应该用引号。</dd><dt id="generic-name"><code>&lt;generic-name&gt;</code></dt><dd><p>通用字体族名是一种备选机制，用于在指定的字体不可用时给出较好的字体。通用字体族名都是关键字，所以不可以加引号。 在列表的末尾应该至少有一个通用字体族名。 以下是该属性可能的取值以及他们的定义。</p><dl><dt id="serif"><code>serif</code></dt><dd style="font-family: serif;">带衬线字体，笔画结尾有特殊的装饰线或衬线。<br>例如： <span style="font-family: lucida bright,serif;">Lucida Bright</span>, <span style="font-family: lucida fax,serif;">Lucida Fax</span>, <span style="font-family: palatino,serif;">Palatino</span>, <span style="font-family: palatino linotype,serif;">“Palatino Linotype”</span>, <span style="font-family: palladio,serif;">Palladio</span>, <span style="font-family: " urw="">“URW Palladio”</span>, <span style="font-family: serif;">serif</span>.</dd><dt id="sans-serif"><code>sans-serif</code></dt><dd style="font-family: sans-serif;">无衬线字体，即笔画结尾是平滑的字体。<br>例如， <span style="font-family: open sans,sans-serif;">“Open Sans”</span>, <span style="font-family: fira sans,sans-serif;">“Fira Sans”</span>, <span style="font-family: lucida sans,sans-serif;">“Lucida Sans”</span>, <span style="font-family: lucida sans unicode sans-serif;">“Lucida Sans Unicode”</span>, <span style="font-family: trebuchet ms,sans-serif;">“Trebuchet MS”</span>, <span style="font-family: liberation sans,sans-serif;">“Liberation Sans”</span>, <span style="font-family: nimbus sans l,sans-serif;">“Nimbus Sans L”</span>, <span style="font-family: sans-serif;">sans-serif</span>.</dd><dt id="monospace"><code>monospace</code></dt><dd style="font-family: monospace;">等宽字体，即字体中每个字宽度相同。<br>例如， <span style="font-family: fira mono,monospace;">“Fira Mono”</span>, <span style="font-family: dejavu sans mono,monospace;">“DejaVu Sans Mono”</span>, <span style="font-family: menlo,monospace;">Menlo</span>, <span style="font-family: consolas,monospace;">Consolas</span>, <span style="font-family: liberation mono,monospace;">“Liberation Mono”</span>, <span style="font-family: monaco,monospace;">Monaco</span>, <span style="font-family: lucida console,monospace;">“Lucida Console”</span>, <span style="font-family: monospace;">monospace</span>.</dd><dt id="cursive"><code>cursive</code></dt><dd style="font-family: cursive;">草书字体。这种字体有的有连笔，有的还有特殊的斜体效果。因为一般这种字体都有一点连笔效果，所以会给人一种手写的感觉。<br>例如，<span style="font-family: brush script mt,cursive;">“Brush Script MT</span>“, <span style="font-family: brush script std,cursive;">“Brush Script Std</span>“, <span>“Lucida Calligraphy”</span>, <span>“Lucida Handwriting”</span>, <span style="font-family: apple chancery,cursive;">“Apple Chancery”</span>, <span style="font-family: cursive;">cursive</span>.</dd><dt id="fantasy"><code>fantasy</code></dt><dd style="font-family: fantasy;">Fantasy 字体主要是那些具有特殊艺术效果的字体。<br>例如，<span style="font-family: papyrus,fantasy;">Papyrus</span>, <span style="font-family: herculanum,fantasy;">Herculanum</span>, <span style="font-family: party let,fantasy;">Party LET</span>, <span style="font-family: curlz mt,fantasy;">Curlz MT</span>, <span style="font-family: harrington,fantasy;">Harrington</span>, <span style="font-family: fantasy;">fantasy</span>.</dd><dt id="system-ui"><code>system-ui</code></dt><dd>从浏览器所处平台处获取的默认用户界面字体。由于世界各地的排版习惯之间有很大的差异，这个通用选项为无法清晰映射到其他类型的字体提供支持。</dd><dt id="math"><code>math</code></dt><dd>针对显示数学相关字符的特殊样式问题而设计的字体：支持上标和下标、跨行括号、嵌套表达式和具有不同含义的双字母字形。</dd><dt id="emoji"><code>emoji</code></dt><dd>专门用于呈现 Emoji 表情符号的字体。</dd><dt id="fangsong"><code>fangsong</code></dt><dd>一种汉字字体，介于宋体和楷体之间。这种字体常用于某些政府文件。</dd></dl></dd></dl></div><h2 id="通过-font-style-设置字体样式"><a href="#通过-font-style-设置字体样式" class="headerlink" title="通过 font-style 设置字体样式"></a>通过 <code>font-style</code> 设置字体样式</h2><p>可以设置为 <code>italic</code>（斜体） <code>oblique</code>（倾斜体）默认是 <code>normal</code> 。</p><h2 id="通过-font-weight-设置字体粗细"><a href="#通过-font-weight-设置字体粗细" class="headerlink" title="通过 font-weight 设置字体粗细"></a>通过 <code>font-weight</code> 设置字体粗细</h2><p>可以设置为一个介于 1 和 1000 (包含) 之间的数字类型值（需为 100 的整倍数），更大的数值代表字体更粗（前提是字体支持）。默认是 <code>normal</code> 相当于 400。可以设置为 <code>bold</code> 相当于 700，也可以设置成 <code>lighter</code> 或 <code>bolder</code> 表示比从父元素继承来的值更细或更粗。</p><h2 id="通过-font-size-设置字体大小"><a href="#通过-font-size-设置字体大小" class="headerlink" title="通过 font-size 设置字体大小"></a>通过 <code>font-size</code> 设置字体大小</h2><p>可以使用 绝对大小值 <code>xx-small, x-small, small, medium, large, x-large, xx-large</code> ，可以使用相对值 <code>larger, smaller</code> 表示比父元素大或者小，可以使用 em/ex/百分比 表示相对父元素的大小，不过最常见的是使用像素 px。</p><h2 id="通过-font-variant-设置字体的变体"><a href="#通过-font-variant-设置字体的变体" class="headerlink" title="通过 font-variant 设置字体的变体"></a>通过 <code>font-variant</code> 设置字体的变体</h2><p><code>font-variant</code> 属性是 <code>font-variant-caps</code>, <code>font-variant-numeric</code>, <code>font-variant-alternates</code>, <code>font-variant-ligatures</code>, <code>font-variant-east-asian</code> 等属性的简写。</p><p>这些属性都不常用到。一个比较有意思的属性是 <code>font-variant-east-asian</code> 设置 <code>font-variant-east-asian: traditional;</code> 可以将简体文本显示为繁体字，但需要字体族支持。</p><h2 id="通过-font-对多个字体属性进行简写"><a href="#通过-font-对多个字体属性进行简写" class="headerlink" title="通过 font 对多个字体属性进行简写"></a>通过 <code>font</code> 对多个字体属性进行简写</h2><p><code>font</code> 属性可以用来作为 <code>font-style</code>, <code>font-variant</code>, <code>font-weight</code>, <code>font-size</code>, <code>line-height</code> 和 <code>font-family</code> 属性的简写，或将元素的字体设置为系统字体。如果是作为简写使用，必须包括 <code>font-size</code> 和 <code>font-family</code> 属性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> font </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web Components 小抄</title>
      <link href="/blog/2022/02/15/FE-Web-Components/"/>
      <url>/blog/2022/02/15/FE-Web-Components/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/WICG/webcomponents">Web Components</a> 是 W3C 在2014年提出的网页组件式开发的技术规范，旨在给 Web 开发者提供浏览器原生级别的组件能力。通过 Web Components 规范开发者可以自定义可重用的 Web 组件并引入到任意项目中而不必借助 Web 组件化框架，并且不必考虑组件内样式和变量污染的问题。</p><span id="more"></span><h2 id="Web-Components-相关的-Web-标准"><a href="#Web-Components-相关的-Web-标准" class="headerlink" title="Web Components 相关的 Web 标准"></a>Web Components 相关的 Web 标准</h2><p>Web Components 主要基于以下几种 Web 标准:  </p><ol><li><p>自定义元素 （Custom Elements）</p><p> <a href="https://html.spec.whatwg.org/multipage/scripting.html#custom-elements">Custom Elements 规范</a> 为设计和使用新类型的 DOM 元素奠定了基础。它允许定义自定义元素及其行为，然后可以在 HTML 中按照需要使用它们。</p></li><li><p>影子 DOM （Shadow DOM）</p><p> <a href="https://dom.spec.whatwg.org/">Shadow DOM 规范</a> 定义了如何在 Web 组件中使用封装的样式和标记。封装的 Web 组件内的元素可以无法被外部 Javascript 获取，CSS 样式也与Web 组件外部的样式隔离。</p></li><li><p>HTML 内容模板 （HTML Template）</p><p> <a href="https://html.spec.whatwg.org/multipage/scripting.html#the-template-element">HTML Template 规范</a> 定义了如何声明标记的 HTML 片段，这些 HTML 片段在页面加载时不会被使用，但可以在运行时实例化。</p></li></ol><h2 id="浏览器支持情况"><a href="#浏览器支持情况" class="headerlink" title="浏览器支持情况"></a>浏览器支持情况</h2><table><thead><tr><th></th><th>Chrome</th><th>Firefox</th><th>Safari</th><th>Edge</th><th>Opera</th></tr></thead><tbody><tr><td>Custom Elements</td><td>&gt;67</td><td>&gt;63</td><td>&gt;10.1</td><td>&gt;79</td><td>&gt;54</td></tr><tr><td>Shadow DOM</td><td>&gt;53</td><td>&gt;63</td><td>&gt;10</td><td>&gt;79</td><td>&gt;40</td></tr><tr><td>HTML Template</td><td>&gt;90</td><td>&gt;13</td><td>&gt;8</td><td>&gt;90</td><td>&gt;15</td></tr><tr><td>Class definitions</td><td>&gt;49</td><td>&gt;45</td><td>&gt;9</td><td>&gt;13</td><td>&gt;36</td></tr></tbody></table><p>目前主流浏览器的最新版本都支持这些特性，对于老版本可以使用 WebcomponentsJS polyfill <code>@webcomponents/webcomponentsjs</code>，但是它没有真正的提供局部CSS。这意味着在不同 Web Components 中如果有同样的 class 和 id ，在同一个 document 中，它们将会发生冲突。此外 Shadow DOM 的 css 选择器 <code>:host()</code> <code>:sloted()</code> 可能无法正常工作。</p><h2 id="如何创建一个-Web-Component"><a href="#如何创建一个-Web-Component" class="headerlink" title="如何创建一个 Web Component"></a>如何创建一个 Web Component</h2><ol><li><p>创建一个继承自 HTMLElement 的类来指定 Web 组件的功能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserCard</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>();</span><br><span class="line">        <span class="keyword">const</span> image = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">        image.<span class="property">src</span> = <span class="string">&#x27;https://mangon.cn/blog/images/favicon.ico&#x27;</span>;</span><br><span class="line">        image.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;image&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> container = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">        container.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;container&#x27;</span>);</span><br><span class="line">        <span class="keyword">const</span> name = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">        name.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line">        name.<span class="property">innerText</span> = <span class="string">&#x27;Name&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> email = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">        email.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;email&#x27;</span>);</span><br><span class="line">        email.<span class="property">innerText</span> = <span class="string">&#x27;Email&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> like = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">        like.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;like&#x27;</span>);</span><br><span class="line">        like.<span class="property">innerText</span> = <span class="string">&#x27;Like&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        container.<span class="title function_">append</span>(name, email, like);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">append</span>(image, container);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>customElements.define()</code> 方法注册自定义元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">customElements</span>.<span class="title function_">define</span>(<span class="string">&#x27;user-card&#x27;</span>, <span class="title class_">UserCard</span>);</span><br></pre></td></tr></table></figure><p><code>customElements.define()</code> 的第一个参数为元素名，根据规范，自定义元素的名称必须包含连词线，用于与原生 HTML 元素进行区别。第二个元素为自定义的继承自 HTMLElement 的类，第三个参数为可选参数对象，目前只有一个 <code>extends</code> 参数指定继承于已创建的元素（比如原生 HTML 元素）</p></li><li><p>使用 <code>&lt;template&gt;</code>  可以更方便的定义一个HTML模板，而不是使用复杂的 DOM API。使用 <code>&lt;slot&gt;</code> 可以在模板中添加一个可选的占位的插槽，以便与其它的元素组合</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;user-card-template&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://mangon.cn/blog/images/avatar.jpeg&quot;</span> <span class="attr">class</span>=<span class="string">&quot;image&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;name&quot;</span>&gt;</span>Name<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;email&quot;</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;like&quot;</span>&gt;</span>Like<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以在 UserCard 类中更方便的引用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserCard</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>();</span><br><span class="line">        <span class="keyword">const</span> template = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;user-card-template&#x27;</span>);</span><br><span class="line">        <span class="keyword">const</span> content = template.<span class="property">content</span>.<span class="title function_">cloneNode</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以为自定义元素添加参数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;name&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">const</span> name = <span class="variable language_">this</span>.<span class="title function_">getAttribute</span>(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line">            content.<span class="title function_">querySelector</span>(<span class="string">&#x27;.name&#x27;</span>).<span class="property">innerText</span> = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;email&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">const</span> email = <span class="variable language_">this</span>.<span class="title function_">getAttribute</span>(<span class="string">&#x27;email&#x27;</span>);</span><br><span class="line">            content.<span class="title function_">querySelector</span>(<span class="string">&#x27;.email&#x27;</span>).<span class="property">innerText</span> = email;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;img&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">const</span> img = <span class="variable language_">this</span>.<span class="title function_">getAttribute</span>(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">            content.<span class="title function_">querySelector</span>(<span class="string">&#x27;.image&#x27;</span>).<span class="title function_">setAttribute</span>(<span class="string">&#x27;src&#x27;</span>, img);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 也可以为自定义元素中的元素绑定事件</span></span><br><span class="line">        content.<span class="title function_">querySelector</span>(<span class="string">&#x27;.like&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">window</span>.<span class="title function_">alert</span>(<span class="string">&#x27;Thanks!&#x27;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">appendChild</span>(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>Element.attachShadow()</code> 方法将一个 shadow DOM 附加到自定义元素上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserCard</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>();</span><br><span class="line">        <span class="keyword">const</span> template = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;user-card-template&#x27;</span>);</span><br><span class="line">        <span class="keyword">const</span> content = template.<span class="property">content</span>.<span class="title function_">cloneNode</span>(<span class="literal">true</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">attachShadow</span>(&#123;</span><br><span class="line">            <span class="attr">mode</span>: <span class="string">&#x27;closed&#x27;</span></span><br><span class="line">        &#125;).<span class="title function_">appendChild</span>(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>attachShadow()</code> 方法的 mode 参数可以是 open 或者 closed。这定义了 Shadow RooT 的内部实现是否可被 JavaScript 访问及修改 — 也就是说，该实现是否公开。</p></li><li><p>可以为 HTML Template 添加 scoped css 样式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;user-card-template&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-pseudo">:host</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">450px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">180px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">box-shadow</span>: <span class="number">1px</span> <span class="number">1px</span> <span class="number">5px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.1</span>);</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.image</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> auto;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">120px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">120px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">vertical-align</span>: middle;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">160px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.container</span> &gt; <span class="selector-class">.name</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-weight</span>: <span class="number">600</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">line-height</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-bottom</span>: <span class="number">5px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.container</span> &gt; <span class="selector-class">.email</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">opacity</span>: <span class="number">0.75</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">line-height</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-bottom</span>: <span class="number">15px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.container</span> &gt; <span class="selector-class">.like</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding</span>: <span class="number">8px</span> <span class="number">24px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border-radius</span>: <span class="number">8px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background</span>: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#666</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">text-transform</span>: uppercase;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.container</span> &gt; <span class="selector-class">.like</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">box-shadow</span>: <span class="number">5px</span> <span class="number">2px</span> <span class="number">5px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.1</span>);</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>:host</code> 表示选择 Shadow DOM 的 Shadow Host ，内容是 Shadow Host 使用的 CSS</p></li><li><p>在页面任何位置使用自定义元素，就像使用常规 HTML 元素那样。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">user-card</span> <span class="attr">img</span>=<span class="string">&quot;https://mangon.cn/blog/images/avatar.jpeg&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Mangon&quot;</span> <span class="attr">email</span>=<span class="string">&quot;gaoxiang.like@163.com&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">&quot;description&quot;</span>&gt;</span>Front-End Software Engineer<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user-card</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="Custom-Elements-的生命周期"><a href="#Custom-Elements-的生命周期" class="headerlink" title="Custom Elements 的生命周期"></a>Custom Elements 的生命周期</h2><ul><li><p><code>connetedCallback</code></p><p>当自定义元素添加到 DOM 中时触发</p></li><li><p><code>disConnectedCallback</code></p><p>当自定义元素从 DOM 中移除时触发</p></li><li><p><code>attributeChangedCallback</code></p><p>当组件的属性改变时触发</p></li><li><p><code>adoptedCallback</code></p><p>当自定义元素被移动到新的文档中时触发</p></li></ul><h2 id="Web-Components-相关的库"><a href="#Web-Components-相关的库" class="headerlink" title="Web Components 相关的库"></a>Web Components 相关的库</h2><ol><li><a href="https://github.com/Polymer/polymer">Ploymer</a> 是一个由 Google 开发的 Web Component 库，目前已不再提供更新支持。</li></ol><ol start="2"><li><a href="https://github.com/lit/lit">Lit</a> 是一个由 Google 开发并支持的 Web Components 组件工具库，作为 Ploymer 的替代品。它封装了常用的自定义组件逻辑，支持响应式的属性模板更新绑定。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">LitElement</span>, css, html&#125; <span class="keyword">from</span> <span class="string">&#x27;lit&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;customElement, property, query&#125; <span class="keyword">from</span> <span class="string">&#x27;lit/decorators.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@<span class="title function_">customElement</span>(<span class="string">&#x27;simple-greeting&#x27;</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">SimpleGreeting</span> <span class="keyword">extends</span> <span class="title class_ inherited__">LitElement</span> &#123;</span><br><span class="line">  <span class="comment">// Define scoped styles right with your component, in plain CSS</span></span><br><span class="line">  <span class="keyword">static</span> styles = css`<span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-pseudo">:host</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>: blue;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  `</span>;</span><br><span class="line"></span><br><span class="line">  @<span class="title function_">query</span>(<span class="string">&#x27;#name&#x27;</span>)</span><br><span class="line">  input!: <span class="title class_">HTMLInputElement</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Declare reactive properties</span></span><br><span class="line">  @<span class="title function_">property</span>()</span><br><span class="line">  name?: string = <span class="string">&#x27;World&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Render the UI as a function of component state</span></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> html`<span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello, </span><span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span><span class="language-xml">!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">aria-label</span>=<span class="string">&quot;your name&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=</span></span><span class="subst">$&#123;<span class="variable language_">this</span>.submit&#125;</span><span class="language-xml"><span class="tag">&gt;</span>submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    `</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">submit</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="variable language_">this</span>.<span class="property">input</span>.<span class="property">value</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">input</span>.<span class="property">value</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lit 使用了 Decorator 语法，所以必须使用 Typescript 或者 Babel 的编译器来构建代码。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Web API </tag>
            
            <tag> component </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Decorator 小抄</title>
      <link href="/blog/2022/02/09/JS-Decorator%E5%B0%8F%E6%8A%84/"/>
      <url>/blog/2022/02/09/JS-Decorator%E5%B0%8F%E6%8A%84/</url>
      
        <content type="html"><![CDATA[<p>现在的前端项目中，装饰器作为装饰器模式的语法糖得到了越来越广泛的应用。本文会先介绍装饰器的具体用法，然后会将 Javascript 中的装饰器和其他语言常见的装饰器用法进行比较，展示 Javascript 中装饰器的不同之处。</p><span id="more"></span><h2 id="什么是-Decorator"><a href="#什么是-Decorator" class="headerlink" title="什么是 Decorator"></a>什么是 Decorator</h2><p>Decorator 装饰器是 ECMAScript 的一个语言功能提案，目前（文章书写时间 2022-02-09 13:54:26）还处于 <a href="https://github.com/tc39/proposal-decorators">stage-2</a> 阶段。但是借助 TypeScript 或者 Babel，已经有大量的优秀开源项目深度使用上它了。比如：VS Code, Angular, Nest.js, Mobx 等等。Decorator 装饰器本质上是一种特殊的函数，在定义类、类元素时通过 <code>@</code> 来引用该函数，可以对被装饰的目标进行注入添加新的功能而无需从根本上改变其外部行为。</p><p>一个 Decorator 的例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@defineElement</span>(<span class="string">&quot;my-class&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123;</span><br><span class="line">  <span class="meta">@reactive</span> accessor clicked = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Decorator-的作用"><a href="#Decorator-的作用" class="headerlink" title="Decorator 的作用"></a>Decorator 的作用</h2><h3 id="主要的功能"><a href="#主要的功能" class="headerlink" title="主要的功能"></a>主要的功能</h3><p>Decorator 有四个主要的功能</p><ol><li>它可以用具有相同语义的匹配值<strong>替换</strong>正在修饰的值。（例如，装饰器可以用另一个方法替换一个方法，用另一个字段替换一个字段，用另一个类替换一个类，等等）。</li><li>它可以将<strong>元数据</strong>与正在修饰的值相关联。然后可以从外部读取这些元数据，并将其用于元编程(metaprogramming, 编写能改变语言语法特性或者运行时特性的程序)和自省(introspection, 检查对象的一种能力）。</li><li>它可以通过元数据提供对正在修饰的值的<strong>访问</strong>。对于公共值(public)，他们可以通过值的名称来实现这一点。对于私有值(private)，它们接收访问器函数(accessor functions)，然后可以选择共享这些函数。</li><li>它可以<strong>初始化</strong>被修饰的值，在值被完全定义后运行额外的代码。如果该值是类的成员，则每个实例都会进行一次初始化。</li></ol><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ol><li>装饰器表达式（在 <code>@</code> 符号后的内容）的<strong>求值</strong>过程中穿插着计算属性名。</li><li>在类定义期间，在对方法进行评估之后，但在将构造函数和原型组合在一起之前，会<strong>调用</strong>装饰器（作为函数）。</li><li>在调用了所有装饰器之后，装饰器会同时被<strong>应用</strong>（修改构造函数和原型）。</li></ol><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>常见应用场景：</p><p>日志记录，性能统计，类型检查</p><h2 id="Decorator的局限性"><a href="#Decorator的局限性" class="headerlink" title="Decorator的局限性"></a>Decorator的局限性</h2><p>使用装饰器语法特性的确可以带来很多方便，但还是有许多需要注意的地方，一方面是由于 Javascript 语言实现上的特性，一方面是装饰器语法本身的问题，还有一方面是语法方案本身进度的问题。</p><h3 id="不支持方法装饰器"><a href="#不支持方法装饰器" class="headerlink" title="不支持方法装饰器"></a>不支持方法装饰器</h3><p>有关方法装饰器可参见 <a href="https://github.com/tc39/proposal-decorators/blob/master/EXTENSIONS.md#function-decorators-and-annotations">function-decorators-and-annotations</a> 。其他语言像 python 是支持方法装饰器的。但是因为 Javascript 中的方法会变量提升，而装饰器并不会提升（详见<a href="https://github.com/microsoft/TypeScript/issues/2249#issuecomment-86853710">Why decorator should not be hoisted</a>），所以 Javascript Decorator 草案初版不打算支持方法装饰器。详见<a href="https://github.com/tc39/proposal-decorators/issues/40">Allow decorating functions</a>。</p><h3 id="不支持编译时装饰器"><a href="#不支持编译时装饰器" class="headerlink" title="不支持编译时装饰器"></a>不支持编译时装饰器</h3><p>像 java 之类语言，装饰器（java一般叫注解 Annotation）可以在编译时产生不影响输出的代码。但 Javascript 不存在输出字节码这步，原生当然不支持编译时装饰器。不过工具如 Typescript 其实理论上是可以支持的。</p><h3 id="无法被tree-shaking"><a href="#无法被tree-shaking" class="headerlink" title="无法被tree-shaking"></a>无法被tree-shaking</h3><p>目前从实现上来说，无论是 <code>babel-plugin-transform-decorators</code> 还是 Typescript 本质上都是一个 expression 。构建工具都没办法知道这个 expression 做了什么，所以被装饰的类没有办法被 tree-shaking 。例如下面的 TestClass 就无法被 tree-shaking 。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestClass</span> &#123;</span><br><span class="line">    <span class="meta">@Foo</span>()</span><br><span class="line">    <span class="keyword">private</span> content = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestClass</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">content</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">__decorate</span>([</span><br><span class="line">    <span class="title class_">Foo</span>(),</span><br><span class="line">    <span class="title function_">__metadata</span>(<span class="string">&quot;design:type&quot;</span>, <span class="title class_">Object</span>)</span><br><span class="line">], <span class="title class_">TestClass</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&quot;content&quot;</span>, <span class="built_in">void</span> <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// es5</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">TestClass</span> = <span class="comment">/** <span class="doctag">@class</span> */</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">TestClass</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">content</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">__decorate</span>([</span><br><span class="line">        <span class="title class_">Foo</span>(),</span><br><span class="line">        <span class="title function_">__metadata</span>(<span class="string">&quot;design:type&quot;</span>, <span class="title class_">Object</span>)</span><br><span class="line">    ], <span class="title class_">TestClass</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&quot;content&quot;</span>, <span class="built_in">void</span> <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">TestClass</span>;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>代码压缩工具如 Terser 或 Uglify.js 支持用 <code>/*@__PURE__*/</code>comment来声明方法为 pure 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="comment">/*#__PURE__*/</span><span class="title function_">i_am_dropped_if_x_is_not_used</span>()</span><br></pre></td></tr></table></figure><p>Typescript 中可以使用 <code>/** @class */</code> 注释。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">TestClass</span> = <span class="comment">/** <span class="doctag">@class</span> */</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">return</span> <span class="title class_">TestClass</span>;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>我们可以在构建工具利用字符替换将这个注释替换成自动替换成 pure 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">resolve</span>(&#123; <span class="attr">jsnext</span>: <span class="literal">true</span>, <span class="attr">module</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">transform</span>(<span class="params">code, id</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> code.<span class="title function_">replace</span>(<span class="regexp">/\/\*\* @class \\*\//g</span>, <span class="string">&quot;\/*@__PURE__*\/&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">uglify</span>(uglify_options),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="过多的装饰器增加调试成本"><a href="#过多的装饰器增加调试成本" class="headerlink" title="过多的装饰器增加调试成本"></a>过多的装饰器增加调试成本</h3><p>装饰器层次增多，会增加调试成本，很难追溯到一个 Bug 是在哪一层包装导致的。</p><h3 id="装饰器语法仍处于草案状态"><a href="#装饰器语法仍处于草案状态" class="headerlink" title="装饰器语法仍处于草案状态"></a>装饰器语法仍处于草案状态</h3><p>当前的 <a href="https://github.com/tc39/proposal-decorators">tc39 装饰器语法草案</a> 与 Babel “legacy” decorators 和 <a href="https://www.typescriptlang.org/docs/handbook/decorators.html">Typescript “experimental” decorators</a> 实现均不同。虽然 Babel 7 已经支持了 TC39 2018.11 会议上通过的草案，但其实现仍旧面临了性能上的问题。所以 tc39 的建议是，如果在之前已经使用了装饰器语法，那么继续按照老的方案使用。</p><h2 id="Typescript-中的-Decorator-实现"><a href="#Typescript-中的-Decorator-实现" class="headerlink" title="Typescript 中的 Decorator 实现"></a>Typescript 中的 Decorator 实现</h2><p>目前 Typescript 中的 Decorator 实现是基于 2014 年的 JavaScript 装饰器语法草案。详细实现参见 <a href="https://www.typescriptlang.org/docs/handbook/decorators.html">Typescript “experimental” decorators</a>。</p><h3 id="Decorator-例子"><a href="#Decorator-例子" class="headerlink" title="Decorator 例子"></a>Decorator 例子</h3><p>假设我们要实现一个 <code>Person</code> 的类，这个类包括两个方法 <code>walk</code> 与 <code>run</code>，我们通过装饰器记录 <code>walk</code> 与 <code>run</code> 消耗的时间。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logTime</span>(<span class="params">target, key, desc</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> fn = desc.<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">const</span> logTime = <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> end = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> time: <span class="subst">$&#123;end - start&#125;</span>ms`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    desc.<span class="property">value</span> = logTime;</span><br><span class="line">    <span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@logTime</span></span><br><span class="line">    <span class="title function_">walk</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Walk&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@logTime</span></span><br><span class="line">    <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Run&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ming = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">ming.<span class="title function_">walk</span>();</span><br><span class="line">ming.<span class="title function_">run</span>();</span><br></pre></td></tr></table></figure><h3 id="decorate-方法解析"><a href="#decorate-方法解析" class="headerlink" title="__decorate 方法解析"></a>__decorate 方法解析</h3><p>上述代码经过 Typescript 转换后变为如下代码(emitDecoratorMetadata=false 不生成装饰器元数据)：</p><p>可以在 <a href="https://www.typescriptlang.org/play?emitDecoratorMetadata=false#code/PTAEHUFMBsGMHsC2lQBd5oBYoCoE8AHSAZVgCcBLA1UABWgEM8BzM+AVwDsATAGiwoBnUENANQAd0gAjQRVSQAUCEmYKsTKGYUAbpGF4OY0BoadYKdJMoL+gzAzIoz3UNEiPOofEVKVqAHSKymAAmkYI7NCuqGqcANag8ABmIjQUXrFOKBJMggBcISGgoAC0oACCbvCwDKgU8JkY7p7ehCTkVDQS2E6gnPCxGcwmZqDSTgzxxWWVoASMFmgYkAAeRJTInN3ymj4d-jSCeNsMq-wuoPaOltigAKoASgAywhK7SbGQZIIz5VWCFzSeCrZagNYbChbHaxUDcCjJZLfSDbExIAgUdxkUBIursJzCFJtXydajBZJcWD1RrVZg4KGQAAUqEczEgqH48UgeH43H0pPQZAAlKAAN6KEolBCcQQ0ZJeAC8cP5h3gZACOgY0HYkAA3BLJdLZbT6chQEqKeZqV5GQE7azBCLxZKXWiZUcWWQaEqACJ1SABAYSRlC-WuyWoMh4MUG8MupyofFeeUBBgEBZ4ZlqQQXMjMR1huMAXxxGS10GjzrjLqNNBRrl9-sD8GDodj1bdgng7gC0HgzEZAAMACSirl4Ev1ZD5UCj+uzWWOVBFxCCQdt6tF9tbl18wQCtUarU680mhmFkoJpPK-eqsj6reKWCMQTCWjfLtecXtgACfbpDLtrk0DxCGMbVka3YBv+jIAOTgFq8SwRukqPi6f79qaSjxlwYFVuGkE9jBsGPFwyEXqAW6PrWoCIMMp6cJAEh0B+jQhvqdGcMwATAaBbacdxZC4W2xQ4M0HhkF4iBqs4wLsDQXxuGYzDsAwbL8M+6iJAwwJ6CIXgAEQAKKrAwiALPoBlJNiBngA4qCwcIAByTEGUEKgAPJfGQ7yCJA-Bsh6S6QK40jRk40k6PRXx+WiiDQsIlyKRIarRCIBgcNiCxMKwHA8EEJRAA">Typescript Playground</a> 看到完整代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> __decorate = (<span class="variable language_">this</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">__decorate</span>) || <span class="keyword">function</span> (<span class="params">decorators, target, key, desc</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="variable language_">arguments</span>.<span class="property">length</span>,</span><br><span class="line">        r = c &lt; <span class="number">3</span> ? <span class="attr">target</span>:</span><br><span class="line">            desc === <span class="literal">null</span> ? desc = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(target, key) : desc,</span><br><span class="line">        d;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">Reflect</span> === <span class="string">&quot;object&quot;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">Reflect</span>.<span class="property">decorate</span> === <span class="string">&quot;function&quot;</span>)</span><br><span class="line">        r = <span class="title class_">Reflect</span>.<span class="title function_">decorate</span>(decorators, target, key, desc);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = decorators.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (d = decorators[i])</span><br><span class="line">                r = (c &lt; <span class="number">3</span> ? <span class="title function_">d</span>(r) : c &gt; <span class="number">3</span> ? <span class="title function_">d</span>(target, key, r) : <span class="title function_">d</span>(target, key)) || r;</span><br><span class="line">    <span class="keyword">return</span> c &gt; <span class="number">3</span> &amp;&amp; r &amp;&amp; <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, key, r), r;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logTime</span>(<span class="params">target, key, descriptor</span>) &#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Persion</span> &#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line"><span class="title function_">__decorate</span>([</span><br><span class="line">    logTime</span><br><span class="line">], <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&quot;walk&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="title function_">__decorate</span>([</span><br><span class="line">    logTime</span><br><span class="line">], <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&quot;run&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">const</span> ming = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">ming.<span class="title function_">walk</span>();</span><br><span class="line">ming.<span class="title function_">run</span>();</span><br></pre></td></tr></table></figure><p>上述代码有关装饰器实现的核心点是两个部分，一个是定义，一个是执行。</p><ul><li><p>Part1 装饰器工具函数 <code>__decorate</code> 的执行</p><p>执行会传入以下 4 个参数：</p><ol><li>装饰器业务逻辑函数</li><li>类的构造器</li><li>类的构造器属性名</li><li>属性描述符(可以为null)</li></ol></li><li><p>Part2 装饰器工具函数 <code>__decorate</code> 的定义</p><p>首先，将该函数主要逻辑无关的部分剥离</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> __decorate = <span class="keyword">function</span> (<span class="params">decorators, target, key, desc</span>) &#123;</span><br><span class="line">    <span class="comment">// Step1 备份原来类构造器 (Class.prototype) 的属性描述符 (Descriptor)</span></span><br><span class="line">    <span class="keyword">var</span> r = desc = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(target, key),</span><br><span class="line">    <span class="keyword">var</span> d;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = decorators.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="comment">// d 为装饰器业务逻辑函数</span></span><br><span class="line">      <span class="keyword">if</span> (d = decorators[i]) &#123;</span><br><span class="line">        <span class="comment">// Step2 执行 d，并传入 target 类构造器，key 属性名，r 属性描述符</span></span><br><span class="line">        r = <span class="title function_">d</span>(target, key, r) || r;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Step3 用装饰器函数覆盖原来属性描述符</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, key, r);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以看到，Typescript 对装饰器编译后的代码，是将装饰器逻辑抽离成了一个工具函数，这个工具函数主要包括三个部分：</p><ol><li>使用 <code>Object.getOwnPropertyDescriptor</code> 备份原来的类构造器的属性描述符</li><li>执行装饰器业务逻辑函数，并传入类构造器、属性名、属性描述符</li><li>使用 <code>Object.defineProperty</code> 将装饰器函数覆盖原来的属性描述符</li></ol></li></ul><h3 id="Decorator-类型"><a href="#Decorator-类型" class="headerlink" title="Decorator 类型"></a>Decorator 类型</h3><p>Typescript 中的装饰器一共有5种类型：</p><ol><li>类装饰器(Class)</li><li>类属性装饰器(Class Field / Property)</li><li>类方法装饰器(Class Method)</li><li>类访问器装饰器(Calss Accessor)</li><li>参数装饰器(Parameter)</li></ol><p>需要注意的是，在最新版 tc39 stage2 草案中，参数装饰器暂时没有被安排在内。并且 tc39 的草案与 Typescript 的实现有较大差别。</p><p>Typescript 中各种装饰器的入参和返回值可参见以下描述：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">TypedPropertyDescriptor</span>&lt;T&gt; &#123;</span><br><span class="line">    enumerable?: <span class="built_in">boolean</span>;</span><br><span class="line">    configurable?: <span class="built_in">boolean</span>;</span><br><span class="line">    writable?: <span class="built_in">boolean</span>;</span><br><span class="line">    value?: T;</span><br><span class="line">    get?: <span class="function">() =&gt;</span> T;</span><br><span class="line">    set?: <span class="function">(<span class="params">value: T</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类装饰器</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">type</span> <span class="title class_">ClassDecorator</span> = &lt;<span class="title class_">TFunction</span> <span class="keyword">extends</span> <span class="title class_">Function</span>&gt;<span class="function">(<span class="params">target: TFunction</span>) =&gt;</span> <span class="title class_">TFunction</span> | <span class="built_in">void</span>;</span><br><span class="line"><span class="comment">// 属性装饰器</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">type</span> <span class="title class_">PropertyDecorator</span> = <span class="function">(<span class="params">target: <span class="built_in">Object</span>, propertyKey: <span class="built_in">string</span> | <span class="built_in">symbol</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"><span class="comment">// 方法装饰器/访问器装饰器</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">type</span> <span class="title class_">MethodDecorator</span> = &lt;T&gt;<span class="function">(<span class="params">target: <span class="built_in">Object</span>, propertyKey: <span class="built_in">string</span> | <span class="built_in">symbol</span>, descriptor: TypedPropertyDescriptor&lt;T&gt;</span>) =&gt;</span> <span class="title class_">TypedPropertyDescriptor</span>&lt;T&gt; | <span class="built_in">void</span>;</span><br><span class="line"><span class="comment">// 参数装饰器</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">type</span> <span class="title class_">ParameterDecorator</span> = <span class="function">(<span class="params">target: <span class="built_in">Object</span>, propertyKey: <span class="built_in">string</span> | <span class="built_in">symbol</span>, parameterIndex: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure><h3 id="Decorator-执行顺序"><a href="#Decorator-执行顺序" class="headerlink" title="Decorator 执行顺序"></a>Decorator 执行顺序</h3><p>同一个类的方法有多个装饰器，其执行顺序为先从外到内进入，然后由内向外执行。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dec</span>(<span class="params">id</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;evaluation&#x27;</span>, id);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">target, key, desc</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;call&#x27;</span>, id);</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="meta">@dec</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="meta">@dec</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="title function_">method</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// evaluation 1</span></span><br><span class="line"><span class="comment">// evaluation 2</span></span><br><span class="line"><span class="comment">// call 2</span></span><br><span class="line"><span class="comment">// call 1</span></span><br></pre></td></tr></table></figure><p>同一个类有不同类型的装饰器时，按照以下顺序执行：</p><ol><li>按照 实例 &gt;&gt; 静态 &gt;&gt; 构造函数 &gt; 类 的优先级顺序执行</li><li>同一优先级内的（参数|方法/访问器/属性）装饰器按照出现的先后顺序执行</li><li>同一个方法既有方法装饰器又有参数装饰器时，参数装饰器先执行</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">d</span>(<span class="params">value: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value, <span class="string">&#x27;evaluation&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">target: <span class="built_in">any</span>, key?: <span class="built_in">any</span>, desc?: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(value, <span class="string">&#x27;call&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@d</span>(<span class="string">&#x27;Class&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="meta">@d</span>(<span class="string">&#x27;Static Property&#x27;</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="attr">prop</span>: <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@d</span>(<span class="string">&#x27;Instance Property&#x27;</span>)</span><br><span class="line">    <span class="attr">prop</span>: <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="meta">@d</span>(<span class="string">&#x27;Constructor Parameter&#x27;</span>) foo: <span class="built_in">void</span></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@d</span>(<span class="string">&#x27;Static Method&#x27;</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">method</span>(<span class="params"><span class="meta">@d</span>(<span class="string">&#x27;Static Method Parameter&#x27;</span>) foo: <span class="built_in">void</span></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@d</span>(<span class="string">&#x27;Instance Method&#x27;</span>)</span><br><span class="line">    <span class="title function_">method</span>(<span class="params"><span class="meta">@d</span>(<span class="string">&#x27;Instance Method Parameter&#x27;</span>) foo: <span class="built_in">void</span></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instance Property evaluation</span></span><br><span class="line"><span class="comment">// Instance Property call</span></span><br><span class="line"><span class="comment">// Instance Method evaluation</span></span><br><span class="line"><span class="comment">// Instance Method Parameter evaluation</span></span><br><span class="line"><span class="comment">// Instance Method Parameter call</span></span><br><span class="line"><span class="comment">// Instance Method call</span></span><br><span class="line"><span class="comment">// Static Property evaluation</span></span><br><span class="line"><span class="comment">// Static Property call</span></span><br><span class="line"><span class="comment">// Static Method evaluation</span></span><br><span class="line"><span class="comment">// Static Method Parameter evaluation</span></span><br><span class="line"><span class="comment">// Static Method Parameter call</span></span><br><span class="line"><span class="comment">// Static Method call</span></span><br><span class="line"><span class="comment">// Class evaluation</span></span><br><span class="line"><span class="comment">// Constructor Parameter evaluation</span></span><br><span class="line"><span class="comment">// Constructor Parameter call</span></span><br><span class="line"><span class="comment">// Class call</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> ES7 </tag>
            
            <tag> decorator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端常用软件与工具</title>
      <link href="/blog/2022/01/19/FE-%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E4%B8%8E%E5%B7%A5%E5%85%B7/"/>
      <url>/blog/2022/01/19/FE-%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E4%B8%8E%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="集成开发环境"><a href="#集成开发环境" class="headerlink" title="集成开发环境"></a>集成开发环境</h2><p>集成开发环境（IDE，Integrated Development Environment ）是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具。集成了代码编写功能、分析功能、编译功能、调试功能等一体化的开发软件服务套。所有具备这一特性的软件或者软件套（组）都可以叫集成开发环境。</p><span id="more"></span><h3 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h3><p>官网：https://code.visualstudio.com<br>源代码：https://github.com/microsoft/vscode</p><p>Visual Studio Code（VSCode） 是由 Microsoft 提供的一款开源文本编辑器。它将文本编辑器与开发者常用的 “编辑-构建-调试” 的循环结合了起来，提供了全面的代码编辑、导航、轻量级的代码调试的支持，同时通过丰富的插件支持扩展功能。</p><p>主要功能：</p><ul><li>支持跨平台，提供了 Windows、Linux、macOS 等多个版本</li><li>支持代码高亮 &amp; 自动代码提示</li><li>支持在编辑器调试代码</li><li>支持文件系统浏览器，可以在一个窗口中浏览和打开单个文件、整个项目或多个项目</li><li>内置 Git 命令，支持源代码管理</li><li>集成 zsh/bash 终端</li><li>可以通过插件扩展和定制其它功能</li></ul><h3 id="Atom"><a href="#Atom" class="headerlink" title="Atom"></a>Atom</h3><p>官网：https://atom.io<br>源代码：https://github.com/atom/atom</p><p>Atom 是一款界面简洁优美同时功能十分强大的开源文本编辑器，由 Github 提供支持，基于 Electron 构建，包含了现代编辑器的大部分常用功能，而且支持深度定制。</p><p>主要功能：</p><ul><li>跨平台编辑，OS X、Windows 或 Linux 均可使用</li><li>内置包管理器，支持搜索并安装新包</li><li>文件系统浏览器，可以在一个窗口中浏览和打开单个文件、整个项目或多个项目</li><li>支持代码高亮 &amp; 自动代码提示</li><li>支持全局查找与替换</li><li>支持多窗口跨文件比较与编辑</li><li>支持深色、浅色等多个主题</li><li>通过 teletype 支持多人协同编辑</li><li>集成 Git 与 Github 进行代码管理</li><li>深度定制，可以通过 CSS/Less 调整外观，可以使用 HTML 和 JavaScript 添加额外功能</li></ul><h3 id="Sublime-Text"><a href="#Sublime-Text" class="headerlink" title="Sublime Text"></a>Sublime Text</h3><p>官网：https://www.sublimetext.com</p><p>Sublime Text 是一款快速的，用于编码、标记或写作的文本编辑器。Sublime Text 是收费软件，一次性收费 $99，包含三年的更新支持，由 Sublime HQ Pty Ltd 开发并提供技术支持。</p><p>主要功能：</p><ul><li>支持GPU渲染</li><li>对 Apple Silicon 处理器原生支持，Linux ARM64 版本也可用于 Raspberry Pi 等设备</li><li>支持文件选项卡</li><li>基于上下文支持自动完成提示</li><li>主题和配色方案支持自动暗模式切换</li><li>默认支持 Typescript、JSX、TSX</li><li>支持语法高亮</li></ul><h3 id="WebStorm"><a href="#WebStorm" class="headerlink" title="WebStorm"></a>WebStorm</h3><p>官网：https://www.jetbrains.com/webstorm/</p><p>WebStorm 是一款适用于 Javascript 和相关技术的集成开发环境。WebStorm 由 JetBrains 提供技术支持，个人版 $59/年</p><p>主要功能：</p><ul><li>提供了对 Javascript 相关生态的原生支持</li><li>支持代码补全和代码提示</li><li>支持对 客户端与 Node.js 应用程序进行调试</li><li>支持代码比较和查看提交历史</li><li>内置 HTTP 客户端</li><li>集成 linter</li><li>集成终端</li><li>支持导航和搜索代码</li><li>支持通过 Code With Me 进行协同开发</li><li>支持集成 JetBrains Space 进行代码审查</li><li>支持自定义 UI 与 键盘映射</li><li>支持通过插件市场扩展功能</li></ul><h3 id="HBuilder"><a href="#HBuilder" class="headerlink" title="HBuilder"></a>HBuilder</h3><p>官网：https://www.dcloud.io/hbuilderx.html</p><p>HBuilder 是一款小巧、轻量级的文本编辑器。它只有10M的安装包，功能较少，主要支持 Vue 及小程序相关生态。HBuilder 由 DCloud（数字天堂）提供技术支持，是一款免费软件。</p><p>主要功能：</p><ul><li>对 Vue 生态，小程序生态进行了更好的支持</li><li>支持语法分析，代码提示</li><li>对 markdown 文件进行了原生支持</li><li>提供插件市场支持扩展功能</li></ul><h2 id="代码管理客户端"><a href="#代码管理客户端" class="headerlink" title="代码管理客户端"></a>代码管理客户端</h2><h3 id="Sourcetree"><a href="#Sourcetree" class="headerlink" title="Sourcetree"></a>Sourcetree</h3><p>官网：https://www.sourcetreeapp.com</p><p>Sourcetree 是一款免费的 Git 客户端，支持 Windows 和 Mac 系统。Sourcetree 由 Atlassian 提供技术支持，是免费的，但是需要注册 Atlassian 账户才能使用。</p><p>主要功能：</p><ul><li>支持 Windows &amp; Mac 操作系统</li><li>支持代码分支提交历史可视化</li><li>支持多种 Git 工作流</li><li>Git 大文件支持（Git LFS）</li><li>支持子模块 （Submodules）</li><li>支持远程仓库管理</li><li>支持本地提交搜索</li></ul><h3 id="Github-Desktop"><a href="#Github-Desktop" class="headerlink" title="Github Desktop"></a>Github Desktop</h3><p>官网：https://desktop.github.com<br>源代码：https://github.com/desktop/desktop</p><p>Github Desktop 是由 Github 提供的一款开源 Git 客户端。</p><p>主要功能：</p><ul><li>支持为提交快速地添加共同作者</li><li>检出分支时带推送请求同时可查看持续集成状态</li><li>代码比较时支持语法高亮</li></ul><h3 id="Sublime-Merge"><a href="#Sublime-Merge" class="headerlink" title="Sublime Merge"></a>Sublime Merge</h3><p>官网：https://www.sublimemerge.com</p><p>Sublime Merge 是由 Sublime HQ Pty Ltd 提供的一款跨平台的 Git 客户端。Sublime Merge 是收费软件，一次性收费 $99，包含三年的更新支持。</p><p>主要功能：</p><ul><li>通过 zippy 支持跨平台</li><li>支持语法高亮</li><li>文件对比时可拆行</li><li>支持本地提交搜索</li></ul><h2 id="网络调试代理"><a href="#网络调试代理" class="headerlink" title="网络调试代理"></a>网络调试代理</h2><p>网络调试代理（Web Debugging Proxy）是一类提供了 HTTP 网络代理与调试的工具。</p><h3 id="Charles"><a href="#Charles" class="headerlink" title="Charles"></a>Charles</h3><p>官网：https://www.charlesproxy.com</p><p>Charles 是一个 HTTP 代理/ HTTP 监视器/反向代理，它使开发人员能够查看其计算机与 Internet 之间的所有 HTTP 和 SSL/HTTPS 通信。这包括请求、响应和 HTTP 头（其中包含 cookie 和缓存信息）。Charles 提供了 Windows、macOS 和 Linux版本，由 <a href="https://www.xk72.com">xk72</a> 开发，售价为 $50。</p><h3 id="Fiddler"><a href="#Fiddler" class="headerlink" title="Fiddler"></a>Fiddler</h3><p>官网：https://www.telerik.com/fiddler</p><p>Fiddler 是一款可以运行在 macOS、Windows、Linux 上的网络调试代理 。Fiddler 由 Progress Software Corporation 开发，采用订阅式收费，售价为 $12/用户/月。</p><h3 id="Whistle"><a href="#Whistle" class="headerlink" title="Whistle"></a>Whistle</h3><p>官网：https://wproxy.org/whistle/<br>源代码：https://github.com/avwo/whistle</p><p>Whistle 是一款基于 Node.js 实现的跨平台开源 web 调试代理工具。主要用于查看、修改 HTTP/HTTPS/Websocket 的请求、响应，也可以作为 HTTP 代理服务器使用。它采用的是类似配置系统 hosts 的方式，一切操作都可以通过配置实现，支持域名、路径、正则表达式、通配符、通配路径等多种匹配方式，且可以通过 Node.js 模块扩展功能。Whistle 由 Tencent 公司的 <a href="https://github.com/avwo">avenwu</a> 开发。</p><h2 id="API-调试与管理工具"><a href="#API-调试与管理工具" class="headerlink" title="API 调试与管理工具"></a>API 调试与管理工具</h2><h3 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h3><p>官网：https://postman.com</p><p>Postman 是一个用于构建和使用 API 的 API 平台。Postman 提供了 API 调试和管理的功能。Postman 提供了免费版，也以订阅的形式提供售价不同的高级版本。</p><h3 id="Hoppscotch"><a href="#Hoppscotch" class="headerlink" title="Hoppscotch"></a>Hoppscotch</h3><p>官网：https://hoppscotch.io<br>源代码：https://github.com/hoppscotch/hoppscotch</p><p>Hoppscotch 是一款开源的 API 开发工具，提供轻量级快速的 API 调试功能。</p><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p>浏览器是用来检索、展示以及传递 Web 信息资源的应用程序。</p><table><thead><tr><th>公司</th><th>浏览器</th><th>浏览器内核</th><th>js 引擎</th></tr></thead><tbody><tr><td><a href="https://www.microsoft.com/">Microsoft</a></td><td><a href="https://www.microsoft.com/en-us/download/internet-explorer.aspx">Internet Exporler(IE)</a> -&gt; <a href="https://www.microsoft.com/zh-cn/edge">Edge</a></td><td>Trident(MSHTML，IE11-) -&gt; EdgeHTML/MSHTML(Edge)-&gt;Blink（基于WebKit）</td><td>JScript（IE3.0-IE8.0） -&gt; <a href="https://github.com/chakra-core/ChakraCore">ChakraCore</a>（IE9+之后）-&gt; v8</td></tr><tr><td><a href="https://www.google.com/">Google</a></td><td><a href="https://www.google.com/intl/zh-CN/chrome/">Chrome</a>/<a href="https://github.com/chromium/chromium">Chromium</a></td><td>WebKit -&gt; Blink（28.0.1469.0+，基于Webkit）</td><td><a href="https://github.com/v8/v8">v8</a></td></tr><tr><td><a href="https://www.apple.com/">Apple</a></td><td><a href="https://www.apple.com.cn/safari/">Safari</a></td><td><a href="https://github.com/WebKit/WebKit">WebKit</a></td><td><a href="https://trac.webkit.org/wiki/JavaScriptCore">JavaScriptCore</a> -&gt; SquirrelFish（Nitro）</td></tr><tr><td><a href="https://www.mozilla.org/">Mozilla</a></td><td><a href="http://www.firefox.com.cn/">Firefox</a></td><td><a href="https://github.com/mozilla/gecko-dev">Gecko</a></td><td>SpiderMonkey（1.0-3.0）-&gt; TraceMonkey（3.5-3.6）-&gt; JägerMonkey（4.0-）-&gt; IonMonkey (18.0+) -&gt; OdinMonkey（22.0+）</td></tr><tr><td><a href="https://www.opera.com/">Opera</a></td><td><a href="https://www.opera.com/zh-cn">Opera</a></td><td>Elektra(4-6) -&gt; Presto(7.0-12.18) -&gt; WebKit -&gt; Blink（基于Webkit）</td><td>Linear A（4.0-6.1）-&gt; Linear B（7.0-9.2）-&gt; Futhark（9.5-10.2）-&gt; Carakan（10.5-）-&gt; V8</td></tr></tbody></table><h2 id="下载软件与工具"><a href="#下载软件与工具" class="headerlink" title="下载软件与工具"></a>下载软件与工具</h2><p>下载软件与工具是用来下载和管理软件包的应用程序。</p><h3 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h3><p>官网：https://brew.sh<br>源代码：https://github.com/Homebrew/brew</p><p>Homebrew 是一款 macOS/Linux 环境下的包管理工具。通过 Homebrew 可以轻松的通过命令行管理（包括安装、卸载、更新、搜索、查看）软件包，Homebrew 会将软件包安装在特定的目录下从而将软件包与系统尽量的隔离。</p><h3 id="Wget"><a href="#Wget" class="headerlink" title="Wget"></a>Wget</h3><p>官网：https://www.gnu.org/software/wget<br>源代码：https://github.com/mirror/wget</p><p>GNU Wget 是一个免费的非交互式的实用程序，用于从网络下载文件。它支持 HTTP、HTTPS、FTP、FTPS 协议。Wget 属于 GNU 项目的一部分，采用 GPL 协议分发。</p><h3 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h3><p>官网：https://curl.se<br>源代码：https://github.com/curl/curl</p><p>curl 是一个命令行工具，用于通过 URL 来传输数据。curl 支持 HTTP、HTTPS、FTP、FTPS 等众多协议。curl 已经在 macOS、Windows10 等系统中预先安装，可以直接使用。curl 采用 MIT 协议分发。</p>]]></content>
      
      
      
        <tags>
            
            <tag> tool </tag>
            
            <tag> front-end </tag>
            
            <tag> software </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web 安全</title>
      <link href="/blog/2022/01/13/FE-web-%E5%AE%89%E5%85%A8/"/>
      <url>/blog/2022/01/13/FE-web-%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="供应链攻击（Supply-Chain-Attack）"><a href="#供应链攻击（Supply-Chain-Attack）" class="headerlink" title="供应链攻击（Supply Chain Attack）"></a>供应链攻击（Supply Chain Attack）</h2><p>供应链攻击是一种针对供应链中的组织或产品的网络攻击形式。它利用供应链中的弱点或恶意行为，以获取未经授权的访问权限、窃取敏感信息、传播恶意软件或破坏目标组织的安全。</p><h3 id="软件源安全"><a href="#软件源安全" class="headerlink" title="软件源安全"></a>软件源安全</h3><p>软件源安全是指在开发过程中或工作过程中使用的软件应该是安全的，需保证不会对开发或工作的环境造成破坏，不会对项目的开发造成风险。</p><p>解决方案：</p><ul><li>成立软件管理委员会统一负责软件（包括开发软件）的评估、评级与分发。</li><li>软件管理委员会提供统一安装渠道（白名单机制），对待安装软件分级，分为“安全，警告，禁止”三个级别，对安全的软件提供统一获取渠道和标准化安装步骤（安全的商业软件提供授权获取通道），警告的软件由安装者自行保证（通常为暂未进行评估的软件或者竞品软件），对禁止的软件禁止安装并说明原因且提供推荐替代方案。如果同一个软件的不同版本安全级别可能不同，则当成两个软件对待。</li><li>如果使用者对未列在软件列表中的软件有需求可提供工单，由专人（软件管理委员会）对待安装软件进行评估和评级。</li><li>对已安装软件进行定期扫描，对不符合要求的软件进行告警提示，责令限期卸载。</li></ul><span id="more"></span><h3 id="服务器安全"><a href="#服务器安全" class="headerlink" title="服务器安全"></a>服务器安全</h3><p>服务器安全是指运行项目或代码的环境应保证是安全的。</p><p>解决方案：</p><p>使用经过验证的服务器与服务器配套组件：</p><ul><li>Web服务器类：Nginx、Apache、Tomcat、Resin、Nodejs</li><li>数据库类：MySQL（MariaDB）、Memcached、Mongodb、Redis</li><li>代理类：LVS/LB、Apache、Nginx、Varnish、Squid、HAProxy、Lighttpd</li><li>云计算&amp;大数据：Hadoop、Spark、Storm、Docker</li><li>其它：各种编程语言及配套CGI、OpenSSL、OpenSSH、Rsync</li></ul><h3 id="框架-库安全"><a href="#框架-库安全" class="headerlink" title="框架/库安全"></a>框架/库安全</h3><p>框架/库安全是指项目或代码依赖的框架库应保证是安全的。</p><p>解决方案：</p><ul><li>自建内部软件源，对框架/库强制要求从内部源下载与更新，在必要时（例如某组件报安全问题后）可从源上禁止对框架/库的下载。</li><li>项目使用的框架和库需要采用正确的合适的授权协议。（BSD、MIT、Apache License）</li><li>提供黑名单机制，项目构建时强制要求扫描是否引入了黑名单中的框架/库，如果有引入，不能发布。（禁止 Struts、phpMyAdmin）</li><li>禁止框架/库的自动更新，固定版本号，确定开发与生产环境编译依赖一致。</li><li>定时更新项目依赖的框架/库，尤其是安全性更新。</li><li>生产环境关闭框架/库提供的报错和调试功能。</li></ul><h2 id="中间人攻击（Man-in-the-Middle）"><a href="#中间人攻击（Man-in-the-Middle）" class="headerlink" title="中间人攻击（Man-in-the-Middle）"></a>中间人攻击（Man-in-the-Middle）</h2><p>MitM（Man-in-the-Middle）中间人攻击是一种网络安全攻击方式，攻击者通过在通信链路中插入自己作为中间人的角色，来窃取、篡改或伪造通信数据。</p><p>中间人攻击包括以下几种手段：</p><ol><li>ARP欺骗（ARP Spoofing）</li></ol><p>攻击者通过伪造 ARP 响应包，将自己的 MAC 地址与目标 IP 地址绑定，使得通信流量经过攻击者的设备。</p><ol start="2"><li>DNS欺骗（DNS Spoofing）</li></ol><p>攻击者篡改DNS响应，将合法域名解析到攻击者控制的恶意IP地址，使得用户访问的是攻击者的服务器。</p><ol start="3"><li>SSL/TLS劫持</li></ol><p>攻击者伪造合法的SSL/TLS证书，使得用户与攻击者建立安全连接，从而能够窃取用户的敏感信息。</p><ol start="4"><li>WiFi钓鱼</li></ol><p>攻击者创建一个伪装成合法WiFi网络的恶意热点，用户连接后，攻击者可以窃取用户的通信数据。</p><ol start="5"><li>IP欺骗</li></ol><p>攻击者伪造源IP地址，使得目标服务器将响应发送给攻击者，从而能够窃取通信数据。</p><p>为了防范中间人攻击，可以采取以下措施：</p><ol><li>使用加密通信：使用SSL/TLS等加密协议来保护通信数据的机密性，防止被中间人窃取。</li><li>验证证书：在建立SSL/TLS连接时，验证服务器的证书是否合法和可信，防止受到SSL/TLS劫持攻击。</li><li>使用VPN：通过使用虚拟私人网络（VPN），可以在公共网络上建立加密的通信隧道，防止中间人攻击。</li><li>注意网络环境：避免连接不可信的公共WiFi网络，尽量使用受信任的网络环境。</li><li>定期更新软件和设备：及时安装软件和设备的安全更新，以修复已知的安全漏洞。</li></ol><h2 id="会话劫持（Session-Hijacking）"><a href="#会话劫持（Session-Hijacking）" class="headerlink" title="会话劫持（Session Hijacking）"></a>会话劫持（Session Hijacking）</h2><p>会话劫持是指攻击者通过某种方式获取合法用户的会话信息，然后利用这些信息冒充用户进行恶意操作或者获取敏感信息的行为。</p><p>为了避免会话劫持，可以采取以下措施：</p><ol><li><p>使用HTTPS：使用HTTPS协议加密通信，防止会话信息在传输过程中被窃取或篡改。</p></li><li><p>使用安全的会话管理机制：确保会话ID的安全性，避免会话ID被猜测或者盗取。可以使用随机、复杂的会话ID，并设置合理的过期时间。</p></li><li><p>防止跨站脚本攻击（XSS）：通过对用户输入进行合理的过滤和转义，防止恶意脚本注入，从而避免攻击者窃取会话信息。</p></li><li><p>防止跨站请求伪造（CSRF）：使用CSRF令牌验证用户请求的合法性，确保请求来自合法的源。</p></li><li><p>定期更新和强化密码策略：要求用户使用强密码，并定期更新密码，避免密码被猜测或者破解。</p></li><li><p>使用双因素认证：引入双因素认证机制，增加登录的安全性，即使会话信息被窃取，攻击者也无法轻易登录。</p></li><li><p>定期审查和监控会话活动：监控用户会话活动，及时发现异常行为，并采取相应的措施。</p></li></ol><h3 id="会话固定（Session-fixation）"><a href="#会话固定（Session-fixation）" class="headerlink" title="会话固定（Session fixation）"></a>会话固定（Session fixation）</h3><p>利用了应用程序在建立用户会话时的漏洞。攻击者通过在用户登录之前或之后获取会话标识符（Session ID），然后将该会话标识符注入到目标用户的会话中。这样，攻击者就能够控制目标用户的会话，获取其敏感信息或执行未经授权的操作。</p><p>攻击者通常会使用以下几种方式进行会话固定攻击：</p><ol><li><p>预先分配会话标识符：攻击者在用户登录之前就生成一个会话标识符，并将其发送给用户。当用户登录时，应用程序会使用该会话标识符来建立用户会话。然而，攻击者已经知道了该会话标识符，并可以使用它来获取用户的会话。</p></li><li><p>会话标识符传递：攻击者通过某种方式将自己的会话标识符传递给目标用户，例如通过URL参数、隐藏表单字段或Cookie。当目标用户使用该会话标识符登录时，攻击者就能够获取用户的会话。</p></li></ol><p>一旦攻击者成功固定了目标用户的会话，他们可以模拟目标用户的身份，执行各种操作，包括访问用户的个人信息、修改用户设置、进行未经授权的操作等。</p><p>为了防止会话固定攻击，应用程序可以采取以下措施：</p><ol><li><p>生成随机的会话标识符：应用程序应该使用足够强大的随机算法生成会话标识符，以使攻击者无法猜测或预测会话标识符。</p></li><li><p>在用户登录时重新生成会话标识符：应用程序在用户登录时应该生成一个新的会话标识符，并将旧的会话标识符无效化，以防止攻击者使用预先分配的会话标识符。</p></li><li><p>使用HTTPS：使用HTTPS加密通信可以防止攻击者在网络传输过程中截获会话标识符。</p></li><li><p>限制会话的有效期：应用程序可以设置会话的有效期，使会话在一定时间后自动过期，从而减少攻击者的窗口期。</p></li></ol><h2 id="分布式拒绝服务（DDoS，Distributed-Denial-of-Service）"><a href="#分布式拒绝服务（DDoS，Distributed-Denial-of-Service）" class="headerlink" title="分布式拒绝服务（DDoS，Distributed Denial of Service）"></a>分布式拒绝服务（DDoS，Distributed Denial of Service）</h2><p>分布式拒绝服务攻击指借助于客户/服务器技术，将多个计算机联合起来作为攻击平台，对一个或多个目标发起请求，从而使受攻击方网络瘫痪的一种攻击方式。</p><p>详见 <a href="/blog/2018/09/17/HACK-DDOS攻击/">DDos</a></p><h2 id="代码注入（Code-Injection）"><a href="#代码注入（Code-Injection）" class="headerlink" title="代码注入（Code Injection）"></a>代码注入（Code Injection）</h2><p>代码注入是指攻击者通过将恶意代码注入到应用程序的输入参数中，从而使应用程序执行攻击者所期望操作的行为。代码注入攻击可以利用应用程序对用户输入的不正确处理，从而导致应用程序受到攻击。</p><h3 id="SQL注入（SQL-Injection）"><a href="#SQL注入（SQL-Injection）" class="headerlink" title="SQL注入（SQL Injection）"></a>SQL注入（SQL Injection）</h3><p>如果程序根据用户输入的参数动态生成SQL语句并执行，黑客可通过传入恶意参数值注入自己定义的语句，使数据库执行任意自己需要的指令，实现数据窃取或入侵破坏。</p><h3 id="命令注入（Command-Injection）"><a href="#命令注入（Command-Injection）" class="headerlink" title="命令注入（Command Injection）"></a>命令注入（Command Injection）</h3><p>如果程序根据用户输入的参数动态生成系统命令并执行，黑客可通过传入恶意参数值注入自己定义的命令，从而控制服务器。</p><h3 id="XSS跨站脚本（Cross-Site-Scripting）"><a href="#XSS跨站脚本（Cross-Site-Scripting）" class="headerlink" title="XSS跨站脚本（Cross Site Scripting）"></a>XSS跨站脚本（Cross Site Scripting）</h3><p>XSS是发生在目标用户的浏览器层面上的攻击方式，当浏览器渲染页面的过程中发生了不在预期内执行的JS代码时，就发生了XSS攻击。</p><p>详见 <a href="/blog/2018/09/09/HACK-XSS攻击/">XSS</a></p><p>为了防止代码注入攻击，可以采取以下措施：</p><ol><li><p>输入验证和过滤：对于用户输入的数据，进行验证和过滤，确保只接受符合预期格式和类型的数据。例如，对于数字输入，可以使用输入验证函数确保只接受数字字符。</p></li><li><p>使用参数化查询或预编译语句：对于数据库查询，使用参数化查询或预编译语句，而不是将用户输入直接拼接到查询语句中。这样可以防止SQL注入攻击，因为参数化查询会将用户输入作为参数传递，而不是将其作为查询的一部分。</p></li><li><p>输出转义和过滤：在将数据输出到应用程序的界面或其他地方时，进行适当的转义和过滤。这可以防止跨站脚本攻击，因为转义和过滤可以确保恶意脚本代码不会被执行。</p></li><li><p>最小权限原则：确保应用程序在执行操作时具有最小的权限。这意味着应用程序只能访问和执行必要的操作，而不是拥有完整的系统权限。这可以减少攻击者利用代码注入攻击获得的潜在权限。</p></li><li><p>定期更新和修补漏洞：及时更新和修补应用程序的漏洞是非常重要的。漏洞可能会被攻击者利用来进行代码注入攻击。通过及时更新和修补漏洞，可以增强应用程序的安全性。</p></li></ol><h2 id="跨站请求伪造（CSRF，Cross-Site-Request-Forgery）"><a href="#跨站请求伪造（CSRF，Cross-Site-Request-Forgery）" class="headerlink" title="跨站请求伪造（CSRF，Cross Site Request Forgery）"></a>跨站请求伪造（CSRF，Cross Site Request Forgery）</h2><p>CSRF跨站请求伪造，也被称为 One Click Attack 或者 Session Riding ，通常缩写为 CSRF 或者 XSRF ，是一种通过伪造用户请求破坏网站的攻击方式。</p><p>详见 <a href="/blog/2018/09/10/HACK-CSRF攻击/">CSRF</a></p><h2 id="服务器请求伪造（SSRF，Server-Side-Request-Forgery）"><a href="#服务器请求伪造（SSRF，Server-Side-Request-Forgery）" class="headerlink" title="服务器请求伪造（SSRF，Server Side Request Forgery）"></a>服务器请求伪造（SSRF，Server Side Request Forgery）</h2><p>服务器请求伪造（Server-Side Request Forgery，SSRF）是一种攻击技术，攻击者通过欺骗服务器发起伪造的请求，使服务器在其信任的上下文中执行恶意操作。攻击者通常会利用服务器对其他系统或资源的信任来执行攻击，例如访问内部网络、绕过防火墙或执行未经授权的操作。</p><p>为了防范服务器请求伪造（SSRF）攻击，可以采取以下措施：</p><ol><li><p>输入验证和过滤：对于用户提供的输入，应该进行严格的验证和过滤，确保输入的URL或参数符合预期的格式和范围。可以使用白名单来限制允许的URL或IP地址。</p></li><li><p>限制服务器访问权限：服务器应该以最小特权原则运行，并限制其对其他系统或资源的访问权限。确保服务器只能访问必要的资源，并禁止访问敏感的内部网络。</p></li><li><p>使用安全的网络代理：在服务器和外部资源之间使用安全的网络代理，例如反向代理或应用程序防火墙（WAF），以过滤和检测恶意请求。</p></li><li><p>防火墙配置：配置防火墙以限制服务器对外部网络的访问，并阻止不必要的出站连接。</p></li><li><p>安全的URL解析：在服务器端解析和处理URL时，应该使用安全的解析库或函数，以防止恶意URL的利用。</p></li><li><p>定期更新和维护：及时更新服务器和相关软件的补丁和安全更新，以修复已知的漏洞和弱点。</p></li><li><p>安全意识培训：对开发人员和系统管理员进行安全意识培训，使其了解服务器请求伪造（SSRF）攻击的风险，并学习如何防范和应对此类攻击。</p></li></ol><h2 id="点击劫持（Click-Hijacking）"><a href="#点击劫持（Click-Hijacking）" class="headerlink" title="点击劫持（Click Hijacking）"></a>点击劫持（Click Hijacking）</h2><p>攻击者在恶意站点实现了一个和信任站点极其相似的恶意页面，然后在恶意页面的上层覆盖了一个信任站点的合法页面（通常采用 iframe 的方式），并将合法页面设置成透明态，诱导用户点击页面，这时实际触发的是合法页面上的事件。用户的操作被劫持到攻击者事先设计好的恶意按钮或链接上，从而导致用户敏感信息泄露、实施转账、添加权限或者删除记录等敏感操作。</p><p>要防范点击劫持（Clickjacking）攻击，可以采取以下措施：</p><ol><li><p>使用X-Frame-Options头部：通过在HTTP响应头中设置X-Frame-Options头部，可以指示浏览器不允许将网页嵌入到iframe中，从而防止点击劫持攻击。可以设置X-Frame-Options头部为”deny”，表示不允许嵌入到任何iframe中，或者设置为”sameorigin”，表示只允许嵌入到同源的iframe中。</p></li><li><p>使用Content Security Policy（CSP）：CSP是一种安全策略，可以通过限制网页中允许加载的资源和执行的操作来防止点击劫持等攻击。可以在HTTP响应头中设置Content-Security-Policy头部，指定允许的资源来源和操作限制。</p></li><li><p>使用Frame Busting代码：在网页中嵌入Frame Busting代码，可以检测当前页面是否被嵌入到iframe中，并在检测到时跳转或显示警告信息，以防止点击劫持攻击。常见的Frame Busting代码包括JavaScript代码，例如使用window.top.location.href跳转到顶级窗口。</p></li><li><p>设置透明样式：通过将网页的样式设置为透明或与背景颜色相同，可以防止攻击者将网页隐藏在其他可见元素之下，从而防止点击劫持攻击。</p></li><li><p>用户教育和意识提高：提高用户对点击劫持攻击的认识和意识，教育用户不要点击可疑或未知来源的链接，以及注意网页的外观和行为是否正常。</p></li></ol><h2 id="点击欺骗（Click-Bait）"><a href="#点击欺骗（Click-Bait）" class="headerlink" title="点击欺骗（Click Bait）"></a>点击欺骗（Click Bait）</h2><p>攻击者通过伪装成合法网站或应用程序，诱使用户点击恶意链接或下载恶意文件。</p><p>防范点击欺骗的措施与防范点击劫持的方案相同。</p><h2 id="文件上传下载读取漏洞"><a href="#文件上传下载读取漏洞" class="headerlink" title="文件上传下载读取漏洞"></a>文件上传下载读取漏洞</h2><h3 id="任意文件上传（Unrestricted-File-Upload）"><a href="#任意文件上传（Unrestricted-File-Upload）" class="headerlink" title="任意文件上传（Unrestricted File Upload）"></a>任意文件上传（Unrestricted File Upload）</h3><p>任意文件上传漏洞是由于 Web 应用程序在实现文件上传功能时对上传的文件缺少必要的检查，使得攻击者可上传任意文件。利用该漏洞，攻击者可以直接上传 webshell （WebShell就是以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以将其称之为一种网页后门）、病毒、恶意脚本等各种危险文件，可能导致服务器权限被直接获取，从而危及整个系统的安全运行。</p><p>解决方案：</p><ul><li>对用户上传的文件后缀采用白名单进行限制，且重命名文件名</li><li>限定文件上传目录，且该目录不允许解析动态脚本文件</li><li>更新 Web 服务器版本，防止解析漏洞</li><li>上传接口严格控制权限和认证，文件上传前必须验证用户身份</li><li>服务器端对 HTTP 包头的 MIME Type 和上传文件的大小也需要进行检查，文件上传校验不但要验证文件包头信息是否匹配，而且要验证文件后缀名，最后还要限制合适的文件大小</li><li>使用对象存储存放用户上传的文件，与Web容器隔离</li></ul><h3 id="任意文件读取（Unrestricted-File-Read）"><a href="#任意文件读取（Unrestricted-File-Read）" class="headerlink" title="任意文件读取（Unrestricted File Read）"></a>任意文件读取（Unrestricted File Read）</h3><p>因 Web 程序提供的文件查看下载、附件下载等功能存在安全缺陷，导致通过修改文件路径就能够查看和下载任意文件，这些文件包括：源代码文件、系统文件（ <code>/etc/passwd</code>、<code>C:/boot.ini</code> 等）、配置文件（ <code>config.php</code> 、 <code>/WEB-INF/web.xml</code> 、 <code>web.config</code> 等），造成网站敏感信息泄露，严重危害网站安全。</p><p>解决方案：</p><ul><li>服务端过滤特殊字符，如：“.”、“/”、“\”</li><li>判断用户输入的参数的格式是否合法</li><li>指定文件类型白名单（如：jpg、gif、png、rar、zip、pdf、doc、xls、ppt等），禁止用户读取、下载白名单以外的文件</li><li>指定下载路径，禁止用户读取、下载指定目录以外的文件</li></ul><h3 id="任意文件包含（Unrestricted-File-Inclusion）"><a href="#任意文件包含（Unrestricted-File-Inclusion）" class="headerlink" title="任意文件包含（Unrestricted File Inclusion）"></a>任意文件包含（Unrestricted File Inclusion）</h3><p> Web 程序在引入文件时，由于传入的文件名没有经过合理的校验，或者检验被绕过，从而操作了预想之外的文件，导致意外的敏感信息泄露，甚至恶意的代码注入，使攻击者获取到网站服务器权限。</p><p>解决方案：</p><ul><li>关闭危险的文件打开函数</li><li>过滤特殊字符，如：“.”、“/”、“\”</li><li>检测文件内容</li></ul><h2 id="任意URL跳转（Open-Redirect）"><a href="#任意URL跳转（Open-Redirect）" class="headerlink" title="任意URL跳转（Open Redirect）"></a>任意URL跳转（Open Redirect）</h2><p>某些业务场景（例如登录跳转、导航前进后退）会接受不信任的用户输入，并返回一个 302 响应或者 URL 重定向。因此攻击者通过操控输入的 URL ，可以欺骗用户跳转到不安全的页面，造成钓鱼攻击。</p><p>要防范任意URL跳转（Open Redirect）攻击，可以采取以下措施：</p><ol><li><p>输入验证和过滤：对于用户提供的输入，特别是涉及到URL跳转的参数，应该进行严格的验证和过滤。确保输入的URL符合预期的格式和范围，只允许跳转到可信的域名或URL。</p></li><li><p>使用白名单：维护一个白名单，列出允许跳转的URL或域名。在进行URL跳转之前，检查目标URL是否在白名单中，如果不在则拒绝跳转。</p></li><li><p>验证跳转URL的合法性：在进行URL跳转之前，对目标URL进行验证，确保它是一个合法的URL。可以使用URL解析库或正则表达式来验证URL的格式和结构。</p></li><li><p>使用安全的跳转方法：使用安全的跳转方法，例如使用服务器端重定向（HTTP 301或302状态码）来进行跳转，而不是直接在页面中使用JavaScript进行跳转。服务器端重定向可以提供更好的控制和安全性。</p></li><li><p>显示警告信息：在进行URL跳转之前，向用户显示警告信息，告知他们即将离开当前网站，并提醒他们注意目标网站的可信度。这可以增加用户的警觉性，减少受到欺骗的风险。</p></li><li><p>用户教育和意识提高：提高用户对任意URL跳转攻击的认识和意识，教育用户不要点击可疑或未知来源的链接，以及注意URL的域名和路径是否与预期一致。<br>7.</p><h2 id="缓冲区溢出（Buffer-Overflow）"><a href="#缓冲区溢出（Buffer-Overflow）" class="headerlink" title="缓冲区溢出（Buffer Overflow）"></a>缓冲区溢出（Buffer Overflow）</h2></li></ol><p>缓冲区溢出是针对程序设计缺陷，向程序输入缓冲区写入使之溢出的内容（通常是超过缓冲区能保存的最大数据量的数据），从而破坏程序运行、并获取程序乃至系统的控制权的一种攻击行为。</p><p>要防范缓冲区溢出（Buffer Overflow）攻击，可以采取以下措施：</p><ol><li><p>输入验证和过滤：对于用户输入的数据，进行严格的验证和过滤，确保输入的数据符合预期的格式和范围。例如，限制输入的长度，检查输入是否包含非法字符或特殊字符。</p></li><li><p>使用安全的编程语言和库：选择使用安全的编程语言和库，这些语言和库提供了内置的缓冲区溢出保护机制，例如自动内存管理和边界检查。避免使用容易受到缓冲区溢出攻击的编程语言和库。</p></li><li><p>使用安全的函数和API：使用安全的函数和API来处理字符串和缓冲区操作，这些函数和API提供了边界检查和长度限制，可以防止缓冲区溢出。例如，使用安全的字符串拷贝函数（如strncpy）替代不安全的函数（如strcpy）。</p></li><li><p>使用堆栈保护技术：使用堆栈保护技术，例如栈溢出保护（Stack Overflow Protection）和地址空间布局随机化（Address Space Layout Randomization，ASLR）。这些技术可以在运行时检测和防止缓冲区溢出攻击。</p></li><li><p>定期更新和修补软件：及时更新和修补软件，包括操作系统、编译器和库文件。这些更新和修补通常包含了对已知缓冲区溢出漏洞的修复。</p></li><li><p>安全编码实践：遵循安全编码实践，例如避免使用不安全的函数、避免硬编码敏感信息、进行错误处理和异常处理等。这些实践可以减少缓冲区溢出攻击的风险。</p></li><li><p>安全测试和代码审查：进行安全测试和代码审查，以发现潜在的缓冲区溢出漏洞。使用静态代码分析工具和漏洞扫描工具来辅助发现和修复安全问题。</p></li></ol><h2 id="钓鱼攻击（Phishing-Attack）"><a href="#钓鱼攻击（Phishing-Attack）" class="headerlink" title="钓鱼攻击（Phishing Attack）"></a>钓鱼攻击（Phishing Attack）</h2><p>攻击者伪装成受信任的实体欺骗受害者，通过发送邮件或者文件的方式，诱骗受害者暴露密码或者执行恶意代码。</p><p>要防范钓鱼攻击（Phishing Attack），可以采取以下措施：</p><ol><li><p>提高用户教育和意识：教育用户如何识别和避免钓鱼攻击。提醒用户不要点击可疑的链接或附件，不要泄露个人敏感信息，以及注意验证网站的真实性。</p></li><li><p>验证网站的真实性：在访问网站时，确保网站使用了安全的HTTPS协议，并且具有有效的SSL证书。用户可以通过检查网站的URL是否以”https://“开头，并且浏览器是否显示了安全锁定图标来验证网站的真实性。</p></li><li><p>警惕钓鱼邮件和信息：警惕来自不明或可疑发送者的电子邮件、短信或社交媒体信息。避免点击其中的链接或下载附件，特别是要求提供个人信息或登录凭据的链接。</p></li><li><p>使用多因素身份验证：对于重要的账户和系统，启用多因素身份验证（MFA）。这样即使攻击者获得了用户名和密码，仍需要额外的身份验证因素才能登录。</p></li><li><p>定期更新和维护系统：及时更新和维护操作系统、应用程序和安全软件，以修复已知的漏洞和安全问题。这可以减少攻击者利用已知漏洞进行钓鱼攻击的机会。</p></li><li><p>使用反钓鱼工具和技术：使用反钓鱼工具和技术来检测和阻止钓鱼网站和恶意链接。这些工具可以帮助过滤和阻止钓鱼邮件、恶意网站和欺诈性链接。</p></li><li><p>加强网络安全意识：组织和企业应加强网络安全意识，培训员工如何识别和应对钓鱼攻击。建立报告机制，使员工能够及时报告可疑的钓鱼邮件、信息或网站。同时，组织和企业可以进行模拟钓鱼攻击，以测试员工的警惕性和应对能力，并提供相应的培训和指导。</p></li><li><p>使用安全浏览器和防病毒软件：选择使用安全性较高的浏览器，并及时更新浏览器和防病毒软件。这些工具可以帮助检测和阻止钓鱼网站、恶意链接和恶意软件。</p></li><li><p>实施安全策略和访问控制：制定和实施严格的安全策略和访问控制措施，限制对敏感信息和系统的访问。确保只有授权的人员能够访问和处理敏感数据。</p></li><li><p>监测和响应：建立监测和响应机制，及时检测和应对钓鱼攻击。使用安全事件和信息管理系统（SIEM）来监视网络活动，并采取适当的措施来应对和阻止钓鱼攻击。</p></li></ol><h2 id="逻辑漏洞（Logical-Vulnerabilities）"><a href="#逻辑漏洞（Logical-Vulnerabilities）" class="headerlink" title="逻辑漏洞（Logical Vulnerabilities）"></a>逻辑漏洞（Logical Vulnerabilities）</h2><p>攻击者利用应用程序中的逻辑错误或不完善的业务流程，绕过安全控制，执行未经授权的操作。</p><h2 id="信息泄露（Information-Disclosure）"><a href="#信息泄露（Information-Disclosure）" class="headerlink" title="信息泄露（Information Disclosure）"></a>信息泄露（Information Disclosure）</h2><p>攻击者通过获取应用程序或系统中的敏感信息，如配置文件、日志文件、错误消息等，来获取有关目标系统的有用信息。</p><h2 id="重放攻击（Replay-Attack）"><a href="#重放攻击（Replay-Attack）" class="headerlink" title="重放攻击（Replay Attack）"></a>重放攻击（Replay Attack）</h2><p>攻击者截获合法用户的请求，并将其重新发送给目标服务器，以执行未经授权的操作。</p><p>要防范重放攻击（Replay Attack），可以采取以下措施：</p><ol><li><p>使用加密和身份验证：使用加密技术来保护通信数据的机密性和完整性。同时，使用身份验证机制来验证通信双方的身份，确保只有合法的用户可以访问系统。</p></li><li><p>使用随机化和时间戳：在通信过程中引入随机化和时间戳，使每个请求都具有唯一性。这样可以防止攻击者重放之前的请求。</p></li><li><p>使用单次令牌（One-Time Token）：为每个请求生成一个单次令牌，确保每个令牌只能使用一次。这样即使攻击者截获了请求，也无法再次使用该令牌进行攻击。</p></li><li><p>使用挑战-响应认证：在通信过程中使用挑战-响应认证机制，其中服务器向客户端发送一个随机的挑战，客户端必须正确响应该挑战才能继续通信。这样可以防止攻击者重放之前的响应。</p></li><li><p>使用防重放令牌：在通信中使用防重放令牌，这些令牌具有短暂的有效期，并且每次请求都需要携带有效的令牌。服务器会验证令牌的有效性，如果令牌已过期或已使用过，则拒绝请求。</p></li><li><p>监测和记录请求：实施请求监测和记录机制，记录每个请求的相关信息，包括时间戳、来源IP地址等。这样可以检测到重放攻击的迹象，并采取相应的防御措施。</p></li><li><p>定期更新密钥和令牌：定期更新加密密钥和令牌，以增加攻击者破解的难度。使用强大的加密算法和安全的密钥管理机制，确保密钥的保密性和完整性。</p></li><li><p>使用防重放协议：在通信协议中使用防重放机制，例如使用序列号或时间戳来标识每个请求，确保每个请求都是唯一的。这样可以防止攻击者重放之前的请求。</p></li><li><p>强化网络安全防护：采用综合的网络安全防护措施，包括防火墙、入侵检测系统（IDS）、入侵防御系统（IPS）等，以及定期进行安全漏洞扫描和渗透测试，及时发现和修复系统中的安全漏洞。</p></li><li><p>监测和响应：建立实时监测和响应机制，及时检测和应对重放攻击。使用安全事件和信息管理系统（SIEM）来监视网络活动，并采取适当的措施来阻止和应对重放攻击。</p></li></ol><h2 id="逆向工程（Reverse-Engineering）"><a href="#逆向工程（Reverse-Engineering）" class="headerlink" title="逆向工程（Reverse Engineering）"></a>逆向工程（Reverse Engineering）</h2><p>攻击者通过分析应用程序的二进制代码或反编译应用程序，来获取有关应用程序的敏感信息或执行未经授权的操作。</p><p>要防范逆向工程（Reverse Engineering），可以采取以下措施：</p><ol><li><p>代码混淆（Code Obfuscation）：通过对源代码进行混淆，使其难以理解和分析。这可以包括重命名变量和函数名，删除或添加无用代码，以及使用特定的算法和技术来隐藏代码逻辑。</p></li><li><p>加密关键代码和敏感数据：对于包含关键算法或敏感数据的部分，可以使用加密技术进行保护。这样即使逆向工程成功，攻击者也无法轻易获取到明文的关键信息。</p></li><li><p>使用硬件保护：将关键代码和数据存储在安全的硬件模块中，如安全芯片或加密USB设备。这样可以增加逆向工程的难度，因为攻击者需要物理访问硬件才能进行分析。</p></li><li><p>使用反调试和反动态分析技术：在应用程序中集成反调试和反动态分析技术，以阻止攻击者使用调试器或动态分析工具来分析应用程序的执行过程。</p></li><li><p>强化应用程序的安全性：采用安全编码实践，如输入验证、输出编码、访问控制等，以防止常见的安全漏洞，如缓冲区溢出、代码注入等。同时，定期进行安全审计和漏洞扫描，及时修复发现的安全漏洞。</p></li><li><p>使用软件保护工具：使用专业的软件保护工具，如代码加壳、反调试工具、代码签名等，以增加逆向工程的难度。</p></li><li><p>法律保护：了解并遵守相关的知识产权和法律法规，如软件许可协议、版权保护等。在必要的情况下，可以采取法律手段来保护自己的知识产权。</p></li></ol><h2 id="安全加固手段"><a href="#安全加固手段" class="headerlink" title="安全加固手段"></a>安全加固手段</h2><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>详见 <a href="/blog/2021/04/22/HTTP小抄/#HTTPS">HTTPS</a></p><p>在用户请求资源时，如果请求的是 http 资源，则 302 重定向到 https 资源，并添加 <code>Strict-Transport-Security</code> 要求强制使用 HTTPS 协议。</p><h3 id="输入验证（Validation）"><a href="#输入验证（Validation）" class="headerlink" title="输入验证（Validation）"></a>输入验证（Validation）</h3><p>前端与后端均需进行输入验证，对用户的输入表单参数、URL参数、HTTP头进行校验。<br>需要校验参数类型，长度，范围，字符集合是否符合要求，同时需要根据业务类型校验参数。<br>常见的业务类型包括：日期、域名、ip、邮箱地址、用户名、手机号（带国际区号）、用户ID等。<br>对SQL注入、XSS、命令注入中常见的危险字符 <code>&lt;&gt;&#39;&quot;%|;&amp;/\</code> 进行过滤或实体编码。<br>拼接URL时需要进行实体编码。<br>保证前后端校验方法一致。</p><h3 id="数据脱敏（Data-Mask）"><a href="#数据脱敏（Data-Mask）" class="headerlink" title="数据脱敏（Data Mask）"></a>数据脱敏（Data Mask）</h3><p> API 接口或 HTTP 服务如果没有对敏感信息进行脱敏输出，可能会被嗅探收集、批量爬取，泄漏业务核心数据。</p><p>需要脱敏的数据包括姓名、手机号、身份证号、银行卡号、邮箱、营业执照号、社交媒体账号、工资流水、通信记录等。</p><h3 id="接口频率限制（Frequency-Limiting）"><a href="#接口频率限制（Frequency-Limiting）" class="headerlink" title="接口频率限制（Frequency Limiting）"></a>接口频率限制（Frequency Limiting）</h3><p>接口需要限制请求频率，防止对接口数据进行爬取或者对登录接口进行暴力破解。</p><p>核心数据接口要求权限认证。</p><h3 id="加密（Encryption）"><a href="#加密（Encryption）" class="headerlink" title="加密（Encryption）"></a>加密（Encryption）</h3><ol><li>密码在设定时要求二次输入验证，防止用户手动输入错误，二次输入禁止复制粘贴</li><li>在传输过程中可以进行 base-64 编码，防止在传输之前（例如devtools中）被查看</li><li>在存储时需要加盐加密，知名的不安全算法包括 MD5、SHA-1</li></ol><h3 id="多因子认证（Multi-Factor-Authentication）"><a href="#多因子认证（Multi-Factor-Authentication）" class="headerlink" title="多因子认证（Multi Factor Authentication）"></a>多因子认证（Multi Factor Authentication）</h3><p>多因子认证是用两种及两种以上的条件对用户进行认证的方法。通常将口令和实物（如U盾、密码器、手机短信、指纹等）结合起来，以有效提升安全性。</p><h3 id="验证码（Verification-Code）"><a href="#验证码（Verification-Code）" class="headerlink" title="验证码（Verification Code）"></a>验证码（Verification Code）</h3><p>验证码又被称为 全自动区分计算机和人类的图灵测试（CAPTCHA，Completely Automated Public Turing test to tell Computers and Humans Apart）是一种区分用户是计算机还是人的公共全自动程序，主要为了防止机器的暴力破解和批量提交。常见的人机识别方法包括文本识别验证、图片点选验证、滑块拼图验证、用户行为验证等。</p><h3 id="代码混淆（Code-Obfuscation）"><a href="#代码混淆（Code-Obfuscation）" class="headerlink" title="代码混淆（Code Obfuscation）"></a>代码混淆（Code Obfuscation）</h3><p>通过对源代码进行混淆，使其难以理解和分析。这包括重命名变量和函数名、添加无用代码和逻辑、修改代码结构等。代码混淆可以增加逆向工程的难度，使攻击者难以理解和还原源代码。</p><h3 id="Cookie安全"><a href="#Cookie安全" class="headerlink" title="Cookie安全"></a>Cookie安全</h3><p>详见 <a href="/blog/2021/12/29/HTTP-Cookie/">Cookie</a></p><p>解决方案：</p><ol><li>添加 HttpOnly 标志只允许服务器进行读取，防止xss攻击</li><li>添加 Secure 标志，采用 HTTPS 请求，防止被中间人获取</li><li>为了防止 Cookie 被篡改，服务器通常可以将 会话标志符 存储在 Cookie 中，而不是直接存储会话信息。这样，即使攻击者获取到了 Cookie 内容，如果不知道会话标志符编码解码规则，就无法进行修改。</li><li>如果站点使用 Cookie 对用户进行身份验证，则每当用户进行身份验证时，它都应重新生成并重新发送会话 Cookie，即使会话 Cookie 已经存在。</li><li>服务器不应该在同一主机的不同端口上运行互不信任的服务。</li><li>服务器不应该在同一主机的不同路径上运行互不信任的服务。</li></ol><h3 id="HTTP-header-设置"><a href="#HTTP-header-设置" class="headerlink" title="HTTP header 设置"></a>HTTP header 设置</h3><p>解决方案：</p><ol><li>通过设置 <code>X-Frame-Option</code> 告知浏览器该页面是否可以被嵌入，减少被 点击劫持 攻击的可能</li><li>通过设置 <code>Content-Security-Policy</code> 告知浏览器该页面的内容安全策略，减少被 XSS 攻击的可能</li><li>通过设置 <code>Referrer-Policy</code> 监管访问来源信息，减少来源地址探测</li><li>通过设置 <code>Cross-Origin-Opener-Policy</code> <code>Cross-Origin-Resource-Policy</code> <code>Cross-Origin-Embedder-Policy</code> 来减少跨源跳转/嵌入时的可能攻击</li><li>添加 csrf token ，减少被 CSRF 攻击的可能</li></ol><h3 id="服务器安全-1"><a href="#服务器安全-1" class="headerlink" title="服务器安全"></a>服务器安全</h3><ol><li>及时更新和修补漏洞</li><li>防火墙和入侵检测系统（IDS/IPS）</li><li>安全审计和日志记录</li><li>定期安全评估和渗透测试</li></ol><h3 id="运维安全"><a href="#运维安全" class="headerlink" title="运维安全"></a>运维安全</h3><ol><li>灾备</li><li>运维日志记录</li><li>运维行为审计</li><li>运维账号、权限控制</li><li>定期安全培训</li></ol><h3 id="法律保护"><a href="#法律保护" class="headerlink" title="法律保护"></a>法律保护</h3><p>中国与数据安全和网络安全有关的法律法规包括：</p><ol><li><p>《中华人民共和国网络安全法》：该法于2017年6月1日正式实施，旨在保护网络安全，维护国家安全和社会公共利益。它规定了网络运营者的责任和义务，要求网络运营者采取措施保护用户信息和网络数据的安全。</p></li><li><p>《中华人民共和国个人信息保护法》：该法于2021年11月1日正式实施，旨在保护个人信息的合法收集、使用和处理。它规定了个人信息的定义、个人信息处理者的义务和责任，以及个人信息泄露和滥用的处罚措施。</p></li><li><p>《中华人民共和国电子商务法》：该法于2019年1月1日正式实施，旨在规范电子商务活动，保护消费者权益和网络交易安全。它规定了电子商务经营者的责任和义务，要求保护用户的个人信息和交易数据安全。</p></li><li><p>《中华人民共和国反垄断法》：该法于2008年8月1日正式实施，旨在维护市场竞争秩序，保护消费者权益。它规定了反垄断行为的禁止和处罚，包括滥用市场支配地位、垄断协议和滥用知识产权等行为。</p></li><li><p>《中华人民共和国商业秘密法》：该法于2018年7月1日正式实施，旨在保护商业秘密的合法权益。它规定了商业秘密的定义、保护范围和保护措施，以及商业秘密的侵权行为和法律责任。</p></li><li><p>《中华人民共和国计算机信息系统安全保护条例》：该条例于1994年12月1日正式实施，旨在保护计算机信息系统的安全。它规定了计算机信息系统的安全保护要求、安全管理措施和安全事件的处理程序。</p></li><li><p>《中华人民共和国反恶意程序条例》：该条例于2019年3月1日正式实施，旨在防止和打击恶意程序的传播和使用。它规定了恶意程序的定义、禁止行为和处罚措施，以及恶意程序的防范和处理措施。</p></li><li><p>《中华人民共和国数据安全法》：该法自2021年9月1日起施行，该法旨在加强对数据的保护和管理，维护国家安全和社会公共利益。它强调了数据安全的重要性，要求各方主体加强数据安全管理，保护个人信息和重要数据的安全。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器架构与基本原理</title>
      <link href="/blog/2022/01/04/FE-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
      <url>/blog/2022/01/04/FE-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是浏览器"><a href="#什么是浏览器" class="headerlink" title="什么是浏览器"></a>什么是浏览器</h2><p>浏览器是用来检索、展示以及传递Web信息资源的应用程序。  </p><h2 id="浏览器有哪些"><a href="#浏览器有哪些" class="headerlink" title="浏览器有哪些"></a>浏览器有哪些</h2><p>现如今常见的浏览器有 <a href="https://www.google.cn/chrome/">Chrome</a> 、<a href="https://www.mozilla.org/zh-CN/firefox/new/">Firefox</a> 、<a href="https://www.microsoft.com/en-us/edge">Edge</a>(Internet Exporler)、 <a href="https://www.apple.com/safari/">Safari</a>、 <a href="https://www.opera.com/">Opera</a>。  </p><p>中国国内的话，还有 <a href="https://browser.qq.com/">QQ浏览器</a>、<a href="https://browser.360.cn/">360浏览器</a>、<a href="https://ie.sogou.com/">搜狗浏览器</a>、<a href="https://www.uc.cn/">uc浏览器</a>。  </p><p>有一些浏览器只在特定的环境下比较流行，比如<a href="https://github.com/KDE/konqueror">Konqueror</a> 、<a href="https://gitlab.gnome.org/GNOME/epiphany">Epiphany</a> 、<a href="https://github.com/kurtchen/Lynx">Lynx</a> 等。  </p><span id="more"></span><h2 id="浏览器历史"><a href="#浏览器历史" class="headerlink" title="浏览器历史"></a>浏览器历史</h2><p>1990年，<a href="https://zh.wikipedia.org/wiki/%E8%92%82%E5%A7%86%C2%B7%E4%BC%AF%E7%BA%B3%E6%96%AF-%E6%9D%8E">蒂莫西·约翰·伯纳斯-李爵士(Sir Timothy John Berners-Lee)</a> 开发了第一个网页浏览器 <a href="https://zh.wikipedia.org/wiki/WorldWideWeb">WorldWideWeb</a>，后改名为 Nexus 。 WorldWideWeb 浏览器支持早期的 HTML ，功能比较简单，只能支持文本、简单的样式表、视频、音频、图片等资源的显示。</p><p>1993年，<a href="https://zh.wikipedia.org/wiki/%E9%A9%AC%E5%85%8B%C2%B7%E5%AE%89%E5%BE%B7%E6%A3%AE">马克·安德里森(Marc Lowell Andreessen)</a> 领导的团开发了一个真正有影响力的浏览器 <a href="https://zh.wikipedia.org/wiki/Mosaic">Mosaic</a>，这就是后来世界上最流行的浏览器 <a href="https://zh.wikipedia.org/wiki/Netscape_Navigator">Netscape Navigator</a>。</p><p>1995年，Microsoft 推出了闻名于世的浏览器 <a href="https://zh.wikipedia.org/wiki/Internet_Explorer">Internet Explorer</a>。</p><p>1998年，Netscape 公司开放 Netscape Navigator 源代码，成立了 Mozilla 基金会。</p><p>2003年，Apple 公司发布了 Safari 浏览器。</p><p>2004年，Netscape 公司发布了著名的开源浏览器 <a href="https://zh.wikipedia.org/wiki/Firefox">Mozilla Firefox</a>。</p><p>2005年，Apple 公司开源了浏览器中的核心代码，基于此发起了一个新的开源项目 <a href="https://webkit.org/">WebKit</a>。</p><p>2008年， Google 公司以 WebKit 为基础，创建了一个新的浏览器项目 <a href="https://chromium.googlesource.com/chromium/">Chromium</a>。以 Chromium 为基础，谷歌发布了 Chrome 浏览器。至于这两者的关系，可以简单地理解为： Chromium 为实验版，具有众多新特性； Chrome 为稳定版。</p><h2 id="浏览器功能与特性"><a href="#浏览器功能与特性" class="headerlink" title="浏览器功能与特性"></a>浏览器功能与特性</h2><p>现代浏览器主要包含如下几部分的功能与特性：</p><ul><li><strong>网络</strong> 浏览器通过网络模块下载各种资源，如：HTML文档、JavaScript代码、样式表、图片、音频视频文件等。 网络模块是浏览器最重要的模块之一。</li><li><strong>网页浏览</strong> 浏览器最核心的功能。浏览器通过网络下载资源，并从资源管理器获得资源，然后将其转化为可视化结果。</li><li><strong>资源管理</strong> 浏览器通过高效的管理机制来管理网络资源和本地资源。比如如何避免重复下载资源、缓存资源等。</li><li><strong>多页面管理</strong> 浏览器支持多页面浏览，因此支持多页面同时加载。浏览器需要多页面管理机制来解决例如多页面的相互影响和安全等问题。</li><li><strong>插件和扩展</strong> 现代浏览器的重要特征。插件可以用来显示网页特定内容；扩展则是增加浏览器新功能的软件或压缩包。</li><li><strong>账户和同步</strong> 现代软件的普遍特性。浏览器将用户的浏览信息，例如历史记录、书签等信息同步到服务器，提供多系统下的统一体验。</li><li><strong>安全机制</strong> 现代软件的重要特性。浏览器的安全机制需要提供一个安全的浏览环境，例如：避免用户信息被窃取或破坏、防止浏览器被恶意代码攻破等。</li><li><strong>开发者工具</strong> 开发者工具是浏览器提供给网页开发者的工具，可以帮助审查HTML元素、调试JavaScript代码、改善网页性能等。</li></ul><h2 id="浏览器系统架构"><a href="#浏览器系统架构" class="headerlink" title="浏览器系统架构"></a>浏览器系统架构</h2><p>不同的浏览器在结构方面虽然有所差异，但是整体的设计理念是相似的。因此，可以抽象得到如下图所示的参考结构：</p><p><img src="/blog/static/imgs/browser/browser-architecture.png" alt="inner-browser-architecture"></p><p>浏览器的抽象分层结构图中将浏览器分成了以下8个子系统：</p><h3 id="用户界面（User-Interface）"><a href="#用户界面（User-Interface）" class="headerlink" title="用户界面（User Interface）"></a>用户界面（User Interface）</h3><p>用户界面主要包括工具栏、地址栏、前进/后退按钮、书签菜单、可视化页面加载进度、下载管理、首选项、打印等。<br>除了浏览器主窗口显示请求的页面之外，其他显示的部分都属于用户界面。<br>用户界面还可以与桌面环境集成，以提供浏览器会话管理或与其他桌面应用程序通信。<br>浏览器的用户界面并没有任何正式的规范，但是经过多年来的最佳实践自然发展以及彼此之间相互模仿，浏览器的用户界面有很多彼此相同的元素，其中包括：  </p><ul><li>用来输入 URI 的地址栏</li><li>前进和后退按钮</li><li>书签（收藏）设置选项</li><li>用于刷新和停止加载当前文档的刷新和停止按钮</li><li>用于返回主页的主页按钮</li></ul><h3 id="浏览器引擎（Browser-Engine）"><a href="#浏览器引擎（Browser-Engine）" class="headerlink" title="浏览器引擎（Browser Engine）"></a>浏览器引擎（Browser Engine）</h3><p>浏览器引擎是一个可嵌入的组件，其为渲染引擎提供高级接口。<br>浏览器引擎可以加载一个给定的URI，并支持诸如：前进/后退/重新加载等浏览操作。<br>浏览器引擎提供查看浏览会话的各个方面的挂钩，例如：当前页面加载进度、JavaScript alert。<br>浏览器引擎还允许查询/修改渲染引擎设置。  </p><h3 id="渲染引擎（Rendering-Engine）"><a href="#渲染引擎（Rendering-Engine）" class="headerlink" title="渲染引擎（Rendering Engine）"></a>渲染引擎（Rendering Engine）</h3><p>渲染引擎为指定的URI生成可视化的表示。<br>渲染引擎能够显示 HTML 和 XML 文档，可选择 CSS 样式，以及嵌入式内容（如图片）。<br>渲染引擎能够准确计算页面布局，可使用”回流(重排)/重绘（reflow/repaint）”算法逐步调整页面元素的位置。  </p><h3 id="网络（Networking）"><a href="#网络（Networking）" class="headerlink" title="网络（Networking）"></a>网络（Networking）</h3><p>网络系统实现 HTTP(HTTPS) 和 FTP(SFTP) 等文件传输协议。<br>网络系统可以在不同的字符集之间进行转换，为文件解析 MIME 媒体类型。<br>网络系统可以实现最近检索资源的缓存功能。  </p><p>Firefox 使用了 Necko</p><h3 id="JavaScript解释器（JavaScript-Interpreter）"><a href="#JavaScript解释器（JavaScript-Interpreter）" class="headerlink" title="JavaScript解释器（JavaScript Interpreter）"></a>JavaScript解释器（JavaScript Interpreter）</h3><p>JavaScript 解释器能够解释并执行嵌入在网页中的 JavaScript （又称ECMAScript）代码。   </p><p>Firefox 使用了 SpiderMonkey , Chrome 使用了 V8</p><h3 id="XML解析器（XML-Parser）"><a href="#XML解析器（XML-Parser）" class="headerlink" title="XML解析器（XML Parser）"></a>XML解析器（XML Parser）</h3><p>XML 解析器可以将 XML 文档（通常是 HTML）解析成 文档对象模型（Document Object Model，DOM）树。<br>XML解析器是浏览器架构中复用最多的子系统之一，几乎所有的浏览器实现都利用现有的 XML 解析器，而不是从头开始创建自己的 XML 解析器。  </p><p>Firefox 使用了 <a href="https://github.com/libexpat/libexpat">Expat</a> , Chrome 使用了 <a href="https://github.com/GNOME/libxml2">libXML</a></p><h3 id="显示后端（Display-Backend）"><a href="#显示后端（Display-Backend）" class="headerlink" title="显示后端（Display Backend）"></a>显示后端（Display Backend）</h3><p>显示后端用来绘制基础组件例如组合框和窗口。它抽象了非特定平台的通用接口，在底层会使用操作系统接口方法。</p><p>Firefox 使用了 <a href="https://github.com/GNOME/gtk">GTK</a></p><h3 id="数据持久层（Data-Persistence）"><a href="#数据持久层（Data-Persistence）" class="headerlink" title="数据持久层（Data Persistence）"></a>数据持久层（Data Persistence）</h3><p>数据持久层将与浏览会话相关联的各种数据存储在硬盘上。这些数据可能是诸如：书签、工具栏设置等这样的高级数据，也可能是诸如：Cookie，安全证书、缓存等这样的低级数据。</p><h2 id="浏览器进程架构"><a href="#浏览器进程架构" class="headerlink" title="浏览器进程架构"></a>浏览器进程架构</h2><p>早期的浏览器使用单进程的架构，整个浏览器程序在一个进程中运行，用不同的线程来执行不同部分的功能，比如用网络线程来处理网络请求，用插件线程来运行插件，用渲染线程渲染出整个页面。这会有什么问题呢？首先当其中某个线程崩溃，整个浏览器进程就会全部崩掉。其次因为线程可以共享进程资源。所以插件就有可能获取到浏览器运行过程中的数据，就有可能让某些恶意插件获取到网站的敏感数据。</p><p>但是慢慢随着技术的发展，web应用的复杂性和重要性都在提升，浏览器技术也需要提升来支撑新的发展。渐渐演化出了多进程的浏览器架构。Chrome/Chromuim 就是基于多进程的架构。在 Chrome 里点击右上角的菜单按钮后选择“更多工具–任务管理器”可以看到浏览器当前使用的进程。</p><p>浏览器中的进程：</p><p><img src="/blog/static/imgs/browser/browserprocess.png" alt="inner-browser-process"></p><p>Chrome 中一些进程和它们的作用如下：</p><ul><li>浏览器主进程（Browser Process）：控制浏览器中导航，书签，按钮等可视区域；控制网络请求，文件读写，数据存储等功能；控制子进程的管理、调配和通信。</li><li>渲染进程（Renderer Process)：控制显示网站tab内的所有内容。</li><li>插件进程（Plugin Process）：控制网站使用的所有插件。</li><li>GPU进程（GPU Process）：与其他进程隔离地处理GPU任务。</li><li>其它进程（Other Process）：包括扩展进程（Extension）和开发者工具进程（DevTools）或其他服务，比如声音服务（Audio Service）、网络服务（Network Service）、存储服务（Storage Service）等。</li></ul><p><img src="/blog/static/imgs/browser/processfunction.png" alt="inner-browser-process-function"></p><h3 id="多进程的好处与问题"><a href="#多进程的好处与问题" class="headerlink" title="多进程的好处与问题"></a>多进程的好处与问题</h3><p>多进程架构的好处：</p><ul><li>避免一个tab页面中的崩溃影响到所有的tab页面。</li><li>安全性和沙盒，因为操作系统提供了限制进程权限的方法，因此浏览器可以对某些功能中的某些进程进行沙箱处理。</li></ul><p>多进程的问题：</p><ul><li>每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），启动多个进程后，浏览器会消耗更多的内存资源。</li></ul><p>Chrome 优化内存的方法：</p><ul><li>Chrome 根据设备的硬件性能限制了可启动的进程数。一旦达到限制后，Chrome 会把在一个网站中的tab页面在同一进程中运行。</li><li>将浏览器程序的每个部分作为服务运行，这样可以方便拆分或者合并进程。当 Chrome 在性能好的硬件设备上运行时，它可能会将每个服务拆分为不同的进程，从而提供更高的稳定性，但是如果在资源受限的设备上， Chrome 会将服务整合到一个进程中，从而节省了内存。</li></ul><h3 id="Chromium-进程模型"><a href="#Chromium-进程模型" class="headerlink" title="Chromium 进程模型"></a>Chromium 进程模型</h3><p>Chromium 支持四种不同的模型，它们影响浏览器分配页面给渲染进程的行为。下面对这几种模型进行介绍：</p><ol><li>process-per-site-instance: 为访问网站的每个实例创建一个渲染进程。</li></ol><p>首先说一下是什么是网站实例，网站实例是指来自同一网站的连接的页面集合。如果两个页面可以在 JavaScript 代码中获得彼此的引用，就可以把他们认为是连接在一起的。</p><p>这种模型的优点有:</p><ul><li>隔离来自不同网站的内容。页面可以和其他发生错误的页面隔离开来。</li><li>隔离同一网站的不同tab。在不同tab中独立访问同一网站将创建不同的进程，可以防止失败的实例影响其他实例。</li></ul><p>缺点是:</p><ul><li>更多的内存开销。因为这种模型会创建比较多的渲染进程，虽然可以增加稳定性，但同时也会增加内存开销。</li><li>实施起来比较复杂。需要复杂的逻辑来支持在网站之间导航时在tab中交换进程，以及处理类似 postMessage 等 JavaScript API。</li></ul><ol start="2"><li>process-per-site: 将不同的网站彼此隔离，但是将同一网站的所有实例组合到同一进程中。</li></ol><p>这种模型的优点有:</p><p>1）隔离来自不同站点的内容。与 process-per-site-instance 模型一样，来自不同站点的页面将不会共享，同时会有更少的内存开销。但与 process-per-site-instance 和 process-per-tab 模型相比，这种模型创建的并发进程可能更少。</p><p>缺点是:</p><p>1）可能会导致渲染进程过大。比如 google.com 之类的网站托管着各种各样的应用程序，这些应用程序可以在浏览器中同时打开，所有这些应用程序都将在同一渲染进程中渲染。因此，这些应用程序中的资源争用和故障可能会影响许多tab，从而使浏览器的响应性降低。<br>2）实施起来比较复杂。像 process-per-site-instance 模型一样，这需要用于在导航期间交换流程并代理一些 JavaScript 交互的逻辑。</p><ol start="3"><li>process-per-tab: 对每一个tab，用一个渲染进程进行渲染。</li></ol><p>和 process-per-site-instance 和 process-per-site 模型在创建渲染器进程时都会考虑内容的来源不同 ， process-per-tab 模型将一个渲染进程专用于每个tab。所以它的优点是：</p><p>1）简单易懂。每个选项卡都有一个专用的渲染器进程，该进程不会随时间变化。</p><p>但是它的缺点为：</p><p>1）网站页面之间的共享可能有问题。例如用户将当前tab中的网站导航到其他网站，则新页面将与原先浏览实例中的页面共享。</p><p>需要注意的是， Chromium 在 process-per-tab 模型中强制执行安全性时，仍然会强制执行进程交换。例如，不允许普通网页与特权页面（如“设置”和“新标签页”）共享进程。这样就会导致这种模型在实践中并没有比 process-per-site-instance 简单得多。</p><ol start="4"><li>single process: 单进程模型，浏览器和渲染引擎都在单个进程中运行。</li></ol><p>单进程模型为测量多进程模型性能提供了一个标准。它不是安全或可靠的模型，因为任何渲染线程崩溃都将导致整个浏览器崩溃。它用于测试和开发目的，并且可能包含模型中没有的错误。</p><h2 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h2><p>浏览器内核(Browser Core) 在不同的浏览器中定义并不完全一致，但一般包括 Render Engine 和 Browser Engine 的部分，有些也会把 User Interface 和 Data Persistene 也算上。  </p><table><thead><tr><th>公司</th><th>浏览器</th><th>浏览器内核</th><th>js 引擎</th></tr></thead><tbody><tr><td><a href="https://www.microsoft.com/">Microsoft</a></td><td><a href="https://www.microsoft.com/en-us/download/internet-explorer.aspx">Internet Exporler(IE)</a> -&gt; <a href="https://www.microsoft.com/zh-cn/edge">Edge</a></td><td>Trident(MSHTML，IE11-)-&gt;EdgeHTML/MSHTML(Edge)-&gt;Blink（基于WebKit）</td><td>JScript（IE3.0-IE8.0） -&gt; <a href="https://github.com/chakra-core/ChakraCore">ChakraCore</a>（IE9+之后）-&gt; v8</td></tr><tr><td><a href="https://www.google.com/">Google</a></td><td><a href="https://www.google.com/intl/zh-CN/chrome/">Chrome</a>/<a href="https://github.com/chromium/chromium">Chromium</a></td><td>WebKit-&gt;Blink（28.0.1469.0+，基于Webkit）</td><td><a href="https://github.com/v8/v8">v8</a></td></tr><tr><td><a href="https://www.apple.com/">Apple</a></td><td><a href="https://www.apple.com.cn/safari/">Safari</a></td><td><a href="https://github.com/WebKit/WebKit">WebKit</a></td><td><a href="https://trac.webkit.org/wiki/JavaScriptCore">JavaScriptCore</a>-&gt;SquirrelFish（Nitro）</td></tr><tr><td><a href="https://www.mozilla.org/">Mozilla</a></td><td><a href="http://www.firefox.com.cn/">Firefox</a></td><td><a href="https://github.com/mozilla/gecko-dev">Gecko</a></td><td>SpiderMonkey（1.0-3.0）-&gt; TraceMonkey（3.5-3.6）-&gt; JägerMonkey（4.0-）-&gt; IonMonkey (18.0+) -&gt; OdinMonkey（22.0+）</td></tr><tr><td><a href="https://www.opera.com/">Opera</a></td><td><a href="https://www.opera.com/zh-cn">Opera</a></td><td>Elektra(4-6)-&gt;Presto(7.0-12.18)-&gt;WebKit-&gt;Blink（基于Webkit）</td><td>Linear A（4.0-6.1）-&gt; Linear B（7.0-9.2）-&gt; Futhark（9.5-10.2）-&gt; Carakan（10.5-）-&gt; V8</td></tr></tbody></table><h2 id="浏览器工作流程（页面加载过程）"><a href="#浏览器工作流程（页面加载过程）" class="headerlink" title="浏览器工作流程（页面加载过程）"></a>浏览器工作流程（页面加载过程）</h2><p>当地址栏输入一个 URL 之后，浏览器会先将 URL 解析成 IP 地址，接着发送 HTTP 请求到对应的 IP 地址请求资源，得到网页资源后，根据类型进行解析，HTML资源将会被解析成 DOM 树，接着将 CSS 样式加载 DOM 树中，生成 Render 树，最后遍历 Render 树来显示内容。</p><p>大体上可以分为两块，一部分是网络获取资源，另一部分是渲染。</p><h3 id="网络加载"><a href="#网络加载" class="headerlink" title="网络加载"></a>网络加载</h3><ol><li>URI 解析</li></ol><p>对地址栏的输入进行解析，如果是一个合法的 URI 则根据协议类型进行对应处理，如果不是，通常现代浏览器会把输入作为搜索关键词，调用对应的搜索引擎进行搜索。若是 HTTP（HTTPS）协议的 URI 则尝试发起 HTTP（HTTPS） 请求。</p><p>有关 URI 详情可见 <a href="/blog/2021/04/22/HTTP小抄/#URI-统一资源标志符">URI-统一资源标志符</a></p><ol start="2"><li>判断是否使用缓存</li></ol><p>浏览器缓存策略依托于 HTTP 协议，故又称 HTTP 缓存策略，详见<a href="/blog/2021/04/23/HTTP-缓存/">HTTP 缓存策略</a></p><p><img src="/blog/static/imgs/browser/cacheprocess.png" alt="inner_cache-process"></p><ol start="3"><li>DNS 查找</li></ol><p>浏览器根据 DNS 协议查询 URL 域名对应的 IP 地址，在某个路由表查到结果后就会返回，不再继续继续查询。如果在根域名服务器还查不到 IP 地址，则查询失败。</p><p><img src="/blog/static/imgs/browser/dnsprocess.png" alt="inner_dns-process"></p><ol start="4"><li>浏览器向服务器发送 HTTP 请求</li></ol><p>浏览器与服务器建立 TCP 连接后向服务器发送网络请求。这个过程基于 TCP/IP 协议族，此协议族可分为四层，每层都会对数据进行封装，其大致过程如下图所示:  </p><p><img src="/blog/static/imgs/browser/httpprocess.png" alt="inner_http-process"></p><ol start="5"><li>服务器处理请求</li></ol><p>服务器处理请求的过程因具体实现而异，但大致如下：  </p><p><img src="/blog/static/imgs/browser/serverprocess.png" alt="inner_server-process"></p><ol start="6"><li>浏览器接受响应</li></ol><p>浏览器收到服务器的响应后对其进行分析、处理。首先会查看 <a href="/blog/2018/11/02/HTTP-状态码/">HTTP 状态码</a>，收到 404 会显示资源不存在的页面、收到 301 会重定向到另一个 URL，各个返回码的含义可参考相关 <a href="https://www.rfc-editor.org/rfc/inline-errata/rfc2616.html">RFC2616</a> 。如果返回码正常（例如收到了200），则判断是否需要先解压，如果需要则解压，否则根据资源的 MIME 解析内容。  </p><p>浏览器对相应 HTTP状态码 的响应可以见 <a href="/blog/2018/11/02/HTTP-状态码/">HTTP 状态码</a> 。  </p><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>渲染引擎的作用是在浏览器的屏幕上显示请求的内容。渲染引擎可显示 HTML 和 XML 文档与图片，甚至可以通过插件支持PDF文档等等。这里，我们将集中介绍他的主要用途：显示使用 CSS 格式化的 HTML 内容和图片。  </p><p>不同浏览器渲染引擎渲染的整体流程是基本相同的，只是其中的关键步骤术语稍有不同。  </p><p>webkit 渲染流程如下：<br><img src="/blog/static/imgs/browser/webkitflow.png" alt="inner-webkitflow"></p><p>gecko 渲染流程如下：<br><img src="/blog/static/imgs/browser/geckoflow.jpeg" alt="inner-geckoflow"></p><p>下图所示为渲染引擎的抽象工作流程，以及各个步骤所对应的模块：<br><img src="/blog/static/imgs/browser/renderflow.png" alt="inner-renderflow"></p><p>主要有以下几个步骤：</p><ol><li>将 HTML 解析成结构化的 <a href="https://www.w3.org/DOM/DOMTR">DOM</a> （文档对象模型 Document Object Model） 树（Parsing HTML to Construct DOM Tree）<br>渲染引擎使用 HTML 解析器解析 HTML 文档，将各个 HTML 元素逐个转化成 DOM 节点，从而生成 DOM 树。使用 Javascript 解释器解释 Javascript 脚本，变更 DOM 树。同时，渲染引擎使用 CSS 解析器解析外部 CSS 文件以及 HTML 元素中的样式规则生成 CSS Rule 树（也称为CSSOM，CSS Object Model）。</li><li>渲染树构建（Render Tree construction）<br>渲染引擎使用第1步 CSS 解析器解析得到的 CSSOM，将其附着到 DOM 树上，从而构成渲染树（Gecko 中称为 框架树 Frame Tree）。渲染树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。</li><li>渲染树布局（Layout of Render Tree）<br>渲染树构建完毕之后，进入本阶段进行“布局（Layout or Reflow，中文称回流或重排）”，也就是为每个节点分配一个应出现在屏幕上的确切坐标。</li><li>渲染树绘制（Painting Render Tree）<br>渲染引擎将遍历渲染树，并调用显示后代将每个节点绘制（Paint）出来。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://grosskurth.ca/papers/browser-refarch.pdf">A Reference Architecture for Web Browsers</a></p><p><a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%A1%B5%E6%B5%8F%E8%A7%88%E5%99%A8">wikipedia-web browser</a></p><p><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/">浏览器的工作原理：新式网络浏览器幕后揭秘</a></p><p><a href="http://chuquan.me/2018/01/21/browser-architecture-overview/">现代浏览器工作原理</a></p><p>《Inside look at modern web browser》</p>]]></content>
      
      
      
        <tags>
            
            <tag> design </tag>
            
            <tag> browser </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器内容安全策略CSP</title>
      <link href="/blog/2021/12/31/HTTP-%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5/"/>
      <url>/blog/2021/12/31/HTTP-%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<p>内容安全策略 (Content Security Policy) 是一个额外的安全层，用于检测并削弱某些特定类型的攻击(尤其是XSS攻击)。</p><p>CSP通过指定浏览器认可的可执行脚本的有效来源使服务器管理者有能力减少或消除XSS攻击所依赖的载体。一个兼容CSP的浏览器将会仅执行从白名单域获取到的脚本文件，忽略所有的其他脚本 (包括内联脚本和HTML的事件处理属性)。</p><span id="more"></span><h2 id="CSP-使用方法"><a href="#CSP-使用方法" class="headerlink" title="CSP 使用方法"></a>CSP 使用方法</h2><p>有两种方法可以应用此策略：</p><ol><li>配置服务器返回  <code>Content-Security-Policy</code>  HTTP头部<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span><span class="punctuation">: </span>&lt;policy-directive&gt;; [&lt;policy-directive&gt;;]</span><br><span class="line"><span class="attribute">Content-Security-Policy-Report-Only</span><span class="punctuation">: </span>report-uri URI; [&lt;policy-directive&gt;;]</span><br></pre></td></tr></table></figure>Content-Security-Policy-Report-Only 表明对于每个企图违反内容安全策略的内容发送违规报告，发送地址为 report-uri 指定的地址。  </li></ol><p>违例报告包含以下内容：  </p><table><thead><tr><th>key</th><th>内容</th></tr></thead><tbody><tr><td>document-uri</td><td>发生违规的文档的URI</td></tr><tr><td>referrer</td><td>违规发生处的文档引用（地址）</td></tr><tr><td>blocked-uri</td><td>被CSP阻止的资源URI。如果被阻止的URI来自不同的源而非文档URI，那么被阻止的资源URI会被删减，仅保留协议，主机和端口号</td></tr><tr><td>violated-directive</td><td>违反的策略名称</td></tr><tr><td>original-policy</td><td>在 Content-Security-Policy HTTP 头部中指明的原始策略</td></tr></tbody></table><ol start="2"><li>在文档的 <code>&lt;meta&gt;</code>  元素里配置该策略<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;default-src &#x27;self&#x27;; img-src https://*; child-src &#x27;none&#x27;;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>如果 HTTP 头与 Meta 定义同时存在，则优先采用 HTTP 中的定义。  </p><h2 id="CSP-指令"><a href="#CSP-指令" class="headerlink" title="CSP 指令"></a>CSP 指令</h2><p>内容安全策略可以配置多个，一个策略由一系列策略指令所组成，每个策略指令都描述了一个针对某个特定类型资源以及生效范围的策略。</p><p>策略指令分为五种：获取指令（Fetch directives）、文档指令（Document directives）、导航指令（Navigation directives）、报告指令（Reporting directives）、其它指令（Other directives）</p><h3 id="CSP-指令可取的key"><a href="#CSP-指令可取的key" class="headerlink" title="CSP 指令可取的key"></a>CSP 指令可取的key</h3><table><thead><tr><th>获取指令</th><th>作用</th></tr></thead><tbody><tr><td>child-src</td><td>为 web workers 和其他内嵌浏览器内容（例如用 <code>&lt;frame&gt;</code> 和 <code>&lt;iframe&gt;</code> 加载到页面的内容）定义合法的源地址，相当于 frame-src 和 worker-src</td></tr><tr><td>connect-src</td><td>限制能通过脚本接口加载的URL</td></tr><tr><td>default-src</td><td>为其他取指令提供备用服务</td></tr><tr><td>font-src</td><td>设置允许通过@font-face加载的字体源地址</td></tr><tr><td>frame-src</td><td>设置允许通过类似 <code>&lt;frame&gt;</code> 和 <code>&lt;iframe&gt;</code> 标签加载的内嵌内容的源地址</td></tr><tr><td>img-src</td><td>限制图片和图标的源地址</td></tr><tr><td>manifest-src</td><td>限制应用声明文件的源地址</td></tr><tr><td>media-src</td><td>限制通过 <code>&lt;audio&gt;</code> 、 <code>&lt;video&gt;</code> 或 <code>&lt;track&gt;</code> 标签加载的媒体文件的源地址</td></tr><tr><td>object-src</td><td>限制 <code>&lt;object&gt;</code>、<code>&lt;embed&gt;</code>、<code>&lt;applet&gt;</code> 标签的源地址</td></tr><tr><td>prefetch-src</td><td>指定预加载或预渲染的允许源地址</td></tr><tr><td>script-src</td><td>限制JavaScript的源地址</td></tr><tr><td>style-src</td><td>限制层叠样式表文件源</td></tr><tr><td>webrtc-src</td><td>指定WebRTC连接的合法源地址</td></tr><tr><td>worker-src</td><td>限制 Worker、SharedWorker 或者 ServiceWorker 脚本源</td></tr></tbody></table><table><thead><tr><th>文档指令</th><th>作用</th></tr></thead><tbody><tr><td>base-uri</td><td>限制在DOM中 <code>&lt;base&gt;</code> 元素可以使用的URL</td></tr><tr><td>plugin-types</td><td>通过限制可以加载的资源类型来限制哪些插件可以被嵌入到文档中</td></tr><tr><td>sandbox</td><td>类似 <code>&lt;iframe&gt;</code> sandbox 属性，为请求的资源启用沙盒</td></tr></tbody></table><table><thead><tr><th>导航指令</th><th>作用</th></tr></thead><tbody><tr><td>form-action</td><td>限制能被用来作为给定上下文的表单提交的目标 URL</td></tr><tr><td>frame-ancestors</td><td>指定可能嵌入页面的有效父项 <code>&lt;frame&gt;</code>, <code>&lt;iframe&gt;</code>, <code>&lt;object&gt;</code>, <code>&lt;embed&gt;</code>, <code>&lt;applet&gt;</code></td></tr><tr><td>navigation-to</td><td>限制文档可以通过以下任何方式访问URL (a, form, window.location, window.open, etc.)</td></tr></tbody></table><table><thead><tr><th>报告指令</th><th>作用</th></tr></thead><tbody><tr><td>report-uri</td><td>当出现可能违反CSP的操作时，让客户端提交报告。这些违规报告会以JSON文件的格式通过POST请求发送到指定的URI</td></tr><tr><td>report-to</td><td>触发 SecurityPolicyViolationEvent</td></tr></tbody></table><table><thead><tr><th>其它指令</th><th>作用</th></tr></thead><tbody><tr><td>block-all-mixed-content</td><td>当使用HTTPS加载页面时阻止使用HTTP加载任何资源</td></tr><tr><td>require-sri-for</td><td>需要使用 SRI 作用于页面上的脚本或样式</td></tr><tr><td>upgrade-insecure-requests</td><td>让浏览器把一个网站所有的不安全 URL（通过 HTTP 访问）当做已经被安全的 URL 链接（通过 HTTPS 访问）替代</td></tr></tbody></table><h3 id="CSP-指令可取的value"><a href="#CSP-指令可取的value" class="headerlink" title="CSP 指令可取的value"></a>CSP 指令可取的value</h3><table><thead><tr><th>指令值</th><th>指令值示例</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>img-src *</td><td>允许任何内容</td></tr><tr><td>‘none’</td><td>img-src ‘none’</td><td>不允许任何内容</td></tr><tr><td>‘self’</td><td>img-src ‘self’</td><td>允许来自相同源内容（相同协议、域名和端口）</td></tr><tr><td>data:</td><td>img-src data:</td><td>允许 data: 协议</td></tr><tr><td><a href="http://www.example.com">www.example.com</a></td><td>img-src img.example.com</td><td>允许加载指定域名的资源</td></tr><tr><td>*.example.com</td><td>img-src *.example.com</td><td>允许加载 example.com 任何子域的资源</td></tr><tr><td>‘unsafe-inline’</td><td>script-src ‘unsafe-inline’</td><td>允许加载 inline 资源</td></tr><tr><td>‘unsafe-eval’</td><td>script-src ‘unsafe-eval’</td><td>允许加载动态 js 代码（eval）</td></tr></tbody></table><h2 id="常见策略"><a href="#常见策略" class="headerlink" title="常见策略"></a>常见策略</h2><p>允许加载同源的图片、脚本、AJAX和CSS资源，并阻止加载其他任何资源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default-src &#x27;none&#x27;; script-src &#x27;self&#x27;; connect-src &#x27;self&#x27;; img-src &#x27;self&#x27;; style-src &#x27;self&#x27;;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy">MDN docs Content-Security-Policy</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP">MDN docs CSP</a><br><a href="https://www.w3.org/TR/CSP1/">w3 CSP1</a><br><a href="https://www.w3.org/TR/CSP2/">w3 CSP2</a><br><a href="https://w3c.github.io/webappsec-upgrade-insecure-requests/">w3 github Upgrade Insecure Requests</a><br><a href="https://w3c.github.io/webappsec-subresource-integrity/">w3 github Subresource Integrity</a><br><a href="https://w3c.github.io/webappsec-mixed-content/">w3 github Mixed Content</a><br><a href="https://w3c.github.io/webappsec-csp/">w3 github CSP3</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> security </tag>
            
            <tag> CSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器同源策略与跨域</title>
      <link href="/blog/2021/12/30/HTTP-%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E4%B8%8E%E8%B7%A8%E5%9F%9F/"/>
      <url>/blog/2021/12/30/HTTP-%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E4%B8%8E%E8%B7%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<p>浏览器的同源策略（Same-origin policy）是一个重要的基础安全策略，它用于限制一个源（origin）的文档或者它加载的脚本如何能与另一个源的资源进行交互。如果从 <code>http://example.com/doc.html</code> 检索到的文档尝试访问从 <code>https://example.com/target.html</code> 检索到的文档的 DOM ，则用户代理将不允许访问。它能帮助阻隔恶意文档，减少可能的攻击行为。</p><span id="more"></span><p>当尝试跨域访问资源时会收到以下错误<br><img src="/blog/static/imgs/cors.webp" alt="cors"></p><h2 id="同源的定义"><a href="#同源的定义" class="headerlink" title="同源的定义"></a>同源的定义</h2><p>如果两个 URL 的 协议、域名和端口 都相同的话，则这两个 URL 是同源的。  </p><h3 id="源的修改"><a href="#源的修改" class="headerlink" title="源的修改"></a>源的修改</h3><p>Javascript 脚本可以将 <code>document.domain</code> 的值设置为当前域名或当前域的父域名。如果将其设置为其当前域的父域名时，则这个较短的父域名将用于后续源的检查。任何对 <code>document.domain</code> 的赋值操作，包括 <code>document.domain = document.domain</code> 都会导致端口号被重写为 null 。因此，如果希望子域名和父域名同源，需要在他们双方中都进行赋值。  </p><h2 id="跨源网络访问"><a href="#跨源网络访问" class="headerlink" title="跨源网络访问"></a>跨源网络访问</h2><p>受同源策略的影响，通常，文档允许嵌入跨源的资源，但是不允许对跨源资源进行读取。  </p><table><thead><tr><th>资源</th><th>权限</th></tr></thead><tbody><tr><td>内嵌iframe</td><td>允许跨源嵌入，但不允许跨域读取（例如使用 JavaScript 访问 iframe 中的文档）</td></tr><tr><td>样式CSS</td><td>跨源 CSS 可以使用 <code>&lt;link&gt;</code> 元素或在CSS文件中通过 <code>@import</code> 嵌入（Content-Type 需要设置正确）</td></tr><tr><td>表单forms</td><td>跨源 URLs 可以作为 form 元素的 action 属性</td></tr><tr><td>图片images</td><td>跨源图片可以通过 <code>&lt;img&gt;</code> 元素嵌入，但是不能读取（例如使用 JavaScript 将跨域图像加载到 canvas 元素中）</td></tr><tr><td>多媒体multimedia</td><td>可以使用 <code>&lt;video&gt;</code> 和 <code>&lt;audio&gt;</code> 元素嵌入跨源视频和音频</td></tr><tr><td>脚本script</td><td>跨源脚本可以使用 <code>&lt;script&gt;</code> 元素嵌入，但特定 api(例如 跨源的 Fetch API 请求 或者 XMLHttpRequest 请求)会被阻止</td></tr><tr><td>API</td><td><code>iframe.contentWindow</code>、 <code>window.parent</code>、<code>window.open</code> 和 <code>window.opener</code> 在跨源时 访问 Window 和 Location 对象均被限制</td></tr><tr><td>localStorage &amp; IndexedDB</td><td>无法跨源访问</td></tr></tbody></table><p>同源策略主要限制以下三种情况：  </p><ul><li>DOM同源策略：禁止对不同源页面DOM进行操作。这里主要场景是 iframe 跨域的情况，不同域名的 iframe 是限制互相访问的。  </li><li>Ajax同源策略：禁止使用 XMLHttpRequest 对象 或者 Fetch API 向不同源的服务器地址发起 HTTP 请求。  </li><li>存储同源策略：禁止读取非同源的 sessionStorage、localStorage、IndexedDB</li></ul><h2 id="如何跨域共享资源"><a href="#如何跨域共享资源" class="headerlink" title="如何跨域共享资源"></a>如何跨域共享资源</h2><p>同源策略本质上为了对不同的源做资源隔离。但实际应用中，经常有不同的域名属于同一个实体的情况（比如为了突破浏览器并发请求数限制或对静态资源做了CDN配置导致静态资源和API请求不在同一域名下）。在这些情况下同源策略太严格了，给拥有多个域名（或子域）的大型网站跨域资源共享带来了问题。以下列出一些较常见的场景和方法来避免因同源策略导致的资源共享问题。</p><h3 id="CORS（Cross-Origin-Resource-Sharing）-跨源资源共享"><a href="#CORS（Cross-Origin-Resource-Sharing）-跨源资源共享" class="headerlink" title="CORS（Cross Origin Resource Sharing） 跨源资源共享"></a>CORS（Cross Origin Resource Sharing） 跨源资源共享</h3><p>这种方式使用了一个新的 <code>Origin</code> 请求头和一个新的 <code>Access-Control-Allow-Origin</code> 响应头扩展了HTTP。允许服务端设置 <code>Access-Control-Allow-Origin</code> 头标识哪些站点可以请求文件，或者设置 <code>Access-Control-Allow-Origin: *</code>，表示允许任意站点访问文件。根据请求类型是否是“简单请求”，浏览器可能发送 OPTIONS 类型的预检请求。  </p><p>对于跨源的 XMLHttpRequest 或 Fetch 请求，浏览器 <em>不会</em> 发送身份凭证信息。如果需要携带身份信息，需要在 XMLHttpRequest 实例中添加 withCredentials 属性，值为 true，如果服务器接受身份信息，则响应头中会包含 <code>Access-Control-Allow-Credentials: true</code> ，这样，浏览器就会发送 Cookie（Cookie 受 SameSite 属性控制） 和 Authorization 信息。  </p><p>与 CORS 相关的 HTTP 请求头和响应头包括以下这些：  </p><p>响应</p><table><thead><tr><th>首部字段名</th><th>说明</th><th>例子</th></tr></thead><tbody><tr><td>Access-Control-Allow-Origin</td><td>origin 参数的值指定了允许访问该资源的外域 URI。对于不需要携带身份凭证的请求，服务器可以指定该字段的值为通配符，表示允许来自所有域的请求。如果服务端指定了具体的域名而非“*”，那么响应首部中的 <code>Vary</code> 字段的值必须包含 <code>Origin</code>。这将告诉客户端：服务器对不同的源站返回不同的内容。</td><td><code>Access-Control-Allow-Origin: &lt;origin&gt; ｜ *</code></td></tr><tr><td>Access-Control-Expose-Headers</td><td>让服务器把允许浏览器访问的头放入白名单</td><td><code>Access-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header</code></td></tr><tr><td>Access-Control-Max-Age</td><td>指定了preflight请求的结果能够被缓存多久</td><td><code>Access-Control-Max-Age: &lt;delta-seconds&gt;</code></td></tr><tr><td>Access-Control-Allow-Credentials</td><td>指定了当浏览器的 credentials 设置为 true 时是否允许浏览器读取 response 的内容</td><td><code>Access-Control-Allow-Credentials: true</code></td></tr><tr><td>Access-Control-Allow-Methods</td><td>用于预检请求的响应，指明了实际请求所允许使用的 HTTP 方法</td><td><code>Access-Control-Allow-Methods: &lt;method&gt;[, &lt;method&gt;]*</code></td></tr><tr><td>Access-Control-Allow-Headers</td><td>用于预检请求的响应，指明了实际请求中允许携带的首部字段</td><td><code>Access-Control-Allow-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]*</code></td></tr></tbody></table><p>请求</p><table><thead><tr><th>首部字段名</th><th>说明</th><th>例子</th></tr></thead><tbody><tr><td>Origin</td><td>源站 URI</td><td><code>Origin: &lt;origin&gt;</code></td></tr><tr><td>Access-Control-Request-Method</td><td>用于预检请求，将实际请求所使用的 HTTP 方法告诉服务器</td><td><code>Access-Control-Request-Method: &lt;method&gt;</code></td></tr><tr><td>Access-Control-Request-Headers</td><td>用于预检请求，将实际请求所携带的首部字段告诉服务器</td><td><code>Access-Control-Request-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]*</code></td></tr></tbody></table><h3 id="document-domain-父子域名资源共享"><a href="#document-domain-父子域名资源共享" class="headerlink" title="document.domain 父子域名资源共享"></a>document.domain 父子域名资源共享</h3><p>如前所描，如果两个待共享资源的域名是父子域名的关系，或者同属于一个父域名，则可以通过修改 <code>document.domain</code> 将其源改为相同的父域名来实现跨域共享资源。</p><h3 id="window-postMessage-跨文档通信"><a href="#window-postMessage-跨文档通信" class="headerlink" title="window.postMessage 跨文档通信"></a>window.postMessage 跨文档通信</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage">window.postMessage</a> 可以安全地实现跨源通信。</p><figure class="highlight js"><figcaption><span>发送窗口</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otherWindow.<span class="title function_">postMessage</span>(message, targetOrigin, [transfer]);</span><br></pre></td></tr></table></figure><ul><li>otherWindow: 其他窗口的一个引用，比如 iframe 的 contentWindow 属性、执行 window.open 返回的窗口对象、或者是命名过或数值索引的 window.frames</li><li>message: 将要发送到其他 window 的数据</li><li>targetOrigin: 通过窗口的 origin 属性来指定哪些窗口能接收到消息事件</li><li>transfer(可选) : 是一串和 message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权</li></ul><figure class="highlight js"><figcaption><span>接收窗口</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;message&quot;</span>, receiveMessage, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">receiveMessage</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> origin = event.<span class="property">origin</span>;</span><br><span class="line">    <span class="comment">// 不检查 origin 属性会导致跨站点脚本攻击（XSS）</span></span><br><span class="line">    <span class="keyword">if</span> (origin !== <span class="string">&quot;http://example.org:8080&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取 event.data 数据，同时 可以使用 event.source 继续和 source 通信</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>WebSocket 规范定义了可在浏览器和服务器之间建立持久连接的 API，这种方式通信没有使用 HTTP，因此也没有跨域的限制。  </p><p>客户端：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://localhost:8080&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  socket.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    socket.<span class="title function_">send</span>(<span class="string">&quot;message&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript">  socket.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>服务器：<br><figure class="highlight js"><figcaption><span>nodejs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">WebSocket</span> = <span class="built_in">require</span>(<span class="string">&quot;ws&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> server = <span class="keyword">new</span> <span class="title class_">WebSocket</span>.<span class="title class_">Server</span>(&#123; <span class="attr">port</span>: <span class="number">8080</span> &#125;);</span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&quot;connection&quot;</span>, <span class="keyword">function</span>(<span class="params">socket</span>) &#123;</span><br><span class="line">  socket.<span class="title function_">on</span>(<span class="string">&quot;message&quot;</span>, <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    socket.<span class="title function_">send</span>(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="JSONP-JSON-with-padding-hack"><a href="#JSONP-JSON-with-padding-hack" class="headerlink" title="JSONP - JSON with padding (hack)"></a>JSONP - JSON with padding (hack)</h3><p>JSONP 是利用 <code>&lt;script\&gt;</code> 标签没有跨域限制的要求来达到与第三方通讯的目的。JSONP 只能支持 GET 类型的请求。当需要通讯时，源站脚本创建一个 <code>&lt;script\&gt;</code> 元素，地址指向第三方的API地址，形如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://www.example.net/api?param1=1&amp;param2=2&amp;func=callback&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>并提供一个回调函数来接收数据（函数名可约定，或通过地址参数传递）。<br>第三方产生的响应为 json 数据的包装（故称之为jsonp，即json with padding），形如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">callback</span>(&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;hax&quot;</span>,<span class="string">&quot;gender&quot;</span>:<span class="string">&quot;Male&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p>这样浏览器会调用 callback 函数，并传递解析后 json 对象作为参数。本站脚本可在 callback 函数里处理所传入的数据。</p><p>客户端实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> url=<span class="string">&quot;http://www.x.com/test?a=1&amp;callback=test&quot;</span>;</span><br><span class="line"><span class="comment">// 然后前端通过script标签去访问并执行，上面的东西</span></span><br><span class="line"><span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">script.<span class="title function_">setAttribute</span>(<span class="string">&#x27;src&#x27;</span>, url);</span><br><span class="line"><span class="comment">// 把script标签加入head，此时调用开始</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;head&#x27;</span>)[<span class="number">0</span>].<span class="title function_">appendChild</span>(script); </span><br><span class="line"><span class="comment">// 然后就会调用页面的test方法</span></span><br><span class="line"><span class="comment">// test(&#123;&#125;)</span></span><br></pre></td></tr></table></figure><h3 id="window-name-hack"><a href="#window-name-hack" class="headerlink" title="window.name (hack)"></a>window.name (hack)</h3><p>window 对象有个 name 属性，该属性有个特征：即在一个窗口(window)的生命周期内，窗口载入的所有的页面都是共享一个 window.name 的，每个页面对 window.name 都有读写的权限，window.name 是持久存在一个窗口载入过的所有页面中的。</p><h3 id="通过请求代理实现跨域"><a href="#通过请求代理实现跨域" class="headerlink" title="通过请求代理实现跨域"></a>通过请求代理实现跨域</h3><p>浏览器有跨域限制，但是服务器/代理工具不存在跨域问题，所以可以由同源服务器/代理工具请求所要域的资源再返回给客户端。</p><ul><li>服务器代理 - 你可以自己启动一个服务器，然后将接口转发，不过开发服务器一般都有代理工具可以快速对接口进行代理，例如 webpack-dev-server 可以通过配置 devServer.proxy 来配置对接口的代理，底层是使用了 <a href="https://github.com/chimurai/http-proxy-middleware">http-proxy-middleware</a> 包进行了处理 </li><li>代理工具代理 - 多数代理工具提供了接口转发功能，例如 charles 可以在 tools/map remote 中将请求转发到另一个地址</li><li>Nginx 反向代理 - 将不同接口转发到对应的域名下</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 local.test</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> local.test;</span><br><span class="line">    <span class="section">location</span> /api &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://localhost:8080;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://localhost:8000;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">MDN Docs Same-origin policy</a><br><a href="https://www.w3.org/Security/wiki/Same_Origin_Policy">w3 Same_Origin_Policy</a><br><a href="https://web.dev/same-origin-policy/">web.dev Same-origin policy</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">MDN Docs CORS</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage">MDN Docs window.postMessage</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> security </tag>
            
            <tag> browser </tag>
            
            <tag> same-origin </tag>
            
            <tag> CORS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP Cookie 小抄</title>
      <link href="/blog/2021/12/29/HTTP-Cookie/"/>
      <url>/blog/2021/12/29/HTTP-Cookie/</url>
      
        <content type="html"><![CDATA[<h2 id="Cookie-作用"><a href="#Cookie-作用" class="headerlink" title="Cookie 作用"></a>Cookie 作用</h2><p><a href="https://datatracker.ietf.org/doc/rfc6265/">HTTP Cookie</a>（也叫 Web Cookie 或浏览器 Cookie）是服务器发送到用户代理（一般是浏览器，以下统一用浏览器表示）并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。虽然 Cookie 具有许多降低其安全性的缺陷和隐私问题，但由于历史原因，Cookie 和 Set-Cookie 头字段还是被广泛的在互联网上使用。</p><p>Cookie 主要用于以下三个方面：</p><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><span id="more"></span><p>Cookie 曾一度用于浏览器数据的存储，但浏览器的每次请求都会携带 Cookie 数据，会带来额外的性能开销，随着新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API （本地存储和会话存储）或 IndexedDB ，Cookie 作为浏览器数据存储的功能渐渐被淘汰。</p><p>在 Chrome 浏览器中可以通过 <a href="chrome://settings/siteData">chrome settings</a> 管理浏览器 Cookie。也可以 F12 打开 dev-tools 在 Application-Storage-Cookie 下查看当前页面相关的 Cookie 。</p><p>另外还有 <a href="https://datatracker.ietf.org/doc/rfc7873/">DNS Cookies</a>、<a href="https://datatracker.ietf.org/doc/rfc6013/">TCP Cookie Transactions</a> 也被叫做 Cookie，但都没有 HTTP Cookie 知名。  </p><h2 id="使用-Cookie"><a href="#使用-Cookie" class="headerlink" title="使用 Cookie"></a>使用 Cookie</h2><p>服务器使用 Set-Cookie 响应头部向浏览器发送 Cookie 信息</p><figure class="highlight http"><figcaption><span>header</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>&lt;cookie name&gt;=&lt;cookie value&gt;[;Expires=&lt;date&gt;][;Max-Age=&lt;non-zero-digit&gt;][;Domain=&lt;domain-value&gt;][;Path=&lt;path-value&gt;][;Secure][;HttpOnly][;SameSite=&lt;Strict|Lax|None&gt;];</span><br></pre></td></tr></table></figure><p>例如在 nodejs 中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Set-Cookie&#x27;</span>, [<span class="string">&#x27;locale=zh-cn&#x27;</span>, <span class="string">&#x27;language=javascript&#x27;</span>]);</span><br></pre></td></tr></table></figure><ul><li><code>&lt;cookie-name&gt;</code> 可以是除了控制字符 (CTLs)、空格 (spaces) 或制表符 (tab)之外的任何 US-ASCII 字符。同时不能包含以下分隔字符： ( ) &lt; &gt; @ , ; : \ “ /  [ ] ? = { }.</li><li><code>&lt;cookie-value&gt;</code> 是可选的，如果存在的话，那么需要包含在双引号里面。支持除了控制字符（CTLs）、空格（whitespace）、双引号（double quotes）、逗号（comma）、分号（semicolon）以及反斜线（backslash）之外的任意 US-ASCII 字符。关于编码：许多应用会对 Cookie 值按照 URL 编码（URL encoding）规则进行编码，但是按照 RFC 规范，这不是必须的。不过需要满足规范中对于 <code>&lt;cookie-value&gt;</code> 所允许使用的字符的要求。</li></ul><p>浏览器使用 <code>document.cookie</code> API 获取 Cookie，使用 <code>document.cookie = &quot;&lt;cookie name&gt;=&lt;cookie value&gt;[;Expires=&lt;date&gt;][;Max-Age=&lt;non-zero-digit&gt;][;Domain=&lt;domain-value&gt;][;Path=&lt;path-value&gt;][;Secure][;SameSite=&lt;Strict|Lax|None&gt;]&quot;;</code> 来创建 Cookie。浏览器读取 Cookie 需要进行字符串解析与 Unicode 编码，直接使用 API 进行变更不太方便，有一些库可以更方便的对 Cookie 进行设置 例如 <a href="https://github.com/js-cookie/js-cookie">js-cookie</a>。</p><p>Cookie 并不直接提供修改、删除的操作，如果要修改某个 Cookie，只需要新建一个 Name、Domain、Path 均与原 Cookie 相同的 Cookie，即会覆盖原 Cookie。如果要删除某个Cookie，只需要新建一个 Name、Domain、Path 均与原 Cookie 相同的 Cookie，并将 Max-Age 设置为 0 或者 将 Expires 设置为过去的时间即可。</p><h2 id="Cookie-属性"><a href="#Cookie-属性" class="headerlink" title="Cookie 属性"></a>Cookie 属性</h2><p>Cookie 具有以下属性<br>名称/值 Name Value<br>作用域 Domain Path<br>有效期 Expires Max-Age<br>安全属性 HttpOnly Secure SameSite  </p><h3 id="Cookie-作用域"><a href="#Cookie-作用域" class="headerlink" title="Cookie 作用域"></a>Cookie 作用域</h3><p>Domain 和 Path 标识定义了 Cookie 的作用域：即允许 Cookie 应该发送给哪些 URL。一般情况下，一个 Cookie 只有 Domain 和 Path 均比 HTTP(S) 请求的域名和路径更高层级（或同层级）时才会发送。 Name Domain Path 可以决定一个唯一的 Cookie，当设置一个 Name Domain Path 相同的 Cookie 时，Cookie 的值会被覆盖。  </p><h4 id="Domain"><a href="#Domain" class="headerlink" title="Domain"></a>Domain</h4><p><code>Domain=&lt;domain-value&gt;</code> 指定 Cookie 可以送达的域名。默认值为当前文档访问地址中的域名(<code>window.location.origin</code>)，而且不包含子域名（存储时 host-only-flag 为 true）。设定 Cookie 时如果指定了 Domain ，则包含子域名，而且 指定的 Domain 必须涵盖原始服务器的域名（属于当前域名的父级域名），否则会被浏览器拒绝。</p><h4 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h4><p><code>Path=&lt;path-value&gt;</code> 指定 Cookie 可以送达的 URL 路径，这个路径必须出现在要请求的资源的路径中才可以发送 Cookie header。默认值为当前文档的路径(<code>window.location.pathname</code>)的上一层。</p><h3 id="Cookie-生命周期"><a href="#Cookie-生命周期" class="headerlink" title="Cookie 生命周期"></a>Cookie 生命周期</h3><p>Cookie 根据生命周期可以分为两种， 会话期 Cookie 和 持久性 Cookie。<br>不指定过期时间（Expires）或者有效期（Max-Age）的 Cookie 是会话期 Cookie，浏览器关闭之后它会被自动删除。（如果浏览器支持会话恢复功能，会话期 Cookie 会一直生效。）<br>持久性 Cookie 的生命周期取决于过期时间（Expires）或有效期（Max-Age）指定的一段时间。  </p><h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p><code>Expires=&lt;date&gt;</code> Cookie 的最长有效时间，形式为符合 <a href="https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.1.2">RFC7231 HTTP-date</a> 规范的时间戳。设置早于当前时间的 Expires 会使 Cookie 直接过期。  </p><h4 id="Max-Age"><a href="#Max-Age" class="headerlink" title="Max-Age"></a>Max-Age</h4><p><code>Max-Age=&lt;non-zero-digit&gt;</code> 在 Cookie 失效之前需要经过的秒数。秒数为 0 或 -1 将会使 Cookie 直接过期。如果 Expires 和 Max-Age 均存在，那么 Max-Age 优先级更高。  </p><h3 id="Cookie-安全属性"><a href="#Cookie-安全属性" class="headerlink" title="Cookie 安全属性"></a>Cookie 安全属性</h3><h4 id="Secure"><a href="#Secure" class="headerlink" title="Secure"></a>Secure</h4><p><code>Secure</code> 一个带有 Secure 属性的 Cookie 只有在请求使用 HTTPS 协议的时候才会被发送到服务器。(但是在 Chrome 52 和 Firefox 52 以下版本中，仍旧能够在使用 HTTP 时被浏览器覆盖。)其目的是为了防范中间人攻击(MitM).</p><h4 id="HttpOnly"><a href="#HttpOnly" class="headerlink" title="HttpOnly"></a>HttpOnly</h4><p><code>HttpOnly</code> 设置了 HttpOnly 属性的 Cookie 不能使用 JavaScript 经由 <code>Document.cookie</code>  属性、XMLHttpRequest 和  Request APIs 进行访问。也即浏览器不能直接访问。其目的是为了防范跨站脚本攻击(XSS)。</p><h4 id="SameSite"><a href="#SameSite" class="headerlink" title="SameSite"></a>SameSite</h4><p><code>SameSite=&lt;Strict|Lax|None&gt;</code> 允许服务器要求某个 Cookie 在跨站请求时不会被发送。其目的是为了阻止跨站请求伪造攻击(CSRF)和解决第三方 Cookie 导致的用户追踪问题。该属性在<a href="https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cookie-same-site-00">RFC6265bis</a>中进行了定义。</p><ul><li>Strict 完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。</li><li>Lax 允许部分第三方请求携带 Cookie。</li><li>None 无论是否跨站都会发送 Cookie，只支持 HTTPS（也即 Cookie 有 Secure 属性）。</li></ul><p>SameSite 是 Chrome 51 新增的属性，从 Chrome 84 开始 默认值从 None 变更为 Lax。现在 Chrome 的 SameSite 默认值是 Lax ，而 Safari 的默认值是 Strict 。  </p><table><thead><tr><th>请求类型</th><th>实例</th><th>Strict</th><th>Lax</th><th>None</th></tr></thead><tbody><tr><td>链接</td><td><code>&lt;a href=&quot;...&quot;&gt;&lt;/a&gt;</code></td><td>不发送</td><td>发送cookie</td><td>发送cookie</td></tr><tr><td>预加载</td><td><code>&lt;link rel=&quot;prerender&quot; href=&quot;...&quot; /&gt;</code></td><td>不发送</td><td>发送cookie</td><td>发送cookie</td></tr><tr><td>get 表单</td><td><code>&lt;form method=&quot;GET&quot; action=&quot;...&quot; &gt;&lt;/form&gt;</code></td><td>不发送</td><td>发送cookie</td><td>发送cookie</td></tr><tr><td>post 表单</td><td><code>&lt;form method=&quot;POST&quot; action=&quot;...&quot; &gt;&lt;/form&gt;</code></td><td>不发送</td><td>不发送</td><td>发送cookie</td></tr><tr><td>iframe</td><td><code>&lt;iframe src=&quot;...&quot; /&gt;</code></td><td>不发送</td><td>不发送</td><td>发送cookie</td></tr><tr><td>Ajax</td><td><code>$.get(&quot;...&quot;)</code></td><td>不发送</td><td>不发送</td><td>发送cookie</td></tr><tr><td>Image</td><td><code>&lt;img src=&quot;...&quot; /&gt;</code></td><td>不发送</td><td>不发送</td><td>发送cookie</td></tr></tbody></table><h3 id="Cookie-的其它属性"><a href="#Cookie-的其它属性" class="headerlink" title="Cookie 的其它属性"></a>Cookie 的其它属性</h3><h4 id="Cookie-prefixes"><a href="#Cookie-prefixes" class="headerlink" title="Cookie prefixes"></a>Cookie prefixes</h4><ul><li><strong>Secure- 前缀：以 </strong>Secure- 为前缀的 Cookie（其中连接符是前缀的一部分），必须与 secure 属性一同设置，同时必须应用于安全页面（即使用 HTTPS 访问的页面）。</li><li><strong>Host- 前缀： 以 </strong>Host- 为前缀的 Cookie，必须与 secure 属性一同设置，必须应用于安全页面（即使用 HTTPS 访问的页面），必须不能设置 domain 属性 （也就不会发送给子域），同时 path 属性的值必须为“/”。</li></ul><h4 id="SameParty"><a href="#SameParty" class="headerlink" title="SameParty"></a>SameParty</h4><p>同主体标志，结合 First-Party Sets 来判断不同域名是否为同一主体，是否需要发送 Cookie 。SameParty Cookie 必须包含 Secure 且不得包含 SameSite=Strict。该属性主要是为了限制第三方 Cookie 及解决同一主体拥有不同域名时跨站 Cookie 共享的问题。</p><h4 id="Priority"><a href="#Priority" class="headerlink" title="Priority"></a>Priority</h4><p>当 Cookie 超过每个域的 Cookie 容量时，将会被删除。Priority 属性（分为 High Medium(默认) Low）决定较低优先级的旧 Cookie 会被优先删除。</p><h2 id="Cookie的发送规则"><a href="#Cookie的发送规则" class="headerlink" title="Cookie的发送规则"></a>Cookie的发送规则</h2><p>浏览器会将 Domain（当前请求的域名和 Cookie 的 Domain 相同，或者 Cookie 的 Domain 符合请求的上级域名）、Path（当前请求的路径和 Cookie 的 Path 相同，或者 Cookie 的 Path 符合请求的父级路径）、 Secure（当前请求为https请求） 均符合的 Cookie 按照 Path 长的在前、创建时间早的在前的规则发送给服务器，只发送 Name 和 Value。</p><h2 id="Cookie-的限制条件"><a href="#Cookie-的限制条件" class="headerlink" title="Cookie 的限制条件"></a>Cookie 的限制条件</h2><ul><li>单个 Cookie 最大 4k，任何 Cookie 大小超过限制都被忽略  </li><li>单个 域名 至少提供50条 Cookie</li><li>总共 提供 至少 3000条 Cookie</li></ul><p>根据这些限制条件，浏览器随时可能清除 Cookie，服务器应当使 Cookie 的体积小，数量少。</p><h2 id="其他安全策略与问题"><a href="#其他安全策略与问题" class="headerlink" title="其他安全策略与问题"></a>其他安全策略与问题</h2><ul><li><p>为了防止 Cookie 被篡改，服务器通常可以将 会话标志符 存储在 Cookie 中，而不是直接存储会话信息。这样，即使攻击者获取到了 Cookie 内容，如果不知道会话标志符编码解码规则，就无法进行修改。  </p></li><li><p>如果站点使用 Cookie 对用户进行身份验证，则每当用户进行身份验证时，它都应重新生成并重新发送会话 Cookie，即使会话 Cookie 已经存在。此技术有助于防止会话固定攻击（<a href="https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#session_hijacking">session fixation attacks</a>）。</p></li><li><p>Cookie 不提供端口隔离。如果 cookie 可由运行在一个端口上的服务读取/写入，则该 cookie 也可由运行在同一服务器的另一个端口上的服务读取/写入。出于这个原因，当使用 Cookie 来存储安全敏感信息时，服务器不应该在同一主机的不同端口上运行互不信任的服务。</p></li><li><p>Cookie 不对路径提供完整性保护。<code>document.cookie</code> API 不会隔离从不同路径获取的 Cookie，浏览器会接受 Set-Cookie 头中的任意 Path 属性 。出于这个原因，当使用 Cookie 来存储安全敏感信息时，服务器不应该在同一主机的不同路径上运行互不信任的服务。</p></li><li><p>Cookie 不为同级域（及其子域）提供完整性保证。例如，考虑 foo.example.com 和 bar.example.com。foo.example.com 服务器可以设置一个域属性为 “example.com” 的 cookie （可能覆盖由 bar.example.com 设置的现有 “example.com” cookie ），并且浏览器会将该 cookie 包含在对 bar.example.com 的 HTTP 请求。这里面最坏的情况是，bar.example.com 将无法区分这个 cookie和它自己设置的 cookie。foo.example.com 服务器可能能够利用这种能力对 bar.example.com 发起攻击。</p></li><li><p>Cookie 是依赖 DNS 来确保安全的，如果 DNS 层面已经不安全了（比如发生 DNS劫持），那 Cookie 也无法保证安全。</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://datatracker.ietf.org/doc/rfc6265/">RFC6265 HTTP State Management Mechanism</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies#Secure_and_HttpOnly_cookies">MDN Web Docs HTTP cookies</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie">MDN Web Docs Set-Cookie</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies">MDN Web Docs Using HTTP cookies</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie">MDN Web Docs Document.cookie</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#session_hijacking">MDN Web Docs Type of attacks</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/MitM">MDN Web Docs MitM</a><br><a href="https://github.com/privacycg/first-party-sets">Github first-party-sets</a><br><a href="https://github.com/cfredric/sameparty">Github sameparty</a><br><a href="https://web.dev/samesite-cookies-explained/">web.dev samesite-cookies-explained</a><br><a href="https://book.douban.com/subject/25863515/">图解 http</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> cookie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运维危险命令合集</title>
      <link href="/blog/2021/12/24/CS-%E8%BF%90%E7%BB%B4%E5%8D%B1%E9%99%A9%E5%91%BD%E4%BB%A4%E5%90%88%E9%9B%86/"/>
      <url>/blog/2021/12/24/CS-%E8%BF%90%E7%BB%B4%E5%8D%B1%E9%99%A9%E5%91%BD%E4%BB%A4%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>命令</th><th>作用</th><th>类型</th><th>危险级别</th></tr></thead><tbody><tr><td><code>rm -rf</code></td><td><code>rm</code> 命令用于在 Linux 系统下删除文件文件夹 <code>-r</code> 参数用于递归删除文件夹 <code>-f</code> 参数用于强制删除(不经过询问)</td><td>恶意删除</td><td>中</td></tr><tr><td><code>rm -rf /</code></td><td>递归强制删除根目录下的所有文件与文件夹</td><td>恶意删除</td><td>高</td></tr><tr><td><code>rm -rf *</code></td><td>递归强制删除当前目录的所有文件</td><td>恶意删除</td><td>高</td></tr><tr><td><code>rm -rf .</code></td><td>递归强制删除当前目录的所有文件夹</td><td>恶意删除</td><td>中</td></tr><tr><td><code>mv / /dev/null</code></td><td>该命令会将文件夹移动到 /dev/null 下，在 Linux 系统中 /dev/null 是一个特殊的文件，所有写入他的数据都会被清除，然后返回操作成功</td><td>恶意删除</td><td>低</td></tr><tr><td><code>:()&#123;:｜:&amp;&#125;;:</code></td><td>fork 炸弹，具体操作是通过定义一个名为 ‘:‘ 的函数，它会调用自己两次，一次在前台另一次运行在后台，它会反复的执行下去直到系统崩溃</td><td>资源耗尽</td><td>高</td></tr><tr><td><code>echo &quot; &quot; &gt; /dev/sda</code></td><td>/dev 目录下存放的是设备的文件描述符。直接往设备描述符中写入数据，将破坏整个设备</td><td>直接操作设备文件描述符</td><td>高</td></tr><tr><td><code>mkfs.ext3 /dev/sda</code></td><td>把硬盘格式化成ext3文件系统，在执行这个命令后你的块设备（硬盘驱动器）会被格式化，直接让你的系统达到不可恢复的阶段</td><td>直接操作设备文件描述符</td><td>高</td></tr><tr><td><code>fdisk /dev/sda</code></td><td>重建分区</td><td>直接操作设备文件描述符</td><td>高</td></tr><tr><td><code>dd if=/dev/zero of=/dev/sda</code> <code>dd if=/dev/random of=/dev/sda</code></td><td>直接写入数据到磁盘设备文件描述符</td><td>直接操作设备文件描述符</td><td>高</td></tr><tr><td><code>&gt; file</code></td><td>该命令常用来清空文件内容或记录命令输出，用户可能真正想用的是 <code>&gt;&gt;</code>，即累加新的输出到文件，而不是刷新那个文件</td><td>恶意命令执行</td><td>低</td></tr><tr><td><code>export HISTCONTROL = ignorespace</code></td><td>在命令前面插入空格，这条命令会被 shell 忽略，也就意味着它不会出现在历史记录中。但是这种方法有个前提，只有在你的环境变量 HISTCONTROL 设置为 “ignorespace” 或者 “ignoreboth” 才会起作用。在大多数情况下，这个是默认值，我们无需设置这个环境变量。</td><td>隐藏命令</td><td>低</td></tr><tr><td><code>ln -s /dev/null ~/.bash_history</code></td><td>history 记录存放在 <code>~/.bash_history</code> 文件中，把写入 <code>~/.bash_history</code> 使用软连接转移写入到其他的地方可以隐藏命令历史</td><td>隐藏命令</td><td>低</td></tr><tr><td><code>^foo^bar</code></td><td>该命令用来编辑先前运行的命令而无需重打整个命令，如果用户没有彻底检查命令，可能调用不符合预期的命令</td><td>隐式调用</td><td>低</td></tr></tbody></table><span id="more"></span><table><thead><tr><th>类型</th><th>名称</th><th>正则表达式</th><th>威胁等级</th></tr></thead><tbody><tr><td>反弹shell</td><td>反弹shell</td><td><code>exec\s*\d*&lt;&gt;\s*/dev/tcp/(.*)/(.*)</code></td><td>高危</td></tr><tr><td>反弹shell</td><td>利用bash反弹shell</td><td><code>bash\s+-i\s*&gt;&amp;\s+\/dev\/tcp\/\d+\.\d+\.\d+\.\d+\/\d+</code></td><td>高危</td></tr><tr><td>agent威胁操作</td><td>杀掉agent进程</td><td><code>pkill\s+titanagent</code></td><td>高危</td></tr><tr><td>agent威胁操作</td><td>删除agent配置</td><td><code>\s*rm\s+-\w+\s+\/etc\/titan</code></td><td>高危</td></tr><tr><td>端口转发</td><td>portmap端口转发</td><td><code>portmap\s+\-m</code></td><td>高危</td></tr><tr><td>代理</td><td>利用代理软件lcx</td><td><code>lcx(\.exe)*\s\-(slave｜listen)</code></td><td>高危</td></tr><tr><td>代理</td><td>rcsocks执行socks反向代理</td><td><code>rcsocks\s+-\w</code></td><td>高危</td></tr><tr><td>代理</td><td>使用ssocks建立socks反向代理</td><td><code>rssocks\s*-vv</code></td><td>高危</td></tr><tr><td>代理</td><td>rssocks创建socks反向代理</td><td><code>^rssocks&lt;&gt;-vv</code></td><td>高危</td></tr><tr><td>代理</td><td>利用$IFS绕过，执行rssocks</td><td><code>rssocks\$IFS-vv</code></td><td>高危</td></tr><tr><td>代理</td><td>利用{}绕过，rssocks执行socks反向代理</td><td><code>\&#123;rssocks,-vv\&#125;</code></td><td>高危</td></tr><tr><td>清理痕迹</td><td>清除替换系统安全日志</td><td><code>(ca｜ech)[t｜o]*(.*)\w+\s*(?=\&gt;)&gt;(?&lt;=&gt;)\s*[\w/]+secure\b</code></td><td>高危</td></tr><tr><td>后门</td><td>设置ssh任意密码登录后门</td><td><code>ln\s*\-sf\s*/usr/sbin/sshd\s(.*)</code></td><td>高危</td></tr><tr><td>后门</td><td>替换ssh密钥</td><td><code>^echo\s+[&#39;｜&quot;]ssh-rsa\s+((.｜\n)*)[&#39;｜&quot;]\s*&gt;&gt;\.ssh\/authorized_keys</code></td><td>高危</td></tr><tr><td>后门</td><td>创建任意密码登录后门</td><td><code>ln\s+-\w+\s+(\/\w+)+\/sshd\s+(\/\w+)+\/su;(\/\w+)\/su\s+-\w+=\d+</code></td><td>高危</td></tr><tr><td>后门</td><td>使用curl安装后门的连贯操作</td><td><code>curl\s*http.*&gt;.*;.*chmod\s*777\s*(.*)\s*;\s*</code></td><td>高危</td></tr><tr><td>后门</td><td>使用wget安装后门的连贯操作</td><td><code>wget\s*http.*-O.*;.*chmod\s*777\s*(.*)\s*;\s*</code></td><td>高危</td></tr><tr><td>可疑命令</td><td>使用 hydra 进行密码爆破</td><td><code>hydra\s(.*)</code></td><td>高危</td></tr><tr><td>可疑命令</td><td>利用变量绕过执行系统命令</td><td><code>^\w+=\$[&#39;｜&quot;]\\x20.+[&#39;｜&quot;]\&amp;\&amp;.+\$\w+</code></td><td>高危</td></tr><tr><td>可疑命令</td><td>vigr修改shadow文件</td><td><code>^(vigr｜\/usr\/sbin\/vigr)\s+-s</code></td><td>高危</td></tr><tr><td>可疑命令</td><td>vipw修改shadow文件</td><td><code>^(vipw｜\/usr\/sbin\/vipw)\s+-+s</code></td><td>高危</td></tr><tr><td>代理</td><td>使用代理软件ngrok</td><td><code>ngrok\s+-(domain｜config)</code></td><td>中危</td></tr><tr><td>代理</td><td>使用代理软件frp</td><td><code>frp[cs]\s+-c\s+\w+\.ini</code></td><td>中危</td></tr><tr><td>代理</td><td>使用代理软件tgcd</td><td><code>tgcd\s+-[CLF]</code></td><td>中危</td></tr><tr><td>代理</td><td>使用代理软件iox</td><td><code>iox\s+(fwd｜proxy)</code></td><td>中危</td></tr><tr><td>代理</td><td>使用代理软件natbypass</td><td><code>nb\s+-(listen｜tran｜slave)</code></td><td>中危</td></tr><tr><td>代理</td><td>使用http代理转发</td><td><code>python\s+reGeorgSocksProxy\.py</code></td><td>中危</td></tr><tr><td>代理</td><td>利用{}绕过，执行rssocks</td><td><code>\&#123;\s*rssocks\s*,\s*\-vv\s*\&#125;</code></td><td>中危</td></tr><tr><td>agent威胁操作</td><td>卸载agent</td><td><code>\/titan\/agent\/install.sh\s+(disclean｜uninstall)</code></td><td>中危</td></tr><tr><td>后门</td><td>ssh软连接后门准备工作，复制pam.d下的文件</td><td><code>^cp\s*\/etc\/pam.d/\w+\s+\/\w+(.*)</code></td><td>中危</td></tr><tr><td>后门</td><td>ssh软连接后门安装</td><td><code>ln\s*-sf\s*\/usr\/sbin\/sshd\s*\/\w+\/\w+\s*;\s*\/\w+\/\w+\s*-[o｜O][p｜P][o｜O][r｜R][t｜T]\s*=\s*[0-9]*</code></td><td>中危</td></tr><tr><td>后门</td><td>替换ssh密钥</td><td><code>^echo\s+[&#39;｜&quot;]ssh-rsa\s+((.｜\n)*)[&#39;｜&quot;]\s*&gt;&gt;\.ssh\/authorized_keys</code></td><td>中危</td></tr><tr><td>arp 欺骗</td><td>使用 arp-dsniff 进行 arp 欺骗</td><td><code>dsniff\s*</code></td><td>中危</td></tr><tr><td>arp 欺骗</td><td>使用 ettercap 进行 arp 欺骗</td><td><code>^ettercap\s*</code></td><td>中危</td></tr><tr><td>arp 欺骗</td><td>使用 arpsniffer 进行 arp 欺骗</td><td><code>arpsniffer\s(.*)</code></td><td>中危</td></tr><tr><td>arp 欺骗</td><td>使用 arpspoof 进行 arp 欺骗</td><td><code>arpspoof\s*</code></td><td>中危</td></tr><tr><td>清理痕迹</td><td>设置操作命令不记录进日志a</td><td><code>HISTFILESIZE\s*=\s*[0-9]</code></td><td>中危</td></tr><tr><td>清理痕迹</td><td>设置操作命令不记录进日志b</td><td><code>HISTFILESIZE\s*=\s*10</code></td><td>中危</td></tr><tr><td>清理痕迹</td><td>设置操作命令不记录进日志c</td><td><code>HISTSIZE\s*=\s*[0-9]</code></td><td>中危</td></tr><tr><td>清理痕迹</td><td>设置操作命令不记录进日志d</td><td><code>^history\s*-c</code></td><td>中危</td></tr><tr><td>清理痕迹</td><td>设置操作命令不记录进日志e</td><td><code>HISTSIZE\s*=\s*10</code></td><td>中危</td></tr><tr><td>清理痕迹</td><td>设置操作命令不记录进日志f</td><td><code>unset(\s*HIST[A-Z]+)+</code></td><td>中危</td></tr><tr><td>清理痕迹</td><td>查看或修改历史记录</td><td><code>(cat｜vim｜vi｜nano)\s+.*\.\w+_history</code></td><td>中危</td></tr><tr><td>清理痕迹</td><td>清除系统中 wtmp 记录</td><td><code>wtmpclean\s(.*)</code></td><td>中危</td></tr><tr><td>清理痕迹</td><td>清除替换用户登录信息</td><td><code>(ca｜ech)[t｜o]*(.*)\w+\s*(?=\&gt;)&gt;(?&lt;=&gt;)\s*[\w/]+lastlog\b</code></td><td>中危</td></tr><tr><td>清理痕迹</td><td>清理bash历史记录日志</td><td><code>cat\s*\/dev\/null\s*\&gt;\s*([~\/a-zA-Z0-9\.])+\.bash_history</code></td><td>中危</td></tr><tr><td>清理痕迹</td><td>清除替换web日志</td><td><code>(ca｜ech)[t｜o]*(.*)\w+\s*(?=\&gt;)&gt;(?&lt;=&gt;)\s*[\w/]+access_log\b</code></td><td>中危</td></tr><tr><td>清理痕迹</td><td>设置操作命令不记录进日志</td><td><code>set\s*\+o\s*history</code></td><td>中危</td></tr><tr><td>清理痕迹</td><td>清除历史记录</td><td><code>history\s*-c\s*</code></td><td>中危</td></tr><tr><td>清理痕迹</td><td>清除替换utmp日志</td><td><code>(ca｜ech)[t｜o]*(.*)\w+\s*(?=\&gt;)&gt;(?&lt;=&gt;)\s*[\w/]+utmp\b</code></td><td>中危</td></tr><tr><td>清理痕迹</td><td>清除替换messages日志系统</td><td><code>(ca｜ech)[t｜o]*(.*)\w+\s*(?=\&gt;)&gt;(?&lt;=&gt;)\s*[\w/]+messages\b</code></td><td>中危</td></tr><tr><td>清理痕迹</td><td>利用{}绕过,设置操作命令不记录进日志</td><td><code>\&#123;\s*export\s*,\s*HISTSIZE=0\s*\&#125;</code></td><td>中危</td></tr><tr><td>清理痕迹</td><td>清除替换记录日志</td><td><code>(ca｜ech)[t｜o]*(.*)\w+\s*(?=\&gt;)&gt;(?&lt;=&gt;)\s*[\w/]+wtmp\b</code></td><td>中危</td></tr><tr><td>清理痕迹</td><td>设置操作命令不记录进日志</td><td><code>export\$IFSHISTFILE\s*=\s*\/dev\/null</code></td><td>中危</td></tr><tr><td>清理痕迹</td><td>利用{}绕过,不记录历史</td><td><code>\&#123;\s*unset\s*,\s*HIST[A-Z]+\s*\&#125;</code></td><td>中危</td></tr><tr><td>清理痕迹</td><td>使用logtamper修改linux日志</td><td><code>logtamper-static\s(.*)</code></td><td>中危</td></tr><tr><td>清理痕迹</td><td>清除替换记录错误的登录信息</td><td><code>(ca｜ech)[t｜o]*(.*)\w+\s*(?=\&gt;)&gt;(?&lt;=&gt;)\s*[\w/]+btmp\b</code></td><td>中危</td></tr><tr><td>清理痕迹</td><td>利用{}绕过,查看或修改历史文件</td><td><code>\&#123;(vi｜vim｜cat),(\/.+\/)*\.bash_history\&#125;</code></td><td>中危</td></tr><tr><td>清理痕迹</td><td>设置操作命令不记录进日志</td><td><code>export\s*HISTSIZE=0</code></td><td>中危</td></tr><tr><td>清理痕迹</td><td>清除替换记录web错误日志</td><td><code>(ca｜ech)[t｜o]*(.*)\w+\s*(?=\&gt;)&gt;(?&lt;=&gt;)\s*[\w/]+error_log\b</code></td><td>中危</td></tr><tr><td>清理痕迹</td><td>设置操作命令不记录进日志</td><td><code>export\s*HISTFILE=\/dev\/null</code></td><td>中危</td></tr><tr><td>清理痕迹</td><td>利用$IFS绕过查看或修改mysql历史记录</td><td><code>(vim｜cat｜vi)\$IFS.+\.mysql_history</code></td><td>中危</td></tr><tr><td>清理痕迹</td><td>清除替换登录认证日志</td><td><code>(ca｜ech)[t｜o]*(.*)\w+\s*(?=\&gt;)&gt;(?&lt;=&gt;)\s*[\w/]+auth.log\b</code></td><td>中危</td></tr><tr><td>清理痕迹</td><td>利用{}绕过,设置操作命令不记录进日志</td><td><code>^\&#123;export,HISTFILE\s*=\s*\/dev\/null\&#125;</code></td><td>中危</td></tr><tr><td>可疑命令</td><td>nmap端口扫描</td><td><code>^\s*nmap\s(.*)</code></td><td>中危</td></tr><tr><td>可疑命令</td><td>查看或修改host key</td><td><code>(cat｜vim｜vi)\s*(.)*known_hosts</code></td><td>中危</td></tr><tr><td>可疑命令</td><td>查看etc目录下的passwd文件</td><td><code>^\s*&lt;\/etc\/passwd\s+grep\s+([a-z]｜[A-Z]｜[0-9]｜\:｜\/)+$</code></td><td>中危</td></tr><tr><td>可疑命令</td><td>查看系统数据库passwd相关记录</td><td><code>getent\s*password\s*\S*</code></td><td>中危</td></tr><tr><td>可疑命令</td><td>使用python执行切换shell</td><td><code>pty\.spawn\((&#39;｜&quot;)\/bin\/(bash｜sh)(&#39;｜&quot;)\)</code></td><td>中危</td></tr><tr><td>可疑命令</td><td>vigr修改密码文件</td><td><code>^(vigr｜\/usr\/sbin\/vigr)\s+-p</code></td><td>中危</td></tr><tr><td>可疑命令</td><td>vipw修改密码文件</td><td><code>^(vipw｜\/usr\/sbin\/vipw)\s+-p</code></td><td>中危</td></tr><tr><td>可疑命令</td><td>查看etc目录下shadow文件</td><td><code>^\s*&lt;\/etc\/shadow\s+grep\s+([a-z]｜[A-Z]｜[0-9]｜\:｜\/)+$</code></td><td>中危</td></tr><tr><td>可疑命令</td><td>从github下载或提交代码</td><td><code>^git((?!clone｜commit).)*github.*</code></td><td>中危</td></tr><tr><td>明文登录</td><td>MongoDB明文密码登录</td><td>命中示例：<code>mongo 127.0.0.1:27017/admin -u superuser -p pwd</code></td><td>中危</td></tr><tr><td>明文登录</td><td>MySQL明文密码登录</td><td>命中示例：<code>mysql -P 3306 -u root -p 123456</code></td><td>中危</td></tr><tr><td>代理</td><td>利用{}绕过,rssocks执行socks反向代理</td><td><code>\&#123;rssocks,-vv\&#125;</code></td><td>低危</td></tr><tr><td>后门</td><td>ln软连接sshd任意密码登录后门</td><td><code>ln\s*-sf\s*\/usr\/sbin\/sshd.*?(su｜chsh｜chfn);.*?-[oO][pP][oO][rR][tT]=</code></td><td>低危</td></tr><tr><td>反弹shell</td><td>ncat反弹shell</td><td><code>ncat\s+--ssl.*?\/bin\/bash</code></td><td>低危</td></tr><tr><td>反弹shell</td><td>exec重定向反弹shell</td><td><code>\bexec\s*\d+&lt;&gt;\/dev\/(｜udp).*?while\s*read\s*.*?done</code></td><td>低危</td></tr><tr><td>反弹shell</td><td>node反弹shell</td><td><code>node.*?-e.*?.*?require\([&#39;&quot;]child_process[&#39;&quot;]\)\.spawn.*?(bash｜sh).*?connect.*?pipe</code></td><td>低危</td></tr><tr><td>反弹shell</td><td>telnet双端口反弹shell</td><td><code>telnet\s+\d+\.\d+\.\d+\.\d+.*?bash.*?telnet\s+\d+\.\d+\.\d+\.\d+</code></td><td>低危</td></tr><tr><td>反弹shell</td><td>python反弹shell.b</td><td><code>import\s+pty.*?\.spawn\(.*?\).*?&lt;&gt;/dev/(tcp｜udp)/.*?/\d+.*?&gt;.*?</code></td><td>低危</td></tr><tr><td>反弹shell</td><td>Ruby反弹shell.a</td><td><code>ruby(\s+｜\$IFS)-rsocket(\s+｜\$IFS)-ropenssl(\s+｜\$IFS)-e\s*[&#39;｜&quot;]?.*?=OpenSSL::SSL::SSLSocket.new\(TCPSocket.new\(</code></td><td>低危</td></tr><tr><td>反弹shell</td><td>nc反弹shell</td><td><code>cat\s+.*?\｜.*?\s+bash\s+.*?\｜.*?\s+nc\s+.*?</code></td><td>低危</td></tr><tr><td>反弹shell</td><td>Ruby反弹shell.b</td><td><code>ruby(\s+｜\$IFS)-rsocket(\s+｜\$IFS)-e\s*[&#39;｜&quot;]?.*?=TCPSocket\.((new.*?｜O.popen)｜(open.*?\.to_i;exec))</code></td><td>低危</td></tr><tr><td>反弹shell</td><td>socat反弹shell</td><td><code>socat\s*exec:[&#39;｜&quot;]?bash(\s-li)?[&#39;｜&quot;]?.*?\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;:\d&#123;1,5&#125;</code></td><td>低危</td></tr><tr><td>反弹shell</td><td>php反弹fsockopen</td><td><code>php\s*-r\s*[&#39;｜&quot;]?.*?fsockopen\(.*?\);.*?((exec｜proc_open｜shell_exec｜system｜popen)\(.*?\);｜.*?(bash｜sh｜dash｜tcsh｜csh｜ksh｜zsh))</code></td><td>低危</td></tr><tr><td>反弹shell</td><td>rm/mkfifo/sh/nc反弹shell</td><td><code>rm.*?;mkfifo.*?;cat.*?\｜.*?(sh｜bash).*?\｜nc</code></td><td>低危</td></tr><tr><td>反弹shell</td><td>socket/tchsh反弹shell</td><td><code>echo\s[&quot;&#39;].*?\[socket.*?while.*?puts.*?flush.*[&#39;&quot;]\s*\｜\s*tclsh</code></td><td>低危</td></tr><tr><td>反弹shell</td><td>awk反弹shell</td><td><code>g?awk\s+[&#39;&quot;]BEGIN\s*\&#123;.*?\/inet\/tcp\/0\/\d+\.\d+\.\d+\.\d+\/\d+.*?(for｜while).*?getline.*?while.*?getline</code></td><td>低危</td></tr><tr><td>反弹shell</td><td>perl反弹shell</td><td><code>[&#39;&quot;].*?IO::Socket::(SSL｜INET).*?\d+\.\d+\.\d+\.\d+:\d+.*?((while.*?sysread.*?syswrite)｜(fdopen.*?fdopen.*?system\$_\s+while))</code></td><td>低危</td></tr><tr><td>反弹shell</td><td>python反弹shell.a</td><td><code>import.*?socket.*?socket\(.*?\).*?connect\(.*?\).*?((Popen\(.*?PIPE.*?\))｜(os\.dup2.*?(call｜pty\.spawn)\())</code></td><td>低危</td></tr><tr><td>反弹shell</td><td>lua反弹shell</td><td><code>use .*?Socket.*?socket\(.*?SOCK_STREAM.*?connect.*?open.*?exec.*?(sh｜bash)</code></td><td>低危</td></tr><tr><td>反弹shell</td><td>mkfifo/openssl反弹shell</td><td><code>mkfifo\s+\/.*?;\s*\/bin\/sh.*?\｜\s*openssl\s+s_client.*?&gt;</code></td><td>低危</td></tr><tr><td>反弹shell</td><td>bash反弹shell</td><td><code>.*?(bash｜sh｜dash｜tcsh｜csh｜ksh｜zsh).*?\/dev\/(tcp｜udp)\/\d+\.\d+\.\d+\.\d+\/\d+\s+0(&lt;｜&gt;)&amp;</code></td><td>低危</td></tr><tr><td>反弹shell</td><td>exec反弹shell</td><td><code>exec\s*\d*&lt;&gt;\s*/dev/(tcp｜upd)/(.*)/(.*)</code></td><td>低危</td></tr><tr><td>反弹shell</td><td>php_socket反弹shell</td><td><code>php\s+-r\s*[&quot;&#39;].*?stream_socket_client\(.*?STREAM_CLIENT_CONNECT.*?while.*?exec</code></td><td>低危</td></tr><tr><td>清理痕迹</td><td>查看或修改mysql历史记录</td><td><code>(cat｜vim｜vi)\s*(.)*\.mysql_history</code></td><td>低危</td></tr><tr><td>清理痕迹</td><td>利用{},查看或修改mysql历史记录</td><td><code>\&#123;\s*(vim｜vi｜cat)\s*,\s*.+\.mysql_histroy\&#125;</code></td><td>低危</td></tr><tr><td>可疑命令</td><td>增加uid为0的系统账号</td><td><code>useradd\s*-o\s*-u\s*0\s*</code></td><td>低危</td></tr><tr><td>可疑命令</td><td>python/base64执行</td><td><code>python.*?-c.*?exec.*?base64</code></td><td>低危</td></tr><tr><td>可疑命令</td><td>sudo提权漏洞利用</td><td><code>sudo\s*-u#(4294967295｜-1)\s*.*</code></td><td>低危</td></tr><tr><td>可疑命令</td><td>使用netcat工具</td><td><code>netcat\s(.*)</code></td><td>低危</td></tr><tr><td>可疑命令</td><td>利用{}绕过执行netcat</td><td><code>\&#123;\s*netcat\s*,\s*.+\&#125;</code></td><td>低危</td></tr><tr><td>可疑命令</td><td>vigr修改组文件</td><td><code>^(vigr｜\/usr\/sbin\/vigr)\s+-g</code></td><td>低危</td></tr><tr><td>可疑命令</td><td>vipw修改组文件</td><td><code>^(vipw｜\/usr\/sbin\/vipw)\s+-g</code></td><td>低危</td></tr><tr><td>可疑命令</td><td>修改权限，利用$IFS绕过</td><td><code>chmod(\$IFS([0-9a-zA-Z\.\&#39;])+)+</code></td><td>低危</td></tr><tr><td>可疑命令</td><td>切换shell.a</td><td><code>^ +\.\/(｜z｜da｜tc｜c｜k)sh$</code></td><td>低危</td></tr><tr><td>可疑命令</td><td>切换shell.b</td><td><code>^\s*\/bin\/(｜z｜da｜tc｜c｜k)sh$</code></td><td>低危</td></tr><tr><td>可疑命令</td><td>ncat测试端口连通性</td><td><code>ncat\s+\d+\.\d+\.\d+\.\d+\s+\d+</code></td><td>低危</td></tr><tr><td>可疑命令</td><td>查看/etc/passwd用户数</td><td><code>wc\s+-l\s+\&lt;\s+\/etc\/passwd</code></td><td>低危</td></tr><tr><td>可疑命令</td><td>wipe删除文件或目录</td><td><code>wipe\s(.*)</code></td><td>低危</td></tr><tr><td>可疑命令</td><td>查看/etc/shadow</td><td><code>^\s*&lt;\/etc\/shadow\s+grep\s+([a-z]｜[A-Z]｜[0-9]｜\:｜\/)+$</code></td><td>低危</td></tr><tr><td>可疑命令</td><td>查看内核版本</td><td><code>ls\s+\/boot(\/)*\s*$</code></td><td>低危</td></tr><tr><td>可疑命令</td><td>nc规则</td><td><code>^nc(\s+-\w+)+</code></td><td>低危</td></tr><tr><td>可疑命令</td><td>使用ettercap嗅探</td><td><code>ettercap\s+\-\w\s+\-\w\s+arp</code></td><td>低危</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正式环境禁用调试-无限debug</title>
      <link href="/blog/2021/12/02/HACK-%E6%AD%A3%E5%BC%8F%E7%8E%AF%E5%A2%83%E7%A6%81%E7%94%A8%E8%B0%83%E8%AF%95-%E6%97%A0%E9%99%90debug/"/>
      <url>/blog/2021/12/02/HACK-%E6%AD%A3%E5%BC%8F%E7%8E%AF%E5%A2%83%E7%A6%81%E7%94%A8%E8%B0%83%E8%AF%95-%E6%97%A0%E9%99%90debug/</url>
      
        <content type="html"><![CDATA[<p>前端的代码包括js文件、html文件和css文件都是需要发送给浏览器客户端的，在一定程度上，我们的代码是完全“开源”给了用户，但难免有恶意用户通过调试我们的代码发现系统的漏洞，从而对我们的网站进行攻击，或者盗用我们的代码，与我们进行竞争。这时就需要采取一定的手段，禁止恶意用户盗取代码的行为，或者加大恶意用户使用调试我们代码的成本。现如今，已经有多种成熟的方案可以达到这些目的，比如压缩代码、混淆代码、控制流平坦化等。<br>这里我们提一种禁止开发者工具调试的方法，基本原理就是让开发者工具一直处于断点调试的状态，从而无法查看真正的代码。</p><span id="more"></span><p>说到调试，首先我们能想到一个关键字 <code>debugger</code> ，这个关键字能让页面在打开开发者工具后自动添加断点，在不打开开发者工具时对用户完全无感知。它本意是为了方便调试，这里，我们使用它来达到一直断点的目的。</p><p>（以下代码均以 macOS 10.15.7 系统 Chrome 96.0.4664.55 浏览器执行结果为准）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">debugger</span></span><br></pre></td></tr></table></figure><p>在代码中添加 <code>debugger</code> 可以让调试中断，但是只能中断一次，用户只要按 F8 或者 Command + \ 继续执行脚本，就可以跳过。为了能不停的 debug 我们需要和定时器 <code>setInterval</code> 结合来使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="keyword">debugger</span>&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>这样，用户在打开网页之后就会不停的 debug 。但是，我们总要把上述代码添加到我们自己的代码中去，因为执行到断点时会显示当前脚本所在文件，所以我们的代码还是展示在了用户面前，为了避免这个问题我们可以使用 <code>Function</code> 构造一个新函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;debugger&#x27;</span>), <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>这样，在执行到断点的时候，开发者工具就会打开一个名为类似 VM5419 的文件执行断点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">anonymous</span>(<span class="params"></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">debugger</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但是，有经验的开发者仍旧可以跳过这个断点，只需要在 <code>debugger</code> 所在的行左边点击右键，然后选择“一律不在此处暂停”即可。为了避免这个问题，我们需要每次执行断点时，都创建一个新的匿名函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;debugger&#x27;</span>)()&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>这样，每次执行断点都会在一个新的匿名函数中，用户就无法通过禁用单次断点来调试我们的代码了。如果用户还是想查看代码，可以通过按 Command + F8 禁用断点来查看。但禁用了断点的话，用户同时也无法调试代码了。你可能想到，即使这样，用户还是可以通过在代码中进行字符串查找，查找 <code>debugger</code> 关键字，然后通过代理将该行代码删除后再进行调试。这里我们就需要让用户找不到 <code>debugger</code> 关键字，方法有很多种，比如改变编码形式，进行字符串拼接等，这里我们以采用 base64 编码的形式为例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="title function_">atob</span>(<span class="string">&#x27;c2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXtuZXcgRnVuY3Rpb24oIiIsImRlYnVnZ2VyIikoKX0sIDEwMCk=&#x27;</span>));</span><br></pre></td></tr></table></figure><p>结合 webpack UglifyJS Tensor 等工具，对代码进行拆分，压缩，混淆，监听鼠标键盘按键，对敏感操作（右键 f12 复制）进行一些过滤，重写 <code>console</code> 等日志打印方法，同时加上 无限debugger，可以成倍的加大破解代码的成本，没有能力和耐心的黑客恐怕要知难而退了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> security </tag>
            
            <tag> debugger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React router速读速懂</title>
      <link href="/blog/2021/11/29/React-router%E9%80%9F%E8%AF%BB%E9%80%9F%E6%87%82/"/>
      <url>/blog/2021/11/29/React-router%E9%80%9F%E8%AF%BB%E9%80%9F%E6%87%82/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/remix-run/react-router">React Router</a> 是一个基于 React 之上的路由库，它可以让你向应用中快速地添加视图和数据流，同时保持页面与 URL 间的同步。  </p><p>React Router 是建立在 <a href="https://github.com/remix-run/history">history</a> 库之上的。 history 监听浏览器地址栏的变化，解析 URL 并转化为 location 对象， 然后 router 使用它匹配到路由，最后正确地渲染对应的组件。  </p><p>该文章写于 2021-11-29 10:56:40 目前 React-router 最新版本为 6.0.2，React-router 不同版本 API 相差较大，该文章以当前最新版本为标准。  </p><span id="more"></span><h2 id="React-router-用法"><a href="#React-router-用法" class="headerlink" title="React router 用法"></a>React router 用法</h2><p>参考 <a href="https://github.com/remix-run/react-router/blob/main/docs/getting-started/tutorial.md">React router 教程</a></p><figure class="highlight js"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BrowserRouter</span>, <span class="title class_">Routes</span>, <span class="title class_">Route</span>, <span class="title class_">Navigate</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Expenses</span>, <span class="title class_">Invoices</span>, <span class="title class_">Invoice</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./routes&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">render</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">App</span> /&gt;</span>&#125; &gt;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;expenses&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Expenses</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;invoices&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Invoices</span> /&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">Route</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">index</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">element</span>=<span class="string">&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                            &lt;<span class="attr">main</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">padding:</span> &quot;<span class="attr">1rem</span>&quot; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">                                <span class="tag">&lt;<span class="name">p</span>&gt;</span>Select an invoice<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                            <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        &#125;</span></span><br><span class="line"><span class="language-xml">                    /&gt;</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;:invoiceId&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Invoice</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;old-expenses&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    &lt;<span class="attr">Navigate</span> <span class="attr">to</span>=<span class="string">&quot;/expenses&quot;</span> <span class="attr">replace</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#125;&gt;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Route</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">path</span>=<span class="string">&quot;*&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">element</span>=<span class="string">&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        &lt;<span class="attr">main</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">padding:</span> &quot;<span class="attr">1rem</span>&quot; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">                            <span class="tag">&lt;<span class="name">p</span>&gt;</span>There&#x27;s nothing here!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    &#125; /&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">BrowserRouter</span>&gt;</span></span>,</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol><li>根结点 BrowserRouter 表示采用浏览器 path 导航</li><li>Routes 是 Route 的父节点，表明从子节点 Route 中选一个匹配，Route 的 path 参数表明对应的路由路径，element 参数表明需要渲染的组件</li><li>Route 可以嵌套，当 Route 嵌套时，父组件中的 Outlet 组件表明了子组件渲染的位置</li><li>Route 的 index 参数为 true 表示其为当兄弟 Route 的 path 均不匹配时的默认渲染组件</li><li>path 参数’*’为通配符，以 ‘/‘开头时为绝对路径，否则为相对路径</li><li>Navigate 表示跳转到对应路径，replace 参数代表是否替换当前 history，所以<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&quot;old-expenses&quot;</span> element=&#123;</span><br><span class="line">     <span class="language-xml"><span class="tag">&lt;<span class="name">Navigate</span> <span class="attr">to</span>=<span class="string">&quot;/expenses&quot;</span> <span class="attr">replace</span> /&gt;</span></span></span><br><span class="line"> &#125;&gt;</span><br></pre></td></tr></table></figure>其实实现了重定向的功能</li></ol><figure class="highlight js"><figcaption><span>App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Outlet</span>, <span class="title class_">Link</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Bookkeeper!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">nav</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">borderBottom:</span> &quot;<span class="attr">solid</span> <span class="attr">1px</span>&quot;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">paddingBottom:</span> &quot;<span class="attr">1rem</span>&quot;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/invoices&quot;</span>&gt;</span>Invoices<span class="tag">&lt;/<span class="name">Link</span>&gt;</span> |&#123;&quot; &quot;&#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/expenses&quot;</span>&gt;</span>Expenses<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Outlet</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>Link 表示点击跳转（渲染为a元素），to 参数表示跳转的路径</li><li>Outlet 标志了子组件的渲染位置</li></ol><figure class="highlight jsx"><figcaption><span>routes/invoices.jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NavLink</span>, <span class="title class_">Outlet</span>, useSearchParams &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; getInvoices &#125; <span class="keyword">from</span> <span class="string">&quot;../data&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; useLocation &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果想要跳转时保留searchparams 需要使用QueryNavLink,否则使用Navlink</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">QueryNavLink</span>(<span class="params">&#123; to, ...props &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> location = <span class="title function_">useLocation</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">&#123;to</span> + <span class="attr">location.search</span>&#125; &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Invoices</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> invoices = <span class="title function_">getInvoices</span>();</span><br><span class="line">    <span class="keyword">let</span> [searchParams, setSearchParams] = <span class="title function_">useSearchParams</span>();</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">display:</span> &quot;<span class="attr">flex</span>&quot; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">nav</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">borderRight:</span> &quot;<span class="attr">solid</span> <span class="attr">1px</span>&quot;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">padding:</span> &quot;<span class="attr">1rem</span>&quot;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">value</span>=<span class="string">&#123;searchParams.get(</span>&quot;<span class="attr">filter</span>&quot;) || &quot;&quot;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">onChange</span>=<span class="string">&#123;event</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">                        let filter = event.target.value;</span></span><br><span class="line"><span class="language-xml">                        if (filter) &#123;</span></span><br><span class="line"><span class="language-xml">                            setSearchParams(&#123; filter &#125;);</span></span><br><span class="line"><span class="language-xml">                        &#125; else &#123;</span></span><br><span class="line"><span class="language-xml">                            setSearchParams(&#123;&#125;);</span></span><br><span class="line"><span class="language-xml">                        &#125;</span></span><br><span class="line"><span class="language-xml">                    &#125;&#125;</span></span><br><span class="line"><span class="language-xml">                /&gt;</span></span><br><span class="line"><span class="language-xml">                &#123;invoices</span></span><br><span class="line"><span class="language-xml">                    .filter(invoice =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">                        let filter = searchParams.get(&quot;filter&quot;);</span></span><br><span class="line"><span class="language-xml">                        if (!filter) return true;</span></span><br><span class="line"><span class="language-xml">                        let name = invoice.name.toLowerCase();</span></span><br><span class="line"><span class="language-xml">                        return name.startsWith(filter.toLowerCase());</span></span><br><span class="line"><span class="language-xml">                    &#125;).map(invoice =&gt; (</span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">QueryNavLink</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                            <span class="attr">style</span>=<span class="string">&#123;(&#123;</span> <span class="attr">isActive</span> &#125;) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">                                return &#123;</span></span><br><span class="line"><span class="language-xml">                                    display: &quot;block&quot;,</span></span><br><span class="line"><span class="language-xml">                                    margin: &quot;1rem 0&quot;,</span></span><br><span class="line"><span class="language-xml">                                    color: isActive ? &quot;red&quot; : &quot;&quot;</span></span><br><span class="line"><span class="language-xml">                                &#125;;</span></span><br><span class="line"><span class="language-xml">                            &#125;&#125;</span></span><br><span class="line"><span class="language-xml">                            to=&#123;`/invoices/$&#123;invoice.number&#125;`&#125;</span></span><br><span class="line"><span class="language-xml">                            key=&#123;invoice.number&#125;</span></span><br><span class="line"><span class="language-xml">                        &gt;</span></span><br><span class="line"><span class="language-xml">                            &#123;invoice.name&#125;</span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;/<span class="name">QueryNavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    ))&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Outlet</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>通过 useSearchParams 钩子可以获取到搜索参数</li><li>NavLink 同 Link 类似，也会渲染成 a 元素，但是 style 属性和 className 属性中提供了 isActive 参数来识别是否和当前页面一致</li><li>NavLink 比较跳转链接和当前页面地址是否一致时只比较页面路径，如果还需比较其他参数，可以通过 useLocation 钩子获取 location 相关的参数自行比较</li></ol><figure class="highlight js"><figcaption><span>routes/invoice.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useParams, useNavigate &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; getInvoice, deleteInvoice &#125; <span class="keyword">from</span> <span class="string">&quot;../data&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Invoice</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> navigate = <span class="title function_">useNavigate</span>();</span><br><span class="line">    <span class="keyword">let</span> params = <span class="title function_">useParams</span>();</span><br><span class="line">    <span class="keyword">let</span> invoice = <span class="title function_">getInvoice</span>(<span class="built_in">parseInt</span>(params.<span class="property">invoiceId</span>, <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">main</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">padding:</span> &quot;<span class="attr">1rem</span>&quot; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Total Due: &#123;invoice.amount&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;invoice.name&#125;: &#123;invoice.number&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>Due Date: &#123;invoice.due&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">                        deleteInvoice(invoice.number);</span></span><br><span class="line"><span class="language-xml">                        navigate(&quot;/invoices&quot;);</span></span><br><span class="line"><span class="language-xml">                    &#125;&#125;</span></span><br><span class="line"><span class="language-xml">                &gt;</span></span><br><span class="line"><span class="language-xml">                    Delete</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>通过 useNavigate 钩子可以实现程序控制的跳转/重定向(添加第二个参数 <code>&#123; replace: true &#125;</code> )</li><li>通过 useParams 钩子可以获取页面 path 参数，该参数为字符串类型</li></ol><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><p>参考 <a href="https://github.com/remix-run/react-router/blob/main/docs/api.md">React router API</a></p><h3 id="Packages-包"><a href="#Packages-包" class="headerlink" title="Packages 包"></a>Packages 包</h3><p>React router 包含了三个 npm 库 react-router、react-router-dom 和 react-router-native。</p><ul><li><p>react-router 库包含了最核心的组件和钩子</p></li><li><p>react-router-dom 库包含了 react-router 库和一些 DOM 操作相关的API 例如 <code>&lt;BroserRouter&gt;</code> <code>&lt;HashRouter&gt;</code> <code>&lt;Link&gt;</code></p></li><li><p>react-router-native 库包含了 react-router 库和一些和 RN 相关的API 例如 <code>&lt;NativeRouter&gt;</code> 和 本地版本的 <code>&lt;Link&gt;</code></p></li></ul><h3 id="Setup-开始"><a href="#Setup-开始" class="headerlink" title="Setup 开始"></a>Setup 开始</h3><p>你必须在组件树的根结点使用一个 router 组件才能在应用中使用 React router。根据应用类型的不同，React router 提供了几种不同的 router 。</p><ul><li><code>&lt;BrowserRouter&gt;</code> 和 <code>&lt;HashRouter&gt;</code> 应当在 web 浏览器环境中使用，其中 <code>&lt;BrowserRouter&gt;</code> 采用浏览器 path 导航，体验更好，而 <code>&lt;HashRouter&gt;</code> 采用 hash 导航，兼容性更好。</li><li><code>&lt;StaticRouter&gt;</code> 在服务器渲染的时候使用。</li><li><code>&lt;NativeRouter&gt;</code> 在 React Native 应用中使用。</li><li><code>&lt;MemoryRouter&gt;</code> 在测试场景中使用。</li></ul><h3 id="Routing-路由"><a href="#Routing-路由" class="headerlink" title="Routing 路由"></a>Routing 路由</h3><p>路由决定了当你给定应用的页面时，哪一个React组件应当被渲染以及如何嵌套。React router 提供了两种接口描述路由。</p><ul><li>使用JSX的话可以用 <code>&lt;Routes&gt;</code> 和 <code>&lt;Route&gt;</code></li><li>使用Js配置的话，可以用 <code>useRoutes</code></li></ul><h3 id="Navigation-导航"><a href="#Navigation-导航" class="headerlink" title="Navigation 导航"></a>Navigation 导航</h3><p>React router 的导航接口允许通过修改当前 location 来改变当前渲染的页面。</p><ul><li><code>&lt;Link&gt;</code> 和 <code>&lt;NavLink&gt;</code> 生成一个 <code>&lt;a&gt;</code> 元素，当用户点击时进行相应的导航。<code>&lt;NavLink&gt;</code> 的 <code>style</code> 和 <code>className</code> 属性提供了 <code>isActive</code> 参数来判断 Link 是否是当前页面地址</li><li><code>useNavigate</code> 和 <code>&lt;Navigate&gt;</code> 允许程序性的导航，尤其是在事件处理器中或者状态变化时</li></ul><h3 id="Hooks-钩子"><a href="#Hooks-钩子" class="headerlink" title="Hooks 钩子"></a>Hooks 钩子</h3><ul><li><code>useSearchParams</code> 钩子可以获取到 URL 的搜索参数</li><li><code>useLocation</code> 钩子可以获取到当前的 history.location 参数</li><li><code>useParams</code> 钩子可以获取到 path 传递的参数</li><li><code>useRoutes</code> 钩子是 <code>&lt;Routes&gt;</code> 的函数形式</li><li><code>useNavigate</code> 钩子返回 navigate 函数，允许程序性的导航</li></ul><h2 id="History"><a href="#History" class="headerlink" title="History"></a>History</h2><p>React router 底层使用到了 <a href="https://github.com/remix-run/history">history</a> 库。 history 库抽象表示了浏览历史的变化，它监听浏览器地址栏（页面路由）的变化，并解析 URL 将其转化为 locaton 对象。基于环境和实现方式的不同，history 库提供了三种形式的 history：</p><ul><li>browserHistory: 通过 HTML5 提供的 history API 实现，需要配置服务器路由将请求重定向到html文件，对应 React router 的 <code>BrowserRouter</code></li></ul><p>例如在 nodejs 中需要配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;*&#x27;</span>, <span class="keyword">function</span> (<span class="params">request, response</span>)&#123;</span><br><span class="line">  response.<span class="title function_">sendFile</span>(path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;public&#x27;</span>, <span class="string">&#x27;index.html&#x27;</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果使用的 nginx 服务器，则需要配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  ...</span><br><span class="line">  location / &#123;</span><br><span class="line">    try_files $uri /index.html</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用的 Apache 服务器，则需要配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RewriteBase /</span><br><span class="line">RewriteRule ^index\.html$ - [L]</span><br><span class="line">RewriteCond %&#123;REQUEST_FILENAME&#125; !-f</span><br><span class="line">RewriteCond %&#123;REQUEST_FILENAME&#125; !-d</span><br><span class="line">RewriteRule . /index.html [L]</span><br></pre></td></tr></table></figure><ul><li>hashHistory: 通过 hash（#） 来实现，不支持 history API 的老旧浏览器也可使用，对应 React router 的 <code>HashRouter</code></li><li>memoryHisotry: 路由存储在内存里，url不会变化，因此不能通过url分享，通常在 node , React Native 环境下使用，对应 React router 的 <code>MemoryRouter</code></li></ul><h2 id="React-router-和-Redux-集成"><a href="#React-router-和-Redux-集成" class="headerlink" title="React router 和 Redux 集成"></a>React router 和 Redux 集成</h2><p>React router 可以和状态管理库 Redux 集成，以便将路由信息同步到 Redux state 统一管理，并且路由组件可以从 Redux 获取路由信息，实现导航等功能。  </p><p>集成好处：</p><ol><li>路由信息可以同步到统一的 store 并可以从中获得</li><li>可以使用 Redux 的 dispatch action 来导航</li><li>集成 Redux 可以支持在 Redux devtools 中路由改变的时间履行调试</li></ol><p>方法：用 react-redux 的<code>&lt;Provider store=&#123;store&#125;&gt;</code> 包住 react-router 的路由组件<code>&lt;Router&gt;</code>、<code>&lt;BrowserRouter&gt;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">(<span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span>  <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">APPRouter</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span>)</span><br><span class="line">,  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span><br></pre></td></tr></table></figure><h2 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h2><p>React router 可以结合 webpack 和 @babel/plugin-syntax-dynamic-import、loadable-components 来实现代码分割。</p><p>一个 React router + webpack + @babel/plugin-syntax-dynamic-import + loadable-components 实现代码分割的简单示例：</p><p>.babelrc 配置文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;prestes&quot;</span>: [<span class="string">&quot;@babel/presets-react&quot;</span>],</span><br><span class="line">  <span class="string">&quot;plugins&quot;</span>: [<span class="string">&quot;@babel/plugin-syntax-dynamic-import&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@babel/plugin-syntax-dynamic-import 插件避免 babel 对动态 import 语法做过多的转化，允许 webpack 打包时将动态 import 的代码分离成单独的 bundle，实现代码分割。</p><p>使用 loadable-component 和动态 import 懒下载组件:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> loadable <span class="keyword">from</span> <span class="string">&quot;@loadable/component&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Loading</span> <span class="keyword">from</span> <span class="string">&quot;./Loading.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">LoadableComponent</span> = <span class="title function_">loadable</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;./Dashboard.js&quot;</span>), &#123;</span><br><span class="line">  <span class="attr">fallback</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Loading</span> /&gt;</span></span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">LoadableDashboard</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">LoadableComponent</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="react-router-amp-react-router-dom-关系"><a href="#react-router-amp-react-router-dom-关系" class="headerlink" title="react-router &amp; react-router-dom 关系"></a>react-router &amp; react-router-dom 关系</h2><p>react-router 只是一个核心库，在具体使用时应该基于不同的平台要使用不同的绑定库。比如：我们要在浏览器中使用 React router，就安装 react-router-dom 库，如果在 React Native 中使用 React router 就应该安装 react-router-native 库。但是我们不需要直接安装 react-router 库。</p>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>png、jpg、bmp、gif、tif图片的区别</title>
      <link href="/blog/2021/11/24/FE-png%E3%80%81jpg%E3%80%81bmp%E3%80%81gif%E3%80%81tif%E5%9B%BE%E7%89%87%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/blog/2021/11/24/FE-png%E3%80%81jpg%E3%80%81bmp%E3%80%81gif%E3%80%81tif%E5%9B%BE%E7%89%87%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="BMP"><a href="#BMP" class="headerlink" title="BMP"></a>BMP</h2><p>BMP（Bitmap）位图，是 Windows 操作系统中的标准图像文件格式，可以分成两类：设备相关位图（DDB）和设备无关位图（DIB）。它采用位映射存储格式，除了图像深度可选以外，不采用其他任何压缩，因此，BMP文件所占用的空间很大。BMP文件的图像深度可选1bit、4bit、8bit及24bit。BMP文件存储数据时，图像的扫描方式是按从左到右、从下到上的顺序。由于BMP文件格式是 Windows 环境中交换与图有关的数据的一种标准，因此在 Windows 环境中运行的图形图像软件都支持BMP图像格式。</p><span id="more"></span><h2 id="TIFF"><a href="#TIFF" class="headerlink" title="TIFF"></a>TIFF</h2><p>TIFF（Tagged Image File Format）标签图像文件格式，是一种灵活的位图格式，主要用来存储包括照片和艺术图在内的图像。它最初由 Aldus 公司与 Microsoft 公司一起为 PostScript 打印开发。TIFF格式在业界得到了广泛的支持，如 Adobe 公司的 Photoshop、The GIMP Team 的 GIMP、Ulead PhotoImpact 和 Paint Shop Pro 等图像处理应用、QuarkXPress 和 Adobe InDesign 这样的桌面印刷和页面排版应用，扫描、传真、文字处理、光学字符识别和其它一些应用等都支持这种格式。</p><h2 id="GIF"><a href="#GIF" class="headerlink" title="GIF"></a>GIF</h2><p>GIF（Graphics Interchange Format）图像交换格式，是 CompuServe 公司在 1987年开发的图像文件格式。GIF文件的数据，是一种基于 LZW（Lempel-Zev-Welch） 算法的连续色调的无损压缩格式。其压缩率一般在50%左右，它不属于任何应用程序。GIF图像文件的数据是经过压缩的，而且是采用了可变长度等压缩算法。所以GIF的图像深度从lbit到8bit，也即GIF最多支持256种色彩的图像。GIF格式的另一个特点是其在一个GIF文件中可以存多幅彩色图像，如果把存于一个文件中的多幅图像数据逐幅读出并显示到屏幕上，就可构成一种最简单的动画。目前几乎所有相关软件都支持它，公共领域有大量的软件在使用GIF图像文件。</p><p>它有以下几个特点：<br>（1）GIF只支持256色以内的图像，不支持Alpha通道；<br>（2）GIF采用无损压缩存储，在不影响图像质量的情况下，可以生成很小的文件；<br>（3）它支持透明色，可以使图像浮现在背景之上；<br>（4）GIF文件可以制作动画，这是它最突出的一个特点。</p><h2 id="JPEG"><a href="#JPEG" class="headerlink" title="JPEG"></a>JPEG</h2><p>JPEG（Joint Photographic Experts Group）联合图片专家组，文件后辍名为“．jpg”或“．jpeg”，是一个国际图像压缩标准。它采用有损压缩方式去除冗余的图像数据，在获得极高的压缩率的同时能展现十分丰富生动的图像。而且 JPEG是一种很灵活的格式，具有调节图像质量的功能，允许用不同的压缩比例对文件进行压缩，支持多种压缩级别，压缩比率通常在 10：1 到 40：1 之间，压缩比越大，品质就越低；相反地，压缩比越小，品质就越好。JPEG格式压缩的主要是高频信息，对色彩的信息保留较好，适合应用于互联网，可减少图像的传输时间，可以支持24bit真彩色，也普遍应用于需要连续色调的图像。</p><p>JPEG2000 作为 JPEG 的升级版，其压缩率比 JPEG 高约30%左右，同时支持有损和无损压缩。JPEG2000格式有一个极其重要的特征在于它能实现渐进传输，即先传输图像的轮廓，然后逐步传输数据，不断提高图像质量，让图像由朦胧到清晰显示。此外，JPEG2000 还支持所谓的”感兴趣区域” 特性，可以任意指定影像上感兴趣区域的压缩质量，还可以选择指定的部分先解压缩。</p><h2 id="EXIF"><a href="#EXIF" class="headerlink" title="EXIF"></a>EXIF</h2><p>EXIF（EXchangeable Image File format）可交换的图像文件格式，是于1994年富士公司提倡的数码相机图像文件格式，其实与JPEG格式相同，区别是除保存图像数据外，还能够存储摄影日期、使用光圈、快门、闪光灯数据等曝光资料和附带信息以及小尺寸图像。</p><h2 id="PNG"><a href="#PNG" class="headerlink" title="PNG"></a>PNG</h2><p>PNG（Portable Network Graphics）便携式网络图形，是 Macromedia 公司出品的 Fireworks 的专业格式，这个格式使用于网络图形，支持背景透明，缺点是不支持动画效果。PNG使用从LZ77派生的无损数据压缩算法，能够提供长度比GIF小30%的无损压缩图像文件。它同时提供 24 位和 48 位真彩色图像支持以及其他诸多技术性支持。PNG用来存储灰度图像时，灰度图像的深度可多达16位，存储彩色图像时，彩色图像的深度可多达48位，并且还可存储多达16位的α通道数据。</p><p>在PNG的基础上另有发展出支持动画的 APNG 和 MNG 格式，但普及度不高。</p><h2 id="PSD"><a href="#PSD" class="headerlink" title="PSD"></a>PSD</h2><p>PSD（PhotoShop Document），PhotoShop文档，是 Photoshop 图像处理软件的专用文件格式，文件扩展名是“．psd”，可以支持图层、通道、蒙板和不同色彩模式的各种图像特征，是一种非压缩的原始文件保存格式。扫描仪不能直接生成该种格式的文件。PSD文件有时容量会很大，但由于可以保留所有原始信息，在图像处理中对于尚未制作完成的图像，选用 PSD 格式保存是最佳的选择。</p><h2 id="ICO"><a href="#ICO" class="headerlink" title="ICO"></a>ICO</h2><p>ICO（Icon）图标，是 Windows 系统使用的图标文件格式。这种文件格式广泛存在于 Windows 系统中的 dll 、exe 文件中。浏览器的标签图标也经常使用这类文件。</p><h2 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h2><p>SVG（Scalable Vector Graphics）可缩放矢量图形，是基于XML（标准通用标记语言的子集）的，由万维网联盟进行开发的一种开放标准的矢量图形语言。可任意放大图形显示，边缘清晰，文字在SVG图像中保留可编辑和可搜寻的状态，没有字体的限制，生成的文件很小，下载很快，十分适合用于设计高分辨率的Web图形页面。</p><h2 id="web常见图片格式比较"><a href="#web常见图片格式比较" class="headerlink" title="web常见图片格式比较"></a>web常见图片格式比较</h2><h3 id="jpg-jpeg"><a href="#jpg-jpeg" class="headerlink" title="jpg/jpeg"></a>jpg/jpeg</h3><p><em>大图片，banner</em></p><ol><li>采用离散余弦变换/离散小波变换进行有损压缩，压缩比灵活</li><li>支持24bit彩色</li><li>支持从模糊到清晰渐进式加载（基于DCT的累进编码模式/JPEG2000）</li><li>不支持透明色</li></ol><h3 id="gif"><a href="#gif" class="headerlink" title="gif"></a>gif</h3><p><em>动画图片，小图片，打点的图片</em></p><ol><li>采用LZW压缩算法</li><li>不支持24bit彩色模式，位深为1-8bit，最多存储256色，适合展示灰度图像或色彩较少的图片</li><li>支持单色透明（GIF89a）</li><li>支持动画（GIF89a）</li><li>Compu Serve 公司拥有版权</li></ol><h3 id="png"><a href="#png" class="headerlink" title="png"></a>png</h3><p><em>需要透明效果的图片</em></p><ol><li>采用从LZ77派生的无损数据压缩算法，压缩比高，文件体积小</li><li>有PNG8、PNG24、PNG32三种形式，PNG8支持256色，PNG24、PNG32支持24bit彩色</li><li>支持透明/半透明效果（PNG8支持索引透明和alpha透明，PNG32支持256级透明）</li><li>IE6等旧浏览器不支持</li></ol><h3 id="svg"><a href="#svg" class="headerlink" title="svg"></a>svg</h3><p><em>图标形按钮</em></p><ol><li>基于 XML（Extensible Markup Language），使用代码来描绘图像，文件体积小</li><li>可缩放，不会牺牲图像质量</li><li>可编辑，文本可搜索</li><li>IE9等旧浏览器不支持</li><li>加载较慢</li><li>仅可用来描述二维矢量及矢量/栅格图形</li></ol><h3 id="ico"><a href="#ico" class="headerlink" title="ico"></a>ico</h3><p><em>favicon图片</em></p><ol><li>有一套标准的大小和属性格式，且通常是正方形的，小尺寸的</li><li>支持透明</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>input输入框的autocomplete属性</title>
      <link href="/blog/2021/11/23/TIPS-input%E8%BE%93%E5%85%A5%E6%A1%86%E7%9A%84autocomplete%E5%B1%9E%E6%80%A7/"/>
      <url>/blog/2021/11/23/TIPS-input%E8%BE%93%E5%85%A5%E6%A1%86%E7%9A%84autocomplete%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>在开发过程中遇到了一个兼容性相关的问题，具体为在Firefox浏览器中，浏览器自带的账号密码自动补全功能显示异常将输入框挡住了，如下。</p><p><img src="/blog/static/imgs/input_error.png" alt="input_error"></p><p>操作系统: macOS 10.15.7<br>浏览器: Firefox 91.0.2 (64 位)</p><span id="more"></span><p>原因为 Firefox 浏览器在 input 没有添加 autocomplete 属性的情况下也会调用自动补全的特性，由于该输入框的高度可能会变化，Firefox 的自动补全下拉框没有动态计算输入框位置导致位置异常。比较有意思的事，似乎夜间模式并不会有这个问题，第一次想要复现这个问题的时候因为是6pm之后我甚至都没有复现。最终，通过为该输入框加入 <code>autoComplete=&quot;new-password&quot;</code> 属性以禁用自动补全功能来解决该问题。  </p><h2 id="autocomplete-属性"><a href="#autocomplete-属性" class="headerlink" title="autocomplete 属性"></a>autocomplete 属性</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Attributes/autocomplete">autocomplete</a> 属性可用于以文本或数字值作为输入的 <code>&lt;input&gt;</code> 元素 ， <code>&lt;textarea&gt;</code> 元素， <code>&lt;select&gt;</code> 元素和 <code>&lt;form&gt;</code> 元素，用以告知浏览器该字段的期望类型并要求浏览器提供关于字段中所期望的信息类型的自动补全。建议值的来源由浏览器决定。 通常，值来自用户输入的过去值，但它们也可能来自预先配置的值。</p><p>为了提供自动完成功能，可能需要 <code>&lt;input&gt;/&lt;select&gt;/&lt;textarea&gt;</code> 元素同时具有以下条件:</p><ol><li>具有 name 和/或 id 属性</li><li>成为 <code>&lt;form&gt;</code> 的后代</li><li>form 需要含有 <code>type=&quot;submit&quot;</code> 的按钮</li></ol><p>autoComplete 的值有很多种，其中，理论上设置 <code>autoComplete=&quot;off&quot;</code> 可以禁止浏览器为此字段自动输入或选择一个值。但实际上，在大多数现代浏览器中， autocomplete 设置为 “off” 不会阻止密码管理器询问用户是否要保存用户名和密码信息，或者自动在网站的登录表单中填写这些值。 <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion#the_autocomplete_attribute_and_login_fields">该文章</a> 解释了原因并给出了取消自动补全的方案（即设置 <code>autoComplete=&quot;new-password&quot;</code>）。</p><h2 id="best-practice"><a href="#best-practice" class="headerlink" title="best practice"></a>best practice</h2><p>最佳实践是，最好在每个 input 输入框上都添加 <code>name</code> 和 <code>autocomplete</code> 属性以避免自动补全的问题，其中 name 标志含义，autocompelte 用来告知浏览器自动补全的类型（或禁止自动补全）。以下列出一些常用的 autocomplete 值供参考： </p><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>name</td><td>该字段期望该值是一个人的全名(姓名)</td></tr><tr><td>email</td><td>电子邮件地址</td></tr><tr><td>username</td><td>用户名或帐户名</td></tr><tr><td>new-password</td><td>新密码。 创建新帐户或更改密码时，应将其用于“输入新密码”或“确认新密码”字段。实际上会禁止自动补全，但如果是 <code>type=&quot;password&quot;</code> 类型的输入框，浏览器仍可能会给出建议的值</td></tr><tr><td>one-time-code</td><td>用于验证用户身份的一次性代码，比如短信验证码，邮箱验证码</td></tr><tr><td>tel</td><td>完整的电话号码，包括国家/地区代码</td></tr><tr><td>url</td><td>URL，例如主页或公司网站地址</td></tr></tbody></table><h2 id="删除记录的过去值"><a href="#删除记录的过去值" class="headerlink" title="删除记录的过去值"></a>删除记录的过去值</h2><p>当你输入一个错误的账号而且不小心提交了，虽然提交不会成功，但这个账号也会被浏览器记录下来，在下一次输入的时候显示在自动补全列表中。你可以使用以下方法删除这些值（在 macOS chrome96.0 中测试过是有效的，不一定对所有浏览器有效）。<br>首先用鼠标指针 hover 到你想删除的值。然后，如果使用的是 Windows 操作系统中可以用 shift + delete 键删除该值。在 macOS 操作系统中 可以使用 fn + shift + backspace 键删除该值。</p>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> input </tag>
            
            <tag> autocomplete </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小文件下载方案</title>
      <link href="/blog/2021/09/13/TIPS-%E5%B0%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%96%B9%E6%A1%88/"/>
      <url>/blog/2021/09/13/TIPS-%E5%B0%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>我们需要一个模板文件供用户进行下载，这个文件是csv类型的，大小很小，一开始是想要放到CDN上，上传COS，然后生成a链接下载，地址是这样的 <code>https://xxx.myqcloud.com/csv/xxx.csv</code>。  </p><p>这里有一个问题，在 Safari 浏览器中直接打开了该文件而不是下载，原因是 http header 当中的 <code>Content-Disposition</code> 没有设置成 <code>attachement;filename=&quot;xxx.csv&quot;</code>，所以浏览器就会按照 <code>Content-Type: text/csv</code> 来进行解析，不同浏览器对该类型返回解析方法不一样， Safari 会打开(以 <code>Content-Disposition: inline</code> 形式)，而 Chrome 等其它浏览器会下载。  </p><p>为了解决这个问题，最后采取了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Data_URIs">Data URLs</a> 的方案。首先，执行 <code>uuencode -m xxx.csv</code> 进行 base64 位编码生成 csv 文件的 Data URL，然后将下载地址替换为该 Data URL 。  </p><p>或者如果需要下载的csv为字符串文本的话，可以使用 js <code>window.btoa()</code> 方法创建一个 base64 编码的字符串。但是 <code>window.btoa()</code> 方法只支持 Latin1 字符，遇到不支持的字符会报错 <code>Uncaught DOMException: Failed to execute &#39;btoa&#39; on &#39;Window&#39;: The string to be encoded contains characters outside of the Latin1 range.</code> 所以需要先通过 <code>encodeURLCompnentd</code> 编码一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`data:text/csv;base64,77u/<span class="subst">$&#123;<span class="variable language_">window</span>.btoa(<span class="built_in">unescape</span>(<span class="built_in">encodeURIComponent</span>(<span class="string">&#x27;字符串&#x27;</span>)))&#125;</span>`</span></span><br></pre></td></tr></table></figure><p><a target="_blank" download="测试.csv" rel="noreferrer noopener"href="data:text/csv;base64,5a2X56ym5Liy">点击下载</a></p><p><code>77u/</code> 是 UTF-8 的 BOM（0xEF 0xBB 0xBF）经过 base64 编码过的代码，如果不添加的话在 Micro Excel 中会显示为乱码。</p><span id="more"></span><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">download</span>=<span class="string">&quot;测试.csv&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;noreferrer noopener&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">href</span>=<span class="string">&quot;data:text/csv;base64,77u/5a2X56ym5Liy&quot;</span>&gt;</span>点击下载<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样就完美解决了 Safari 浏览器不会下载的问题，而且文件名也可以进行国际化支持，展示更加友好。  </p><p>需要注意的是，这种方案只适用于小文件下载，因为该方案实际上相当于把文件变成了页面代码的一部分，如果文件过大，会使得编译后的代码文件过大，对页面加载性能会有负担。  </p>]]></content>
      
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器会话历史 history API</title>
      <link href="/blog/2021/06/23/HTML-history-API/"/>
      <url>/blog/2021/06/23/HTML-history-API/</url>
      
        <content type="html"><![CDATA[<h2 id="History-API"><a href="#History-API" class="headerlink" title="History API"></a>History API</h2><p>History 接口允许操作浏览器的会话历史记录。</p><h2 id="History-API-的方法和属性"><a href="#History-API-的方法和属性" class="headerlink" title="History API 的方法和属性"></a>History API 的方法和属性</h2><table><thead><tr><th>属性</th><th>是否只读</th><th>类型</th><th>作用</th></tr></thead><tbody><tr><td><code>history.length</code></td><td>只读</td><td>整数</td><td>history 堆栈中会话的数量</td></tr><tr><td><code>history.state</code></td><td>只读</td><td>object</td><td>返回一个表示历史堆栈顶部的状态的值</td></tr><tr><td><code>history.scrollRestoration</code></td><td>否</td><td>auto｜manual (string)</td><td>允许Web应用程序在历史导航上显式地设置默认滚动恢复行为</td></tr></tbody></table><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>history.back()</code></td><td>在浏览器历史记录里前往上一页, 用户可点击浏览器左上角的返回按钮模拟此方法. 等价于 <code>history.go(-1)</code></td></tr><tr><td><code>history.forward()</code></td><td>在浏览器历史记录里前往下一页，用户可点击浏览器左上角的前进按钮模拟此方法. 等价于 <code>history.go(1)</code></td></tr><tr><td><code>history.go()</code></td><td>入参为整数，通过当前页面的相对位置从浏览器历史记录加载页面。</td></tr><tr><td><code>history.pushState(state, title[, url])</code></td><td>按指定的名称和URL（如果提供该参数）将数据 push 进会话历史栈，数据被 DOM 进行不透明处理；可以指定任何可以被序列化的 javascript 对象。</td></tr><tr><td><code>history.replaceState(state, title[, url])</code></td><td>按指定的数据，名称和URL(如果提供该参数)，更新历史栈上最新的入口。这个数据被 DOM 进行了不透明处理。你可以指定任何可以被序列化的 javascript 对象。</td></tr></tbody></table><h2 id="History-API-用法"><a href="#History-API-用法" class="headerlink" title="History API 用法"></a>History API 用法</h2><p>History API 最常见的用法是通过 <code>pushState()</code> 方法添加浏览器url历史（浏览器不会加载该 url ，甚至不会检查 url 是否真的存在），这样，在回退的时候就会加载 history 堆栈中的页面。在某种意义上，调用 <code>pushState()</code> 与 设置 <code>window.location = &quot;#foo&quot;</code> 类似，二者都会在当前页面创建并激活新的历史记录。但 <code>pushState()</code> 具有如下几条特点：</p><ul><li>新的 URL 可以是与当前 URL 同源的任意 URL 。相反，只有在修改哈希时，设置 <code>window.location</code> 才能是同一个 document。</li><li>如果你不想改 URL ，就不用改。相反，设置 <code>window.location = &quot;#foo&quot;;</code> 在当前哈希不是 #foo 时，才能创建新的历史记录项。</li><li>你可以将任意数据和新的历史记录项相关联。而基于哈希的方式，要把所有相关数据编码为短字符串。</li><li>如果 标题(title 随后还会被浏览器所用到，那么这个数据是可以被使用的（哈希则不是）。</li><li><code>pushState()</code> 不会触发 hashchange 事件，即使新的 URL 与旧的 URL 仅哈希不同也是如此</li></ul><p>每当活动的历史记录项发生变化时， popstate 事件都会被传递给 window 对象。如果当前活动的历史记录项是被 <code>pushState()</code> 创建的，或者是由 <code>replaceState()</code> 改变的，那么 popstate 事件的状态属性 state 会包含一个当前历史记录状态对象的拷贝。</p><p>参考： https://developer.mozilla.org/zh-CN/docs/Web/API/History</p>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> Web API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM中的事件 Event</title>
      <link href="/blog/2021/06/23/HTML-Event/"/>
      <url>/blog/2021/06/23/HTML-Event/</url>
      
        <content type="html"><![CDATA[<h2 id="DOM中的事件-Event"><a href="#DOM中的事件-Event" class="headerlink" title="DOM中的事件 Event"></a>DOM中的事件 Event</h2><p>Event 接口表示在 DOM 中出现的事件。</p><p>Event（事件）可以由三种方式触发：</p><ul><li>由用户触发动作，例如鼠标或键盘事件</li><li>由 API 生成，例如指示动画已经完成运行的事件，视频已被暂停等</li><li>通过脚本代码触发，例如对元素调用 <code>HTMLElement.click()</code> 方法，或者定义一些自定义事件，再使用 <code>EventTarget.dispatchEvent()</code> 方法将自定义事件派发往指定的目标（target）</li></ul><p>有许多不同类型的事件，其中一些使用基于 Event 主接口的二次接口。Event 本身包含适用于所有事件的属性和方法。</p><p>很多DOM元素可以被设计接收（或者监听) 这些事件, 并且执行代码去响应（或者处理）它们。通过 <code>EventTarget.addEventListener()</code> 方法可以将事件处理函数绑定到不同的HTML elements上 (比如&lt;button>, &lt;div>, &lt;span>等等) 。这种绑定事件处理函数的方式基本替换了老版本中使用 HTML event handler attributes（例如 <code>HTMLElement.onclick = ...</code> ） 来绑定事件处理函数的方式。除此之外，通过正确使用 <code>removeEventListener()</code> 方法，这些事件处理函数也能被移除。</p><span id="more"></span><h2 id="Event-的属性和方法"><a href="#Event-的属性和方法" class="headerlink" title="Event 的属性和方法"></a>Event 的属性和方法</h2><h3 id="Event的属性"><a href="#Event的属性" class="headerlink" title="Event的属性"></a>Event的属性</h3><table><thead><tr><th>属性名</th><th>是否只读</th><th>类型</th><th>作用</th></tr></thead><tbody><tr><td>bubbles</td><td>只读</td><td>boolean</td><td>表示该事件是否会在 DOM 中冒泡</td></tr><tr><td>cancelable</td><td>只读</td><td>boolean</td><td>表示事件是否可以取消</td></tr><tr><td>composed</td><td>只读</td><td>boolean</td><td>表示事件是否可以穿过 Shadow DOM 和常规 DOM 之间的隔阂进行冒泡</td></tr><tr><td>defaultPrevented</td><td>只读</td><td>boolean</td><td>表示 <code>event.preventDefault()</code> 方法是否取消了事件的默认行为</td></tr><tr><td>eventPhase</td><td>只读</td><td>0｜1｜2｜3，含义见下表</td><td>表示事件流正被处理到了哪个阶段</td></tr><tr><td>currentTarget</td><td>只读</td><td>EventTarget类型</td><td>标识是当事件沿着 DOM 触发时事件的当前目标。它总是指向事件绑定的元素</td></tr><tr><td>target</td><td>只读</td><td>EventTarget类型</td><td>触发事件的元素</td></tr><tr><td>timeStamp</td><td>只读</td><td>DOMHighResTimeStamp类型(double)</td><td>事件创建时的时间戳（精度为毫秒）</td></tr><tr><td>type</td><td>只读</td><td>string</td><td>表示该事件对象的事件类型</td></tr><tr><td>isTrusted</td><td>只读</td><td>boolean</td><td>表示事件是由浏览器（例如用户点击）发起的（true），还是由脚本（使用事件创建方法）发出的（false）</td></tr></tbody></table><p>eventPhase 的类型如下：</p><table><thead><tr><th>常量</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>Event.NONE</td><td>0</td><td>这个时间，没有事件正在被处理</td></tr><tr><td>Event.CAPTURING_PHASE</td><td>1</td><td>事件正在被目标元素的祖先对象处理. 这个处理过程从 <code>Window</code> 开始，然后 <code>Document</code> , 然后是 <code>HTMLHtmlElement</code> , 一直这样，直到目标元素的父元素。 通过 <code>EventTarget.addEventListener()</code> 注册为捕获模式的 Event listeners 被调用。</td></tr><tr><td>Event.AT_TARGET</td><td>2</td><td>事件对象已经抵达 the event’s target . 为这个阶段注册的事件监听被调用。 如果 <code>Event.bubbles</code> 的值为 false , 对事件对象的处理在这个阶段后就会结束.</td></tr><tr><td>Event.BUBBLING_PHASE</td><td>3</td><td>事件对象逆向向上传播回目标元素的祖先元素, 从父亲元素开始，并且最终到达包含元素 <code>Window</code> . 这就是冒泡，并且只有 <code>Event.bubbles</code> 值为 true 的时候才会发生。 为这个阶段注册的 Event listeners 在这个过程中被触发.</td></tr></tbody></table><h3 id="Event的方法"><a href="#Event的方法" class="headerlink" title="Event的方法"></a>Event的方法</h3><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>composedPath()</td><td>返回事件的路径（将在该对象上调用监听器）。<br>如果阴影根节点 (shadow root) 创建时 <code>ShadowRoot.mode</code> 值为 closed，那么路径不会包括该根节点下阴影树 (shadow tree) 的节点</td></tr><tr><td>preventDefault()</td><td>取消事件（如果该事件可取消）</td></tr><tr><td>stopPropagation()</td><td>停止冒泡，阻止事件在 DOM 中继续冒泡</td></tr><tr><td>stopImmediatePropagation()</td><td>对这个特定的事件而言，其他监听器停止被调用。<br>这个事件既不会添加到相同的元素上，也不会添加到以后将要遍历的元素上（例如在捕获阶段）</td></tr></tbody></table><p>参考： https://developer.mozilla.org/zh-CN/docs/Web/API/Event</p>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> Web API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>立即调用的函数表达式（IIFE）</title>
      <link href="/blog/2021/06/23/JS-%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88IIFE%EF%BC%89/"/>
      <url>/blog/2021/06/23/JS-%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88IIFE%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>根据 JavaScript 的语法，圆括号()跟在函数名之后，表示调用该函数。比如， <code>print()</code> 就表示调用 <code>print</code> 函数。</p><p>有时，我们需要在定义函数之后，立即调用该函数。这时，你不能在函数的定义之后加上圆括号，这会产生语法错误。</p><span id="more"></span><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line"><span class="comment">// SyntaxError: Unexpected token (</span></span><br></pre></td></tr></table></figure><p>产生这个错误的原因是，function这个关键字既可以当作语句，也可以当作表达式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语句</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表达式</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>当作表达式时，函数可以定义后直接加圆括号调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123; <span class="keyword">return</span> <span class="number">1</span>&#125;();</span><br><span class="line">f <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面的代码中，函数定义后直接加圆括号调用，没有报错。原因就是 <code>function</code> 作为表达式，引擎就把函数定义当作一个值。这种情况下，就不会报错。</p><p>为了避免解析的歧义，JavaScript 规定，如果 <code>function</code> 关键字出现在行首，一律解释成语句。因此，引擎看到行首是 <code>function</code> 关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。</p><p>函数定义后立即调用的解决方法，就是不要让 <code>function</code> 出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/* code */</span> &#125;());</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/* code */</span> &#125;)();</span><br></pre></td></tr></table></figure><p>上面两种写法都是以圆括号开头，引擎就会认为后面跟的是一个表达式，而不是函数定义语句，所以就避免了错误。这就叫做“立即调用的函数表达式”（Immediately-Invoked Function Expression），简称 IIFE。</p><p>注意，上面两种写法最后的分号都是必须的。如果省略分号，遇到连着两个 IIFE，可能就会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/* code */</span> &#125;())</span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/* code */</span> &#125;())</span><br></pre></td></tr></table></figure><p>上面代码的两行之间没有分号，JavaScript 会将它们连在一起解释，将第二行解释为第一行的参数。</p><p>推而广之，任何让解释器以表达式来处理函数定义的方法，都能产生同样的效果，比如下面三种写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="keyword">return</span> <span class="number">10</span>; &#125;();</span><br><span class="line"><span class="literal">true</span> &amp;&amp; <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line"><span class="number">0</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/* code */</span> &#125;();</span><br></pre></td></tr></table></figure><p>甚至像下面这样写，也是可以的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">!<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line">~<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line">-<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line">+<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">/* code */</span> &#125;();</span><br></pre></td></tr></table></figure><p>通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">var</span> tmp = newData;</span><br><span class="line"><span class="title function_">processData</span>(tmp);</span><br><span class="line"><span class="title function_">storeData</span>(tmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> tmp = newData;</span><br><span class="line">  <span class="title function_">processData</span>(tmp);</span><br><span class="line">  <span class="title function_">storeData</span>(tmp);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>上面代码中，写法二比写法一更好，因为完全避免了污染全局变量。</p><p>原文：https://wangdoc.com/javascript/types/function.html#%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88iife%EF%BC%89</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端开发常用英文缩写名词解释</title>
      <link href="/blog/2021/06/21/FE-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%8B%B1%E6%96%87%E7%BC%A9%E5%86%99%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"/>
      <url>/blog/2021/06/21/FE-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%8B%B1%E6%96%87%E7%BC%A9%E5%86%99%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="运营与分析"><a href="#运营与分析" class="headerlink" title="运营与分析"></a>运营与分析</h2><table><thead><tr><th>简称</th><th>含义</th><th>解释</th><th>说明</th></tr></thead><tbody><tr><td>PV</td><td>Page View</td><td>页面访问量</td><td>页面浏览量，用户每次进入页面或刷新页面即被计算一次，反映了页面的活跃程度</td></tr><tr><td>UV</td><td>Unique Visitor</td><td>独立访客</td><td>和PV类似，同样是反映页面的活跃程度，可以防止通过多次刷新页面等方法导致的虚假的活跃</td></tr><tr><td>DAU</td><td>Daily Active Users</td><td>日活跃用户</td><td>用于反映网站活跃情况。DAU 通常统计一日（统计日）之内，登录或使用了某个产品的用户数（去除重复登录的用户）</td></tr><tr><td>MAU</td><td>Monthly Active Users</td><td>月活跃用户</td><td>与DAU类似反应网站的活跃情况，由于产品可能因工作日/休息日等原因造成波动，MAU是以月维度统计的网站活跃程度，可以去除这种波动</td></tr><tr><td>QPS</td><td>Query Per Second</td><td>每秒查询率</td><td>一般指接口的每秒最大响应请求数，反映了接口的承压能力(吞吐量)</td></tr><tr><td>PR</td><td>Page Rank</td><td>网页权重</td><td>反映了页面的重要程度。一般级别从 1 到 10 级。PR 值越高说明该网页越受欢迎</td></tr></tbody></table><h2 id="设计与编程"><a href="#设计与编程" class="headerlink" title="设计与编程"></a>设计与编程</h2><table><thead><tr><th>简称</th><th>含义</th><th>解释</th><th>说明</th></tr></thead><tbody><tr><td>SPA</td><td>Single Page Application</td><td>单页面应用</td><td>一种网络应用程序(WebApp)模型，通过Ajax技术动态地重写页面的部分与用户交互，而避免了过多的页面重载，页面响应速度更快，用户体验更好</td></tr><tr><td>SSR</td><td>Server Side Render</td><td>服务器渲染</td><td>根据数据与页面模板在服务器上渲染出页面并发送到浏览器的技术</td></tr><tr><td>SEO</td><td>Search Engine Optimization</td><td>搜索引擎优化</td><td>通过了解搜索引擎的运作规则（如何抓取网站页面，如何索引以及如何根据特定的关键字展现搜索结果排序等）来调整网站，以提高该网站在搜索引擎中某些关键词的搜索结果排名的技术</td></tr><tr><td>MVC</td><td>Model View Controler</td><td>模型-视图-控制器</td><td>一种数据与视图分离的软件设计模式，最早由Xerox PARC在二十世纪八十年代为编程语言Smalltalk－80发明</td></tr><tr><td>MVP</td><td>Model View Presenter</td><td>模型-视图-</td><td>1990年代Taligent公司创造的，一个用于C++ CommonPoint的模型，将model和view更清晰的分离</td></tr><tr><td>MVVM</td><td>Model View ViewModel</td><td>模型-视图-视图模型</td><td>最初是由微软在使用Windows Presentation Foundation和SilverLight时定义，核心概念是数据绑定</td></tr><tr><td>HTML</td><td>Hyper Text Markup Language</td><td>超文本标记语言</td><td>是一种标记语言。它包括一系列标签．通过这些标签可以将网络上的文档格式统一，使分散的Internet资源连接为一个逻辑整体</td></tr><tr><td>CSS</td><td>Cascading Style Sheets</td><td>层叠样式表</td><td>一种用来表现HTML或XML等文件样式的计算机语言</td></tr><tr><td>URI</td><td>Uniform Resource Identifier</td><td>统一资源标识符</td><td>一个指向资源的字符串。最通常用在 URL 上来指定Web上资源文件的具体位置</td></tr><tr><td>URL</td><td>Uniform Resource Locator</td><td>统一资源定位器</td><td>指定在Internet上可以找到资源的位置的文本字符串</td></tr><tr><td>Ajax</td><td>Asynchronous JavaScript And XML</td><td>异步 Javascript 与 XML</td><td>一种使用 XMLHttpRequest 技术构建更复杂，动态的网页的编程实践</td></tr><tr><td>GUI</td><td>Graphical User Interface</td><td>图形用户接口</td><td>采用图形方式显示的计算机操作用户界面</td></tr><tr><td>API</td><td>Application Programming Interface</td><td>应用编程接口</td><td>软件（应用）中的一系列特性和规则，这些特性和规则允许其他软件与之交互（与用户界面相对）</td></tr><tr><td>HMR</td><td>Hot Module Repalacement</td><td>模块热更新</td><td>一种通过监控文件修改实时编译预览的技术，webpack即提供该功能</td></tr><tr><td>IIFE</td><td>Immediately Invoked Function Expression</td><td>立即调用的函数表达式</td><td>一个在定义时就会立即执行的 JavaScript 函数</td></tr><tr><td>JSON</td><td>JavaScript Object Notation</td><td>Javascript 对象表示</td><td>一种数据交换格式</td></tr><tr><td>DOM</td><td>Document Object Model</td><td>文档对象模型</td><td>用来呈现以及与任意 HTML 或 XML文档交互的API。DOM 是载入到浏览器中的文档模型，以节点树的形式来表现文档，每个节点代表文档的构成部分</td></tr><tr><td>P2P</td><td>Peer-to-peer</td><td>端到端</td><td>一种计算机网络体系结构，其中所有参与的节点（对等方）都有同等的权限并共享工作负载</td></tr><tr><td>RSS</td><td>Really Simple Syndication</td><td>简易信息聚合</td><td>用于发布站点更新的数种 XML 文档格式</td></tr><tr><td>CORS</td><td>Cross-Origin Resource Sharing</td><td>跨域资源共享</td><td>由一系列传输的HTTP头组成，这些HTTP头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应</td></tr><tr><td>CSP</td><td>Content Security Policy</td><td>内容安全策略</td><td>用于检测和减轻用于 Web 站点的特定类型的攻击</td></tr><tr><td>CRUD</td><td>Create Read Update Delete</td><td>增删改查</td><td>对于存储的信息可以进行操作类型</td></tr><tr><td>CSRF</td><td>Cross-Site Request Forgery</td><td>跨站请求伪造</td><td>一种冒充受信任用户，向服务器发送非预期请求的攻击方式</td></tr><tr><td>DDoS</td><td>Distributed Denial of Service</td><td>分布式拒绝服务</td><td>一种网络攻击手段，它通过给服务器发送大量请求来阻止对资源的合法使用</td></tr><tr><td>PR</td><td>Pull Request</td><td>拉取请求</td><td>使用 Git 做代码管理的一个流程，请求将改动拉取到目标代码仓库</td></tr></tbody></table><h2 id="云专有名词"><a href="#云专有名词" class="headerlink" title="云专有名词"></a>云专有名词</h2><table><thead><tr><th>简称</th><th>含义（阿里）</th><th>含义（腾讯）</th><th>含义（百度）</th><th>含义（华为）</th><th>解释</th><th>说明</th></tr></thead><tbody><tr><td>ECS/CVM/BCC/ECS</td><td>Elastic Compute Service</td><td>Cloud Virtual Machine</td><td>Baidu Cloud Compute</td><td>Elastic Cloud Server</td><td>云服务器</td><td>一种弹性可伸缩的云计算服务</td></tr><tr><td>OSS/COS/BOS/OBS</td><td>Object Storage Service</td><td>Cloud Object Storage</td><td>Baidu Object Storage</td><td>Object Storage Service</td><td>云对象存储</td><td>一种基于对象的存储服务</td></tr><tr><td>EBS/CBS/CDS/EVS</td><td>Elastic Block Storage</td><td>Cloud Block Storage</td><td>Cloud Disk Service</td><td>Elastic Volume Service</td><td>块存储/云硬盘/云磁盘</td><td>一种为计算服务提供持久性块存储的服务</td></tr><tr><td>NAS/CFS/CFS/SFS</td><td>Apsara File Storage</td><td>Cloud File Storage</td><td>Cloud File Storage</td><td>Scalable File Service</td><td>云文件存储</td><td>一种可扩展的云文件存储服务</td></tr><tr><td>SLB/CLB/BLB/ELB</td><td>Server Load Balancer</td><td>Cloud Load Balancer</td><td>Baidu Load Balance</td><td>Elastic Load Balance</td><td>负载均衡</td><td>一种流量分发服务，可以将访问流量自动分配到云中的多台云服务器上以降低服务器负载</td></tr><tr><td>ACK/TKE/CCE/CCE</td><td>Alibaba Cloud Container Service for Kubernetes</td><td>Tencent Kubernetes Engine</td><td>Cloud Container Engine</td><td>Cloud Container Engine</td><td>云容器</td><td>一种基于原生 kubernetes 提供以 docker 容器为核心的、高度可扩展的高性能容器管理服务</td></tr></tbody></table><h2 id="网络与安全"><a href="#网络与安全" class="headerlink" title="网络与安全"></a>网络与安全</h2><table><thead><tr><th>简称</th><th>含义</th><th>解释</th><th>说明</th></tr></thead><tbody><tr><td>SSL</td><td>Secure Socket Layer</td><td>安全套接层</td><td>在传输通信协议（TCP/IP）上实现的一种安全协议，采用公开密钥技术</td></tr><tr><td>NAT</td><td>Network Address Translation</td><td>网络地址转换</td><td>一个 IETF 标准，用于在本地网络中使用私有地址，允许一个整体单位机构以一个公用IP地址出现在互联网上</td></tr><tr><td>EIP</td><td>Elastic IP</td><td>弹性公网</td><td>为用户提供独立的公网带宽服务</td></tr><tr><td>CDN</td><td>Content Delivery Network</td><td>内容分发网络</td><td>通过将站点内容发布至遍布全球的网络节点以降低用户访问时间，提升下载速度</td></tr><tr><td>VPC</td><td>Virtual Private Cloud</td><td>专有网络/私有网络</td><td>专属的云上网络空间，不同私有网络间完全逻辑隔离</td></tr><tr><td>VPN</td><td>Virtual Private Network</td><td>虚拟专用网络</td><td>在公用网络上建立专用网络以进行加密通讯</td></tr></tbody></table><h2 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h2><table><thead><tr><th>简称</th><th>含义</th><th>解释</th><th>说明</th></tr></thead><tbody><tr><td>CMS</td><td>Content Management System</td><td>内容管理系统</td><td>一个允许用户发布、组织、修改、删除多种类型的内容的管理系统</td></tr><tr><td>CRM</td><td>Customer Relationship Managment</td><td>客户关系管理</td><td>客户关系管理是指企业为提高核心竞争力，利用相应的信息技术以及互联网技术协调企业与顾客间在销售、营销和服务上的交互，从而提升其管理方式，向客户提供创新式的个性化的客户交互和服务的过程</td></tr><tr><td>ERP</td><td>Enterprise Resource Planning</td><td>企业资源计划</td><td>ERP是针对物资资源管理（物流）、人力资源管理（人流）、财务资源管理（财流）、信息资源管理（信息流）集成一体化的企业管理软件</td></tr><tr><td>BPM</td><td>Business Process Management</td><td>业务流程管理</td><td>一套达成企业各种业务环节整合的全面管理模式</td></tr><tr><td>SCM</td><td>Supply Chain Management</td><td>供应链管理</td><td>一种集成的管理思想和方法，它执行供应链中从供应商到最终用户的物流的计划和控制等职能</td></tr><tr><td>MIS</td><td>Management Information System</td><td>管理信息系统</td><td>用于管理需要的记录，并对记录数据进行相关处理，将处理的信息及时反映给用户的一套网络管理系统</td></tr><tr><td>IDE</td><td>Integrated Development Environment</td><td>集成开发环境</td><td>为程序员提供了软件开发所需的完善工具链的软件应用，一个 IDE 通常包含一个代码编辑器，自动编译工具和一个调试器</td></tr><tr><td>ISP</td><td>Internet Service Provider</td><td>互联网服务供应商</td><td>通过电话线上的拨号连接（这在以前比较常见），或宽带连接（如电缆调制解调器或 DSL 服务）出售互联网接入服务的供应商。例如联通、电信、移动</td></tr><tr><td>SCM</td><td>Source Control Management</td><td>源代码控制管理</td><td>管理源代码的系统，例如 CVS、SVN、Git</td></tr><tr><td>UX/UE</td><td>User Experience</td><td>用户体验</td><td>研究用户和系统之间的交互。其目标是使系统易于从用户的角度进行交互</td></tr><tr><td>MRD</td><td>Market Requirements Document</td><td>市场需求文档</td><td>主要是描述市场分析、竞品调研，阐述什么样的功能和特点的产品（包含产品版本）可以在市场上取得成功</td></tr><tr><td>PRD</td><td>Product Requirements Document</td><td>产品需求文档</td><td>对MRD中的内容进行指标化和技术化，阐述产品的功能改善、产品的细节说明、产品原型</td></tr><tr><td>FSD</td><td>Functional Specifications Document</td><td>功能详细设计说明</td><td>定义产品功能需求的全部细节的文档</td></tr><tr><td>RFC</td><td>Request For Comments</td><td>征求意见稿</td><td>由互联网工程任务组（IETF）发布的一系列备忘录。文件收集了有关互联网相关信息，以及UNIX和互联网社群的软件文件，以编号排定。FC文件是由互联网协会（ISOC）赞助发行</td></tr><tr><td>PMO</td><td>Project Management Office</td><td>项目管理办公室</td><td>在组织内部将 实践、过程、运作 形式化和标准化的部门</td></tr></tbody></table><h2 id="机构与协会"><a href="#机构与协会" class="headerlink" title="机构与协会"></a>机构与协会</h2><table><thead><tr><th>简称</th><th>含义</th><th>解释</th><th>说明</th></tr></thead><tbody><tr><td>ECMA</td><td>European Computer Manufacturers Association</td><td>欧洲计算机制造商协会</td><td>一个开发计算机硬件、通信和程序语言标准的非盈利组织。JavaScript 语言的核心规范 the ECMA-262 specification（即 ECMAScript）的制定者。总部位于瑞士日内瓦。</td></tr><tr><td>W3C</td><td>World Wide Web Consortium</td><td>万维网联盟</td><td>一个维护网络相关规则与架构的国际技术标准机构。HTML标准，CSS标准，XML标准的制定者。由 Web 的发明者 Tim Berners-Lee 及 W3C 的首席执行官 Jeffrey Jaffe 领导，由设立在美国麻省理工大学（MIT）、欧洲数学与信息学研究联盟（ERCIM）、日本庆应大学（Keio University）和中国北京航空航天大学（Beihang University）的四个全球总部（W3C Hosts）的全球团队联合运营。</td></tr><tr><td>ISOC</td><td>Internet Society</td><td>国际互联网协会</td><td>一个非政府、非营利性、全球性的互联网组织，致力于推动互联网全球化，加快网络互连技术、发展应用软件、提高互联网普及率。总部及秘书处设在美国弗吉尼亚州莱斯顿地区，并在美国华盛顿和瑞士日内瓦设有办事处。</td></tr><tr><td>IETF</td><td>The Internet Engineering Task Force</td><td>国际互联网工程任务组</td><td>一个公开性质的大型国际团体，汇集了与互联网架构和互联网顺利运作相关的网络设计者、运营者、投资人和研究人员，主要任务是负责互联网相关技术规范的研发和制定。TCP协议，IP协议，HTTP协议的制定者。ISOC的下属机构。</td></tr><tr><td>IEEE</td><td>Institute of Electrical and Electronics Engineers</td><td>电气和电子工程师协会</td><td>世界上最大的非营利性专业技术学会，致力于电气、电子、计算机工程和与科学有关的领域的开发和研究、行业标准设定。IEEE 802.11 等标准的制定者。总部位于美国纽约。</td></tr><tr><td>ISO</td><td>International Organization for Standardization</td><td>国际标准化组织</td><td>一个全球性的非政府组织。ISO9001质量保证体系的制定者。总部位于瑞士日内瓦。</td></tr></tbody></table><h2 id="系统与协议"><a href="#系统与协议" class="headerlink" title="系统与协议"></a>系统与协议</h2><table><thead><tr><th>简称</th><th>含义</th><th>解释</th><th>说明</th></tr></thead><tbody><tr><td>CDN</td><td>Content Delivery Network</td><td>内容分发网络</td><td>指的是一组分布在各个地区的服务器。这些服务器存储着数据的副本，因此服务器可以根据哪些服务器与用户距离最近，来满足数据的请求</td></tr><tr><td>DNS</td><td>Domain Name System</td><td>域名系统</td><td>一个层次化、分散化的Internet连接资源命名系统。DNS维护着一个包含域名与对应资源例如IP地址的列表</td></tr><tr><td>SSH</td><td>Secure Sheel</td><td>安全外壳协议</td><td>建立在应用层基础上的安全协议</td></tr><tr><td>FTP</td><td>File Transfer Protocol</td><td>文件传输协议</td><td>一种在 Internet 上主机之间传输文件的标准协议</td></tr><tr><td>HTTP(S)</td><td>HyperText Transfer Protocol (Secure)</td><td>超文本传输协议</td><td>用于在 Web 上传输超媒体文件的底层协议 ，最典型场景的是在浏览器和服务器之间传递数据，以供人们浏览</td></tr><tr><td>SMTP</td><td>Simple Mail Transfer Protocol</td><td>简单邮件传输协议</td><td>用于发送的邮件的协议。类似于POP3和NNTP，是一个状态机驱动的协议</td></tr><tr><td>TCP</td><td>Transmission Control Protocol</td><td>传输控制协议</td><td>主要的网络协议之一。它使两台主机能够建立连接并交换数据流</td></tr><tr><td>UDP</td><td>User Datagram Protocol</td><td>用户数据流协议</td><td>当传输速度和效率比安全性和可靠性更重要时，通过IP一起用来发送数据的一种协议</td></tr></tbody></table><h2 id="人员称谓"><a href="#人员称谓" class="headerlink" title="人员称谓"></a>人员称谓</h2><table><thead><tr><th>简称</th><th>含义</th><th>解释</th><th>说明</th></tr></thead><tbody><tr><td>CEO</td><td>Chief Executive Officer</td><td>首席执行官</td><td>类似总经理、总裁，一般同时为企业的法人代表</td></tr><tr><td>COO</td><td>Chief Operations Officer</td><td>首席运营官</td><td>类似常务总经理</td></tr><tr><td>CFO</td><td>Chief Financial Officer</td><td>首席财务官</td><td>类似财务总经理</td></tr><tr><td>CIO</td><td>Chief Information Officer</td><td>首席信息官</td><td>主管企业信息的收集和发布</td></tr><tr><td>CTO</td><td>Chief Technology Officer</td><td>首席技术官</td><td>类似总工程师</td></tr><tr><td>GM</td><td>General Manager</td><td>总经理</td><td>-</td></tr><tr><td>VP</td><td>Vice President</td><td>副总裁</td><td>-</td></tr><tr><td>HRD</td><td>Humen Resource Director</td><td>人力资源总监</td><td>-</td></tr><tr><td>OD</td><td>Operations Director</td><td>运营总监</td><td>-</td></tr><tr><td>MD</td><td>Marketing Director</td><td>市场总监</td><td>-</td></tr><tr><td>OM</td><td>Operations Manager</td><td>运营经理</td><td>-</td></tr><tr><td>PM</td><td>Production Manager</td><td>生产经理</td><td>-</td></tr><tr><td>FE</td><td>Front-End</td><td>前端</td><td>通常指前端开发人员</td></tr><tr><td>RD</td><td>Research &amp; Development</td><td>调研与开发</td><td>通常指后端开发人员</td></tr><tr><td>PM</td><td>Product Manager</td><td>产品经理</td><td>-</td></tr><tr><td>QA</td><td>Quality Assurance</td><td>质量保证</td><td>通常指测试人员</td></tr><tr><td>QC</td><td>Quality Control</td><td>质量控制</td><td>通常指测试人员</td></tr><tr><td>OP</td><td>Operations</td><td>运维</td><td>通常指代运维人员</td></tr><tr><td>DBA</td><td>Database Administrator</td><td>数据库管理员</td><td>-</td></tr></tbody></table><p>需要注意的是 SCM、PM、PR 等术语在不同的语境下有不同的含义，例如 SCM 可能是Supply Chain Management(供应链管理)、Software Configuration Management(软件配置管理)、Source Control Management(源代码控制管理)，PM 可以为 Project Management(项目管理)、Project Manager(项目经理)、Prodcut Manager(产品经理)、Production Manager(生产经理)，还可能代表 Post Meridiem(下午)、Particulate Matter(颗粒物)</p>]]></content>
      
      
      
        <tags>
            
            <tag> front-end </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0.1 + 0.2 为什么不是 0.3</title>
      <link href="/blog/2021/06/18/JS-0-1-0-2%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF0-3/"/>
      <url>/blog/2021/06/18/JS-0-1-0-2%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF0-3/</url>
      
        <content type="html"><![CDATA[<p>我们在 JavaScript 里执行 0.1 + 0.2，会得到下面这个结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 0.1 + 0.2</span><br><span class="line">&gt; 0.30000000000000004</span><br></pre></td></tr></table></figure><p>为什么在 Javascript 中 <code>0.1 + 0.2 !== 0.3</code> 呢？为了解释这个问题，我们首先需要明白，计算机是怎么存储数字的  </p><span id="more"></span><h2 id="计算机是怎么存储数字的"><a href="#计算机是怎么存储数字的" class="headerlink" title="计算机是怎么存储数字的"></a>计算机是怎么存储数字的</h2><p>计算机是用二进制来存储数据的，同样的，我们平常使用的十进制的数字也需要转换成二进制的数字来存储。</p><h2 id="十进制与二进制的转换"><a href="#十进制与二进制的转换" class="headerlink" title="十进制与二进制的转换"></a>十进制与二进制的转换</h2><h3 id="十进制正整数转二进制"><a href="#十进制正整数转二进制" class="headerlink" title="十进制正整数转二进制"></a>十进制正整数转二进制</h3><p>十进制整数转二进制采用的是 <em>除 2 取余法</em> ，比如数字 8 转二进制的过程如下图：</p><p><img src="/blog/static/imgs/integer/1.png" alt="int_inner"></p><p>我们以 <code>int</code> 类型的数字作为例子，int 类型是 32 位的，其中最高位是作为「符号标志位」，正数的符号位是 0，负数的符号位是 1，剩余的 31 位则表示二进制数据。</p><p>那么，对于 int 类型的数字 1 的二进制数表示如下：</p><p><img src="/blog/static/imgs/integer/2.png" alt="int_inner"></p><h3 id="十进制负整数转二进制"><a href="#十进制负整数转二进制" class="headerlink" title="十进制负整数转二进制"></a>十进制负整数转二进制</h3><p>而负数就比较特殊了点，负数在计算机中是以 <em>补码</em> 表示的，所谓的补码就是把正数的二进制全部取反再加 1，比如 -1 的二进制是把数字 1 的二进制取反后再加 1，如下图：</p><p><img src="/blog/static/imgs/integer/3.png" alt="int_inner"></p><h3 id="十进制小数转二进制"><a href="#十进制小数转二进制" class="headerlink" title="十进制小数转二进制"></a>十进制小数转二进制</h3><p>小数部分的转换不同于整数部分，它采用的是 <em>乘 2 取整法</em> ，将十进制中的小数部分乘以 2 作为二进制的一位，然后继续取小数部分乘以 2 作为下一位，直到不存在小数为止。</p><p>我们就以 8.625 转二进制作为例子，转二进制的过程如下图：</p><p><img src="/blog/static/imgs/integer/4.png" alt="int_inner"></p><p>最后把「整数部分 + 小数部分」结合在一起后，其结果就是 1000.101。</p><p>但是，并不是所有小数都可以用二进制表示，前面提到的 0.625 小数是一个特例，刚好通过乘 2 取整法的方式完整的转换成二进制，如果我们用相同的方式，来把 0.1 转换成二进制，过程如下：</p><p><img src="/blog/static/imgs/integer/5.png" alt="int_inner"></p><p>可以发现，0.1 的二进制表示是无限循环的，由于计算机的资源是有限的，所以是没办法用二进制精确的表示 0.1，只能用「近似值」来表示，就是在有限的精度情况下，最大化接近 0.1 的二进制数，于是就会造成精度缺失的情况。</p><h3 id="二进制小数转十进制"><a href="#二进制小数转十进制" class="headerlink" title="二进制小数转十进制"></a>二进制小数转十进制</h3><p>对于二进制小数转十进制时，需要注意一点，小数点后面的指数幂是负数，比如二进制 0.1 转成十进制就是 2^(-1)，也就是十进制 0.5，二进制 0.01 转成十进制就是 2^-2，也就是十进制 0.25，以此类推。</p><p>举个例子，二进制 1010.101 转十进制的过程，如下图：</p><p><img src="/blog/static/imgs/integer/6.png" alt="int_inner"></p><h3 id="定点数与浮点数"><a href="#定点数与浮点数" class="headerlink" title="定点数与浮点数"></a>定点数与浮点数</h3><p>1010.101 这种二进制小数是 <em>定点数</em> 形式，代表着小数点是定死的，不能移动，如果你移动了它的小数点，这个数就变了， 就不再是它原来的值了。</p><p>然而，计算机并不是这样存储的小数的，计算机存储小数的采用的是 <em>浮点数</em> ，名字里的「浮点」表示小数点是可以浮动的，比如 1000.101 这个二进制数，可以表示成 1.000101 x 2^(-3)，类似于数学上的科学记数法。</p><p>因此，如果二进制要用到科学记数法，同时要规范化，那么不仅要保证基数为 2，还要保证小数点左侧只有 1 位，而且必须为 1，所以通常将 1000.101 这种二进制数，表示成 1.000101 x 2^(-3)，其中，最为关键的是 000101 和 -3 这两个东西，它就可以包含了这个二进制小数的所有信息，000101 称为 <em>尾数</em> ，即小数点后面的数字，-3 称为 <em>指数</em>，指定了小数点在数据中的位置。</p><p>现在绝大多数计算机使用的浮点数，一般采用的是 IEEE 制定的国际标准，这种标准形式如下图：</p><p><img src="/blog/static/imgs/integer/7.png" alt="int_inner"></p><p>这三个重要部分的意义如下：</p><ul><li>符号位：表示数字是正数还是负数，为 0 表示正数，为 1 表示负数；</li><li>指数位：指定了小数点在数据中的位置，指数可以是负数，也可以是正数，指数位的长度越长则数值的表达范围就越大；</li><li>尾数位：小数点右侧的数字，也就是小数部分，比如二进制 1.0011 x 2^(-2)，尾数部分就是 0011，而且尾数的长度决定了这个数的精度，因此如果要表示精度更高的小数，则就要提高尾数位的长度；</li><li>用 32 位来表示的浮点数，则称为 <em>单精度浮点数</em>，也就是我们编程语言中的 float 变量，而用 64 位来表示的浮点数，称为 <em>双精度浮点数</em>，也就是 double 变量，它们的结构如下：</li></ul><p><img src="/blog/static/imgs/integer/8.png" alt="int_inner"></p><p>可以看到：</p><ul><li>double 的尾数部分是 52 位，float 的尾数部分是 23 位，由于同时都带有一个固定隐含位（这个后面会说），所以 double 有 53 个二进制有效位，float 有 24 个二进制有效位，所以所以它们的精度在十进制中分别是 log10(2^53) 约等于 15.95 和 log10(2^24) 约等于 7.22 位，因此 double 的有效数字是 15~16 位，float 的有效数字是 7~8 位，这些是有效位是包含整数部分和小数部分；</li><li>double 的指数部分是 11 位，而 float 的指数位是 8 位，意味着 double 相比 float 能表示更大的数值范围；</li></ul><h3 id="二进制小数转二进制浮点数"><a href="#二进制小数转二进制浮点数" class="headerlink" title="二进制小数转二进制浮点数"></a>二进制小数转二进制浮点数</h3><p>那二进制小数，是如何转换成二进制浮点数的呢？我们就以 10.625 作为例子，看看这个数字在 float 里是如何存储的。</p><p><img src="/blog/static/imgs/integer/9.png" alt="int_inner"></p><p>首先，我们计算出 10.625 的二进制小数为 1010.101，然后把小数点，移动到第一个有效数字后面，即将 1010.101 右移 3 位成 1.010101，右移 3 位就代表 +3，左移 3 位就是 -3，float 中的「指数位」就跟这里移动的位数有关系，把移动的位数再加上「偏移量」，float 的话偏移量是 127，相加后就是指数位的值了，即指数位这 8 位存的是 10000010（十进制 130），因此你可以认为「指数位」相当于指明了小数点在数据中的位置。</p><p>1.010101 这小数点右侧的数字就是 float 里的「尾数位」，由于尾数位是 23 位，则后面要补充 0，所以最终尾数位存储的数字是 01010100000000000000000。</p><p>在算指数的时候，你可能会有疑问为什么要加上偏移量呢？</p><p>前面也提到，指数可能是正数，也可能是负数，即指数是有符号的整数，而有符号整数的计算是比无符号整数麻烦的，所以为了减少不必要的麻烦，在实际存储指数的时候，需要把指数转换成无符号整数，float 的指数部分是 8 位，IEEE 标准规定单精度浮点的指数取值范围是 -126 ~ +127，于是为了把指数转换成无符号整数，就要加个偏移量，比如 float 的指数偏移量是 127，这样指数就不会出现负数了。</p><p>比如，指数如果是 8，则实际存储的指数是 8 + 127 = 135，即把 135 转换为二进制之后再存储，而当我们需要计算实际的十进制数的时候，再把指数减去偏移量即可。</p><p>同时，因为 IEEE 标准规定，二进制浮点数的小数点左侧只能有 1 位，并且还只能是 1，既然这一位永远都是 1，那就可以不用存起来了，于是就让 23 位尾数只存储小数部分，电路在计算时会自动把这个 1 加上，这样就可以节约 1 位的空间，尾数就能多存一位小数，相应的精度就更高了一点。这 1 位就是上面提到的固定隐含位。</p><h3 id="二进制浮点数转十进制"><a href="#二进制浮点数转十进制" class="headerlink" title="二进制浮点数转十进制"></a>二进制浮点数转十进制</h3><p>那么，对于我们在从 float 的二进制浮点数转换成十进制时，要考虑到这个隐含的 1，转换公式如下：</p><p><img src="/blog/static/imgs/integer/10.png" alt="int_inner"></p><p>举个例子，我们把下图这个 float 的数据转换成十进制，过程如下：</p><p><img src="/blog/static/imgs/integer/11.png" alt="int_inner"></p><h2 id="为什么-0-1-0-2-0-3"><a href="#为什么-0-1-0-2-0-3" class="headerlink" title="为什么 0.1 + 0.2 !== 0.3"></a>为什么 0.1 + 0.2 !== 0.3</h2><p>前面提到过，并不是所有小数都可以用「完整」的二进制来表示的，比如十进制 0.1 在转换成二进制小数的时候，是一串无限循环的二进制数，计算机是无法表达无限循环的二进制数的，毕竟计算机的资源是有限。</p><p>因此，计算机只能用「近似值」二进制浮点数来表示该十进制小数，那么意味着计算机存放的小数可能不是一个真实值，现在基本都是用 IEEE 754 规范的单精度浮点类型或双精度浮点类型来存储小数的，根据精度的不同，近似值也会不同。</p><p>那计算机是以一个怎么样的二进制浮点数来存储十进制的 0.1 呢？可以使用 <a href="http://www.binaryconvert.com/">binaryconvert</a> 在线转换一下。</p><p>得到 0.1 的二进制浮点数是 00111101 11001100 11001100 11001101 转换成十进制的结果是 0.100000001490116119384765625</p><p><img src="/blog/static/imgs/integer/12.png" alt="int_inner"></p><p>0.2 的二进制浮点数是 00111110 01001100 11001100 11001101 转换成十进制的结果是 0.20000000298023223876953125</p><p><img src="/blog/static/imgs/integer/13.png" alt="int_inner"></p><p>这两个结果相加就是 0.300000004470348358154296875</p><p>所以，你会看到在计算机中 0.1 + 0.2 并不等于完整的 0.3，这主要是因为有的小数无法用「完整」的二进制来表示，所以计算机里只能采用近似数的方式来保存，那两个近似数相加，得到的必然也是一个近似数。</p><p>因为 JavaScript 对于数字都是使用 IEEE 754 标准下的双精度浮点类型来存储的，所以在 JavaScript 里执行 0.1 + 0.2，你会得到 0.30000000000000004 这个结果。  </p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>z-index与CSS层叠顺序</title>
      <link href="/blog/2021/06/14/CSS-z-index%E4%B8%8Ez%E8%BD%B4%E5%B1%82%E5%8F%A0%E9%A1%BA%E5%BA%8F/"/>
      <url>/blog/2021/06/14/CSS-z-index%E4%B8%8Ez%E8%BD%B4%E5%B1%82%E5%8F%A0%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="z轴索引-z-index"><a href="#z轴索引-z-index" class="headerlink" title="z轴索引 - z-index"></a>z轴索引 - z-index</h2><p>z-index 是一个CSS属性，它指定了元素及其子元素在z轴上的层叠顺序，z轴上的顺序可以决定当元素发生覆盖的时候，哪个元素在上面。  </p><p>z-index 属性仅在定位元素（定义了 position 属性，且属性值为非 static 值的元素）上有效果。  </p><p>z-index 的默认值为 auto 相当于 <code>z-index: 0;</code> 但不会创建新的层叠上下文，z-index 可以设置为任何整数值，包括负数。通常 z-index 值较大的元素会覆盖较低的那一个。  </p><span id="more"></span><h2 id="层叠上下文-stacking-context"><a href="#层叠上下文-stacking-context" class="headerlink" title="层叠上下文 - stacking context"></a>层叠上下文 - stacking context</h2><p>层叠上下文（stacking context），是HTML中一个三维的概念。在CSS2.1规范中，每个盒模型的位置是三维的，分别是平面画布上的X轴，Y轴以及表示层叠的Z轴。一般情况下，元素在页面上沿X轴Y轴平铺，我们察觉不到它们在Z轴上的层叠关系。而一旦元素发生堆叠，这时就能发现某个元素可能覆盖了另一个元素或者被另一个元素覆盖。  </p><p>如果一个元素含有层叠上下文，(也就是说它是层叠上下文元素)，我们可以理解为这个元素在Z轴上就会比别的元素有更高的层级，最终表现就是它离屏幕观察者更近。  </p><h2 id="层叠等级-stacking-level"><a href="#层叠等级-stacking-level" class="headerlink" title="层叠等级 - stacking level"></a>层叠等级 - stacking level</h2><p>在同一个层叠上下文中，层叠等级（stacking level）描述定义的是该层叠上下文中的层叠上下文元素在Z轴上的上下顺序。  </p><p>在其他普通元素中，它描述定义的是这些普通元素在Z轴上的上下顺序，普通元素的层叠等级优先由其所在的层叠上下文决定。  </p><p>层叠等级的比较只有在当前层叠上下文元素中才有意义。不同层叠上下文中比较层叠等级是没有意义的。  </p><h2 id="层叠顺序-stacking-order"><a href="#层叠顺序-stacking-order" class="headerlink" title="层叠顺序 - stacking order"></a>层叠顺序 - stacking order</h2><p>层叠顺序（stacking order）表示元素发生层叠时按照特定的顺序规则在Z轴上垂直显示。  </p><p><img src="/blog/static/imgs/stacking_order.png" alt="stacking_order_inner"></p><p>在不考虑CSS3的情况下，当元素发生层叠时，层叠顺序遵循上面的规则。  </p><h2 id="如何产生“层叠上下文”"><a href="#如何产生“层叠上下文”" class="headerlink" title="如何产生“层叠上下文”"></a>如何产生“层叠上下文”</h2><p>层叠上下文基本上是有一些特定的CSS属性创建的，有以下12种方法：  </p><ol><li>文档根元素（<code>&lt;html&gt;</code>）</li><li>position 值为 absolute（绝对定位）或 relative（相对定位）且 z-index 值不为 auto 的元素</li><li>position 值为 fixed（固定定位）或 sticky（粘滞定位）的元素</li><li>flex (flexbox) 容器的子元素，且 z-index 值不为 auto；</li><li>grid (grid) 容器的子元素，且 z-index 值不为 auto；</li><li>opacity 属性值小于 1 的元素</li><li>mix-blend-mode 属性值不为 normal 的元素；</li><li>以下任意属性值不为 none 的元素：<ul><li>transform</li><li>filter</li><li>perspective</li><li>clip-path</li><li>mask / mask-image / mask-border</li></ul></li><li>isolation 属性值为 isolate 的元素；</li><li>-webkit-overflow-scrolling 属性值为 touch 的元素；</li><li>will-change 值设定了任一属性而该属性在 non-initial 值时会创建层叠上下文的元素</li></ol><h2 id="如何判断两个元素发生覆盖时哪个会被覆盖"><a href="#如何判断两个元素发生覆盖时哪个会被覆盖" class="headerlink" title="如何判断两个元素发生覆盖时哪个会被覆盖"></a>如何判断两个元素发生覆盖时哪个会被覆盖</h2><h3 id="层叠上下文相同的元素"><a href="#层叠上下文相同的元素" class="headerlink" title="层叠上下文相同的元素"></a>层叠上下文相同的元素</h3><p>如果层叠上下文层级相同的元素发生了覆盖，那么在 DOM 结构中后面的元素会覆盖前面的元素。如果一个元素有 z-index 属性，z-index 为正数的元素会覆盖 z-index 值为默认的元素，z-index 的值越大，元素的层级越高，z-index为负数的元素会被 z-index 值为默认的元素覆盖，z-index 的值越小，元素的层级越低。  </p><h3 id="层叠上下文不同的元素"><a href="#层叠上下文不同的元素" class="headerlink" title="层叠上下文不同的元素"></a>层叠上下文不同的元素</h3><p>如果层叠上下文不同的两个元素发生了覆盖，首先看它们最近的同层叠上下文的祖先元素的层级，祖先元素的层级较高的元素会覆盖祖先元素层级较低的元素。如果祖先元素的层级相同，那么在 DOM 结构中后面的元素会覆盖前面的元素。  </p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS继承性</title>
      <link href="/blog/2021/06/13/CSS-css%E7%BB%A7%E6%89%BF%E6%80%A7/"/>
      <url>/blog/2021/06/13/CSS-css%E7%BB%A7%E6%89%BF%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="css属性继承性"><a href="#css属性继承性" class="headerlink" title="css属性继承性"></a>css属性继承性</h2><p>css样式继承指的是，特定的css属性可以向下传递到后代元素。</p><span id="more"></span><h2 id="可继承的css属性"><a href="#可继承的css属性" class="headerlink" title="可继承的css属性"></a>可继承的css属性</h2><p>有继承性的属性有以下几类：</p><ol><li>“font”字体系列属性</li></ol><p>包括 <code>font</code>、<code>font-family</code>、<code>font-weight</code>、<code>font-size</code>、<code>font-style</code>、<code>font-variant</code>、<code>font-stretch</code>、<code>font-size-adjust</code></p><ol start="2"><li>“text”文本系列属性</li></ol><p>包括 <code>text-indent</code>、<code>text-align</code>、<code>line-height</code>、<code>word-spacing</code>、<code>letter-spacing</code>、<code>text-transform</code>、<code>direction</code>、<code>color</code></p><ol start="3"><li>元素可见性</li></ol><p><code>visibility</code>、<code>opacity</code></p><ol start="4"><li>“display:table”表格布局属性</li></ol><p><code>caption-side</code>、<code>border-collapse</code>、<code>border-spacing</code>、<code>empty-cells</code>、<code>table-layout</code></p><ol start="5"><li>“display:list-item”列表布局属性</li></ol><p><code>list-style-type</code>、<code>list-style-image</code>、<code>list-style-position</code>、<code>list-style</code></p><ol start="6"><li>生成内容属性</li></ol><p><code>quotes</code></p><ol start="7"><li>光标属性</li></ol><p><code>cursor</code></p><ol start="8"><li>页面样式属性</li></ol><p><code>page</code>、<code>page-break-inside</code>、<code>windows</code>、<code>orphans</code></p><ol start="9"><li>声音样式属性</li></ol><p><code>speak</code>、<code>speak-punctuation</code>、<code>speak-numeral</code>、<code>speak-header</code>、<code>speech-rate</code>、<code>volume</code>、<code>voice-family</code>、<code>pitch</code>、<code>pitch-range</code>、<code>stress</code>、<code>richness</code>、<code>azimuth</code>、<code>elevation</code></p><h2 id="继承属性的优先级"><a href="#继承属性的优先级" class="headerlink" title="继承属性的优先级"></a>继承属性的优先级</h2><p>在计算继承属性时需要考虑以下特殊情况：</p><ol><li><p>a 标签的字体颜色（color）不能被继承</p></li><li><p>h1-h6 标签字体的大小（font-size）不能被继承</p></li><li><p>strong 标签的字体粗细（font-weight）不能被继承</p></li><li><p>s, strike, del, u, ins 标签的文本装饰（text-decoration）不能被继承</p></li></ol><p>因为这些属性是有浏览器默认样式的，也就是说继承属性的优先级不如浏览器默认样式（user agent stylesheet）优先级高</p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量命名风格</title>
      <link href="/blog/2021/06/07/CS-%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E9%A3%8E%E6%A0%BC/"/>
      <url>/blog/2021/06/07/CS-%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E9%A3%8E%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="小驼峰形式"><a href="#小驼峰形式" class="headerlink" title="小驼峰形式"></a>小驼峰形式</h2><p>小驼峰形式（camelCase），常用来表示符号、属性、方法、常量。 小驼峰（也叫标准驼峰）形式的第一个字母要使用小写形式，其他单词的首字母使用大写形式。比如 <code>selectedHero</code>。</p><span id="more"></span><h2 id="大驼峰形式（帕斯卡形式）"><a href="#大驼峰形式（帕斯卡形式）" class="headerlink" title="大驼峰形式（帕斯卡形式）"></a>大驼峰形式（帕斯卡形式）</h2><p>大驼峰形式（UpperCamelCase）或叫帕斯卡形式（PascalCase），常用来表示类名（包括用来定义组件、接口、指令等的类）。 大驼峰形式的第一个字母要使用大写形式。比如 <code>HeroListComponent</code>。</p><h2 id="中线形式（烤串形式）"><a href="#中线形式（烤串形式）" class="headerlink" title="中线形式（烤串形式）"></a>中线形式（烤串形式）</h2><p>中线形式（dash-case）或叫烤串形式（kebab-case），常用来表示项目名、文件名、组件的选择器。比如 <code>create-hero-app</code>。</p><h2 id="下划线形式（蛇形形式）"><a href="#下划线形式（蛇形形式）" class="headerlink" title="下划线形式（蛇形形式）"></a>下划线形式（蛇形形式）</h2><p>下划线形式（underscore_case）或叫蛇形形式（snake_case），后端变量命名常采用此种形式，前端一般不常用。蛇形形式使用下划线连接各个单词，各单词字母小写。 比如 <code>convert_link_mode</code>。</p><h2 id="大写下划线形式（大写蛇形形式）"><a href="#大写下划线形式（大写蛇形形式）" class="headerlink" title="大写下划线形式（大写蛇形形式）"></a>大写下划线形式（大写蛇形形式）</h2><p>大写下划线形式（UPPER_UNDERSCORE_CASE）或叫大写蛇形形式（UPPER_SNAKE_CASE），传统的常量写法。大蛇形形式使用下划线分隔的全大写单词。比如 <code>FIX_ME</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> style </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端技术选型</title>
      <link href="/blog/2021/06/06/FE-%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/"/>
      <url>/blog/2021/06/06/FE-%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>本文主要面向前端基础框架和库的选型，不包括构建工具、 UI 库和框架配套解决方案的选择。由于前端发展速度很快，框架层出不穷，特标明本文发布时间为 2021年6月6日，更新时间 2022年2月21日，更新时间 2022年3月14日，只适用于2021年前端基础框架技术选型。只选择了 web 应用开发时使用的框架，桌面端框架如 Electron、Tauri、Flutter，或者跨平台框架例如 React Native、Weex 或者众多的小程序框架本质上和如下列出的框架不是解决同一类问题所以不在对比之列。</p><span id="more"></span><h2 id="框架背景"><a href="#框架背景" class="headerlink" title="框架背景"></a>框架背景</h2><p><a href="https://github.com/vuejs/vue">Vue</a> 是一款渐进式、可增量采用来构建 UI 界面的 Javascript 框架，它于2014年2月首次由Google前员工 Evan You（尤雨溪）发布。当前最新版本是2.6.12。</p><p><a href="https://github.com/facebook/react">React</a> 是一款用于构建用户界面的 JavaScript 库，最初于2013年3月发布，由 Facebook 进行开发和维护。最新版本为17.0.2。</p><p><a href="https://github.com/angular/angular">Angular</a> 是一款用于构建移动和桌面 web 应用的前端框架，最初于2010年发布，由 Google 进行开发和维护。Angular 1.x名为<a href="https://github.com/angular/angular.js">AngularJS</a>，基于 JavaScript 开发。从 Angular 2开始基于 TypeScript 开发，并去掉了js，直接称为 Angular ，最新版本为12.0.1。</p><p><a href="https://github.com/jquery/jquery">jQuery</a> 是一款流行的 Javascript 库，提供了多种方便的DOM操作、事件绑定、CSS操作、Ajax封装的API。由 John Resig 开发。当前最新版本为3.6.0。</p><p><a href="https://github.com/sveltejs/svelte">Svelte</a> 是一款轻量级高性能的编译型 Javascript 框架。由 Rich Harris 于16年发布。它避开虚拟DOM的概念，在构建期间即将代码编译到小型原始JavaScript模块中。</p><p><a href="https://github.com/preactjs/preact">Preact</a> 是一款只有3kb的轻量级的类 React 的框架。由 Google 工程师 Jason Miller 开发。当前最新版本为10.5.13。</p><p><a href="https://github.com/emberjs/ember.js">Ember</a> 是一款基于 Handlebar 模板的 Javascript 框架。Ember在2011年发布，目前由Ember社区维护。当前最新版本为3.27.3。</p><p><a href="https://github.com/infernojs/inferno">Inferno</a> 是一款为了追求极致性能的类 React 框架。由 Facebook 工程师 Dominic Gannaway 开发。当前最新版本为7.4.8。</p><p><a href="https://github.com/madrobby/zepto">Zepto</a> 是一款轻量级的类 jQeruy 的 Javascript 库。由 Thomas Fuchs 开发。当前最新版本为1.2.0。</p><p><a href="https://github.com/baidu/san">San</a> 是一款高兼容性、高性能、轻量级的 Javascript 框架。由百度前端工程师 Erik (董睿)开发。当前最新版本为3.10.3。</p><p><a href="https://github.com/dojo/framework">Dojo</a> 是一款用 TypeScript 构建的现代 web 应用程序的渐进式框架。由 IBM 开发与支持。当前最新版本为7.0.0。</p><p><a href="https://github.com/Polymer/polymer">Polymer</a> 是一款用来构建可重用的 Web 组件（Web Components）的框架。由 Google 发布，当前最新版本是3.4.1，目前已处于维护模式，不再开发新的功能。</p><p><a href="https://github.com/lit/lit">Lit</a>是一个轻量级的库，用于构建快速、轻量级的 web 组件。由 Google 发布，属于 Polymer 的替代品。当前最新版本是2.2.0。</p><h2 id="特点和优缺点"><a href="#特点和优缺点" class="headerlink" title="特点和优缺点"></a>特点和优缺点</h2><p>Angular特点：</p><ol><li>良好的应用程序架构</li><li>双向数据绑定</li><li>Angular 指令与 HTML 模板</li><li>可嵌入、注入和测试</li></ol><p>优点：</p><ol><li>模板功能强大丰富，自带了极其丰富的 Angular 指令，支持双向数据绑定。</li><li>代码模块化（每个模块的代码独立拥有自己的作用域，model，controller等）</li><li>是一个比较完善的前端框架，包含服务、模板、数据双向绑定、模块化、路由、过滤器、依赖注入等所有功能</li><li>ng模块化引入了对依赖注入的支持，能够很容易的写出可复用的代码</li><li>Angular 由商业公司 Google 开发，这意味着它有一个坚实的基础支持</li></ol><p>缺点：</p><ol><li>Angular 入门较难，需要首先了解 TypeScript 和 ES7 的 decorator 语法，还需要理解 DI</li><li>对 IE6/7 兼容不是很好</li><li>DI依赖注入如果代码压缩需要显示声明</li><li>更适合企业级应用开发，对小型项目来说过于过于重量级需要引入过多模块</li><li>国内使用 Angular 的公司和项目较少</li></ol><p>React特点：</p><ol><li>声明式设计：React采用声明式设计，可以轻松描述应用</li><li>高效：React通过对DOM的模拟（virtual DOM），最大限度地减少低性能的DOM操作</li><li>灵活：React 核心只实现了基础的UI渲染部分，可以与已知的库或框架很好的配合</li></ol><p>优点：</p><ol><li>速度快：在UI渲染过程中，React通过在虚拟 DOM 中的微操作来实现对实际DOM的局部更新</li><li>跨浏览器兼容：虚拟DOM帮助我们解决了跨浏览器问题，它为我们提供了标准化的API，甚至在IE8中都是没问题的</li><li>模块化：为你程序编写独立的模块化UI组件，这样当某个或某些组件出现问题时，可以方便地进行隔离</li><li>单向数据流：Flux是一个用于在 JavaScript 应用中创建单向数据层的架构，它随着React视图库的开发而被Facebook概念化</li><li>同构、纯粹的JavaScript：因为搜索引擎的爬虫程序依赖的是服务端响应而不是JavaScript的执行，预渲染应用有助于搜索引擎优化</li></ol><p>缺点：</p><ol><li>React仅核心库由 facebook 提供支持，其他相关库例如路由，状态管理等均由社区维护</li><li>React 由商业公司 facebook 支持，React Native 开源协议曾受到质疑</li><li>React17 之前版本基于事件委托的合成事件，表现和使用与原生事件存在差异</li></ol><p>Vue特性：</p><ol><li>轻量级的框架</li><li>双向数据绑定</li><li>单页面模板 与 vue 指令</li><li>插件化</li></ol><p>优点：</p><ol><li>简单：官方文档国际化支持更好，语法更易用，比 Angular 和 React 易学</li><li>快速：异步批处理方式更新DOM</li><li>紧凑：~18kb min+gzip，且无依赖</li><li>组合：vue3支持组合式（composition）api 可以用解耦的、可复用的组件组合应用程序</li></ol><p>缺点：</p><ol><li>缺少工程化设计，不利于复用代码</li><li>使用了 <code>Object.defineProperty</code> 语法，不支持 IE8 以下浏览器</li><li>由个人开发者 Even You 支持</li></ol><p>Svelte特性：</p><ol><li>轻量级</li><li>编译型框架</li><li>无 virtual DOM</li></ol><p>优点：</p><ol><li>编译型框架：线上环境无需单独下载框架包，编译好后直接发布</li><li>轻量级：比 react、angular、vue的代码量更少，通过CSS缩小后有约17kb的大小，gzip后更是小到了4kb</li><li>没有 virtual DOM 和 virtual DOM diff，性能更好</li></ol><p>缺点：</p><ol><li>不支持 Typescript</li><li>配套库不太完善，不支持前端路由</li><li>框架较新，社区规模较小</li></ol><table><thead><tr><th>特性</th><th>说明</th><th>Vue</th><th>React</th><th>Angular</th><th>Svelte</th></tr></thead><tbody><tr><td>数据监听</td><td>代码中的某个值变化后，能够通过回调函数实现逻辑</td><td>支持<br><code>watch</code></td><td>支持<br><code>useCallback()</code></td><td>支持<br><code>ngOnChanges</code></td><td>支持<br><code>$:</code></td></tr><tr><td>计算属性</td><td>某个只读变量可以通过另外几个变量和逻辑响应式的得出</td><td>支持<br><code>computed</code></td><td>支持<br><code>useMemo()</code></td><td>支持<br><code>get Var()&#123;&#125;</code></td><td>支持<br><code>$:</code></td></tr><tr><td>数据双向绑定</td><td>主要用于表单提交和更新，用户输入和数据双向绑定，一者变更时另一者随之变化</td><td>支持<br><code>v-model</code></td><td>不支持<br>使用单向数据绑定</td><td>支持<br><code>ngModel</code></td><td>支持<br><code>bind:value</code></td></tr><tr><td>css scoped</td><td>css的作用域只针对当前的组件生效，避免相同的css名字相互影响</td><td>支持</td><td>不支持<br>支持 css in js</td><td>支持</td><td>支持</td></tr><tr><td>组件生命周期</td><td>在组件生成，更新，销毁等情况时可以有回调函数实现逻辑</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>SPA前端路由</td><td>单页APP，url改变不刷新页面</td><td>支持</td><td>支持</td><td>支持</td><td>不支持</td></tr><tr><td>TypeScript</td><td>支持使用 TypeScript</td><td>支持</td><td>支持</td><td>支持</td><td>不支持</td></tr><tr><td>自定义指令(directive)</td><td>为所有页面元素添加全局自定义属性</td><td>支持</td><td>不支持</td><td>支持</td><td>支持</td></tr><tr><td>Pipe/Filter</td><td>可以对字符串、数字在打印模板中进行数据过滤和美化</td><td>支持</td><td>不支持</td><td>支持</td><td>不支持</td></tr></tbody></table><h2 id="框架生态"><a href="#框架生态" class="headerlink" title="框架生态"></a>框架生态</h2><p>一个好的框架会有一些周边生态来完善框架在面对不同的业务场景时的具体问题。</p><p>Angular是一个“完整的解决方案”<br>Angular 命令行工具 - @angular/cli<br>Angular 路由管理 - @angular/router<br>Angular 跨端解决方案 - Cordava Ionic</p><p>React 命令行工具 - Create-react-app<br>React 路由管理 - React-router<br>React 应用状态管理 - <a href="https://github.com/reduxjs/redux">Redux</a>、mobx、flux<br>React SSR解决方案 - Next.js<br>React 跨端解决方案 - React Native<br>React 浏览器开发者工具插件 - react-devtools</p><p>Vue 命令行工具 - @vue/cli<br>Vue 路由管理 Vue-router<br>Vue 应用状态管理 - Vuex<br>Vue SSR解决方案 - Nuxt.js<br>Vue 静态页面生成框架 - Vuepress<br>Vue 跨端解决方案 - Weex<br>Vue 浏览器开发者工具插件 - vue-devtools</p><h2 id="配套UI组件库"><a href="#配套UI组件库" class="headerlink" title="配套UI组件库"></a>配套UI组件库</h2><p>现代 web 应用中，页面一般是由不同的模块组成，为了可以复用代码，提升开发效率，通常会把相同或类似的模块抽象成组件以便于在不同的页面中使用。在长期的开发实践过程中，人们把常用的组件组合成组件库，以便在不同的项目中也可以复用。组件库一般是基于前端基础框架进行扩展，且遵循同一套设计规范。成熟的前端框架很多都有多套配套的UI组件库，可以进一步的提升研发效率。</p><p>常用的 Vue UI库有 </p><table><thead><tr><th>ui库</th><th>介绍</th><th>Github stars</th><th>作者</th><th>类型</th></tr></thead><tbody><tr><td><a href="https://github.com/ElemeFE/element">Element UI</a></td><td>一款界面风格偏向于B端的基于 Vue 2.0 的桌面端组件库</td><td>50.2k</td><td>ElemeFE 饿了么</td><td>PC</td></tr><tr><td><a href="https://github.com/vuetifyjs/vuetify">Vuetify</a></td><td>一款采用 <a href="https://www.material.io/">Material Design</a> 的 vue 组件库</td><td>31k</td><td>John Leider &amp; Heather Leider</td><td>Responsive</td></tr><tr><td><a href="https://github.com/iview/iview">iview</a> <a href="https://github.com/view-design/ViewUI">ViewUI</a></td><td>一款基于 Vue 的高质量 UI 工具集 <br> iview4名称变更为 ViewUI</td><td>23.8k <br> 2.3k</td><td>TalkingData 腾云天下</td><td>PC</td></tr><tr><td><a href="https://github.com/quasarframework/quasar">Quasar</a></td><td>一款基于 Vue 的企业级开源多平台UI库</td><td>18.7k</td><td>Razvan Stoenescu</td><td>Responsive</td></tr><tr><td><a href="https://github.com/youzan/vant">vant</a></td><td>一款基于 Vue2 的移动 UI 组件库</td><td>17.5k</td><td>YouZan 有赞</td><td>Mobile</td></tr><tr><td><a href="https://github.com/airyland/vux">vux</a></td><td>一款采用 <a href="https://weui.io/">WeUI</a> 设计的移动端 Vue UI 组件库</td><td>17.4k</td><td>Airyland</td><td>Mobile</td></tr><tr><td><a href="https://github.com/ElemeFE/mint-ui">mint-ui</a></td><td>一款基于 Vue2 的移动端组件库</td><td>16.4k</td><td>ElemeFE 饿了么</td><td>Mobile</td></tr><tr><td><a href="https://github.com/bootstrap-vue/bootstrap-vue">BootstrapVue</a></td><td>一款基于 Vue2.6 并采用 <a href="https://getbootstrap.com/docs/4.5/getting-started/introduction/">Bootstrap v4.5</a> 组件和栅格系统设计的 UI 组件库</td><td>13.2k</td><td>pooya parsa &amp; Troy Morehouse</td><td>Responsive</td></tr><tr><td><a href="https://github.com/vuematerial/vue-material">Vue Material</a></td><td>一款简单、轻量级的采用 Material Design 的 vue 组件库</td><td>9.4k</td><td>Marcos Moura</td><td>Responsive</td></tr><tr><td><a href="https://github.com/buefy/buefy">Buefy</a></td><td>一个基于 <a href="https://bulma.io/">Bulma</a> 框架和设计的轻量级的 Vue 响应式UI组件库</td><td>8.7k</td><td>Rafael Beraldo</td><td>Responsive</td></tr><tr><td><a href="https://github.com/museui/muse-ui">muse-ui</a></td><td>一款采用 Material Design 的 vue2 UI库</td><td>8.3k</td><td>(停止更新)</td><td>PC</td></tr></tbody></table><p>常用的 React 组件库有</p><table><thead><tr><th>ui库</th><th>介绍</th><th>Github stars</th><th>作者</th><th>类型</th></tr></thead><tbody><tr><td><a href="https://github.com/ant-design/ant-design">Ant Design</a></td><td>一款企业级的 React UI组件库</td><td>72.2k</td><td>Alibaba 阿里-支付宝</td><td></td></tr><tr><td><a href="https://github.com/mui-org/material-ui">Material-UI</a></td><td>一款采用  Material Design 的简单可定制化的 React 组件库</td><td>68.7k</td><td></td><td></td></tr><tr><td><a href="https://github.com/react-bootstrap/react-bootstrap">React-Bootstrap</a></td><td>一款采用 React 构建的 Bootstrap 5 组件库</td><td>19.4k</td><td></td><td></td></tr><tr><td><a href="https://github.com/palantir/blueprint">Blueprint</a></td><td>一款基于 React 的 UI工具集</td><td>17.8k</td><td></td><td>PC</td></tr><tr><td><a href="https://github.com/microsoft/fluentui">Fluent UI</a></td><td>一款React组件、工具的集合</td><td>11.5k</td><td>Microsoft</td><td></td></tr><tr><td><a href="https://github.com/Semantic-Org/Semantic-UI-React">Semantic UI React</a></td><td>Semantic-UI的官方 React 组件库</td><td>12.3k</td><td>Semantic</td><td></td></tr><tr><td><a href="https://github.com/segmentio/evergreen">Evergreen</a></td><td>一款 react UI库</td><td>10.8k</td><td>Segment.io</td><td></td></tr><tr><td><a href="https://github.com/reactstrap/reactstrap">reactstrap</a></td><td>一款基于  Bootstrap4 的无状态的 React 库</td><td>9.9k</td><td></td><td></td></tr></tbody></table><p>常用的 Angular 组件库有</p><table><thead><tr><th>ui库</th><th>介绍</th><th>Github stars</th><th>作者</th><th>类型</th></tr></thead><tbody><tr><td><a href="https://github.com/angular/material2">Material2</a></td><td>Angular官方提供的 Material Design 组件库</td><td>21.5k</td><td>Google</td><td></td></tr></tbody></table><h2 id="活跃度和流行趋势"><a href="#活跃度和流行趋势" class="headerlink" title="活跃度和流行趋势"></a>活跃度和流行趋势</h2><p>在选择一款前端框架时，流行程度和活跃度是需要考量的一部分。被越多的人使用，说明在业界得到很好的认可，而框架的更新频率和社区&amp;话题活跃度则代表了一款框架之后的趋势，如果作者和主要的 maintainer 都不再更新，那么这款框架基本上也就离自己的尽头不远了。比较通用的考察角度可以包括以下几个方面  </p><ul><li>npm包 周期下载量（npm download）</li><li>GitHub 收藏数量及趋势(github stars)</li><li>框架更新频率(last updated)</li><li>框架贡献者(contributors)数量</li></ul><h3 id="npm-trends"><a href="#npm-trends" class="headerlink" title="npm trends"></a>npm trends</h3><p>参见 <a href="https://www.npmtrends.com/angular-vs-ember-source-vs-jquery-vs-lit-html-vs-preact-vs-react-vs-svelte-vs-vue-vs-inferno">npm trends</a></p><p>npm 包的下载量与趋势直观的反映了现存项目对框架包的依赖情况。<br>但是有些框架可能会拆分为不同的包，在横向对比时不能很好的反应框架的使用量，只能反应对应npm包的下载量。<br>另外由于历史项目的依赖等，npm包下载量不能很好的预测未来技术的趋势。同时，考虑 registry 镜像的问题，taobao 的 <a href="https://registry.npm.taobao.org">registry</a> 在中国可能有更广泛的使用，所以 npmjs 也不一定能够反映真实的反应国内的 npm 包下载量。</p><p>从图中我们可以看到 React 处于一骑绝尘的状态，jQuery 和 Vue 也将其他框架远远的甩在了后面。<br>这基本上反映了现存项目的框架依赖状态，React 在国际上应用广泛，而且在可预见的未来都很难有框架能够比拟 React。jQuery 在许多项目中仍旧有用武之地。Vue 也被大量项目使用。</p><h3 id="GitHub-Repo-stars"><a href="#GitHub-Repo-stars" class="headerlink" title="GitHub Repo stars"></a>GitHub Repo stars</h3><table><thead><tr><th>框架</th><th>GitHub Repo stars</th></tr></thead><tbody><tr><td><a href="https://github.com/vuejs/vue">Vue</a></td><td><img src="https://img.shields.io/github/stars/vuejs/vue" alt="GitHub Repo stars"></td></tr><tr><td><a href="https://github.com/facebook/react">React</a></td><td><img src="https://img.shields.io/github/stars/facebook/react" alt="GitHub Repo stars"></td></tr><tr><td><a href="https://github.com/angular/angular">Angular2</a></td><td><img src="https://img.shields.io/github/stars/angular/angular" alt="GitHub Repo stars"></td></tr><tr><td><a href="https://github.com/angular/angular.js">AngularJS</a></td><td><img src="https://img.shields.io/github/stars/angular/angular.js" alt="GitHub Repo stars"></td></tr><tr><td><a href="https://github.com/sveltejs/svelte">Svelte</a></td><td><img src="https://img.shields.io/github/stars/sveltejs/svelte" alt="GitHub Repo stars"></td></tr><tr><td><a href="https://github.com/jquery/jquery">jQuery</a></td><td><img src="https://img.shields.io/github/stars/jquery/jquery" alt="GitHub Repo stars"></td></tr><tr><td><a href="https://github.com/preactjs/preact">Preact</a></td><td><img src="https://img.shields.io/github/stars/preactjs/preact" alt="GitHub Repo stars"></td></tr><tr><td><a href="https://github.com/emberjs/ember.js">Ember</a></td><td><img src="https://img.shields.io/github/stars/emberjs/ember.js" alt="GitHub Repo stars"></td></tr><tr><td><a href="https://github.com/Polymer/polymer">Ploymer</a></td><td><img src="https://img.shields.io/github/stars/Polymer/polymer" alt="GitHub Repo stars"></td></tr><tr><td><a href="https://github.com/infernojs/inferno">Inferno</a></td><td><img src="https://img.shields.io/github/stars/infernojs/inferno" alt="GitHub Repo stars"></td></tr><tr><td><a href="https://github.com/madrobby/zepto">Zepto</a></td><td><img src="https://img.shields.io/github/stars/madrobby/zepto" alt="GitHub Repo stars"></td></tr><tr><td><a href="https://github.com/lit/lit">Lit</a></td><td><img src="https://img.shields.io/github/stars/lit/lit" alt="GitHub Repo stars"></td></tr><tr><td><a href="https://github.com/baidu/san">San</a></td><td><img src="https://img.shields.io/github/stars/baidu/san" alt="GitHub Repo stars"></td></tr><tr><td><a href="https://github.com/dojo/framework">Dojo</a></td><td><img src="https://img.shields.io/github/stars/dojo/framework" alt="GitHub Repo stars"></td></tr></tbody></table><p>Github stars 可以反应项目自在 Github 发布以来的关注度。<br>从 Github Stars 来看，Vue 和 React 均是最受关注的框架，甩了其他框架一个数量级。Angular、Svelte、jQuery 都超过了 5w 的收藏，可以说都是备受关注的框架。使用这些框架开始你的开发，基本上不会有什么大问题，它们都是经过了多数人的验证。</p><h3 id="GitHub-Repo-Star-History"><a href="#GitHub-Repo-Star-History" class="headerlink" title="GitHub Repo Star History"></a>GitHub Repo Star History</h3><p><img src="https://api.star-history.com/svg?repos=vuejs/vue,facebook/react,angular/angular,sveltejs/svelte,jquery/jquery,preactjs/preact,emberjs/ember.js,infernojs/inferno,lit/lit&amp;type=Date" alt="Star History Chart inner"></p><p>GitHub Repo Star History 反映了项目在 Github 流行的趋势。<br>从 GitHub Repo Star History 来看，React、Vue、Angular 和 Svelte 的斜率比其它项目要大的多，说明这些框架正在变得更加流行（虽然 React、Vue 已经非常流行了）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> front-end </tag>
            
            <tag> react </tag>
            
            <tag> vue </tag>
            
            <tag> angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>脱离文档流的方法</title>
      <link href="/blog/2021/06/04/CSS-%E8%84%B1%E7%A6%BB%E6%96%87%E6%A1%A3%E6%B5%81%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/blog/2021/06/04/CSS-%E8%84%B1%E7%A6%BB%E6%96%87%E6%A1%A3%E6%B5%81%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="正常文档布局流"><a href="#正常文档布局流" class="headerlink" title="正常文档布局流"></a>正常文档布局流</h2><p>正常文档布局流（normal document layout flow）是指在没有改变默认布局规则情况下的页面元素布局方式。如果你未曾应用任何CSS规则来改变它们的展现方式，网页上的元素将会按照正常布局流来组织布局。<br>首先说一下独立元素的布局。元素的内容被放在一个独立的元素盒子中，然后在其周边加上内边距（padding）、边框（border）和外边距（margin） — 就是我们所说的盒子模型（box model）。默认情况下，一个块级元素（典型如div）的内容宽度是其父元素的100%，其高度与其内容高度一致。内联元素（典型如span）的高度、宽度与内容一致。你可以通过设置 <code>display: block</code> 与 <code>display: inline</code> 来将一个元素变为块级元素或内联元素。<br>元素之间又是如何相互影响的呢？块级元素默认会按照基于其父元素的书写顺序（writing-mode: horizontal-tb）的块流动方向（block flow direction）放置 — 每个块级元素会在上一个元素下面另起一行，它们会被设置好的外边距（margin）分隔。在英语，或者其他水平书写、自上而下模式里，块级元素是垂直组织的。内联元素的表现有所不同 — 它们不会另起一行；只要在其父级块级元素的宽度内有足够的空间，它们与其他内联元素、相邻的文本内容（或者被包裹的）被安排在同一行。如果空间不够，溢出的文本或元素将移到新的一行。</p><span id="more"></span><h2 id="如何脱离正常文档流"><a href="#如何脱离正常文档流" class="headerlink" title="如何脱离正常文档流"></a>如何脱离正常文档流</h2><p>有时候我们希望元素脱离正常的文档流，在正常文档流中不占用空间，我们有如下三种方法可以达到目的：</p><ol><li>使用 <code>float</code> 属性</li></ol><p>设置 <code>float:left;</code> 或 <code>float:right;</code> 后，其他盒子占用空间时会无视这个元素，但其他盒子内的文本依然会为这个元素让出位置，环绕在该元素的周围</p><ol start="2"><li>设置 <code>position: absolute;</code></li></ol><p>设置 <code>position: absolute;</code> 后该元素会相对于非 <code>position: static;</code> 的祖先元素进行定位</p><ol start="3"><li>设置 <code>position: fixed;</code></li></ol><p>设置 <code>position: fixed;</code> 后元素会相对于浏览器窗口进行定位</p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端API缓存方案</title>
      <link href="/blog/2021/05/21/FE-%E5%89%8D%E7%AB%AFAPI%E7%BC%93%E5%AD%98%E6%96%B9%E6%A1%88/"/>
      <url>/blog/2021/05/21/FE-%E5%89%8D%E7%AB%AFAPI%E7%BC%93%E5%AD%98%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="API-缓存"><a href="#API-缓存" class="headerlink" title="API 缓存"></a>API 缓存</h2><p>在开发 web 应用程序时，性能都是必不可少的话题。对于单页面应用程序而言，我们可以采用很多方式来对性能进行优化，比方说 tree-shaking、模块懒加载、利用网络cdn加速等这些常规的优化。</p><p>而事实上，缓存一定是提升web应用程序性能最有效方法之一，这是一种用空间换取时间的做法，尤其是用户受限于网速的情况下，利用额外的存储来提升系统的响应能力，降低网络的消耗，可以有效的提升 web 应用的性能。</p><p>以浏览器而言，我们有很多缓存数据与资源的方法，例如 标准的浏览器缓存（包括强缓存和协商缓存） 以及 Service worker 等技术。但一般而言，他们都更适合静态内容的缓存。例如 html，js，css以及图片等文件。而如果需要缓存系统数据的话，我们需要采用另外的方案。</p><span id="more"></span><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>对 API 进行缓存，在某些场景下是有害的，例如页面对实时性要求比较高，需要频繁的请求 server 且每次请求 server 获取的数据均不同，或者 server 返回的数据是带策略的，比如有个性化推荐，那么就完全不能对 API 进行缓存。什么场景比较适合对 API 进行缓存呢？当 API 请求的地址和参数不变时，server 返回的数据也是固定的，该部分数据之所以从接口返回是因为该部分数据量级很大，不能完全放到前端，这种情况对 API 进行缓存就比较合适了。一些常见的业务场景有：</p><ol><li><p>文档类型的应用<br>文档类型的页面如果做成静态网站，虽然可以通过HTTP缓存在第二次进入页面时有更快的性能体验，但是在不同的页面之间跳转都会请求静态页面，有刷新感，体验较差，如果做成SPA，切换页面时也会请求数据，如果能缓存这部分数据，在第二次进入页面时就会有更快的体验。  </p></li><li><p>分发类的应用<br>分发类的应用有固定的页面更新时间，在用户进入一次页面之后，可以缓存当前的分发数据。  </p></li><li><p>论坛类的应用<br>文章详情页可以进行缓存，因为文章内容在发布后几乎不会变化，数量巨大，如果缓存了，用户在第二次进入相同的文章时可以立即看到文章。  </p></li></ol><h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><ol><li>简单的数据缓存，第一次请求时候获取数据，之后便使用数据，不再请求后端api</li></ol><p>我们假设获取数据的 function 是这样声明的，它返回一个 promise</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getDataAPI</span>(<span class="params">params</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">callee</span>.<span class="property">name</span>, <span class="string">&#x27;is called.&#x27;</span>);</span><br><span class="line">    <span class="comment">// mock</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(&#123;<span class="attr">data</span>: &#123;&#125;, <span class="attr">status</span>: <span class="number">0</span>, <span class="attr">msg</span>: <span class="string">&#x27;Success.&#x27;</span>&#125;);</span><br><span class="line">    <span class="comment">// online</span></span><br><span class="line">    <span class="keyword">return</span> request.<span class="title function_">get</span>(<span class="string">&#x27;/getData&#x27;</span>, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们希望将 fn 的结果缓存，一般而言，前端可以将数据缓存到内存和硬盘上。内存就是我们正在运行的程序中，我们可以声明一个 Map 或者 Object 用来存储我们的数据。硬盘就是浏览器给我们提供的持久化数据的方法，可以使用 localStorage 或者 IndexedDB。这里我们使用 Object 数据结构用来将数据存储到内存中，用 localStorage 来将数据持久化到客户端。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从storage中获取缓存</span></span><br><span class="line"><span class="keyword">let</span> storageCache = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;cache&#x27;</span>) || <span class="string">&#x27;&#123;&#125;&#x27;</span>;</span><br><span class="line"><span class="comment">// 将缓存放到内存中</span></span><br><span class="line"><span class="keyword">let</span> dataCache = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(storageCache);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params">params</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取缓存的key</span></span><br><span class="line">    <span class="keyword">let</span> apiName = <span class="variable language_">arguments</span>.<span class="property">callee</span>.<span class="property">name</span>;</span><br><span class="line">    <span class="comment">// 从内存缓存中获取数据</span></span><br><span class="line">    <span class="keyword">let</span> data = dataCache[apiName];</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        <span class="comment">// 有数据则返回之前的缓存数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有数据则请求服务器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">getDataAPI</span>(params).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 设置内存数据缓存</span></span><br><span class="line">        dataCache[apiName] = res;</span><br><span class="line">        <span class="comment">// 同步storage缓存</span></span><br><span class="line">        <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;cache&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(dataCache));</span><br><span class="line">        <span class="comment">// 返回最新数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(res);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getData</span>().<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>, data) &#125;);</span><br><span class="line"><span class="comment">// 第二次调用 不再发起 api 请求，直接取得先前的 data</span></span><br><span class="line"><span class="title function_">getData</span>().<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>, data) &#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li>如果此 api 有同时两个以上的调用，会因为请求未返回而进行第二次 api 请求，所以我们需要对 promise 进行缓存，因为只需在内存中缓存，所以在这里我们使用 Map 数据结构</li></ol><p>首先改造下请求 api 使它不那么快的返回</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getDataAPI</span>(<span class="params">params</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">callee</span>.<span class="property">name</span>, <span class="string">&#x27; request.&#x27;</span>);</span><br><span class="line">    <span class="comment">// mock</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">callee</span>.<span class="property">name</span>, <span class="string">&#x27; response.&#x27;</span>);</span><br><span class="line">            <span class="title function_">resolve</span>(&#123;<span class="attr">data</span>: &#123;&#125;, <span class="attr">status</span>: <span class="number">0</span>, <span class="attr">msg</span>: <span class="string">&#x27;Success.&#x27;</span>&#125;);</span><br><span class="line">        &#125;, <span class="number">3000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// online</span></span><br><span class="line">    <span class="keyword">return</span> request.<span class="title function_">get</span>(<span class="string">&#x27;/getData&#x27;</span>, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后改造下缓存方法添加对 promise 的缓存</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> storageCache = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;cache&#x27;</span>) || <span class="string">&#x27;&#123;&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> dataCache = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(storageCache);</span><br><span class="line"><span class="keyword">let</span> promiseCache = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params">params</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> apiName = <span class="variable language_">arguments</span>.<span class="property">callee</span>.<span class="property">name</span>;</span><br><span class="line">    <span class="keyword">let</span> data = dataCache[apiName];</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 promise 缓存中已有该 api ，说明在不久之前我们刚请求过，而且还未返回</span></span><br><span class="line">    <span class="keyword">let</span> promise = promiseCache.<span class="title function_">get</span>(apiName);</span><br><span class="line">    <span class="keyword">if</span> (promise) &#123;</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">    promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">getDataAPI</span>(params).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            dataCache[apiName] = res;</span><br><span class="line">            <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;cache&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(dataCache));</span><br><span class="line">            <span class="title function_">resolve</span>(res);</span><br><span class="line">        &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(e);</span><br><span class="line">        &#125;).<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 请求结束则从内存缓存中删除该api请求</span></span><br><span class="line">            promiseCache.<span class="title function_">delete</span>(apiName);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 将该请求的promise存放到缓存中去</span></span><br><span class="line">    promiseCache.<span class="title function_">set</span>(apiName, promise);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码解决了同一时间发起多次同样请求时不会读取缓存的问题。同时也在后端出错的情况下对 promise 进行了删除，不会出现缓存了错误的 promise 一直出错。</p><p>调用方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getData</span>().<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>, data) &#125;);</span><br><span class="line"><span class="title function_">getData</span>().<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>, data) &#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li>同时同时缓存需要设置过期时间，防止一直获取不到最新数据的问题</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> storageCache = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;cache&#x27;</span>) || <span class="string">&#x27;&#123;&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> dataCache = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(storageCache);</span><br><span class="line"><span class="keyword">let</span> promiseCache = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"> <span class="comment">// api 最大缓存时间 一周</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">MAX_CACHE_TIME</span> = <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params">params</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> apiName = <span class="variable language_">arguments</span>.<span class="property">callee</span>.<span class="property">name</span>;</span><br><span class="line">    <span class="keyword">let</span> data = dataCache[apiName];</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        <span class="comment">// 当前时间还未超出最大缓存时间</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Date</span>.<span class="title function_">now</span>() - data.<span class="property">__timestamp</span> &lt; <span class="variable constant_">MAX_CACHE_TIME</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(data.<span class="property">res</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则将缓存清空</span></span><br><span class="line">        <span class="keyword">delete</span> dataCache[apiName];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> promise = promiseCache.<span class="title function_">get</span>(apiName);</span><br><span class="line">    <span class="keyword">if</span> (promise) &#123;</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">    promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">getDataAPI</span>(params).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            data = &#123;</span><br><span class="line">                res,</span><br><span class="line">                <span class="attr">__timestamp</span>: <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 设置数据缓存</span></span><br><span class="line">            dataCache[apiName] = data;</span><br><span class="line">            <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;cache&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(dataCache));</span><br><span class="line">            <span class="title function_">resolve</span>(res);</span><br><span class="line">        &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(e);</span><br><span class="line">        &#125;).<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            promiseCache.<span class="title function_">delete</span>(apiName);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    promiseCache.<span class="title function_">set</span>(apiName, promise);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>将该方法改为工厂方法，即通过该函数可以将任意 api方法 改造为 可以缓存api的方法</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> storageCache = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;cache&#x27;</span>) || <span class="string">&#x27;&#123;&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> dataCache = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(storageCache);</span><br><span class="line"><span class="keyword">let</span> promiseCache = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">MAX_CACHE_TIME</span> = <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">7</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cacheApi</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> apiName = fn.<span class="property">name</span>;</span><br><span class="line">    <span class="comment">// 返回新的缓存化的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">params</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> data = dataCache[apiName];</span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title class_">Date</span>.<span class="title function_">now</span>() - data.<span class="property">__timestamp</span> &lt; <span class="variable constant_">MAX_CACHE_TIME</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(data.<span class="property">res</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> dataCache[apiName];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> promise = promiseCache.<span class="title function_">get</span>(apiName);</span><br><span class="line">        <span class="keyword">if</span> (promise) &#123;</span><br><span class="line">            <span class="keyword">return</span> promise;</span><br><span class="line">        &#125;</span><br><span class="line">        promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">fn</span>(params).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                data = &#123;</span><br><span class="line">                    res,</span><br><span class="line">                    <span class="attr">__timestamp</span>: <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">                &#125;;</span><br><span class="line">                dataCache[apiName] = data;</span><br><span class="line">                <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;cache&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(dataCache));</span><br><span class="line">                <span class="title function_">resolve</span>(res);</span><br><span class="line">            &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">reject</span>(e);</span><br><span class="line">            &#125;).<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                promiseCache.<span class="title function_">delete</span>(apiName);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        promiseCache.<span class="title function_">set</span>(apiName, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> getData = <span class="title function_">cacheApi</span>(getDataAPI);</span><br><span class="line"><span class="title function_">getData</span>().<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123; <span class="comment">/* 业务逻辑 */</span> &#125;);</span><br></pre></td></tr></table></figure><ol start="5"><li>将该方法改造为类实例方法，避免对全局变量的干扰，同时对同一类的 api 可以修改相同的最大缓存时间。如果所有的api都希望设置相同的最大缓存时间，可以将 memorize 方法改为静态方法。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ApiCache</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将初始化的部分放到 constructor 里</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">time</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">MAX_CACHE_TIME</span> = <span class="title class_">Number</span>(time) || <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">7</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">promiseCache</span> = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">dataCache</span> = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;cache&#x27;</span>)) || &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以主动设置最大缓存时间</span></span><br><span class="line">    <span class="title function_">setMaxCacheTime</span>(<span class="params">time</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">MAX_CACHE_TIME</span> = time;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以清除缓存</span></span><br><span class="line">    <span class="title function_">clearCache</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">dataCache</span> = &#123;&#125;;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">promiseCache</span>.<span class="title function_">clear</span>();</span><br><span class="line">        <span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&#x27;cache&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">memorize</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> apiName = fn.<span class="property">name</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">params</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> data = <span class="variable language_">this</span>.<span class="property">dataCache</span>[apiName];</span><br><span class="line">            <span class="keyword">if</span> (data) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="title class_">Date</span>.<span class="title function_">now</span>() - data.<span class="property">__timestamp</span> &lt; <span class="variable language_">this</span>.<span class="property">MAX_CACHE_TIME</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(data.<span class="property">res</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">dataCache</span>[apiName];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> promise = <span class="variable language_">this</span>.<span class="property">promiseCache</span>.<span class="title function_">get</span>(apiName);</span><br><span class="line">            <span class="keyword">if</span> (!promise) &#123;</span><br><span class="line">                promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="title function_">fn</span>(params).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                        data = &#123;</span><br><span class="line">                            res,</span><br><span class="line">                            <span class="attr">__timestamp</span>: <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">                        &#125;;</span><br><span class="line">                        <span class="variable language_">this</span>.<span class="property">dataCache</span>[apiName] = data;</span><br><span class="line">                        <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;cache&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="variable language_">this</span>.<span class="property">dataCache</span>));</span><br><span class="line">                        <span class="title function_">resolve</span>(res);</span><br><span class="line">                    &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="title function_">reject</span>(e);</span><br><span class="line">                    &#125;).<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="variable language_">this</span>.<span class="property">promiseCache</span>.<span class="title function_">delete</span>(apiName);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">promiseCache</span>.<span class="title function_">set</span>(apiName, promise);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> promise;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getData = <span class="keyword">new</span> <span class="title class_">ApiCache</span>().<span class="title function_">memorize</span>(getDataAPI);</span><br><span class="line"><span class="title function_">getData</span>().<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>, data) &#125;);</span><br><span class="line"><span class="title function_">getData</span>().<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>, data) &#125;);</span><br></pre></td></tr></table></figure><ol start="6"><li>以上只是根据 api 的名字进行了缓存，实际上，一般会根据 api 名字和参数一起来进行缓存，只有当 api名字和参数 均一致时才从缓存中获取；另外，以上代码在不超过最大缓存时间时就会从缓存获取数据，而实际上，即使从缓存获取数据，我们也希望可以异步的更新下缓存；目前只有最大缓存时间，也可以设置最大缓存日期，过期失效；目前采用 class 实现，实际上大部分情况下对于一个api只会调用 <code>new ApiCache(1000 * 60 * 60 * 24 * 30).memorize(getDataAPI)</code> 这一行代码来使之支持缓存，那么我们可以采用代理（proxy）或者修饰器（decorators）的方法对api请求方法进行拦截，会更加方便；</li></ol><p>// TODO： 未完待续</p>]]></content>
      
      
      
        <tags>
            
            <tag> front-end </tag>
            
            <tag> cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPA &amp; MPA &amp; SSR</title>
      <link href="/blog/2021/05/20/FE-SPA-MPA-SSR/"/>
      <url>/blog/2021/05/20/FE-SPA-MPA-SSR/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-SPA-amp-MPA"><a href="#什么是-SPA-amp-MPA" class="headerlink" title="什么是 SPA &amp; MPA"></a>什么是 SPA &amp; MPA</h2><p>单页web应用（single page web application，SPA），是指只有一个web页面的应用，是加载单个HTML页面并在用户与应用程序交互时动态更新该页面的web应用程序。  </p><p>多页web应用（multi page web application，MPA），是指有多个web页面的应用，每一次页面跳转的时候，后台服务器都会返回一个新的HTML文档，并加载js、css资源。  </p><span id="more"></span><h2 id="SPA-和-MPA-的区别"><a href="#SPA-和-MPA-的区别" class="headerlink" title="SPA 和 MPA 的区别"></a>SPA 和 MPA 的区别</h2><table><thead><tr><th></th><th>多页应用模式（MPA）</th><th>单页应用模式（SPA）</th></tr></thead><tbody><tr><td>应用组成</td><td>由多个完整HTML页面构成</td><td>一个HTML页面，通过ajax请求获取数据更新页面</td></tr><tr><td>跳转方式</td><td>页面之间跳转时从一个HTML页面跳转到另一个HTML页面</td><td>通过javascript控制页面的渲染，达到页面切换的目的</td></tr><tr><td>跳转后公共资源是否重新加载</td><td>是</td><td>否</td></tr><tr><td>URL模式</td><td><p>http://xxx/page1.html</p> <p>http://xxx/page2.html</p></td><td><p>http://xxx/shell.html#page1</p> <p>http://xxx/shell.html#page2 （hash）</p></td></tr><tr><td>用户体验</td><td>首页加载速度快，页面间切换加载慢</td><td>页面切换速度快，首页加载速度慢</td></tr><tr><td>SEO（Search engine optimize）</td><td>利于seo</td><td>由于搜索引擎爬虫一般只爬取静态页面，所以SPA一般不利于seo</td></tr></tbody></table><p>总结：SPA页面切换更加流畅，页面切换速度快，但首页因需要加载过多的资源，首页速度较慢，且不利于SEO。在有强SEO需求的情况下，比如文档类型的应用、官网首页采用MPA更合适，开发较大型web应用时采用SPA更合适。  </p><h2 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h2><p>服务器端渲染（Server Side Render）是指在服务器端将模板与数据绑定，并将页面返回给客户端的技术。服务器端渲染的优势就是利于 SEO，首屏加载速度快。  </p><h2 id="同构渲染"><a href="#同构渲染" class="headerlink" title="同构渲染"></a>同构渲染</h2><p>部分 SSR 框架采用了同构渲染的策略。例如 Next.js，同一套代码既可以在服务器端渲染，也可以在客户端渲染。当我们首次访问时（访问首屏页面），Next.js 使用服务器端渲染，为我们返回已经渲染完成的最终 HTML 页面。这样就同时解决了首屏白屏问题以及 SEO 问题。此后当我们再进行交互时，则使用客户端渲染。HTML、CSS、JS 等资源都不需要再重新请求，只需要通过 ajax/websocket 等途径获取数据，在客户端完成渲染过程。  </p>]]></content>
      
      
      
        <tags>
            
            <tag> SPA </tag>
            
            <tag> SSR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPC</title>
      <link href="/blog/2021/05/20/CS-RPC/"/>
      <url>/blog/2021/05/20/CS-RPC/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-RPC"><a href="#什么是-RPC" class="headerlink" title="什么是 RPC"></a>什么是 RPC</h2><p>RPC（Remote Procedure Call）— 远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的 webservice 架构。比如两个不同的服务 A、B 部署在两台不同的机器上，那么服务 A 如果想要调用服务 B 中的某个方法该怎么办呢？使用 HTTP 请求当然可以，但是可能会比较慢而且一些优化做的并不好。 RPC 的出现就是为了解决这个问题。  </p><p>最终解决的问题：让分布式或者微服务系统中不同服务之间可以像本地服务一样调用。  </p><span id="more"></span><h2 id="RPC-原理"><a href="#RPC-原理" class="headerlink" title="RPC 原理"></a>RPC 原理</h2><p><img src="/blog/static/imgs/rpc.jpg" alt="rpc_inner"></p><ol><li>client 以本地调用方式调用服务；</li><li>client stub 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</li><li>client stub 找到服务地址，并将消息发送到服务端；</li><li>server stub 收到消息后进行解码；</li><li>server stub 根据解码结果调用本地的服务；</li><li>server 执行并将结果返回给 server stub；</li><li>server stub 将返回结果打包成消息并发送至 client；</li><li>client stub 接收到消息，并进行解码；</li><li>client 得到最终结果</li></ol><h2 id="常用-RPC-框架"><a href="#常用-RPC-框架" class="headerlink" title="常用 RPC 框架"></a>常用 RPC 框架</h2><ul><li>Dubbo: Dubbo 是阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring 框架无缝集成。目前 Dubbo 已经成为 Spring Cloud Alibaba 中的官方组件。</li><li>gRPC ：gRPC 是可以在任何环境中运行的现代开源高性能 RPC 框架。它可以通过可插拔的支持来有效地连接数据中心内和跨数据中心的服务，以实现负载平衡、跟踪、运行状况检查和身份验证。它也适用于分布式计算的最后一英里，以将设备、移动应用程序和浏览器连接到后端服务。</li><li>Hessian： Hessian是一个轻量级的 remoting-on-http 工具，使用简单的方法提供了 RMI 的功能。 相比 WebService，Hessian 更简单、快捷。采用的是二进制 RPC 协议，因为采用的是二进制协议，所以它很适合于发送二进制数据。</li></ul><h2 id="为什么用-RPC，不直接使用-HTTP"><a href="#为什么用-RPC，不直接使用-HTTP" class="headerlink" title="为什么用 RPC，不直接使用 HTTP"></a>为什么用 RPC，不直接使用 HTTP</h2><p>RPC 是 web service 的一种架构，HTTP 是指 HTTP 协议，事实上 RPC 也可以采用 HTTP 协议进行通信，例如 gRPC 就采用了 HTTP2。一般拿 RPC 和 HTTP 比较是将采用TCP（或UDP）协议的 RPC 和直接使用 HTTP 通信进行比较。  </p><ul><li><em>传输效率</em> RPC通常使用TCP协议，通过自定义上层协议可以让请求报文体积更小；基于 HTTP 1.1 的协议，请求可能会包含很多对业务无用的内容（毕竟HTTP是面向web应用的）</li><li><em>性能消耗</em> RPC在参数序列化上可以基于序列化框架进行，效率比较高；HTTP协议，参数大部分是通过 json 来实现的，字节更多，序列化耗时更多</li><li><em>跨平台</em> HTTP 协议可以运行在多种异构系统上，可移植性较好；RPC通常要求客户端和服务器为统一平台</li></ul><p>基于以上特点考虑，使用基于 TCP 的 RPC 主要用于业务内部的服务调用，性能消耗低，传输效率高。  </p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RPC </tag>
            
            <tag> HTTP </tag>
            
            <tag> webservice </tag>
            
            <tag> SOA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web Worker小抄</title>
      <link href="/blog/2021/05/17/FE-webworker%E5%B0%8F%E6%8A%84/"/>
      <url>/blog/2021/05/17/FE-webworker%E5%B0%8F%E6%8A%84/</url>
      
        <content type="html"><![CDATA[<h2 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h2><p>Web Worker 为 Web 内容在后台线程中运行脚本提供了一种简单的方法，线程可以执行任务而不干扰用户界面。  </p><p>它有以下特点：  </p><ul><li><em>异步多线程</em> 在主线程运行的同时，Worker 线程在后台运行，两者互不干扰</li><li><em>同源限制</em> 分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源，Worker 也仅能被生成它的脚本所使用</li><li><em>DOM 限制</em> Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用 <code>document</code>、<code>window</code>、<code>parent</code> 这些对象。但是，Worker 线程可以访问 <code>navigator</code> 和 <code>location</code> 对象，可以使用大量 window 对象之下的东西，包括 WebSockets ， IndexedDB </li><li><em>message通信机制</em> Worker 线程和主线程间的数据传递通过这样的消息机制进行——双方都使用 <code>postMessage()</code> 方法发送各自的消息，使用 <code>onmessage</code> 事件处理函数来响应消息</li><li><em>支持web IO</em> Worker 线程可以使用 XMLHttpRequest 进行网络I/O</li></ul><span id="more"></span><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h3><p>主线程采用 new 命令，调用 Worker() 构造函数，新建一个 Worker 线程</p><figure class="highlight js"><figcaption><span>main.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;work.js&#x27;</span>);</span><br></pre></td></tr></table></figure><p>Worker() 构造函数的参数是一个脚本文件，该文件就是 Worker 线程所要执行的任务。由于 Worker 不能读取本地文件，所以这个脚本必须来自网络。<br>然后，主线程调用 worker.postMessage() 方法，向 Worker 发消息。  </p><figure class="highlight js"><figcaption><span>main.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">worker.<span class="title function_">postMessage</span>(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">worker.<span class="title function_">postMessage</span>(&#123;<span class="attr">method</span>: <span class="string">&#x27;echo&#x27;</span>, <span class="attr">args</span>: [<span class="string">&#x27;Work&#x27;</span>]&#125;);</span><br></pre></td></tr></table></figure><p>worker.postMessage() 方法的参数，就是主线程传给 Worker 的数据。它可以是各种数据类型，包括二进制数据。<br>接着，主线程通过 worker.onmessage 指定监听函数，接收子线程发回来的消息。  </p><figure class="highlight js"><figcaption><span>main.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">worker.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Received message &#x27;</span> + event.<span class="property">data</span>);</span><br><span class="line">  <span class="title function_">doSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 执行任务</span></span><br><span class="line">  worker.<span class="title function_">postMessage</span>(<span class="string">&#x27;Work done!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，事件对象的data属性可以获取 Worker 发来的数据。<br>Worker 完成任务以后，主线程就可以把它关掉。  </p><figure class="highlight js"><figcaption><span>main.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker.<span class="title function_">terminate</span>();</span><br></pre></td></tr></table></figure><h3 id="worker线程"><a href="#worker线程" class="headerlink" title="worker线程"></a>worker线程</h3><p>Worker 线程内部需要有一个监听函数，监听message事件，监听函数的参数是一个事件对象，它的 data 属性包含主线程发来的数据。postMessage() 方法用来向主线程发送消息。  </p><figure class="highlight js"><figcaption><span>worker.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">onmessage</span>(<span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">postMessage</span>(<span class="string">&#x27;You said: &#x27;</span> + e.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Worker 内部可以通过 <code>importScripts()</code> 来加载其他脚本，脚本的下载顺序不固定，但执行时会按照传入 <code>importScripts()</code> 中的文件名顺序进行。这个过程是同步完成的；直到所有脚本都下载并运行完毕，<code>importScripts()</code> 才会返回。  </p><figure class="highlight js"><figcaption><span>worker.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">importScripts(<span class="string">&#x27;script1.js&#x27;</span>, <span class="string">&#x27;script2.js&#x27;</span>);</span><br></pre></td></tr></table></figure><p>Worker 线程内部可以调用 <code>close()</code> 结束自身  </p><figure class="highlight js"><figcaption><span>worker.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">close</span>();</span><br></pre></td></tr></table></figure><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>主线程可以监听 Worker 是否发生错误。如果发生错误，Worker 会触发主线程的 error 事件。  </p><figure class="highlight js"><figcaption><span>main.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">worker.<span class="title function_">onerror</span>(<span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ERROR: Line &#x27;</span>, e.<span class="property">lineno</span>, <span class="string">&#x27; in &#x27;</span>, e.<span class="property">filename</span>, <span class="string">&#x27;: &#x27;</span>, e.<span class="property">message</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="数据通信"><a href="#数据通信" class="headerlink" title="数据通信"></a>数据通信</h2><p>在主页面与 worker 之间传递的数据是通过拷贝，而不是共享来完成的。传递给 worker 的对象需要经过序列化，接下来在另一端还需要反序列化。页面与 worker 不会共享同一个实例，最终的结果就是在每次通信结束时生成了数据的一个副本。大部分浏览器使用结构化拷贝来实现该特性。  </p><p>主线程与 Worker 之间也可以交换二进制数据，比如 File、Blob、ArrayBuffer 等类型，也可以在线程之间发送。下面是一个例子。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主线程</span></span><br><span class="line"><span class="keyword">var</span> uInt8Array = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">10</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; uInt8Array.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">  uInt8Array[i] = i * <span class="number">2</span>; <span class="comment">// [0, 2, 4, 6, 8,...]</span></span><br><span class="line">&#125;</span><br><span class="line">worker.<span class="title function_">postMessage</span>(uInt8Array);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Worker 线程</span></span><br><span class="line">self.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> uInt8Array = e.<span class="property">data</span>;</span><br><span class="line">  <span class="title function_">postMessage</span>(<span class="string">&#x27;Inside worker.js: uInt8Array.toString() = &#x27;</span> + uInt8Array.<span class="title function_">toString</span>());</span><br><span class="line">  <span class="title function_">postMessage</span>(<span class="string">&#x27;Inside worker.js: uInt8Array.byteLength = &#x27;</span> + uInt8Array.<span class="property">byteLength</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是，拷贝方式发送二进制数据，会造成性能问题。比如，主线程向 Worker 发送一个 500MB 文件，默认情况下浏览器会生成一个原文件的拷贝。为了解决这个问题，JavaScript 允许主线程把二进制数据直接转移给子线程，但是一旦转移，主线程就无法再使用这些二进制数据了，这是为了防止出现多个线程同时修改数据的麻烦局面。这种转移数据的方法，叫做 <a href="http://www.w3.org/html/wg/drafts/html/master/infrastructure.html#transferable-objects">Transferable Objects</a>。这使得主线程可以快速把数据交给 Worker，对于影像处理、声音处理、3D 运算等就非常方便了，不会产生性能负担。  </p><p>如果要直接转移数据的控制权，就要使用下面的写法。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Transferable Objects 格式</span></span><br><span class="line">worker.<span class="title function_">postMessage</span>(arrayBuffer, [arrayBuffer]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">var</span> ab = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">1</span>);</span><br><span class="line">worker.<span class="title function_">postMessage</span>(ab, [ab]);</span><br></pre></td></tr></table></figure><h2 id="同页面的-Web-Worker"><a href="#同页面的-Web-Worker" class="headerlink" title="同页面的 Web Worker"></a>同页面的 Web Worker</h2><p>通常情况下，Worker 载入的是一个单独的 JavaScript 脚本文件，但是也可以载入与主线程在同一个网页的代码。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">&quot;worker&quot;</span> <span class="attr">type</span>=<span class="string">&quot;app/worker&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">postMessage</span>(<span class="string">&#x27;some message&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">      &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面是一段嵌入网页的脚本，注意必须指定 <code>&lt;script&gt;</code> 标签的type属性是一个浏览器不认识的值，上例是 app/worker。<br>然后，读取这一段嵌入页面的脚本，用 Worker 来处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> <span class="title class_">Blob</span>([<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#worker&#x27;</span>).<span class="property">textContent</span>]);</span><br><span class="line"><span class="keyword">var</span> url = <span class="variable language_">window</span>.<span class="property">URL</span>.<span class="title function_">createObjectURL</span>(blob);</span><br><span class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(url);</span><br><span class="line"></span><br><span class="line">worker.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="comment">// e.data === &#x27;some message&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，先将嵌入网页的脚本代码，转成一个二进制对象，然后为这个二进制对象生成 URL，再让 Worker 加载这个 URL。这样就做到了，主线程和 Worker 的代码都在同一个网页上面。</p><h2 id="实例：Worker-线程完成轮询"><a href="#实例：Worker-线程完成轮询" class="headerlink" title="实例：Worker 线程完成轮询"></a>实例：Worker 线程完成轮询</h2><p>有时，浏览器需要轮询服务器状态，以便第一时间得知状态改变。这个工作可以放在 Worker 里面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createWorker</span>(<span class="params">f</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> blob = <span class="keyword">new</span> <span class="title class_">Blob</span>([<span class="string">&#x27;(&#x27;</span> + f.<span class="title function_">toString</span>() +<span class="string">&#x27;)()&#x27;</span>]);</span><br><span class="line">  <span class="keyword">var</span> url = <span class="variable language_">window</span>.<span class="property">URL</span>.<span class="title function_">createObjectURL</span>(blob);</span><br><span class="line">  <span class="keyword">var</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(url);</span><br><span class="line">  <span class="keyword">return</span> worker;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pollingWorker = <span class="title function_">createWorker</span>(<span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> cache;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">compare</span>(<span class="params"><span class="keyword">new</span>, old</span>) &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;/my-api-endpoint&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">res</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> data = res.<span class="title function_">json</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_">compare</span>(data, cache)) &#123;</span><br><span class="line">        cache = data;</span><br><span class="line">        self.<span class="title function_">postMessage</span>(data);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pollingWorker.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// render data</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pollingWorker.<span class="title function_">postMessage</span>(<span class="string">&#x27;init&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，Worker 每秒钟轮询一次数据，然后跟缓存做比较。如果不一致，就说明服务端有了新的变化，因此就要通知主线程。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Web API </tag>
            
            <tag> webworker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JWT-JSON WEB TOKEN</title>
      <link href="/blog/2021/05/17/FE-JWT-JSON-WEB-TOKEN/"/>
      <url>/blog/2021/05/17/FE-JWT-JSON-WEB-TOKEN/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是JWT"><a href="#什么是JWT" class="headerlink" title="什么是JWT"></a>什么是JWT</h2><p>Json web token (JWT)， 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（<a href="https://tools.ietf.org/html/rfc7519">RFC 7519</a>)。该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该 token 也可直接被用于认证，也可被加密。</p><span id="more"></span><h2 id="基于token的鉴权机制"><a href="#基于token的鉴权机制" class="headerlink" title="基于token的鉴权机制"></a>基于token的鉴权机制</h2><p>基于 token 的鉴权机制类似于 http 协议是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于 token 认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。</p><p>流程上是这样的：</p><ol><li>用户使用用户名密码来请求服务器</li><li>服务器进行验证用户的信息</li><li>服务器通过验证发送给用户一个token</li><li>客户端存储token，并在每次请求时附送上这个token值</li><li>服务端验证token值，并返回数据</li><li>这个token必须要在每次请求时传递给服务端，它应该保存在请求头里， </li></ol><h2 id="JWT长什么样"><a href="#JWT长什么样" class="headerlink" title="JWT长什么样"></a>JWT长什么样</h2><p>JWT是由三段信息构成的，将这三段信息文本用.链接一起就构成了JWT字符串。就像这样:</p><p><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</code></p><p>第一部分我们称它为头部（header),第二部分我们称其为载荷（payload, 类似于飞机上承载的物品)，第三部分是签证（signature)。  </p><h3 id="header"><a href="#header" class="headerlink" title="header"></a>header</h3><p>JWT的头部承载两部分信息：</p><ul><li>声明类型，这里是JWT</li><li>声明加密的算法 通常直接使用 HMAC SHA256</li></ul><p>完整的头部就像下面这样的JSON：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  &#x27;typ&#x27;<span class="punctuation">:</span> &#x27;JWT&#x27;<span class="punctuation">,</span></span><br><span class="line">  &#x27;alg&#x27;<span class="punctuation">:</span> &#x27;HS256&#x27;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>然后将头部进行base64加密（该加密是可以对称解密的)，构成了第一部分。  </p><p><code>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</code></p><h3 id="playload"><a href="#playload" class="headerlink" title="playload"></a>playload</h3><p>载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分</p><ol><li>标准中注册的声明</li><li>公共的声明</li><li>私有的声明</li></ol><p>标准中注册的声明 (建议但不强制使用) ：</p><p>iss: JWT签发者<br>sub: JWT所面向的用户<br>aud: 接收JWT的一方<br>exp: JWT的过期时间，这个过期时间必须要大于签发时间<br>nbf: 定义在什么时间之前，该JWT都是不可用的<br>iat: JWT的签发时间<br>jti: JWT的唯一身份标识，主要用来作为一次性token，从而回避重放攻击。</p><p>公共的声明 ：</p><p>公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息。但不建议添加敏感信息，因为该部分在客户端可解密。</p><p>私有的声明 ：</p><p>私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为 base64 是对称解密的，意味着该部分信息可以归类为明文信息。</p><p>定义一个payload:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John Doe&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;admin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>然后将其进行base64加密，得到JWT的第二部分。</p><p><code>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</code></p><h3 id="signature"><a href="#signature" class="headerlink" title="signature"></a>signature</h3><p>JWT的第三部分是一个签证信息，这个签证信息由三部分组成：</p><ul><li>header (base64后的)</li><li>payload (base64后的)</li><li>secret</li></ul><p>这个部分需要 base64 加密后的 header 和 base64 加密后的 payload 使用 <code>.</code> 连接组成的字符串，然后通过 header 中声明的加密方式进行加盐 secret 组合加密，然后就构成了JWT的第三部分。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> encodedString = <span class="title function_">base64UrlEncode</span>(header) + <span class="string">&#x27;.&#x27;</span> + <span class="title function_">base64UrlEncode</span>(payload);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> signature = <span class="title class_">HMACSHA256</span>(encodedString, <span class="string">&#x27;secret&#x27;</span>); <span class="comment">// TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span></span><br></pre></td></tr></table></figure><p>将这三部分用 <code>.</code> 连接成一个完整的字符串，构成了最终的JWT:</p><p><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</code></p><p>注意：secret 是保存在服务器端的，JWT 的签发生成也是在服务器端的，secret 就是用来进行 JWT 的签发和 JWT 的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发 JWT 了。</p><h2 id="如何应用"><a href="#如何应用" class="headerlink" title="如何应用"></a>如何应用</h2><p>一般是在请求头里加入 Authorization ，并加上 Bearer 标注：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;api/user/1&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;Authorization&#x27;</span>: <span class="string">&#x27;Bearer &#x27;</span> + token</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>服务端会验证token，如果验证通过就会返回相应的资源。整个流程就是这样的:  </p><p><img src="/blog/static/imgs/jwt.webp" alt="jwt_inner"></p><h2 id="JWT的优点"><a href="#JWT的优点" class="headerlink" title="JWT的优点"></a>JWT的优点</h2><ul><li>因为json的通用性，所以JWT是可以进行跨语言支持的，JAVA，JavaScript，NodeJS，PHP等很多语言都可以使用。</li><li>因为有了payload部分，所以JWT可以在自身存储一些其他业务逻辑所必要的非敏感信息。</li><li>便于传输，jwt的构成非常简单，字节占用很小，所以它是非常便于传输的。</li><li>它不需要在服务端保存会话信息，所以它易于应用的扩展</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>performance.timing各个参数含义</title>
      <link href="/blog/2021/05/14/FE-performance-timing%E5%90%84%E4%B8%AA%E5%8F%82%E6%95%B0%E5%90%AB%E4%B9%89/"/>
      <url>/blog/2021/05/14/FE-performance-timing%E5%90%84%E4%B8%AA%E5%8F%82%E6%95%B0%E5%90%AB%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h2 id="performance-timing"><a href="#performance-timing" class="headerlink" title="performance.timing"></a>performance.timing</h2><p>window.performance.timing 是W3C规范提供的接口，可以通过它获取到用户访问一个页面的每个阶段的精确时间(timestamp), 从而对性能进行分析  </p><p><img src="/blog/static/imgs/timing.png" alt="timer_inner"></p><span id="more"></span><table><thead><tr><th>timing</th><th>含义</th></tr></thead><tbody><tr><td>navigationStart</td><td>同一个浏览器上一个文档卸载(unload)结束时的时间戳。如果没有上一个文档，这个值会和 fetchStart 相同</td></tr><tr><td>redirectStart</td><td>第一个HTTP重定向开始时的时间戳。如果没有重定向，或者上次重定向不是同源的，这个值会返回0</td></tr><tr><td>unloadEventStart</td><td>上一个文档 unload 事件抛出时的时间戳。如果没有上一个网页，或者之前的网页跳转不是属于同一个域内，则返回值为0</td></tr><tr><td>unloadEventEnd</td><td>上一个网页 unload 事件结束时的时间戳。如果没有前一个网页，或者之前的网页跳转不是属于同一个域内，则返回值为0</td></tr><tr><td>redirectEnd</td><td>最后一个HTTP重定向完成时的时间戳。如果没有重定向，或者上次重定向不是同源的，这个值会返回0</td></tr><tr><td>fetchStart</td><td>浏览器准备好使用HTTP请求来获取(fetch)文档的时间戳。这个时间点会在检查任何应用缓存之前</td></tr><tr><td>domainLookupStart</td><td>DNS 域名查询开始的时间戳。如果使用持久连接（persistent connection），或者这个信息存储到了缓存或者本地资源上，这个值将和 fetchStart 一致</td></tr><tr><td>domainLookupEnd</td><td>DNS 域名查询完成的时间戳。如果使用持久连接（persistent connection），或者这个信息存储到了缓存或者本地资源上，这个值将和 fetchStart 一致</td></tr><tr><td>connectStart</td><td>HTTP请求开始向服务器发送时的时间戳。如果使用持久连接（persistent connection），则返回值等同于 fetchStart 属性的值</td></tr><tr><td>connectEnd</td><td>浏览器与服务器之间的连接建立时的时间戳。如果建立的是持久连接，则返回值等同于 fetchStart 属性的值</td></tr><tr><td>secureConnectionStart</td><td>浏览器与服务器开始安全链接的握手时的时间戳。如果当前网页不要求安全连接，则返回0</td></tr><tr><td>requestStart</td><td>浏览器向服务器发出HTTP请求时（或开始读取本地缓存时）的时间戳</td></tr><tr><td>responseStart</td><td>浏览器从服务器收到（或从本地缓存读取）第一个字节时的时间戳。如果传输层在开始请求之后失败并且连接被重开，该属性将会被设置成新的请求相对应的发起时间</td></tr><tr><td>responseEnd</td><td>浏览器从服务器收到（或从本地缓存读取，或从本地资源读取）最后一个字节时（如果在此之前HTTP连接已经关闭，则返回关闭时）的时间戳</td></tr><tr><td>domLoading</td><td>当前网页DOM结构开始解析时（即Document.readyState属性变为 ‘loading’ 、相应的 readystatechange 事件触发时）的时间戳</td></tr><tr><td>domInteractive</td><td>当前网页DOM结构结束解析、开始加载内嵌资源时（即Document.readyState属性变为 ‘interactive’ 、相应的readystatechange 事件触发时）的时间戳</td></tr><tr><td>domContentLoadedEventStart</td><td>当解析器发送 DOMContentLoaded 事件，即所有需要被执行的脚本已经被解析时的时间戳</td></tr><tr><td>domContentLoadedEventEnd</td><td>当所有需要立即执行的脚本已经被执行（不论执行顺序）时的时间戳</td></tr><tr><td>domComplete</td><td>当前文档解析完成，即 Document.readyState 变为 ‘complete’且相对应的 readystatechange 被触发时的时间戳</td></tr><tr><td>loadEventStart</td><td>该文档下，load 事件被发送时的时间戳。如果这个事件还未被发送，它的值将会是0</td></tr><tr><td>loadEventEnd</td><td>当 load 事件结束，即加载事件完成时的时间戳。如果这个事件还未被发送，或者尚未完成，它的值将会是0</td></tr></tbody></table><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><p>DNS解析耗时: domainLookupEnd - domainLookupStart<br>TCP连接耗时: connectEnd - connectStart<br>SSL安全连接耗时: connectEnd - secureConnectionStart<br>网络请求耗时(TTFB): responseStart - requestStart<br>数据传输耗时: responseEnd - responseStart<br>DOM解析耗时: domInteractive - responseEnd<br>资源加载耗时: loadEventStart - domContentLoadedEventEnd<br>首包时间: responseStart - domainLookupStart<br>首次渲染时间 / 白屏时间: responseEnd - fetchStart<br>首次可交互时间: domInteractive - fetchStart<br>DOM Ready时间: domContentLoadEventEnd - fetchStart<br>页面完全加载时间: loadEventStart - fetchStart</p><h2 id="性能统计"><a href="#性能统计" class="headerlink" title="性能统计"></a>性能统计</h2><p>利用 performance.timing 可以获取到每个阶段的耗时数据，但是不同的人在不同的环境、不同的时间访问同一页面时，统计到的时间是不同的，单次的数据并不能反映页面全局的表现，要想知道该页面的整体性能，需要对统计到的所有数据做一个处理，使得我们对页面的每次变更有一个直观的认识，为用户页面性能调优提供依据。  </p><ol><li>平均值统计法</li></ol><p>收集到一段时间区间中所有用户访问应用的性能数据，将这些数据做均值处理，最终给到这个时间区间的平均耗时数据。<br>这种统计方法简单粗暴，其中长尾数据（可能占比较少但性能十分差的数据）很大程度上会影响均值的大小，导致给出的均值无法很好的表现性能情况；同时性能数据分布情况不清楚，无法制定优化方案。  </p><ol start="2"><li>百分位数统计法</li></ol><p>将数据从小到大排列，处于第n%个数据称为n分位数, 表示n%的性能数据均小于等于该值，那剩下的(1-n%)的数据均大于该值。<br>线上通常 n 取 80 或者 90，代表了 80%/90% （大部分）的用户的性能数据好于我们的基准值的一个情况。与平均值统计方法不同，百分位数统计法会给到几个主要的百分位数的性能数据值，但对于整体的样本情况没有直观的认识。  </p><ol start="3"><li>样本分布统计法</li></ol><p>将性能样本数据进行分桶统计，为了防止桶的个数太多，并且不给实时统计带来很大压力，可以使用不均匀的桶进行统计。对于性能数据，大家会非常关注10s内的样本分布情况，对于10s之后的数据桶可以粗放设置。<br>通过样本分布统计法，可以给用户提供非常直观的样本性能分布情况。通过分布直方图可以很直观的知道页面在指定时间区间内的样本占比。  </p><h2 id="performance-mark-amp-performance-measure"><a href="#performance-mark-amp-performance-measure" class="headerlink" title="performance.mark &amp; performance.measure"></a>performance.mark &amp; performance.measure</h2><ul><li>mark() 方法在浏览器的性能入口缓冲区（performance entry buffer）中使用给定名称添加一个时间戳  </li><li>clearMarks() 这个方法可以从浏览器的性能入口缓冲区 (performance entry buffer) 中移除声明的标记。如果调用这个方法时没有传递参数， 则所有带有 entry type 这类标记的 performance entries 将从 performance entry 缓存区中被移除  </li><li>measure() 方法在浏览器性能入口缓冲区中创建了一个已命名的时间戳来记录两个特殊标志位（通常称为开始标志和结束标志）。 被命名的时间戳称为测量（measure）</li><li>clearMeasures() 方法可以从浏览器的性能入口缓冲区中移除声明的measure。如果这个方法被调用时没有传入参数，则所有 entry type 标记值为 measure 的性能实体将被从性能入口缓冲区中移除</li><li>getEntries() 对于给定的 filter ，此方法返回 PerformanceEntry 对象数组</li></ul><p>可以结合 mark &amp; measure 方法获取程序运行过程中的差值，进而进行性能监控与分析。  </p><h2 id="废弃的属性"><a href="#废弃的属性" class="headerlink" title="废弃的属性"></a>废弃的属性</h2><p>performance.timing 属性在 <a href="https://w3c.github.io/navigation-timing/#obsolete">Navigation Timing Level 2 specification</a> 中已经被废弃，推荐使用 PerformanceNavigationTiming 来获取浏览器相关的时间节点  </p>]]></content>
      
      
      
        <tags>
            
            <tag> performance </tag>
            
            <tag> Web API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 继承</title>
      <link href="/blog/2021/04/26/JS-%E7%BB%A7%E6%89%BF/"/>
      <url>/blog/2021/04/26/JS-%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="prototype-proto-constructor-的关系"><a href="#prototype-proto-constructor-的关系" class="headerlink" title="prototype __proto__ constructor 的关系"></a><code>prototype</code> <code>__proto__</code> <code>constructor</code> 的关系</h2><p><img src="/blog/static/imgs/proto.png" alt="proto_inner"></p><span id="more"></span><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数就是提供了一个生成对象的模板并描述对象的基本结构的函数。一个构造函数，可以生成多个对象，每个对象都有相同的属性和方法。总的来说，构造函数就是对象的模板(类)，对象就是构造函数的实例。同一个构造函数的生成的对象实例之间无法直接共享属性或方法。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;keith&#x27;</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> boy = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(boy.<span class="property">name</span>); <span class="comment">// &#x27;keith&#x27;</span></span><br></pre></td></tr></table></figure><p>构造函数的特点有：</p><p>  a：构造函数的函数名首字母必须大写。<br>  b：内部使用 <code>this</code> 对象，来指向将要生成的对象实例。<br>  c：使用 new 操作符来调用构造函数，并返回对象实例。</p><h3 id="prototype-属性"><a href="#prototype-属性" class="headerlink" title="prototype 属性"></a><code>prototype</code> 属性</h3><p>属性 <code>prototype</code> 是函数特有的属性，这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。通过 <code>prototype</code> 定义的属性及方法能被所有对象实例所共享，这就是 <code>prototype</code> 的意义。  </p><p><em>对于构造函数来说， <code>prototype</code> 是作为构造函数的属性；对于对象实例来说， <code>prototype</code> 是对象实例的原型对象。</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, height</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">height</span> = height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hobby</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 生成的对象实例会共享这样声明的构造函数方法</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;watching movies&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> boy = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;keith&#x27;</span>, <span class="number">180</span>);</span><br><span class="line"><span class="keyword">var</span> girl = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;rascal&#x27;</span>, <span class="number">153</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(boy.<span class="property">name</span>); <span class="comment">//&#x27;keith&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(girl.<span class="property">name</span>); <span class="comment">//&#x27;rascal&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(boy.<span class="property">hobby</span> === girl.<span class="property">hobby</span>); <span class="comment">//true 表明生成的对象实例共享着同一个方法</span></span><br></pre></td></tr></table></figure><p><code>prototype</code> 属性的特点有：</p><p>  a：原型属性 <code>prototype</code> 的作用，就是定义所有对象实例所共享的属性和方法。<br>  b：<code>prototype</code> 对于构造函数来说，它是一个属性；对于对象实例来说，它是一个原型对象。</p><h3 id="constructor-属性"><a href="#constructor-属性" class="headerlink" title="constructor 属性"></a><code>constructor</code> 属性</h3><p>属性 constructor 返回对象实例的构造函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> boy = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(boy.<span class="property">constructor</span>); <span class="comment">// Person</span></span><br></pre></td></tr></table></figure><p><code>constructor</code> 属性实际上是原型对象的属性，这个属性包含了一个指针，指回原构造函数，它被所有实例对象继承。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> boy = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Person</span>); <span class="comment">// true 通过原型对象访问 constructor 属性返回的是原型对象所处的构造函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(boy.<span class="property">constructor</span> === boy.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a><code>instanceof</code> 运算符</h3><p><code>instanceof</code> 用于判断对象是否为某个构造函数的实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> boy = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(boy <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(boy <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">//true 对整个原型链上的对象都有效</span></span><br></pre></td></tr></table></figure><h3 id="proto-属性"><a href="#proto-属性" class="headerlink" title="__proto__ 属性"></a><code>__proto__</code> 属性</h3><p>属性 <code>__proto__</code> 返回对象实例的原型对象，对象内部的 <code>[[Prototype]]</code>，也即对象实例的构造函数的 prototype 属性值。使用 <code>__proto__</code> 是有争议的，也不鼓励使用它，因为它从来没有被包括在 EcmaScript 语言规范中，但是现代浏览器都实现了它。<br>ES6 中可以使用 <code>Object.getPrototypeOf()</code> 获取。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> boy = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;jack&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(boy.<span class="property">__proto__</span>  === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);    <span class="comment">//true  同样的， Person 也有原型对象，通过 Person 的 __proto__ 属性也可以访问到它的原型对象，以此类推，可以实现原型链的向上追溯。</span></span><br></pre></td></tr></table></figure><p>相对于通过 <code>__proto__</code> 属性继承其他对象的属性而言，<code>Object.create()</code> 方法是一个更加值得推荐的方法。该方法接收一个对象作为参数，返回一个以该对象为原型对象的新对象，即继承了作为参数的对象的属性及方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> boy = <span class="title class_">Object</span>.<span class="title function_">create</span>(person);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(boy.<span class="property">age</span>);     <span class="comment">//10</span></span><br></pre></td></tr></table></figure><h2 id="实现-子类-继承-父类"><a href="#实现-子类-继承-父类" class="headerlink" title="实现 子类 继承 父类"></a>实现 子类 继承 父类</h2><p>类继承的核心是让 子类 拥有 父类 的方法和属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">parentAge</span> = <span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span>; <span class="comment">// 注意重置constructor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">parentAge</span>); <span class="comment">// 50</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">parentAge</span> = <span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">parentAge</span>); <span class="comment">// 50</span></span><br></pre></td></tr></table></figure><h2 id="实现-new"><a href="#实现-new" class="headerlink" title="实现 new"></a>实现 new</h2><p>new 其实就是生成了一个对象，初始化时执行类的构造函数，这个对象能够访问类的原型（属性和方法）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myNew</span>(<span class="params">func, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;; <span class="comment">// 新建一个空对象</span></span><br><span class="line">  <span class="keyword">let</span> res = func.<span class="title function_">call</span>(obj, ...args); <span class="comment">// 执行构造函数</span></span><br><span class="line">  obj.<span class="property">__proto__</span> = func.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// 设置原型链</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res <span class="keyword">instanceof</span> <span class="title class_">Object</span> ? res : obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myNew1</span>(<span class="params">func, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(func.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// 以构造器的 prototype 属性为原型，创建新对象；</span></span><br><span class="line">  <span class="keyword">let</span> res = func.<span class="title function_">call</span>(obj, ...args); <span class="comment">// 将 this 和调用参数传给构造器执行</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> res  === <span class="string">&#x27;object&#x27;</span> ? res : obj; <span class="comment">// 如果构造器没有手动返回对象，则返回第一步的对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Puppy</span>(<span class="params">age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">puppyAge</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Puppy</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">say</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;汪汪汪&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myPuppy3 = <span class="title function_">myNew</span>(<span class="title class_">Puppy</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myPuppy3.<span class="property">puppyAge</span>); <span class="comment">// 2</span></span><br><span class="line">myPuppy3.<span class="title function_">say</span>(); <span class="comment">// 汪汪汪</span></span><br></pre></td></tr></table></figure><h2 id="实现-instanceof"><a href="#实现-instanceof" class="headerlink" title="实现 instanceof"></a>实现 instanceof</h2><p><code>instanceof</code> 作用是检查一个对象是不是某个类的实例，换句话说就是检查一个对象的的原型链上有没有这个类的 <code>prototype</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceof</span>(<span class="params">targetObj, targetClass</span>) &#123;</span><br><span class="line">  <span class="comment">// 参数检查</span></span><br><span class="line">  <span class="keyword">if</span>(!targetObj || !targetClass || !targetObj.<span class="property">__proto__</span> || !targetClass.<span class="property"><span class="keyword">prototype</span></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> current = targetObj;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(current) &#123; <span class="comment">// 一直往原型链上面找</span></span><br><span class="line">    <span class="keyword">if</span>(current.<span class="property">__proto__</span> === targetClass.<span class="property"><span class="keyword">prototype</span></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 找到了返回true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    current = current.<span class="property">__proto__</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 没找到返回false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用我们前面的继承实验下</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> = <span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myInstanceof</span>(obj, <span class="title class_">Child</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myInstanceof</span>(obj, <span class="title class_">Parent</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myInstanceof</span>(&#123;&#125;, <span class="title class_">Parent</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue最佳实践</title>
      <link href="/blog/2021/04/24/Vue-Vue%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/blog/2021/04/24/Vue-Vue%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-vue-周边"><a href="#使用-vue-周边" class="headerlink" title="使用 vue 周边"></a>使用 vue 周边</h2><p><a href="https://github.com/vuejs/vue-devtools">vue-devtools</a></p><p>浏览器插件，让你能够实时编辑数据 property 并立即看到其反映出来的变化。另一个主要的好处是能够为 Vuex 提供时间旅行式的调试体验。  </p><p><a href="https://github.com/vue-perf-devtool/vue-perf-devtool">vue-performance-devtool</a></p><p>一个用于检查vue组件性能的浏览器插件。  </p><p><a href="https://github.com/vuejs/vue-cli/">vue-cli</a></p><p>vue-cli 是 vue 开发的标准工具，提供了交互式的项目脚手架，集成了 webpack 和丰富的官方插件集合。</p><p><a href="https://github.com/vuejs/vue-router">vue-router</a></p><p>vue 官方路由管理器，支持嵌套的路由/视图表以及模块化的、基于组件的路由配置。  </p><p><a href="https://github.com/vuejs/vuex">vuex</a></p><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。  </p><p><a href="https://github.com/axios/axios">axios</a></p><p>Axios是一款 promise 化的HTTP客户端，支持在浏览器和 Nodejs 环境中使用。  </p><p><a href="https://github.com/ElemeFE/element">element-ui</a></p><p>elementUI 是一款基于 Vue 2.0 桌面端中后台组件库。  </p><p><a href="https://github.com/iview/iview">iview</a></p><p>iview 是一套基于 Vue 的高质量 UI 组件库，主要服务于 PC 界面的中后台产品。  </p><p><a href="https://github.com/vueComponent/ant-design-vue">Ant Design Vue</a></p><p>Ant Design Vue 是 Ant Design 的 Vue 实现，开发和服务于企业级后台产品。  </p><span id="more"></span><h2 id="数据初始化"><a href="#数据初始化" class="headerlink" title="数据初始化"></a>数据初始化</h2><p>明确定义的数据模型更加适合 Vue 的数据观察模式。建议在定义组件时，在 data 选项中初始化所有需要进行动态观察的属性。  </p><h2 id="验证-props-属性"><a href="#验证-props-属性" class="headerlink" title="验证 props 属性"></a>验证 props 属性</h2><p>在声明 props 属性时明确 props 的类型(type)，是否必须(required)和默认值(default) 或通过 validator 方法进行验证，如果有一个需求没有被满足，则 Vue 会在开发环境中的浏览器控制台中警告你。</p><h2 id="组件间通信-amp-应用状态管理"><a href="#组件间通信-amp-应用状态管理" class="headerlink" title="组件间通信 &amp; 应用状态管理"></a>组件间通信 &amp; 应用状态管理</h2><p>在跨父子组件进行通信时，可以使用 <a href="/blog/2018/10/12/Vue-组件间通信/#Event-Bus-中央事件总栈-emit-on">Event Bus 模式</a> 或者使用 <a href="https://vuex.vuejs.org/zh/">Vuex</a></p><h2 id="代码分割-Code-Splitting"><a href="#代码分割-Code-Splitting" class="headerlink" title="代码分割 - Code Splitting"></a>代码分割 - Code Splitting</h2><ul><li>分离业务代码和第三方库</li><li>避免将所有组件都注册为全局组件，按需加载</li></ul><h2 id="使用-mixin-扩展组件功能"><a href="#使用-mixin-扩展组件功能" class="headerlink" title="使用 mixin 扩展组件功能"></a>使用 mixin 扩展组件功能</h2><p>混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。混入可以大大提升代码的可复用性。</p><h2 id="使用上-vue-自带的修饰符"><a href="#使用上-vue-自带的修饰符" class="headerlink" title="使用上 vue 自带的修饰符"></a>使用上 vue 自带的修饰符</h2><p>在 v-on 绑定的事件处理程序中使用事件/按键/系统修饰符可以减少代码量。</p><h2 id="在-beforeDestroy-生命周期销毁定时器"><a href="#在-beforeDestroy-生命周期销毁定时器" class="headerlink" title="在 beforeDestroy 生命周期销毁定时器"></a>在 beforeDestroy 生命周期销毁定时器</h2><p>在 beforeDestroy 生命周期销毁定时器以减少对性能的消耗。</p><h2 id="为组件样式设置作用域-scope"><a href="#为组件样式设置作用域-scope" class="headerlink" title="为组件样式设置作用域 scope"></a>为组件样式设置作用域 scope</h2><ul><li>使用 reset.css 统一浏览器样式</li><li>在设置组件样式时使用 css scoped 以减少对同名样式之间互相影响。</li></ul><h2 id="始终为列表渲染提供唯一的key值"><a href="#始终为列表渲染提供唯一的key值" class="headerlink" title="始终为列表渲染提供唯一的key值"></a>始终为列表渲染提供唯一的key值</h2><p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key attribute。建议尽可能在使用 v-for 时提供 key attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。</p><h2 id="使用-keepAlive-组件以获得更好的性能"><a href="#使用-keepAlive-组件以获得更好的性能" class="headerlink" title="使用 keepAlive 组件以获得更好的性能"></a>使用 keepAlive 组件以获得更好的性能</h2><p>在动态组件上使用 keep-alive，当这些组件之间互相切换的时候，keep-alive 会想保持这些组件的状态，以避免反复重渲染导致的性能问题。</p><h2 id="避免直接修改-DOM"><a href="#避免直接修改-DOM" class="headerlink" title="避免直接修改 DOM"></a>避免直接修改 DOM</h2><p>Vue 采用了 mvvm 的模型设计，支持数据与模板之间的数据监听与模板渲染，直接操作 DOM 打破了框架的设计模式，除非有十分明确的需求，否则最好通过驱动数据变动来影响视图变化。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue生命周期</title>
      <link href="/blog/2021/04/24/Vue-Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/blog/2021/04/24/Vue-Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="生命周期图示"><a href="#生命周期图示" class="headerlink" title="生命周期图示"></a>生命周期图示</h2><p><img src="/blog/static/imgs/vue-lifecycle.png" alt="vue生命周期_inner"></p><span id="more"></span><h2 id="生命周期钩子函数"><a href="#生命周期钩子函数" class="headerlink" title="生命周期钩子函数"></a>生命周期钩子函数</h2><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>beforeCreate（创建前）</td><td>组件实例更被创建，组件属性计算之前，数据对象 data 都为 undefined，未初始化。</td></tr><tr><td>created（创建后）</td><td>组件实例创建完成，属性已经绑定，数据对象 data 已存在，但 dom 未生成，$el 未存在</td></tr><tr><td>beforeMount（挂载前）</td><td>vue 实例的$el 和 data 都已初始化，挂载之前为虚拟的 dom 节点，data.message 未替换</td></tr><tr><td>mounted（挂载后）</td><td>vue 实例挂载完成，data.message 成功渲染。</td></tr><tr><td>beforeUpdate（更新前）</td><td>当 data 变化时，会触发 beforeUpdate 方法</td></tr><tr><td>updated（更新后）</td><td>当 data 变化时，会触发 updated 方法</td></tr><tr><td>beforeDestroy（销毁前）</td><td>组件销毁之前调用</td></tr><tr><td>destroyed（销毁后）</td><td>组件销毁之后调用，对 data 的改变不会再触发周期函数，vue 实例已解除事件监听和 dom 绑定，但 dom 结构依然存在</td></tr></tbody></table><h3 id="beforeCreate-创建前"><a href="#beforeCreate-创建前" class="headerlink" title="beforeCreate 创建前"></a>beforeCreate 创建前</h3><p>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。  </p><h3 id="created-创建后"><a href="#created-创建后" class="headerlink" title="created 创建后"></a>created 创建后</h3><p>在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，property 和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，<code>$el</code> property 目前尚不可用。  </p><h3 id="beforeMount-挂载前"><a href="#beforeMount-挂载前" class="headerlink" title="beforeMount 挂载前"></a>beforeMount 挂载前</h3><p>在挂载开始之前被调用：相关的 render 函数首次被调用。  </p><h3 id="mounted-挂载后"><a href="#mounted-挂载后" class="headerlink" title="mounted 挂载后"></a>mounted 挂载后</h3><p>实例被挂载后调用，这时 el 被新创建的 vm.$el 替换了。如果根实例挂载到了一个文档内的元素上，当 mounted 被调用时 vm.$el 也在文档内。  </p><p>注意 mounted 不会保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 mounted 内部使用 <code>vm.$nextTick</code> 。  </p><h3 id="beforeUpdate-更新前"><a href="#beforeUpdate-更新前" class="headerlink" title="beforeUpdate 更新前"></a>beforeUpdate 更新前</h3><p>数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。  </p><h3 id="updated-更新后"><a href="#updated-更新后" class="headerlink" title="updated 更新后"></a>updated 更新后</h3><p>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。  </p><p>当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之。  </p><p>注意 updated 不会保证所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以在 updated 里使用 <code>vm.$nextTick</code>  </p><h3 id="beforeDestroy-销毁前"><a href="#beforeDestroy-销毁前" class="headerlink" title="beforeDestroy 销毁前"></a>beforeDestroy 销毁前</h3><p>实例销毁之前调用。在这一步，实例仍然完全可用。  </p><h3 id="destroyed-销毁后"><a href="#destroyed-销毁后" class="headerlink" title="destroyed 销毁后"></a>destroyed 销毁后</h3><p>实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。  </p><h3 id="activated"><a href="#activated" class="headerlink" title="activated"></a>activated</h3><p>被 keep-alive 缓存的组件激活时调用。  </p><h3 id="deactivated"><a href="#deactivated" class="headerlink" title="deactivated"></a>deactivated</h3><p>被 keep-alive 缓存的组件停用时调用。</p><h3 id="errorCaptured"><a href="#errorCaptured" class="headerlink" title="errorCaptured"></a>errorCaptured</h3><p>2.5.0+ 新增</p><p>当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。  </p><h2 id="生命周期解释"><a href="#生命周期解释" class="headerlink" title="生命周期解释"></a>生命周期解释</h2><h3 id="new-Vue-options-后"><a href="#new-Vue-options-后" class="headerlink" title="new Vue(options) 后"></a>new Vue(options) 后</h3><ol><li>将用户提供的 options 与默认 options 合并，初始化 LifeCycle、Events、Render</li><li>触发 beforeCreate 钩子</li><li>初始化 Injections、State(包括初始化 props、methods、data（初始化 data 时 调用 Observer.observe 方法添加 Dep 依赖）、computed、watch)、Provide</li><li>触发 created 钩子</li><li>触发 beforeMount 钩子</li><li>对 vm 创建 Watcher 执行 updateComponent 方法，updateComponent方法调用 vm._render 方法生成 VNode，调用 vm._update 把 VNode 渲染成真实的 DOM</li><li>触发 mounted 钩子</li></ol><h3 id="数据-data-变化后"><a href="#数据-data-变化后" class="headerlink" title="数据 data 变化后"></a>数据 data 变化后</h3><ol><li>初始化 data 时创建的 Observer 通过 Dep 触发了 watcher.update() 方法，watcher.update() 调用 scheduler.queueWatcher() 调用 scheduler.flushSchedulerQueue()，尝试调用 watcher.run()</li><li>触发 beforeUpdate 钩子（之前已经注册了 Watcher.before）</li><li>watcher 执行 watcher.run 方法，执行 watcher.get 方法，执行 watcher.getter 方法 即 updateComponent 方法，updateComponent 方法调用 vm._render 方法生成 VNode，调用 vm._update 把 VNode 渲染成真实的 DOM</li><li>再回到 scheduler.flushSchedulerQueue 方法，在所有的 watcher 执行完毕后，触发 updated 钩子</li></ol><h3 id="组件销毁时"><a href="#组件销毁时" class="headerlink" title="组件销毁时"></a>组件销毁时</h3><p>patch.removeVnodes -&gt; patch.invokeDestroyHook -&gt; destroy -&gt; vm.$destroy -&gt; </p><ol><li>调用 beforeDestroy 钩子</li><li>将自身从父组件中移除，移除 watchers</li><li>调用 destoryed 钩子</li><li>关闭所有实例监听器</li></ol><h2 id="Vue2-与Vue3的生命周期对比"><a href="#Vue2-与Vue3的生命周期对比" class="headerlink" title="Vue2 与Vue3的生命周期对比"></a>Vue2 与Vue3的生命周期对比</h2><table><thead><tr><th>Vue2</th><th>Vue3</th></tr></thead><tbody><tr><td>beforeCreate(组件创建之前)</td><td>setup(组件创建之前)</td></tr><tr><td>created(组件创建完成)</td><td>setup(组件创建完成)</td></tr><tr><td>beforeMount(组件挂载之前)</td><td>onBeforeMount(组件挂载之前)</td></tr><tr><td>mounted(组件挂载完成)</td><td>onMounted(组件挂载完成)</td></tr><tr><td>beforeUpdate(数据更新，虚拟DOM打补丁之前)</td><td>onBeforeUpdate(数据更新，虚拟DOM打补丁之前)</td></tr><tr><td>updated(数据更新，虚拟DOM渲染完成)</td><td>onUpdated(数据更新，虚拟DOM渲染完成)</td></tr><tr><td>beforeDestroy(组件销毁之前)</td><td>onBeforeUnmount(组件销毁之前)</td></tr><tr><td>destroyed(组件销毁之后)</td><td>onUnmounted(组件销毁之后)</td></tr></tbody></table><h2 id="Vue-子组件和父组件执行顺序"><a href="#Vue-子组件和父组件执行顺序" class="headerlink" title="Vue 子组件和父组件执行顺序"></a>Vue 子组件和父组件执行顺序</h2><p>加载渲染过程：</p><ol><li>父组件 beforeCreate</li><li>父组件 created</li><li>父组件 beforeMount</li><li>子组件 beforeCreate</li><li>子组件 created</li><li>子组件 beforeMount</li><li>子组件 mounted</li><li>父组件 mounted</li></ol><p>更新过程：</p><ol><li>父组件 beforeUpdate</li><li>子组件 beforeUpdate</li><li>子组件 updated</li><li>父组件 updated</li></ol><p>销毁过程：</p><ol><li>父组件 beforeDestroy</li><li>子组件 beforeDestroy</li><li>子组件 destroyed</li><li>父组件 destoryed</li></ol><h2 id="异步请求放在哪个生命周期中"><a href="#异步请求放在哪个生命周期中" class="headerlink" title="异步请求放在哪个生命周期中"></a>异步请求放在哪个生命周期中</h2><p>我们可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。</p><p>推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p><ul><li>能更快获取到服务端数据，减少页面加载时间，用户体验更好；</li><li>SSR不支持 beforeMount 、mounted 钩子函数，放在 created 中有助于保持一致性。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/blog/2021/04/24/CS-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/blog/2021/04/24/CS-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>目前我们常说的设计模式，来源于 Erich Gamma、 Richard Helm、 Ralph Johnson 和 John Vlissides(Gang of Four) 编著的《设计模式：可复用面向对象软件的基础》，该书提出了23种软件设计模式(Design Pattern)，作为面向对象软件设计的最佳实践，广为人知。  </p><p>23种设计模式如下：  </p><p>创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”  </p><p>– 单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式。</p><p>结构型模式：用于描述如何将类或对象按某种布局组成更大的结构  </p><p>– 适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。</p><p>行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责  </p><p>– 模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式。</p><span id="more"></span><h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><p>在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据一些原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。  </p><table><thead><tr><th>原则</th><th>定义</th><th>提出者</th><th>目的</th></tr></thead><tbody><tr><td>开闭原则</td><td>软件实体应当对扩展开放，对修改关闭(Software entities should be open for extension，but closed for modification)</td><td>勃兰特·梅耶（Bertrand Meyer）</td><td>降低维护带来的新风险</td></tr><tr><td>里氏替换原则</td><td>继承必须确保超类所拥有的性质在子类中仍然成立(Inheritance should ensure that any property proved about supertype objects also holds for subtype objects)</td><td>里斯科夫（Liskov）</td><td>防止继承泛滥</td></tr><tr><td>依赖倒置原则</td><td>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象（High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions）</td><td>罗伯特·马丁（Robert C.Martin）</td><td>更利于代码结构的升级扩展</td></tr><tr><td>单一职责原则</td><td>单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分（There should never be more than one reason for a class to change）</td><td>罗伯特·C.马丁（Robert C. Martin）</td><td>便于理解，提高代码的可读性</td></tr><tr><td>接口隔离原则</td><td>一个类对另一个类的依赖应该建立在最小的接口上（The dependency of one class to another one should depend on the smallest possible interface）</td><td>罗伯特·C.马丁（Robert C. Martin）</td><td>功能解耦，高聚合、低耦合</td></tr><tr><td>迪米特法则（最少知道原则）</td><td>只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）</td><td>伊恩·荷兰（Ian Holland）</td><td>减少代码臃肿</td></tr></tbody></table><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</p><p>单例模式有 3 个特点：</p><ul><li>单例类只有一个实例对象；</li><li>该单例对象必须由单例类自行创建；</li><li>单例类对外提供一个访问该单例的全局访问点。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Singleton</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Singleton</span>.<span class="property">getInstance</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">instance</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">instance</span> = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">instance</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// let singleton = Singleton.getInstance();</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Singleton</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Singleton</span>.<span class="property">getInstance</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> instance = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// let singleton = Singleton.getInstance();</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Singleton</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> instance = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">            instance = <span class="variable language_">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// let singleton = new Singleton();</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>Singleton.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Singleton</span>.<span class="property">instance</span>) &#123;</span><br><span class="line">      <span class="title class_">Singleton</span>.<span class="property">instance</span> = <span class="variable language_">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Singleton</span>.<span class="property">instance</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance1 = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"><span class="keyword">const</span> instance2 = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance1 === instance2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Prototype</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> instance = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Prototype</span>);</span><br><span class="line"><span class="comment">// Object.getPrototypeOf(instance);</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Prototype</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> instance = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(instance, <span class="title class_">Prototype</span>);</span><br><span class="line"><span class="comment">// Object.getPrototypeOf(instance);</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Prototype</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Instance</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Instance</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Prototype</span>;</span><br><span class="line"><span class="title class_">Instance</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Instance</span>;</span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="title class_">Instance</span>();</span><br><span class="line"><span class="comment">// Object.getPrototypeOf(instance);</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>Prototype.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个原型对象</span></span><br><span class="line"><span class="keyword">const</span> prototype = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;default name&#x27;</span>,</span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新对象，使用原型作为模板</span></span><br><span class="line"><span class="keyword">const</span> obj1 = <span class="title class_">Object</span>.<span class="title function_">create</span>(prototype);</span><br><span class="line">obj1.<span class="property">name</span> = <span class="string">&#x27;John&#x27;</span>;</span><br><span class="line">obj1.<span class="title function_">sayHello</span>(); <span class="comment">// 输出 &quot;Hello, my name is John&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建另一个新对象，使用同样的原型</span></span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="title class_">Object</span>.<span class="title function_">create</span>(prototype);</span><br><span class="line">obj2.<span class="title function_">sayHello</span>(); <span class="comment">// 输出 &quot;Hello, my name is default name&quot;</span></span><br></pre></td></tr></table></figure><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Instance1</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Instance2</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Instance1Factory</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">create</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Instance1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Instance2Factory</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">create</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Instance2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">InstanceFactory</span>(<span class="params">type</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">create</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> factory = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                factory = <span class="keyword">new</span> <span class="title class_">Instance1Factory</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                factory = <span class="keyword">new</span> <span class="title class_">Instance2Factory</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        factory.<span class="title function_">create</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// let instance1Factory = new InstanceFactory(1);</span></span><br><span class="line"><span class="comment">// let instance1 = instance1Factory.create();</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>Factory.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">model, year, color</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">model</span> = model;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">year</span> = year;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarFactory</span> &#123;</span><br><span class="line">  <span class="title function_">createCar</span>(<span class="params">model, year, color</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Car</span>(model, year, color);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> carFactory = <span class="keyword">new</span> <span class="title class_">CarFactory</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myCar = carFactory.<span class="title function_">createCar</span>(<span class="string">&#x27;Tesla&#x27;</span>, <span class="number">2021</span>, <span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myCar); <span class="comment">// Car &#123; model: &#x27;Tesla&#x27;, year: 2021, color: &#x27;red&#x27; &#125;</span></span><br></pre></td></tr></table></figure><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>抽象工厂（Abstract Factory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Instance1</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Instance2</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Instance1Factory</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">create</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Instance1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Instance2Factory</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">create</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Instance2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">InstanceFactory</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">create</span> = <span class="keyword">function</span>(<span class="params">type</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Instance1Factory</span>().<span class="title function_">create</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Instance2Factory</span>().<span class="title function_">create</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// let factory = new InstanceFactory();</span></span><br><span class="line"><span class="comment">// let instance1 = factory.create(1);</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>AbstractFactory.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象工厂模式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">  <span class="title function_">createProductA</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">createProductB</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory1</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AbstractFactory</span> &#123;</span><br><span class="line">  <span class="title function_">createProductA</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductA1</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">createProductB</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductB1</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory2</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AbstractFactory</span> &#123;</span><br><span class="line">  <span class="title function_">createProductA</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductA2</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">createProductB</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductB2</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractProductA</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.<span class="property">target</span> === <span class="title class_">AbstractProductA</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;抽象类不能实例化&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">methodA</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品A1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductA1</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AbstractProductA</span> &#123;</span><br><span class="line">  <span class="title function_">methodA</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ProductA1 的方法被调用！&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品A2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductA2</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AbstractProductA</span> &#123;</span><br><span class="line">  <span class="title function_">methodA</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ProductA2 的方法被调用！&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractProductB</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.<span class="property">target</span> === <span class="title class_">AbstractProductB</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;抽象类不能实例化&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">methodB</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品B1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductB1</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AbstractProductB</span> &#123;</span><br><span class="line">  <span class="title function_">methodB</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ProductB1 的方法被调用！&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品B2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductB2</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AbstractProductB</span> &#123;</span><br><span class="line">  <span class="title function_">methodB</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ProductB2 的方法被调用！&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">factory</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> productA = factory.<span class="title function_">createProductA</span>();</span><br><span class="line">    <span class="keyword">const</span> productB = factory.<span class="title function_">createProductB</span>();</span><br><span class="line">    productA.<span class="title function_">methodA</span>();</span><br><span class="line">    productB.<span class="title function_">methodB</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> client1 = <span class="keyword">new</span> <span class="title class_">Client</span>(<span class="keyword">new</span> <span class="title class_">ConcreteFactory1</span>());</span><br><span class="line"><span class="keyword">const</span> client2 = <span class="keyword">new</span> <span class="title class_">Client</span>(<span class="keyword">new</span> <span class="title class_">ConcreteFactory2</span>());</span><br></pre></td></tr></table></figure><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</p><figure class="highlight js"><figcaption><span>Builder.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Burger</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">builder</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> = builder.<span class="property">size</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cheese</span> = builder.<span class="property">cheese</span> || <span class="literal">false</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">pepperoni</span> = builder.<span class="property">pepperoni</span> || <span class="literal">false</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lettuce</span> = builder.<span class="property">lettuce</span> || <span class="literal">false</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tomato</span> = builder.<span class="property">tomato</span> || <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BurgerBuilder</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">size</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> = size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">addPepperoni</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">pepperoni</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">addLettuce</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lettuce</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">addCheese</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cheese</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">addTomato</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tomato</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">build</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Burger</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> burger = <span class="keyword">new</span> <span class="title class_">BurgerBuilder</span>(<span class="number">14</span>)</span><br><span class="line">  .<span class="title function_">addPepperoni</span>()</span><br><span class="line">  .<span class="title function_">addLettuce</span>()</span><br><span class="line">  .<span class="title function_">addTomato</span>()</span><br><span class="line">  .<span class="title function_">build</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(burger); <span class="comment">// Burger &#123; size: 14, cheese: false, pepperoni: true, lettuce: true, tomato: true &#125;</span></span><br></pre></td></tr></table></figure><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Instance</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">method</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">InstanceProxy</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// proxy could do some extra things</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">instance</span> = <span class="keyword">new</span> <span class="title class_">Instance</span>();</span><br><span class="line">    <span class="comment">// proxy could do some extra things</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">method</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// proxy could do some extra things</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">instance</span>.<span class="title function_">method</span>();</span><br><span class="line">        <span class="comment">// proxy could do some extra things</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// let proxy = new InstanceProxy();</span></span><br><span class="line"><span class="comment">// let result = proxy.method();</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>Proxy.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RealSubject</span> &#123;</span><br><span class="line">  <span class="title function_">request</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;RealSubject: Handling request.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxySubject</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">realSubject</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">realSubject</span> = realSubject;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">request</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">checkAccess</span>()) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">realSubject</span>.<span class="title function_">request</span>();</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">logAccess</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">checkAccess</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ProxySubject: Checking access prior to firing a real request.&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">logAccess</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ProxySubject: Logging the time of request.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">clientCode</span>(<span class="params">subject</span>) &#123;</span><br><span class="line">  subject.<span class="title function_">request</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Client: Executing the client code with a real subject:&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> realSubject = <span class="keyword">new</span> <span class="title class_">RealSubject</span>();</span><br><span class="line"><span class="title function_">clientCode</span>(realSubject);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Client: Executing the same client code with a proxy:&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">ProxySubject</span>(realSubject);</span><br><span class="line"><span class="title function_">clientCode</span>(proxy);</span><br></pre></td></tr></table></figure><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Instance1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">method1</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Instance2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">method2</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">InstanceAdapter</span>(<span class="params">type</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">instance</span> = <span class="keyword">new</span> <span class="title function_">type</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">adapterMethod</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        (<span class="variable language_">this</span>.<span class="property">instance</span>.<span class="property">method1</span> ? <span class="variable language_">this</span>.<span class="property">instance</span>.<span class="property">method1</span> : <span class="variable language_">this</span>.<span class="property">instance</span>.<span class="property">method2</span>)(...<span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// let adapter1 = new InstanceAdapter(Instance1);</span></span><br><span class="line"><span class="comment">// let adapter2 = new InstanceAdapter(Instance2);</span></span><br><span class="line"><span class="comment">// let result1 = adapter1.adaperMethod();</span></span><br><span class="line"><span class="comment">// let result2 = adapter2.adaperMethod();</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>Adapter.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个旧的接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OldInterface</span> &#123;</span><br><span class="line">  <span class="title function_">request</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Old interface is called&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个新的接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewInterface</span> &#123;</span><br><span class="line">  <span class="title function_">specificRequest</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;New interface is called&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个适配器，将旧的接口转换为新的接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adapter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">oldInterface</span> = <span class="keyword">new</span> <span class="title class_">OldInterface</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">request</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">oldInterface</span>.<span class="title function_">request</span>().<span class="title function_">replace</span>(<span class="string">&quot;Old&quot;</span>, <span class="string">&quot;New&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用适配器调用新的接口</span></span><br><span class="line"><span class="keyword">const</span> adapter = <span class="keyword">new</span> <span class="title class_">Adapter</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(adapter.<span class="title function_">request</span>()); <span class="comment">// 输出 &quot;New interface is called&quot;</span></span><br></pre></td></tr></table></figure><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p><figure class="highlight js"><figcaption><span>Bridge.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.<span class="property">target</span> === <span class="title class_">Color</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Color 不能被初始化。&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setColor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;setColor 必须被实现。&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedColor</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Color</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setColor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;红色&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlueColor</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Color</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setColor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;蓝色&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">color</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.<span class="property">target</span> === <span class="title class_">Shape</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Shape 不能被初始化。&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setColor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">color</span>.<span class="title function_">setColor</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;draw 必须被实现。&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体抽象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Shape</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">color</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(color);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`用 <span class="subst">$&#123;<span class="variable language_">this</span>.setColor()&#125;</span> 颜色画一个圆。`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Shape</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">color</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(color);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`用 <span class="subst">$&#123;<span class="variable language_">this</span>.setColor()&#125;</span> 颜色画一个正方形。`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> redCircle = <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="keyword">new</span> <span class="title class_">RedColor</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(redCircle.<span class="title function_">draw</span>()); <span class="comment">// 输出：用 红色 颜色画一个圆。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> blueSquare = <span class="keyword">new</span> <span class="title class_">Square</span>(<span class="keyword">new</span> <span class="title class_">BlueColor</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(blueSquare.<span class="title function_">draw</span>()); <span class="comment">// 输出：用 蓝色 颜色画一个正方形。</span></span><br></pre></td></tr></table></figure><h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p>装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Instance</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Instance</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">method</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;method1&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Decorator</span>(<span class="params">instance</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">instance</span> = instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Decorator</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">method</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">instance</span>.<span class="title function_">method</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;method2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> <span class="title class_">Instance</span>();</span><br><span class="line"><span class="keyword">var</span> instanceDecorated = <span class="keyword">new</span> <span class="title class_">Decorator</span>(instance);</span><br><span class="line"></span><br><span class="line"><span class="comment">// instance.method();</span></span><br><span class="line"><span class="comment">// instanceDecorated.method();</span></span><br></pre></td></tr></table></figure><figure class="highlight ts"><figcaption><span>使用 @decorator 语法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">TypedPropertyDescriptor</span>&lt;T&gt; &#123;</span><br><span class="line">    enumerable?: <span class="built_in">boolean</span>;</span><br><span class="line">    configurable?: <span class="built_in">boolean</span>;</span><br><span class="line">    writable?: <span class="built_in">boolean</span>;</span><br><span class="line">    value?: T;</span><br><span class="line">    get?: <span class="function">() =&gt;</span> T;</span><br><span class="line">    set?: <span class="function">(<span class="params">value: T</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">decorator</span>(<span class="params">target: <span class="built_in">Object</span>, key: <span class="built_in">string</span> | <span class="built_in">symbol</span>, descriptor: TypedPropertyDescriptor&lt;T&gt;</span>) : <span class="title class_">TypedPropertyDescriptor</span>&lt;T&gt; | <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> fn = descriptor.<span class="property">value</span>;</span><br><span class="line">    descriptor.<span class="property">value</span> = <span class="keyword">function</span>(<span class="params">...args: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;method2&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Instance</span> &#123;</span><br><span class="line">    <span class="meta">@decorator</span></span><br><span class="line">    <span class="title function_">method</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;method1&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// var instance = new Instance();</span></span><br><span class="line"><span class="comment">// instance.method();</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>Decorator.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个基础组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">  <span class="title function_">cost</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个装饰器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Milk</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">coffee</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">coffee</span> = coffee;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">cost</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">coffee</span>.<span class="title function_">cost</span>() + <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义另一个装饰器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sugar</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">coffee</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">coffee</span> = coffee;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">cost</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">coffee</span>.<span class="title function_">cost</span>() + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用装饰器</span></span><br><span class="line"><span class="keyword">let</span> coffee = <span class="keyword">new</span> <span class="title class_">Coffee</span>();</span><br><span class="line">coffee = <span class="keyword">new</span> <span class="title class_">Milk</span>(coffee);</span><br><span class="line">coffee = <span class="keyword">new</span> <span class="title class_">Sugar</span>(coffee);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(coffee.<span class="title function_">cost</span>()); <span class="comment">// 输出 13</span></span><br></pre></td></tr></table></figure><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">method1</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">method2</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">method3</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">facadeMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">method1</span>();</span><br><span class="line">    <span class="title function_">method2</span>();</span><br><span class="line">    <span class="title function_">method3</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// facadeMethod();</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>Facade.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外观模式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">openAccount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`在<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>开户`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Credit</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">applyForCredit</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`在<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>申请信用卡`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Facade</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">bank</span> = <span class="keyword">new</span> <span class="title class_">Bank</span>(name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">credit</span> = <span class="keyword">new</span> <span class="title class_">Credit</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">openAccount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">bank</span>.<span class="title function_">openAccount</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">applyForCredit</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">credit</span>.<span class="title function_">applyForCredit</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> facade = <span class="keyword">new</span> <span class="title class_">Facade</span>(<span class="string">&#x27;中国工商银行&#x27;</span>);</span><br><span class="line">facade.<span class="title function_">openAccount</span>();</span><br><span class="line">facade.<span class="title function_">applyForCredit</span>();</span><br></pre></td></tr></table></figure><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。</p><figure class="highlight js"><figcaption><span>Flyweight.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 享元工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyweightFactory</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">flyweights</span> = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getFlyweight</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">flyweights</span>[key]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">flyweights</span>[key];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> flyweight = <span class="keyword">new</span> <span class="title class_">ConcreteFlyweight</span>(key);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">flyweights</span>[key] = flyweight;</span><br><span class="line">      <span class="keyword">return</span> flyweight;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象享元</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Flyweight</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.<span class="property">target</span> === <span class="title class_">Flyweight</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Flyweight is an abstract class&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">operation</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;operation() must be implemented&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体享元</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFlyweight</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Flyweight</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">key</span> = key;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">operation</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`ConcreteFlyweight with key <span class="subst">$&#123;<span class="variable language_">this</span>.key&#125;</span> is being used`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">flyweightFactory</span> = <span class="keyword">new</span> <span class="title class_">FlyweightFactory</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> flyweight1 = <span class="variable language_">this</span>.<span class="property">flyweightFactory</span>.<span class="title function_">getFlyweight</span>(<span class="string">&#x27;key1&#x27;</span>);</span><br><span class="line">    flyweight1.<span class="title function_">operation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> flyweight2 = <span class="variable language_">this</span>.<span class="property">flyweightFactory</span>.<span class="title function_">getFlyweight</span>(<span class="string">&#x27;key2&#x27;</span>);</span><br><span class="line">    flyweight2.<span class="title function_">operation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> flyweight3 = <span class="variable language_">this</span>.<span class="property">flyweightFactory</span>.<span class="title function_">getFlyweight</span>(<span class="string">&#x27;key1&#x27;</span>);</span><br><span class="line">    flyweight3.<span class="title function_">operation</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client = <span class="keyword">new</span> <span class="title class_">Client</span>();</span><br><span class="line">client.<span class="title function_">run</span>();</span><br></pre></td></tr></table></figure><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Composite</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">parent</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">children</span> = [];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Composite</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">add</span>: <span class="keyword">function</span>(<span class="params">child</span>) &#123;</span><br><span class="line">        child.<span class="property">parent</span> = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">children</span>.<span class="title function_">push</span>(child);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">action</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">children</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">children</span>.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">children</span>[i].<span class="title function_">action</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> root = <span class="keyword">new</span> <span class="title class_">Composite</span>(<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> leaf1 = <span class="keyword">new</span> <span class="title class_">Composite</span>(<span class="string">&#x27;leaf1&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> leaf2 = <span class="keyword">new</span> <span class="title class_">Composite</span>(<span class="string">&#x27;leaf2&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> leaf3 = <span class="keyword">new</span> <span class="title class_">Composite</span>(<span class="string">&#x27;leaf3&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> leaf4 = <span class="keyword">new</span> <span class="title class_">Composite</span>(<span class="string">&#x27;leaf4&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> leaf5 = <span class="keyword">new</span> <span class="title class_">Composite</span>(<span class="string">&#x27;leaf5&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> leaf6 = <span class="keyword">new</span> <span class="title class_">Composite</span>(<span class="string">&#x27;leaf6&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> leaf7 = <span class="keyword">new</span> <span class="title class_">Composite</span>(<span class="string">&#x27;leaf7&#x27;</span>);</span><br><span class="line">root.<span class="title function_">add</span>(leaf1).<span class="title function_">add</span>(leaf2).<span class="title function_">add</span>(leaf3).<span class="title function_">add</span>(leaf4);</span><br><span class="line">leaf3.<span class="title function_">add</span>(leaf5).<span class="title function_">add</span>(leaf6).<span class="title function_">add</span>(leaf7);</span><br><span class="line"></span><br><span class="line"><span class="comment">// root.action();</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>Composite.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组合模式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">children</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">add</span>(<span class="params">component</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">children</span>.<span class="title function_">push</span>(component);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">remove</span>(<span class="params">component</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> index = <span class="variable language_">this</span>.<span class="property">children</span>.<span class="title function_">indexOf</span>(component);</span><br><span class="line">    <span class="keyword">if</span> (index !== -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">children</span>.<span class="title function_">splice</span>(index, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">display</span>(<span class="params">depth</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;-&quot;</span>.<span class="title function_">repeat</span>(depth) + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">children</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">      child.<span class="title function_">display</span>(depth + <span class="number">2</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = <span class="keyword">new</span> <span class="title class_">Component</span>(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">root.<span class="title function_">add</span>(<span class="keyword">new</span> <span class="title class_">Component</span>(<span class="string">&quot;leaf A&quot;</span>));</span><br><span class="line">root.<span class="title function_">add</span>(<span class="keyword">new</span> <span class="title class_">Component</span>(<span class="string">&quot;leaf B&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> comp = <span class="keyword">new</span> <span class="title class_">Component</span>(<span class="string">&quot;Composite X&quot;</span>);</span><br><span class="line">comp.<span class="title function_">add</span>(<span class="keyword">new</span> <span class="title class_">Component</span>(<span class="string">&quot;leaf XA&quot;</span>));</span><br><span class="line">comp.<span class="title function_">add</span>(<span class="keyword">new</span> <span class="title class_">Component</span>(<span class="string">&quot;leaf XB&quot;</span>));</span><br><span class="line"></span><br><span class="line">root.<span class="title function_">add</span>(comp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> comp2 = <span class="keyword">new</span> <span class="title class_">Component</span>(<span class="string">&quot;Composite XY&quot;</span>);</span><br><span class="line">comp2.<span class="title function_">add</span>(<span class="keyword">new</span> <span class="title class_">Component</span>(<span class="string">&quot;leaf XYA&quot;</span>));</span><br><span class="line">comp2.<span class="title function_">add</span>(<span class="keyword">new</span> <span class="title class_">Component</span>(<span class="string">&quot;leaf XYB&quot;</span>));</span><br><span class="line"></span><br><span class="line">comp.<span class="title function_">add</span>(comp2);</span><br><span class="line"></span><br><span class="line">root.<span class="title function_">add</span>(<span class="keyword">new</span> <span class="title class_">Component</span>(<span class="string">&quot;leaf C&quot;</span>));</span><br><span class="line"></span><br><span class="line">root.<span class="title function_">display</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h2><p>模板方法（Template Method）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</p><figure class="highlight js"><figcaption><span>TemplateMethod.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">  <span class="title function_">templateMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">primitiveOperation1</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">primitiveOperation2</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteClass</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AbstractClass</span> &#123;</span><br><span class="line">  <span class="title function_">primitiveOperation1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;具体类实现方法1&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">primitiveOperation2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;具体类实现方法2&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> concreteClass = <span class="keyword">new</span> <span class="title class_">ConcreteClass</span>();</span><br><span class="line">concreteClass.<span class="title function_">templateMethod</span>();</span><br></pre></td></tr></table></figure><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strategy1 = <span class="keyword">function</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> val * <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> strategy1 = <span class="keyword">function</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> val * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> strategy1 = <span class="keyword">function</span> (<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> val * <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> executor = <span class="keyword">function</span>(<span class="params">fn, val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fn</span>(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// var params = &#123;&#125;; // strategy parameters</span></span><br><span class="line"><span class="comment">// executor(strategy1, params);</span></span><br><span class="line"><span class="comment">// executor(strategy2, params);</span></span><br><span class="line"><span class="comment">// executor(strategy3, params);</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>Strategy.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">strategy</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">strategy</span> = strategy;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">executeStrategy</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">strategy</span>.<span class="title function_">doOperation</span>(num1, num2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OperationAdd</span> &#123;</span><br><span class="line">  <span class="title function_">doOperation</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OperationSubtract</span> &#123;</span><br><span class="line">  <span class="title function_">doOperation</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 - num2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OperationMultiply</span> &#123;</span><br><span class="line">  <span class="title function_">doOperation</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 * num2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> context = <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">OperationAdd</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`10 + 5 = <span class="subst">$&#123;context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>)&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">context.<span class="property">strategy</span> = <span class="keyword">new</span> <span class="title class_">OperationSubtract</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`10 - 5 = <span class="subst">$&#123;context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>)&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">context.<span class="property">strategy</span> = <span class="keyword">new</span> <span class="title class_">OperationMultiply</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`10 * 5 = <span class="subst">$&#123;context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>)&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Command</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 命令栈</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stack</span> = [];</span><br><span class="line">    <span class="comment">// 栈指针位置</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stackPosition</span> = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Command</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    <span class="attr">execute</span>: <span class="keyword">function</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">_clearRedo</span>();</span><br><span class="line">        <span class="keyword">var</span> command = fn.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行并缓存起来</span></span><br><span class="line">        <span class="title function_">command</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="title function_">push</span>(command);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">stackPosition</span>++;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">canUndo</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">stackPosition</span> &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">canRedo</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">stackPosition</span> &lt; <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 撤销</span></span><br><span class="line">    <span class="attr">undo</span>: <span class="keyword">function</span>(<span class="params">undoFn</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="title function_">canUndo</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">stackPosition</span>--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 命令的撤销，与执行的处理相反</span></span><br><span class="line">        undoFn &amp;&amp; undoFn.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 重做</span></span><br><span class="line">    <span class="attr">redo</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="title function_">canRedo</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行栈顶的命令</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">stack</span>[++<span class="variable language_">this</span>.<span class="property">stackPosition</span>]();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 在执行时，已经撤销的部分不能再重做</span></span><br><span class="line">    <span class="attr">_clearRedo</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">stack</span> = <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="variable language_">this</span>.<span class="property">stackPosition</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// var commandar = new Command();</span></span><br><span class="line"><span class="comment">// commandar.execute(function step1()&#123;console.log(&#x27;command1&#x27;)&#125;);</span></span><br><span class="line"><span class="comment">// commandar.execute(function step2()&#123;console.log(&#x27;command2&#x27;)&#125;);</span></span><br><span class="line"><span class="comment">// commandar.undo(function undoStep2()&#123;console.log(&#x27;command3&#x27;)&#125;);</span></span><br><span class="line"><span class="comment">// commandar.redo();</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>Command.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义命令接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">  <span class="title function_">execute</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义具体命令类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LightOnCommand</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Command</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">light</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">light</span> = light;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">execute</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">light</span>.<span class="title function_">on</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义接收者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Light</span> &#123;</span><br><span class="line">  <span class="title function_">on</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Light is on&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">off</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Light is off&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义调用者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RemoteControl</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">commands</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setCommand</span>(<span class="params">command</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">commands</span>.<span class="title function_">push</span>(command);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">pressButton</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">commands</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">command</span>) =&gt;</span> &#123;</span><br><span class="line">      command.<span class="title function_">execute</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建接收者对象</span></span><br><span class="line"><span class="keyword">const</span> light = <span class="keyword">new</span> <span class="title class_">Light</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建具体命令对象</span></span><br><span class="line"><span class="keyword">const</span> lightOnCommand = <span class="keyword">new</span> <span class="title class_">LightOnCommand</span>(light);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建调用者对象</span></span><br><span class="line"><span class="keyword">const</span> remoteControl = <span class="keyword">new</span> <span class="title class_">RemoteControl</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置命令</span></span><br><span class="line">remoteControl.<span class="title function_">setCommand</span>(lightOnCommand);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行命令</span></span><br><span class="line">remoteControl.<span class="title function_">pressButton</span>(); </span><br></pre></td></tr></table></figure><h2 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h2><p>职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ChainItem</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fn</span> = fn;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ChainItem</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">setNext</span>: <span class="keyword">function</span>(<span class="params">next</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">next</span> = next;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">start</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">fn</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">toNext</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">next</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">start</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>.<span class="property">next</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;There is no more chain.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">action1</span>(<span class="params">input</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/* match action conditions */</span>) &#123;</span><br><span class="line">        <span class="comment">// do action</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">toNext</span>(input);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">action2</span>(<span class="params">input</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/* match action conditions */</span>) &#123;</span><br><span class="line">        <span class="comment">// do action</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">toNext</span>(input);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">action3</span>(<span class="params">input</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/* match action conditions */</span>) &#123;</span><br><span class="line">        <span class="comment">// do action</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">toNext</span>(input);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> chain = <span class="keyword">new</span> <span class="title class_">ChainItem</span>(action1);</span><br><span class="line"><span class="keyword">var</span> action2ChainItem = <span class="keyword">new</span> <span class="title class_">ChainItem</span>(action2);</span><br><span class="line"><span class="keyword">var</span> action3ChainItem = <span class="keyword">new</span> <span class="title class_">ChainItem</span>(action3);</span><br><span class="line">chain.<span class="title function_">setNext</span>(action2ChainItem).<span class="title function_">setNext</span>(action3ChainItem);</span><br><span class="line"></span><br><span class="line"><span class="comment">// chain.start();</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>ResponsibilityChain.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义处理器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">nextHandler</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setNextHandler</span>(<span class="params">handler</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">nextHandler</span> = handler;</span><br><span class="line">    <span class="keyword">return</span> handler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleRequest</span>(<span class="params">request</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">nextHandler</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">nextHandler</span>.<span class="title function_">handleRequest</span>(request);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义具体处理器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteHandler1</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Handler</span> &#123;</span><br><span class="line">  <span class="title function_">handleRequest</span>(<span class="params">request</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (request === <span class="string">&#x27;request1&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;ConcreteHandler1 handled the request&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">handleRequest</span>(request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteHandler2</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Handler</span> &#123;</span><br><span class="line">  <span class="title function_">handleRequest</span>(<span class="params">request</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (request === <span class="string">&#x27;request2&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;ConcreteHandler2 handled the request&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">handleRequest</span>(request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteHandler3</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Handler</span> &#123;</span><br><span class="line">  <span class="title function_">handleRequest</span>(<span class="params">request</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (request === <span class="string">&#x27;request3&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;ConcreteHandler3 handled the request&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">handleRequest</span>(request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">const</span> handler1 = <span class="keyword">new</span> <span class="title class_">ConcreteHandler1</span>();</span><br><span class="line"><span class="keyword">const</span> handler2 = <span class="keyword">new</span> <span class="title class_">ConcreteHandler2</span>();</span><br><span class="line"><span class="keyword">const</span> handler3 = <span class="keyword">new</span> <span class="title class_">ConcreteHandler3</span>();</span><br><span class="line"></span><br><span class="line">handler1.<span class="title function_">setNextHandler</span>(handler2).<span class="title function_">setNextHandler</span>(handler3);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(handler1.<span class="title function_">handleRequest</span>(<span class="string">&#x27;request1&#x27;</span>)); <span class="comment">// ConcreteHandler1 handled the request</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(handler1.<span class="title function_">handleRequest</span>(<span class="string">&#x27;request2&#x27;</span>)); <span class="comment">// ConcreteHandler2 handled the request</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(handler1.<span class="title function_">handleRequest</span>(<span class="string">&#x27;request3&#x27;</span>)); <span class="comment">// ConcreteHandler3 handled the request</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(handler1.<span class="title function_">handleRequest</span>(<span class="string">&#x27;request4&#x27;</span>)); <span class="comment">// null</span></span><br></pre></td></tr></table></figure><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Instance</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>, <span class="string">&#x27;state&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">_state</span> = value;</span><br><span class="line">            <span class="keyword">let</span> statusActionFunc = <span class="variable language_">this</span>[<span class="string">&#x27;_&#x27;</span> + value + <span class="string">&#x27;Action&#x27;</span>];</span><br><span class="line">            statusActionFunc &amp;&amp; statusActionFunc.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_state</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">init</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Instance</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">init</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&#x27;status1&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Instance</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">changeState</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="variable language_">this</span>.<span class="property">state</span> == <span class="string">&#x27;status1&#x27;</span> ? <span class="string">&#x27;status2&#x27;</span> : <span class="string">&#x27;status1&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Instance</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_status1Action</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">_state</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Instance</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_status2Action</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">_state</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// var instance = new Instance();</span></span><br><span class="line"><span class="comment">// instance.changeState();</span></span><br><span class="line"><span class="comment">// instance.changeState();</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>State.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义状态类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">color</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">handle</span>(<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`turn to <span class="subst">$&#123;<span class="variable language_">this</span>.color&#125;</span> light`</span>);</span><br><span class="line">    context.<span class="title function_">setState</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义Context类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getState</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">setState</span>(<span class="params">state</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">let</span> context = <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> green = <span class="keyword">new</span> <span class="title class_">State</span>(<span class="string">&#x27;green&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> yellow = <span class="keyword">new</span> <span class="title class_">State</span>(<span class="string">&#x27;yellow&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> red = <span class="keyword">new</span> <span class="title class_">State</span>(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绿灯亮了</span></span><br><span class="line">green.<span class="title function_">handle</span>(context);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(context.<span class="title function_">getState</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 黄灯亮了</span></span><br><span class="line">yellow.<span class="title function_">handle</span>(context);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(context.<span class="title function_">getState</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 红灯亮了</span></span><br><span class="line">red.<span class="title function_">handle</span>(context);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(context.<span class="title function_">getState</span>());</span><br></pre></td></tr></table></figure><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</p><figure class="highlight js"><figcaption><span>Observer.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义主题对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加观察者</span></span><br><span class="line">  <span class="title function_">addObserver</span>(<span class="params">observer</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">push</span>(observer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除观察者</span></span><br><span class="line">  <span class="title function_">removeObserver</span>(<span class="params">observer</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> index = <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">indexOf</span>(observer);</span><br><span class="line">    <span class="keyword">if</span> (index &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">splice</span>(index, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通知所有观察者</span></span><br><span class="line">  <span class="title function_">notifyObservers</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">      observer.<span class="title function_">update</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义观察者对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 观察者更新方法</span></span><br><span class="line">  <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> 收到通知并进行了更新`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建主题对象</span></span><br><span class="line"><span class="keyword">const</span> subject = <span class="keyword">new</span> <span class="title class_">Subject</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建观察者对象</span></span><br><span class="line"><span class="keyword">const</span> observer1 = <span class="keyword">new</span> <span class="title class_">Observer</span>(<span class="string">&#x27;观察者1&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> observer2 = <span class="keyword">new</span> <span class="title class_">Observer</span>(<span class="string">&#x27;观察者2&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> observer3 = <span class="keyword">new</span> <span class="title class_">Observer</span>(<span class="string">&#x27;观察者3&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加观察者</span></span><br><span class="line">subject.<span class="title function_">addObserver</span>(observer1);</span><br><span class="line">subject.<span class="title function_">addObserver</span>(observer2);</span><br><span class="line">subject.<span class="title function_">addObserver</span>(observer3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知所有观察者</span></span><br><span class="line">subject.<span class="title function_">notifyObservers</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除观察者</span></span><br><span class="line">subject.<span class="title function_">removeObserver</span>(observer2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知所有观察者</span></span><br><span class="line">subject.<span class="title function_">notifyObservers</span>();</span><br></pre></td></tr></table></figure><h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><p>发布订阅（Publish-Subscribe）模式：发布订阅模式定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Observer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">eventTypeObj</span> = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Observer</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">on</span> = <span class="keyword">function</span>(<span class="params">eventType, fn</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">eventTypeObj</span>[eventType]) &#123;</span><br><span class="line">            <span class="comment">// 按照不同的订阅事件类型，存储不同的订阅回调</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">eventTypeObj</span>[eventType] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">eventTypeObj</span>[eventType].<span class="title function_">push</span>(fn);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="title class_">Observer</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">emit</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 可以理解为arguments借用shift方法</span></span><br><span class="line">    <span class="keyword">var</span> eventType = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="keyword">var</span> eventList = <span class="variable language_">this</span>.<span class="property">eventTypeObj</span>[eventType];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; eventList.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        eventList[i].<span class="title function_">apply</span>(eventList[i], <span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// var observer = new Observer();</span></span><br><span class="line"><span class="comment">// observer.on(&#x27;event&#x27;, function(params) &#123;</span></span><br><span class="line"><span class="comment">//     // handle function</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"><span class="comment">// observer.emit(&#x27;event&#x27;, &#123;/* params */&#125;);</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>PublishSubscribe.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PubSub</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span> = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">subscribe</span>(<span class="params">event, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">events</span>[event]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">events</span>[event] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span>[event].<span class="title function_">push</span>(callback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">publish</span>(<span class="params">event, data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">events</span>[event]) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span>[event].<span class="title function_">forEach</span>(<span class="function"><span class="params">callback</span> =&gt;</span> <span class="title function_">callback</span>(data));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pubsub = <span class="keyword">new</span> <span class="title class_">PubSub</span>();</span><br><span class="line"></span><br><span class="line">pubsub.<span class="title function_">subscribe</span>(<span class="string">&#x27;example&#x27;</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Received data: <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pubsub.<span class="title function_">publish</span>(<span class="string">&#x27;example&#x27;</span>, <span class="string">&#x27;hello world&#x27;</span>);</span><br></pre></td></tr></table></figure><p>###　观察者模式和发布订阅模式有什么区别</p><p>观察者模式和发布订阅模式都是用于解决对象之间的通信问题，但是它们的实现方式有所不同。</p><p>观察者模式中，主题对象维护了一个观察者列表，当主题对象发生变化时，会通知所有的观察者进行更新。观察者模式中，观察者和主题对象之间是直接关联的，观察者可以直接访问主题对象。</p><p>发布订阅模式中，发布者和订阅者之间通过一个消息队列进行通信。发布者将消息发布到消息队列中，订阅者从消息队列中订阅消息。发布者和订阅者之间是通过消息队列进行解耦的，它们不需要直接关联。</p><p>在实际应用中，观察者模式更加简单直接，适用于一对多的通信场景；而发布订阅模式更加灵活，适用于多对多的通信场景。</p><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instance1 = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">rank</span>: rankMediator</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance2 = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">rank</span>: rankMediator</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance3 = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">rank</span>: rankMediator</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">rankMediator</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> ranks = [instance1.<span class="property">value</span>, instance2.<span class="property">value</span>, instance3.<span class="property">value</span>].<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> ranks.<span class="title function_">indexOf</span>(<span class="variable language_">this</span>.<span class="property">value</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// instance1.rank(); // 1</span></span><br><span class="line"><span class="comment">// instance1.value = 100;</span></span><br><span class="line"><span class="comment">// isntance1.rank(); // 3</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>Mediator.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中介者模式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colleagues</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">addColleague</span>(<span class="params">colleague</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colleagues</span>.<span class="title function_">push</span>(colleague);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">broadcast</span>(<span class="params">sender, message</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colleagues</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">colleague</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (colleague !== sender) &#123;</span><br><span class="line">        colleague.<span class="title function_">receive</span>(message);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">mediator</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">mediator</span> = mediator;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">send</span>(<span class="params">message</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">mediator</span>.<span class="title function_">broadcast</span>(<span class="variable language_">this</span>, message);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">receive</span>(<span class="params">message</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Received message: <span class="subst">$&#123;message&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mediator = <span class="keyword">new</span> <span class="title class_">Mediator</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> colleague1 = <span class="keyword">new</span> <span class="title class_">Colleague</span>(mediator);</span><br><span class="line"><span class="keyword">const</span> colleague2 = <span class="keyword">new</span> <span class="title class_">Colleague</span>(mediator);</span><br><span class="line"><span class="keyword">const</span> colleague3 = <span class="keyword">new</span> <span class="title class_">Colleague</span>(mediator);</span><br><span class="line"></span><br><span class="line">mediator.<span class="title function_">addColleague</span>(colleague1);</span><br><span class="line">mediator.<span class="title function_">addColleague</span>(colleague2);</span><br><span class="line">mediator.<span class="title function_">addColleague</span>(colleague3);</span><br><span class="line"></span><br><span class="line">colleague1.<span class="title function_">send</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">colleague2.<span class="title function_">send</span>(<span class="string">&quot;How are you?&quot;</span>);</span><br><span class="line">colleague3.<span class="title function_">send</span>(<span class="string">&quot;Nice to meet you!&quot;</span>); </span><br></pre></td></tr></table></figure><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</p><p>JavaScript中的有序数据集合有 Array，Map，Set，String，typeArray，arguments，NodeList  </p><p>以上有序数据集合都部署了 Symbol.iterator 属性，属性值为一个函数，执行这个函数，返回一个迭代器，迭代器部署了 next 方法，调用迭代器的 next 方法可以按顺序访问子元素。同时，任何部署了 Symbol.iterator 接口的数据都可以使用 for…of 循环遍历  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> iterator = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>());  <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>());  <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>());  <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>());  <span class="comment">// &#123;value: 4, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>());  <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>Iterator.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个迭代器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">list</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span> = list;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">index</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">hasNext</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">list</span>[<span class="variable language_">this</span>.<span class="property">index</span>++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">hasNext</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">index</span> &lt; <span class="variable language_">this</span>.<span class="property">list</span>.<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个列表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">add</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">push</span>(item);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取迭代器</span></span><br><span class="line">  <span class="title function_">getIterator</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>(<span class="variable language_">this</span>.<span class="property">list</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用迭代器遍历列表</span></span><br><span class="line"><span class="keyword">const</span> list = <span class="keyword">new</span> <span class="title class_">List</span>();</span><br><span class="line">list.<span class="title function_">add</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">list.<span class="title function_">add</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">list.<span class="title function_">add</span>(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iterator = list.<span class="title function_">getIterator</span>();</span><br><span class="line"><span class="keyword">while</span> (iterator.<span class="title function_">hasNext</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</p><figure class="highlight js"><figcaption><span>Visitor.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义访问者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">  <span class="title function_">visit</span>(<span class="params">element</span>) &#123;</span><br><span class="line">    element.<span class="title function_">accept</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义元素</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Element</span> &#123;</span><br><span class="line">  <span class="title function_">accept</span>(<span class="params">visitor</span>) &#123;</span><br><span class="line">    visitor.<span class="title function_">visit</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义具体元素</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteElement</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Element</span> &#123;</span><br><span class="line">  <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ConcreteElement doSomething&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义具体访问者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteVisitor</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Visitor</span> &#123;</span><br><span class="line">  <span class="title function_">visit</span>(<span class="params">element</span>) &#123;</span><br><span class="line">    element.<span class="title function_">doSomething</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> visitor = <span class="keyword">new</span> <span class="title class_">ConcreteVisitor</span>();</span><br><span class="line"><span class="keyword">const</span> element = <span class="keyword">new</span> <span class="title class_">ConcreteElement</span>();</span><br><span class="line">visitor.<span class="title function_">visit</span>(element);</span><br></pre></td></tr></table></figure><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</p><figure class="highlight js"><figcaption><span>Memento.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发起人</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">currentValue</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">add</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">currentValue</span> += value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">subtract</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">currentValue</span> -= value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getCurrentValue</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">currentValue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">save</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Memento</span>(<span class="variable language_">this</span>.<span class="property">currentValue</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">restore</span>(<span class="params">memento</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">currentValue</span> = memento.<span class="title function_">getCurrentValue</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 备忘录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memento</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">currentValue</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">currentValue</span> = currentValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getCurrentValue</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">currentValue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管理者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">History</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">mementos</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">push</span>(<span class="params">memento</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">mementos</span>.<span class="title function_">push</span>(memento);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">mementos</span>.<span class="title function_">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> calculator = <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line"><span class="keyword">const</span> history = <span class="keyword">new</span> <span class="title class_">History</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一些数字</span></span><br><span class="line">calculator.<span class="title function_">add</span>(<span class="number">5</span>);</span><br><span class="line">history.<span class="title function_">push</span>(calculator.<span class="title function_">save</span>());</span><br><span class="line"></span><br><span class="line">calculator.<span class="title function_">add</span>(<span class="number">10</span>);</span><br><span class="line">history.<span class="title function_">push</span>(calculator.<span class="title function_">save</span>());</span><br><span class="line"></span><br><span class="line">calculator.<span class="title function_">subtract</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 输出：保存和添加之前的当前值：15</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(calculator.<span class="title function_">getCurrentValue</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弹出两次</span></span><br><span class="line">calculator.<span class="title function_">restore</span>(history.<span class="title function_">pop</span>());</span><br><span class="line">calculator.<span class="title function_">restore</span>(history.<span class="title function_">pop</span>());</span><br><span class="line"><span class="comment">// 输出：恢复到先前状态后的当前值：5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(calculator.<span class="title function_">getCurrentValue</span>());</span><br></pre></td></tr></table></figure><h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><p>解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</p><figure class="highlight js"><figcaption><span>Interpreter.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义表达式类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">  <span class="title function_">interpret</span>(<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;This method should be overwritten!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义数字表达式类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberExpression</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Expression</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">number</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">number</span> = number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">interpret</span>(<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义加法表达式类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddExpression</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Expression</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">left</span> = left;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">right</span> = right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">interpret</span>(<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">left</span>.<span class="title function_">interpret</span>(context) + <span class="variable language_">this</span>.<span class="property">right</span>.<span class="title function_">interpret</span>(context);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义减法表达式类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubtractExpression</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Expression</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">left</span> = left;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">right</span> = right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">interpret</span>(<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">left</span>.<span class="title function_">interpret</span>(context) - <span class="variable language_">this</span>.<span class="property">right</span>.<span class="title function_">interpret</span>(context);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义上下文类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">expression</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setExpression</span>(<span class="params">expression</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">expression</span> = expression;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">evaluate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">expression</span>.<span class="title function_">interpret</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用例子</span></span><br><span class="line"><span class="keyword">const</span> context = <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">NumberExpression</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title class_">NumberExpression</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title class_">NumberExpression</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> <span class="title class_">AddExpression</span>(a, b);</span><br><span class="line"><span class="keyword">const</span> e = <span class="keyword">new</span> <span class="title class_">SubtractExpression</span>(d, c);</span><br><span class="line"></span><br><span class="line">context.<span class="title function_">setExpression</span>(e);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(context.evaluate()); <span class="comment">// 输出 13</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> design </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sourcemap的作用和原理</title>
      <link href="/blog/2021/04/24/FE-sourcemap%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86/"/>
      <url>/blog/2021/04/24/FE-sourcemap%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Sourcemap"><a href="#什么是Sourcemap" class="headerlink" title="什么是Sourcemap"></a>什么是Sourcemap</h2><p>Sourcemap 本质上是一个信息文件，里面储存着代码转换前后的对应位置信息。它记录了转换压缩后的代码所对应的转换前的源代码位置，是源代码和生产环境代码的映射。 Sourcemap 解决了在打包过程中，代码经过压缩，去空格以及 babel 编译转化后，由于源代码与生产环境代码之间差异性过大，造成无法debug的问题。  </p><p>在生产环境文件中，会有一行底部注释 其中 <code>sourceMappingURL</code> 指向 sourcemap 文件地址，形如：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//# sourceMappingURL=http://example.com/path/to/your/sourcemap.map</span></span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="Sourcemap作用"><a href="#Sourcemap作用" class="headerlink" title="Sourcemap作用"></a>Sourcemap作用</h2><p>Sourcemap 构建了处理前以及处理后的代码之间的一座桥梁，方便定位生产环境中出现 bug 的位置。因为现在的前端开发都是模块化、组件化的方式，在上线前对 js 和 css 文件进行合并压缩容易造成混淆。如果对这样的线上代码进行调试，肯定不切实际，Sourcemap 的作用就是能够让浏览器的调试面版将生成后的代码映射到源码文件当中，开发者可以在源码文件中 debug，这样就会让调试轻松、简单很多。</p><h2 id="Sourcemap的用法"><a href="#Sourcemap的用法" class="headerlink" title="Sourcemap的用法"></a>Sourcemap的用法</h2><p>为了调试工作能够使用 Sourcemap，你必须：</p><ol><li>生产一个 Sourcemap 文件</li><li>在转换后的文件末尾加入一个注释，以 <code>#</code> 开始，声明参数 <code>sourceMappingURL</code> 指向 Sourcemap 文件所在位置。</li></ol><p>这样，浏览器的开发者工具就会在 debug 时解析 sourcemap 文件定位源代码中变量的位置</p><h2 id="Sourcemap的原理"><a href="#Sourcemap的原理" class="headerlink" title="Sourcemap的原理"></a>Sourcemap的原理</h2><p>为了更清晰的描述 sourcemap 的生成，我们用一个最简单的 case 来编译并生成 sourcemap：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// input</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">example</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;example&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = <span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;example&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>利用 babel 将上述代码转为 es5 的同时，我们可以得到一份 sourcemap：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sources&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;src/example.js&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;names&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;example&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;console&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="string">&quot;;;AAAA,IAAMA,OAAO,GAAG,SAAVA,OAAU,GAAM;AACpBC,EAAAA,OAAO,CAACC,GAAR,CAAY,SAAZ;AACD,CAFD&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sourcesContent&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;const example = () =&gt; &#123;\n  console.log(\&quot;example\&quot;);\n&#125;;\n&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到其有多个属性，分别代表着：</p><ul><li>version: source map 的版本号。</li><li>sources: 转换前的文件。该项是一个数组，可能存在多个文件合并成一个文件。</li><li>names: 转换前的所有变量名和属性名。</li><li>mappings: 记录位置信息的字符串。</li><li>sourceContent: 原始内容。</li></ul><p>其中最重要的，便是记录着原始代码和编译后代码映射关系的 mappings 字段。</p><h3 id="mappings-是如何记录映射的"><a href="#mappings-是如何记录映射的" class="headerlink" title="mappings 是如何记录映射的"></a>mappings 是如何记录映射的</h3><p>可以花两分钟简单思考一下，如果是你来设计 sourcemap，你会如何记录一份原始代码到编译后代码的映射？很简单，我将编译后的每一个单词，对应的原始位置都记录下来就可以了，需要注意的是，由于存在多个文件编译成一个文件的情况，所以我们需要记录下原始文件名：</p><table><thead><tr><th>编译后的位置（行/列）</th><th>编译后单词</th><th>原始文件名</th><th>原始位置（行/列）</th><th>原始单词</th></tr></thead><tbody><tr><td>0, 0</td><td>var</td><td>src/example.js</td><td>0, 0</td><td>const</td></tr><tr><td>0, 4</td><td>example</td><td>src/example.js</td><td>0, 6</td><td>example</td></tr><tr><td>0, 11</td><td>=</td><td>src/example.js</td><td>0, 13</td><td>=</td></tr><tr><td>0, 14</td><td>function</td><td>src/example.js</td><td>0, 16</td><td>(</td></tr><tr><td>0, 23</td><td>example</td><td>src/example.js</td><td>0, 6</td><td>example</td></tr><tr><td>0, 30</td><td>(</td><td>src/example.js</td><td>0, 16</td><td>(</td></tr><tr><td>0, 33</td><td>{</td><td>src/example.js</td><td>0, 22</td><td>{</td></tr></tbody></table><p>到这里，我们已经将第一行代码的原始信息记录下来了，可以表示为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0|0|src/example.js|0|0, 0|4|src/example.js|0|6, 0|11|src/example.js|0|13, 0|14|src/example.js|0|16, 0|23|src/example.js|0|16, 0|30|src/example.js|0|16, 0|33|src/example.js|0|22</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同样的，第二行代码与第三行代码的映射关系可以用相同的方式记录下来。当我们完成了映射关系的记录后，便需要考虑一个现实问题：只有 23 个字符的原始信息，我们需要用 150 个字符来记录其映射关系。有没有什么办法，可以用更少的字符记录呢？</p><p>现在，我们对照 sourcemap 的做法，将上面的信息进行逐层的优化：</p><h3 id="对-mappings-的优化"><a href="#对-mappings-的优化" class="headerlink" title="对 mappings 的优化"></a>对 mappings 的优化</h3><ol><li>省去输出文件中的行号，改用 ; 来标识换行</li></ol><p>利用; 来标识换行，我们可以将上述的编码节省为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0|src/example.js|0|0, 4|src/example.js|0|6, 11|src/example.js|0|13, 14|src/example.js|0|16, 23|src/example.js|0|16, 30|src/example.js|0|16, 33|src/example.js|0|22;</span><br></pre></td></tr></table></figure><ol start="2"><li>用索引标识变量名</li></ol><p>前面我们提到 sourcemap 中的 names 数组，在 sourcemap 中，它会将变量名在 names 数组中的索引也记录下来，所以编码会变成如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0|src/example.js|0|0, 4|src/example.js|0|6|0, 11|src/example.js|0|13, 14|src/example.js|0|16, 23|src/example.js|0|16|0, 30|src/example.js|0|16, 33|src/example.js|0|22;</span><br></pre></td></tr></table></figure><ol start="3"><li>用索引来代替文件名</li></ol><p>使用 sources 属性记录下来的原始文件数组，在记录原始信息时用索引代替，如 src/example.js 在 sources 中的索引为 0，所以可以进一步简化为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0|0|0|0, 4|0|0|6|0, 11|0|0|13, 14|0|0|16, 23|0|0|16|0, 30|0|0|16, 33|0|0|22;</span><br></pre></td></tr></table></figure><ol start="4"><li>用相对位置来代替绝对位置</li></ol><p>当文件内容巨大时，上面精简后的代码也有可能某些数字会随着增加而变得很长，如果一行的位置记录了某个位置，那么根据这一位置进行相对定位是可以到达一行内的任意位置。如：</p><table><thead><tr><th>编译后的位置（列）</th><th>编译后单词</th><th>原始文件名</th><th>原始位置（行/列）</th><th>原始单词</th></tr></thead><tbody><tr><td>0</td><td>var</td><td>src/example.js</td><td>0, 0</td><td>const</td></tr><tr><td>4（上一个位置+4）</td><td>example</td><td>src/example.js</td><td>0, 6</td><td>example</td></tr><tr><td>7（上一个位置+7）</td><td>=</td><td>src/example.js</td><td>0, 7</td><td>=</td></tr><tr><td>3（上一个位置+10）</td><td>function</td><td>src/example.js</td><td>0, 3</td><td>(</td></tr><tr><td>9（上一个位置+9）</td><td>example</td><td>src/example.js</td><td>0, -10</td><td>example</td></tr><tr><td>7（上一个位置+7）</td><td>(</td><td>src/example.js</td><td>0, 10</td><td>(</td></tr><tr><td>3（上一个位置+3）</td><td>{</td><td>src/example.js</td><td>0, 6</td><td>{</td></tr></tbody></table><p>所以我们的 mappings 继续被简化为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0|0|0|0, 4|0|0|6|0, 7|0|0|7, 3|0|0|3, 10|0|10, 9|0|0|-10, 7|0|0|10, 3|0|0|6;</span><br></pre></td></tr></table></figure><ol start="5"><li>VLQ 编码</li></ol><p>如果我们可以想办法去掉每个单词之间的分隔符（在我们的例子中是 | )，我们可以进一步省下大量的字符。当然，限制我们去掉这个分隔符的问题是，我们无法在没有分隔符的帮助下区分 10010 是 10|0|10 还是 100|1|0，但我们可以设计一套方法，让我们能够在去掉分隔符的情况下依然能够正确的分组。sourcemap 使用了这一套方法：</p><p>在二进制中，使用 6 个字节比特来记录一个数字，用其中一个字节来标识它是否结束（下方 C），再用一位标识正负（下方 S），剩下还有四位用来表示数值。用这样 6 个字节来表示我们需要的数字。</p><table><thead><tr><th>B5</th><th>B4</th><th>B3</th><th>B2</th><th>B1</th><th>B0</th></tr></thead><tbody><tr><td>C</td><td>value</td><td>value</td><td>value</td><td>value</td><td>S</td></tr></tbody></table><table><thead><tr><th>十进制</th><th>二进制</th></tr></thead><tbody><tr><td>4</td><td>100</td></tr><tr><td>0</td><td>0</td></tr><tr><td>6</td><td>110</td></tr></tbody></table><p>任意数字中，第一组的第一个比特就已经明确标明该数字的正负，所以后续比特不需要再标识，也就是说，第一组有 4 个比特来表示数值，后续每一组都有 5 个 比特来表示数值（每组依然有一个比特标识是否结束） 我们用上述的简化过的 mappings 的第二项 4|0|0|6|0 为例：</p><p>所以它们应该被编码为：</p><table><thead><tr><th>4</th><th>B5</th><th>B4</th><th>B3</th><th>B2</th><th>B1</th><th>B0</th></tr></thead><tbody><tr><td></td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><table><thead><tr><th>0</th><th>B5</th><th>B4</th><th>B3</th><th>B2</th><th>B1</th><th>B0</th></tr></thead><tbody><tr><td></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><table><thead><tr><th>6</th><th>B5</th><th>B4</th><th>B3</th><th>B2</th><th>B1</th><th>B0</th></tr></thead><tbody><tr><td></td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td></tr></tbody></table><blockquote><p>注：如果是一个分组无法表达的数字，则会用第二个分组来容纳剩余部分，这里举个例子：23 的二进制为 10111，由于一个分组无法容纳，那么将 10111 分为两组，第一组是最后面的四位，既 10111，第二组是剩下的 10111，那么它最终会被编码为：101110 000001。</p></blockquote><p>所以 4|0|0|6|0 最终被转化为 001000 000000 000000 001100 000000，随后再进行 base64 编码得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">001000 000000 000000 001100 000000</span><br><span class="line">I      A      A      M      A</span><br></pre></td></tr></table></figure><p>之所以要用 6 个比特为一组记录一个数字，正是因为每一个 base64 编码最多可以表示二进制 6 位，所以通过这样的编码，我们将 4|0|0|6|0 转化为了 IAAMA。至此，我们便了解了 sourcemap 的原理和生成方式。</p><h2 id="在-webpack-中使用-Sourcemap"><a href="#在-webpack-中使用-Sourcemap" class="headerlink" title="在 webpack 中使用 Sourcemap"></a>在 webpack 中使用 Sourcemap</h2><p>可以在 webpack 配置文件中添加 <code>devtool</code> 参数用来说明 Sroucemap 的处理方式。常见的有以下几种：  </p><table><thead><tr><th>devtool取值</th><th>作用</th></tr></thead><tbody><tr><td>source-map</td><td>产生一个单独的source-map文件，功能最完全，但会减慢打包速度</td></tr><tr><td>inline (如 inline-source-map）</td><td>该模式不会生成一份独立的.map 文件，而是用 base64 编码将 sourcemap 进行编码后附在编译后代码的末处。缺点是这样会使得编译后代码的体积变得庞大，其他方面则和 source-map 模式一样。</td></tr><tr><td>eval</td><td>源码以字符的形式被 eval(…) 来调用，不会生成 sourceMap 信息，只会通过一个附着在各个模块后的 sourceURL 来存储原始文件的位置，同时，我们只能在控制台中看到经过 webpack 处理的编译后代码，所以它并不能反映真实的行号</td></tr><tr><td>eval-source-map</td><td>使用eval打包源文件模块，直接在源文件中写入干净完整的source-map，不影响构建速度，但影响执行速度和安全，<em>建议开发环境中使用，生产阶段不要使用</em></td></tr><tr><td>cheap-source-map</td><td>生成的 sourcemap 只有行信息，不会记录列信息。cheap-source-map 记录下的是与被 loader 转化后的代码之间的映射</td></tr><tr><td>cheap-module-source-map</td><td>和 cheap-source-map 类似，但使用 cheap-module-source-map 可以记录下 loader 转译前的信息</td></tr><tr><td>cheap-module-eval-source-map</td><td>不会产生单独的map文件，（与eval-source-map类似）但开发者工具就只能看到行，无法对应到具体的列（符号），对调试不便</td></tr><tr><td>nosources</td><td>在这个模式下，会生成不包含 sourcecontent 的 sourcemap，具体表现为有错误堆栈信息但没有具体的内容</td></tr><tr><td>hidden</td><td>在这个模式下，会生成 sourcemap，但是不会将 sourcemapURL 信息附着在编译后代码中</td></tr></tbody></table><p>此外还有一些模式的组合，具体可以是”^(inline-|hidden-|eval-)?(nosources-)?(cheap-(module-)?)?source-map$”</p>]]></content>
      
      
      
        <tags>
            
            <tag> sourcemap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP-缓存</title>
      <link href="/blog/2021/04/23/HTTP-%E7%BC%93%E5%AD%98/"/>
      <url>/blog/2021/04/23/HTTP-%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是HTTP缓存"><a href="#什么是HTTP缓存" class="headerlink" title="什么是HTTP缓存"></a>什么是HTTP缓存</h2><p>缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。<br>HTTP 缓存机制就是，通过配置 HTTP 响应头来告诉浏览器是否应该对请求的资源进行缓存、缓存多长时间、缓存是否过期的一种机制。  </p><span id="more"></span><h2 id="缓存的优缺点"><a href="#缓存的优缺点" class="headerlink" title="缓存的优缺点"></a>缓存的优缺点</h2><p>缓存的优点：</p><ol><li>减少了不必要的数据传输，节省带宽</li><li>减少服务器的负担，提升网站性能</li><li>加快了客户端加载网页的速度</li></ol><p>缺点：</p><p>资源如果有更改但是客户端不及时更新会造成用户获取信息滞后</p><h2 id="HTTP缓存有哪几种"><a href="#HTTP缓存有哪几种" class="headerlink" title="HTTP缓存有哪几种"></a>HTTP缓存有哪几种</h2><p>根据加载缓存是否需要同服务器交互可以将缓存分为 <em>强缓存</em> 与 <em>协商缓存</em></p><ul><li>强缓存：浏览器直接从本地缓存中获取数据，不与服务器进行交互。</li><li>协商缓存：浏览器发送请求到服务器，服务器判定是否可使用本地缓存。</li></ul><h2 id="缓存流程图"><a href="#缓存流程图" class="headerlink" title="缓存流程图"></a>缓存流程图</h2><p><img src="/blog/static/imgs/cache.png" alt="cache-process_inner"></p><h2 id="与HTTP缓存有关的首部字段有哪些，有什么作用"><a href="#与HTTP缓存有关的首部字段有哪些，有什么作用" class="headerlink" title="与HTTP缓存有关的首部字段有哪些，有什么作用"></a>与HTTP缓存有关的首部字段有哪些，有什么作用</h2><p>与HTTP缓存有关的字段有：  </p><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Cache-Control</td><td>控制对资源的缓存行为</td></tr><tr><td>Expires</td><td>控制资源的过期时间</td></tr><tr><td>Last-Modified</td><td>资源的最后修改日期时间</td></tr><tr><td>ETag</td><td>资源的匹配信息</td></tr><tr><td>If-Non-Match</td><td>条件式请求，服务器上没有任何资源的 ETag 属性值与这个首部中列出的相匹配的时候，服务器端会才返回所请求的资源，响应码为 200 。当验证失败的时候，服务器端必须返回响应码 304</td></tr><tr><td>If-Modified-Since</td><td>条件式请求，服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 。如果请求的资源从那时起未经修改，那么返回一个不带有消息主体的 304 响应。当与 If-None-Match 一同出现时，If-Modified-Since 会被忽略掉。</td></tr></tbody></table><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>代表了资源的缓存策略，常用的有以下几种选择：  </p><table><thead><tr><th>Cache-Control字段</th><th>说明</th></tr></thead><tbody><tr><td>max-age</td><td>表示缓存最大有效时间，以秒为单位</td></tr><tr><td>public</td><td>表示可以被浏览器和代理服务器缓存</td></tr><tr><td>private</td><td>客户端可以缓存该资源，但代理服务器不缓存</td></tr><tr><td>no-cache</td><td>跳过设置强缓存，强制设置协商缓存</td></tr><tr><td>no-store</td><td>不缓存，包括客户端、服务器都不缓存</td></tr><tr><td>immutable</td><td>表示该资源永久不变(非标准)</td></tr></tbody></table><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>Expires 代表了资源的过期日期，在没有 Cache-Control 时，则会去查看是否包含 Expires 属性，通过比较 Expires 的值和首部里面 Date 属性的值来判断是否缓存还有效。  </p><h3 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h3><p>如果没有 Cache-Control 和 Expires 时，Last-Modified 响应头可以作为一种弱校验器。浏览器隐式的设置资源过期时间为 (Date - Last-Modified) * 10% 缓存过期时间。如果响应头里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。  </p><h3 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h3><p>ETag 代表了资源的特定版本的标识符，用做缓存的一种强校验器。  </p><ul><li>浏览器请求资源，服务器会在响应报文头中加入 ETag 字段。资源更新时，服务器端的ETag值也随之更新；</li><li>浏览器再次请求资源时，会在请求报文头中添加 If-None-Match 字段，它的值就是上次响应报文中的 ETag 的值；</li><li>服务器会比对 ETag 与 If-None-Match 的值是否一致，如果不一致，服务器则接受请求，返回更新后的资源；如果一致，表明资源未更新，则返回状态码为 304 的响应，可继续使用本地缓存，要注意的是，此时响应头还是会加上 ETag 字段，即使它没有变化。</li></ul><h3 id="If-Non-Match-If-Modified-Since"><a href="#If-Non-Match-If-Modified-Since" class="headerlink" title="If-Non-Match If-Modified-Since"></a>If-Non-Match If-Modified-Since</h3><p>当一个资源被缓存存储后，该资源应该可以被永久存储在缓存中。由于缓存只有有限的空间用于存储资源副本，所以缓存会定期地将一些副本删除，这个过程叫做 <em>缓存驱逐</em> 。另一方面，当服务器上面的资源进行了更新，那么缓存中的对应资源也应该被更新，由于HTTP是C/S模式的协议，服务器更新一个资源时，不可能直接通知客户端更新缓存，所以双方必须为该资源约定一个过期时间，在该过期时间之前，该资源（缓存副本）就是新鲜的，当过了过期时间后，该资源（缓存副本）则变为陈旧的。驱逐算法用于将陈旧的资源（缓存副本）替换为新鲜的，注意，一个陈旧的资源（缓存副本）是不会直接被清除或忽略的，当客户端发起一个请求时，缓存检索到已有一个对应的陈旧资源（缓存副本），则缓存会先将此请求附加一个 If-None-Match 头，然后发给目标服务器，以此来检查该资源副本是否是依然还是算新鲜的，若服务器返回了 304 (Not Modified)（该响应不会有带有实体信息），则表示此资源副本是新鲜的，这样一来，可以节省一些带宽。若服务器通过 If-None-Match 或 If-Modified-Since 判断后发现已过期，那么会带有该资源的实体内容返回。  </p>]]></content>
      
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP小抄</title>
      <link href="/blog/2021/04/22/HTTP%E5%B0%8F%E6%8A%84/"/>
      <url>/blog/2021/04/22/HTTP%E5%B0%8F%E6%8A%84/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是HTTP"><a href="#什么是HTTP" class="headerlink" title="什么是HTTP"></a>什么是HTTP</h2><p>HTTP全称超文本传输协议（HyperText Transfer Protocol），诞生于 1989年3月，由 CERN(欧洲核子研究组织)的 Tim Berners Lee 博士和他的团队设计，是一种能够获取如 HTML 这样的网络资源的通讯协议。它是在 Web 上进行数据交换的基础，是一种 客户端-服务器 协议，也就是说，请求通常是由像浏览器这样的客户端发起的。一个完整的Web文档通常是由不同的子文档拼接而成的，像是文本、布局描述、图片、视频、脚本等等。  </p><p>HTTP正式作为标准是在 1996年的5月，版本被命名为 HTTP/1.0，并记载于 <a href="https://www.ietf.org/rfc/rfc1945.txt">RFC1945</a>。  </p><p>HTTP在基本的TCP/IP协议栈上发送信息，1994年底，网景公司（Netscape Communication）在此基础上创建了一个额外的加密传输层：SSL(Secure Socket Layer 安全套接层)，SSL在标准化道路上最终成为TLS(Transport Layer Security 安全传输层协议)，并记载于 <a href="https://www.ietf.org/rfc/rfc2246.txt">RFC2246</a>。  </p><p>1997年1月 HTTP/1.1公布，当初的标准是 <a href="https://www.ietf.org/rfc/rfc2068.txt">RFC2068</a>，目前最新的修订版是1999年6月发布的 <a href="https://www.ietf.org/rfc/rfc2616.txt">RFC2616</a></p><p>HTTP2目前正在设计中，它的两个预览版本 <a href="https://www.ietf.org/rfc/rfc7230.txt">RFC7230</a>、<a href="https://www.ietf.org/rfc/rfc7235.txt">RFC7235</a> 发布于2014年6月</p><span id="more"></span><h2 id="计算机网络模型"><a href="#计算机网络模型" class="headerlink" title="计算机网络模型"></a>计算机网络模型</h2><p>HTTP 是被用来进行计算机通信的一个应用层协议，它的运行基础是计算机网络。被广为人知的计算机网络模型一般有两种，一个是被ISO(International Organization for Standardization 国际标准化组织)制定的 OSI（Open System Interconnection）七层模型（包括应用层、表示层、会话层、传输层、网络层、数据链路层、物理层，实际使用中该模型太过理想化，并没有被广泛的采用），另一个是被实际使用的 TCP/IP 模型。TCP/IP 模型按通信层次分为以下五层：应用层、传输层、网络层、数据链路层、物理层（一般把数据链路层与物理层统称为网络接口层）。</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层决定了向用户提供应用服务时通信的活动。<br>属于该层的协议有 FTP（File Transfer Protocol 文件传输协议）、 SMTP（Simple Mail Transfer Protocol 简单邮件传送协议）、 DNS（Domain Name System 域名系统）、 HTTP（HyperText Transfer Protocol 超文本传输协议）、Telnet(远程登录协议) 、POP3(Post Office Protocol - Version 3 邮局协议版本3)、 SNMP（Simple Network Management Protocol 简单网络管理协议）、DHCP（Dynamic Host Configuration Protocol 动态主机配置协议）、SSH（Secure SHell protocol 安全外壳协议）</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>传输层提供处于网络连接中的两台计算机之间的数据传输。<br>属于该层的协议有 TCP（Transmission Control Protocol 传输控制协议） UDP（User Data Protocol 用户数据报协议）</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>网络层用来处理在网络上流动的数据包。<br>属于该层的协议有 IP（Internet Protocol 网络互联协议）包括 IPv4、Ipv6， ICMP（Internet Control Message Protocol 互联网控制报文协议）、ARP（Address Resolution Protocol 地址解析协议）、IRP（Route Information Protocol 路由信息协议）、IGMP（Internet Group Management Protocol 互联网组管理协议）</p><h3 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h3><p>网络接口层用来处理连接网络硬件与链路的部分。包括控制操作系统、硬件设备驱动、网络适配器（NIC）及光纤等。<br>属于该层的协议有 FDDI（Fiber Distributed Data Interface 光纤分布式数据接口）、SLIP（Serial Line Internet Protocol 串行线路网际协议）、PPP（Point to Point Protocol 点对点协议）、<a href="https://1.ieee802.org/">IEEE802.1</a>（802 LAN/MAN 体系结构与互连、安全、总体网络管理、MAC &amp; LLC 层 协议）、<a href="https://www.ieee802.org/3/">IEEE802.3</a>（ETHERNET 以太网标准）、<a href="https://www.ieee802.org/11/">IEEE802.11</a>（WIRELESS LOCAL AREA NETWORKS 无线局域网标准 WLAN Wi-Fi） <a href="https://ieeexplore.ieee.org/document/1490827">IEEE802.15.1</a>（Bluetooth 蓝牙）<a href="https://ieeexplore.ieee.org/document/7460875">IEEE802.15.4</a>（ZigBee基于此标准）等</p><h2 id="HTTP报文由哪些元素构成"><a href="#HTTP报文由哪些元素构成" class="headerlink" title="HTTP报文由哪些元素构成"></a>HTTP报文由哪些元素构成</h2><p>HTTP报文包括请求报文和响应报文  </p><p>请求报文 包括 请求方法 URI 协议版本 请求首部字段 内容实体 构成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /form/entry HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 16</span><br><span class="line"></span><br><span class="line">name=userName&amp;age=16</span><br></pre></td></tr></table></figure><p>响应报文 包括 协议版本 状态码 原因短语 创建响应的时间 响应首部字段 主体 构成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Thu Apr 22 2021 00:08:31 GMT</span><br><span class="line">Content-Length: 3620</span><br><span class="line">Content-Type: text/html</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>HTTP Method 是区分大小写的，而 Header 是不区分的。  </p><h3 id="method-请求方法"><a href="#method-请求方法" class="headerlink" title="method 请求方法"></a>method 请求方法</h3><p>HTTP/1.1 支持请求的方法如下：  </p><table><thead><tr><th>请求方法</th><th>含义</th></tr></thead><tbody><tr><td>GET</td><td>GET方法用来请求访问已被URI识别的资源</td></tr><tr><td>POST</td><td>POST方法用来传输报文主体部分</td></tr><tr><td>PUT</td><td>PUT方法用来传输文件，但PUT方法自身不带验证机制，所以一般web网站不使用该方法</td></tr><tr><td>DELETE</td><td>DELETE方法用来删除文件，同PUT方法作用相反，但因为不带验证机制，所以一般也不使用</td></tr><tr><td>HEAD</td><td>HEAD方法用来获取报文首部，不返回报文主体</td></tr><tr><td>OPTIONS</td><td>OPTIONS方法用来询问服务器支持的方法</td></tr><tr><td>TRACE</td><td>TRACE方法让web服务器将之前的请求通信返回给客户端，容易引起XST（Cross-Site Tracing）攻击，所以也不常用</td></tr><tr><td>CONNECT</td><td>CONNECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信</td></tr></tbody></table><p>GET 和 POST 请求的区别可以参考 <a href="/blog/2021/03/19/HTTP-get-post区别/">HTTP-get-post区别</a></p><h3 id="URI-统一资源标志符"><a href="#URI-统一资源标志符" class="headerlink" title="URI 统一资源标志符"></a>URI 统一资源标志符</h3><p>URI（Uniform Resource Identifier）是指访问资源所使用的协议类型名称。在 <a href="https://www.ietf.org/rfc/rfc7230.txt">RFC2396</a> 中定义。标准的URI协议有30多种，由 国际互联网资源管理的非盈利性社团 ICANN(Internet Corporation for Assigned Names and Numbers) 管理。  </p><p>URI包括以下几个部分：  </p><p><code>http://user:pass@www.example.com:80/dir/index.html?uid=1#ch1</code><br>协议名、登录信息、服务器地址、服务器端口号、带层次的文件路径、查询字符串、片段标志符</p><h3 id="Connection-amp-Keep-Alive-持久连接"><a href="#Connection-amp-Keep-Alive-持久连接" class="headerlink" title="Connection &amp; Keep-Alive 持久连接"></a>Connection &amp; Keep-Alive 持久连接</h3><p>为了减少TCP三次握手的消耗，HTTP/1.1默认采用了 <code>Connection: keep-alive</code> 的首部字段来复用TCP三次握手所建立的连接通道。持久连接让客户端的请求可以以管线化的方式发送，即并行的同时发送多个请求而不需要等待上一个请求响应。同时，多数浏览器会对同时发起的请求数量进行限制以防止对连接资源的消耗。Chrome 浏览器限制为 8 个请求。  </p><p>同时，消息发送者可以通过发送 <code>Keep-Alive: timeout=5, max=1000</code> 设置超时时长和最大请求数。  </p><h4 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h4><p>TCP协议位于传输层，提供了可靠的字节流服务。为了准确无误的将数据送达目标处，TCP协议采用了三次握手的策略，在数据包送出后会通过 TCP 标志 SYNC（synchronize） 和 ACK（acknowledgement）向对方确认是否成功送达。<br>发送端首先发送一个带有 SYNC 标志的数据包给对方。接收端收到后，回传一个带有 SYNC/ACK 标志的数据包以示传达确认信息。最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。   </p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>HTTP请求是无状态的，但某些情况下我们需要进行状态管理，比如用户登录场景。Cookie 技术通过在请求和响应报文中写入 cookie 信息来控制客户端的状态。<br>Server端可以在响应报文中通过 <code>Set-Cookie</code> 的首部字段来通知客户端添加 cookie，客户端可以通过 <code>document.cookie</code> 获取和修改 cookie 相关信息。  </p><p>更详细的介绍参见 <a href="/blog/2021/12/29/HTTP-Cookie/">HTTP Cookie</a></p><h3 id="Content-Encoding-内容编码"><a href="#Content-Encoding-内容编码" class="headerlink" title="Content-Encoding 内容编码"></a>Content-Encoding 内容编码</h3><p>内容编码指明了应用在实体内容上的编码格式，并保持实体原样压缩。内容编码后的实体由客户端接受并负责解码。 在请求报文首部中，添加 <code>Accept-Encoding</code> 字段表明客户端支持的内容编码形式，Server端在响应报文首部中添加 <code>Content-Encoding</code> 字段表明该次请求采用的内容编码形式。常见内容编码压缩方式如下：  </p><table><thead><tr><th>内容编码方式</th><th>含义</th></tr></thead><tbody><tr><td>gzip</td><td>GNU zip</td></tr><tr><td>compress</td><td>UNIX系统的标准压缩</td></tr><tr><td>deflate</td><td>zlib</td></tr><tr><td>identify</td><td>不进行编码</td></tr></tbody></table><h3 id="Content-Type-内容类型"><a href="#Content-Type-内容类型" class="headerlink" title="Content-Type 内容类型"></a>Content-Type 内容类型</h3><p>HTTP采用了MIME(Multipurpose internet Mail Extensions)来描述传输的内容类型。<br>MIME 信息是由 Internet Engineering Task Force (IETF) 在下面的文档中提供的:  </p><ul><li><a href="https://www.ietf.org/rfc/rfc822.txt">RFC-822</a> Standard for ARPA Internet text messages</li><li><a href="https://www.ietf.org/rfc/rfc2045.txt">RFC-2045</a> MIME Part 1: Format of Internet Message Bodies</li><li><a href="https://www.ietf.org/rfc/rfc2046.txt">RFC-2046</a> MIME Part 2: Media Types</li><li><a href="https://www.ietf.org/rfc/rfc2047.txt">RFC-2047</a> MIME Part 3: Header Extensions for Non-ASCII Text</li><li><a href="https://www.ietf.org/rfc/rfc2048.txt">RFC-2048</a> MIME Part 4: Registration Procedures</li><li><a href="https://www.ietf.org/rfc/rfc2049.txt">RFC-2049</a> MIME Part 5: Conformance Criteria and Examples</li></ul><p>常见的 Content-Type 类型有如下：  </p><table><thead><tr><th>文件扩展名</th><th>Content-Type</th><th>含义</th></tr></thead><tbody><tr><td>.html</td><td>text/html</td><td>超文本标记语言文本</td></tr><tr><td>.txt</td><td>text/plain</td><td>普通文本</td></tr><tr><td>.gif</td><td>image/gif</td><td>GIF图形</td></tr><tr><td>.png</td><td>image/png</td><td>png图形</td></tr><tr><td>.jpeg,.jpg</td><td>image/jpeg</td><td>JPEG图形</td></tr><tr><td>.ico</td><td>image/x-icon</td><td>icon图形</td></tr><tr><td>.au</td><td>audio/basic</td><td>声音文件</td></tr><tr><td>.mpg,.mpeg</td><td>video/mpeg</td><td>MPEG文件</td></tr><tr><td>.avi</td><td>video/x-msvideo</td><td>AVI文件</td></tr><tr><td>.tar</td><td>application/x-tar</td><td>TAR文件</td></tr><tr><td></td><td>multipart/form-data</td><td>web表单数据</td></tr><tr><td>.js</td><td>application/javascript application/x-javascript</td><td>js文件</td></tr><tr><td>.css</td><td>text/css</td><td>css文件</td></tr><tr><td>.json</td><td>application/json</td><td>json文件</td></tr><tr><td></td><td>multipart/form-data</td><td>HTML表单</td></tr></tbody></table><p>在缺失 MIME 类型或客户端认为文件设置了错误的 MIME 类型时，浏览器可能会通过查看资源来进行MIME嗅探。每一个浏览器在不同的情况下会执行不同的操作。因为这个操作会有一些安全问题，有的 MIME 类型表示可执行内容而有些是不可执行内容。服务器可以通过设置 <code>X-Content-Type-Options: nosniff</code> 响应头来阻止 MIME 嗅探。</p><h3 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h3><p>内容协商机制是指客户端和服务器就响应的资源内容进行交涉，然后提供给客户端最为合适的资源。内容协商字段会包含在请求报文的首部字段。包括： Accept、Accept-Charset、Accept-Encoding、Accept-Language、Content-Language  </p><h3 id="HTTPS协议升级机制"><a href="#HTTPS协议升级机制" class="headerlink" title="HTTPS协议升级机制"></a>HTTPS协议升级机制</h3><p><code>Upgrade-Insecure-Requests</code> 是一个请求首部，用来向服务器端发送信号，表示客户端优先选择加密及带有身份验证的响应，并且它可以成功处理 <code>upgrade-insecure-requests</code> 的 CSP 指令。此请求头已添加为<a href="https://www.w3.org/TR/2015/CR-upgrade-insecure-requests-20151008/#preference">W3C Candidate Recommendation</a>，Chrome 在 44.0.2403.130 版本将 <code>Upgrade-Insecure-Requests</code> 自动添加到 HTTP 请求的头部中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br></pre></td></tr></table></figure><p>如果服务器同样支持 HTTPS 请求，则可以返回一个 带 <code>Location</code> 的 <code>Status-Code</code> 为 3xx 的响应，将请求重定向到 HTTPS 版本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Location: https://example.com/</span><br><span class="line">Vary: Upgrade-Insecure-Requests</span><br></pre></td></tr></table></figure><h3 id="Status-Code-状态码"><a href="#Status-Code-状态码" class="headerlink" title="Status Code 状态码"></a>Status Code 状态码</h3><p>参见 <a href="/blog/2018/11/02/HTTP-状态码/">HTTP-状态码</a></p><h3 id="HTTP-1-1-首部字段"><a href="#HTTP-1-1-首部字段" class="headerlink" title="HTTP/1.1 首部字段"></a>HTTP/1.1 首部字段</h3><p>首部字段分为四种 通用 请求 响应 实体  </p><p>HTTP 首部字段参见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers">HTTP Headers</a>  </p><p>常见的有以下字段：  </p><p>通用：</p><table><thead><tr><th>首部字段名</th><th>说明</th><th>例子</th></tr></thead><tbody><tr><td>Cache-Control</td><td>控制缓存的行为</td><td>public;max-age=3600</td></tr><tr><td>Connection</td><td>逐跳首部、连接的管理</td><td>keep-alive</td></tr><tr><td>Date</td><td>创建报文的日期时间</td><td>Thu, 22 Apr 2021 16:38:01 GMT</td></tr><tr><td>Transfer-Encoding</td><td>制定报文主体的传输编码方式</td><td>chunked</td></tr><tr><td>Upgrade</td><td>升级为其他协议</td><td>TLS/1.0,HTTP/1.1</td></tr></tbody></table><p>请求：</p><table><thead><tr><th>首部字段名</th><th>说明</th><th>例子</th></tr></thead><tbody><tr><td>Accept</td><td>用户代理可处理的媒体类型</td><td>text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,<em>/</em>;q=0.8,application/signed-exchange;v=b3;q=0.9</td></tr><tr><td>Accept-Charset</td><td>优先的字符集</td><td></td></tr><tr><td>Accept-Encoding</td><td>优先的内容编码</td><td>gzip, deflate, br</td></tr><tr><td>Accept-Language</td><td>优先的语言（自然）</td><td>zh-CN,zh;q=0.9</td></tr><tr><td>Host</td><td>请求资源所在服务器</td><td>mangon.cn</td></tr><tr><td>If-Match</td><td>比较实体标记(ETag)</td><td></td></tr><tr><td>If-Modify-Since</td><td>比较资源的更新时间</td><td></td></tr><tr><td>If-None-Match</td><td>比较实体标记(与If-Match相反)</td><td></td></tr><tr><td>User-Agent</td><td>HTTP客户端程序的信息</td><td>Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.75 Safari/537.36</td></tr><tr><td>Upgrade-Insecure-Requests</td><td>表示客户端优先选择加密及带有身份验证的响应</td><td>Upgrade-Insecure-Requests: 1</td></tr></tbody></table><p>响应：</p><table><thead><tr><th>首部字段名</th><th>说明</th><th>例子</th></tr></thead><tbody><tr><td>ETag</td><td>资源的匹配信息</td><td>ETag: 61d64f3e-1f2</td></tr><tr><td>Location</td><td>令客户端重定向至指定URI</td><td>Location: HTTPS://example.com:443/</td></tr><tr><td>Server</td><td>HTTP服务器的安装信息</td><td>Server: nginx/1.16.1</td></tr><tr><td>Vary</td><td>Vary 决定了对于未来的一个请求头，应该用一个缓存的响应还是向源服务器请求一个新的回复</td><td>Vary: Upgrade-Insecure-Requests</td></tr><tr><td>X-Frame-Options</td><td>用来给浏览器 指示允许一个页面 可否在 <code>&lt;frame&gt;</code>, <code>&lt;iframe&gt;</code>, <code>&lt;embed&gt;</code> 或者 <code>&lt;object&gt;</code> 中展现的标记。主要是为了防止 点击劫持 攻击</td><td><code>X-Frame-Options: &lt;deny｜sameorigin｜allow-from uri&gt;</code></td></tr><tr><td>X-XSS-Protection</td><td>X-XSS-Protection 响应头是 Internet Explorer，Chrome 和 Safari 的一个特性，当检测到跨站脚本攻击（XSS）时，浏览器将停止加载页面。</td><td>X-XSS-Protection: 1; mode=block</td></tr><tr><td>Content-Security-Policy</td><td>Content-Security-Policy允许站点管理者控制用户代理能够为指定的页面加载哪些资源，这主要是为了防止跨站脚本攻击（XSS）</td><td>Content-Security-Policy: default-src ‘self’ http://example.com; connect-src ‘none’;</td></tr><tr><td>X-Content-Type-Options</td><td>X-Content-Type-Options 相当于一个提示标志，被服务器用来提示客户端一定要遵循在 Content-Type 首部中对  MIME 类型 的设定，而不能对其进行修改。这就禁用了客户端的 MIME 类型嗅探行为</td><td>X-Content-Type-Options: nosniff</td></tr><tr><td>Strict-Transport-Security</td><td>告知浏览器只能通过HTTPS访问当前资源，chrome 可以在 <code>chrome://net-internals/#hsts</code> 查看hsts设置</td><td>Strict-Transport-Security: “max-age=63072000; includeSubdomains” always;</td></tr></tbody></table><p>实体：</p><table><thead><tr><th>首部字段名</th><th>说明</th><th>例子</th></tr></thead><tbody><tr><td>Allow</td><td>资源可支持的HTTP方法</td><td></td></tr><tr><td>Content-Encoding</td><td>实体主体适用的编码方式</td><td></td></tr><tr><td>Content-Language</td><td>实体主体的自然语言</td><td></td></tr><tr><td>Content-Length</td><td>实体主体的大小（字节）</td><td></td></tr><tr><td>Content-Location</td><td>替代对应资源的URI</td><td></td></tr><tr><td>Content-MD5</td><td>实体主体的报文摘要</td><td></td></tr><tr><td>Content-Type</td><td>实体主体的媒体类型</td><td></td></tr><tr><td>Expires</td><td>实体主体过期的日期时间</td><td></td></tr><tr><td>Last-Modified</td><td>资源的最后修改日期时间</td></tr></tbody></table><p>CORS 相关字段参见 <a href="/blog/2021/12/30/HTTP-同源策略/#CORS（Cross-Origin-Resource-Sharing）-跨源资源共享">CORS</a></p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTP协议中没有加密机制，但可以通过和SSL（Secure Socket Layer 安全套接层）或 TLS（Transport Layer Security 安全传输层协议）的组合使用，加密 HTTP 协议的内容。与 SSL 组合使用的 HTTP 被称为 HTTPS（HTTP Secure 超文本传输安全协议）或 HTTP over SSL。  </p><p>HTTPS 相对于 HTTP 多了三个方面</p><ul><li>报文加密</li><li>服务器认证</li><li>完整性保护</li></ul><h3 id="报文加密"><a href="#报文加密" class="headerlink" title="报文加密"></a>报文加密</h3><p>SSL采用非对称的公开密钥加密（Public-key cryptography）的加密处理方式，加密算法是公开的，公有密钥（public key）是公开的，用来加密，私有密钥（private）是保密的，用来解密。  </p><h3 id="服务器认证"><a href="#服务器认证" class="headerlink" title="服务器认证"></a>服务器认证</h3><p>为了证明公有密钥的正确性，我们需要由数字证书认证机构（CA Certificate Authority）和其相关机关颁发的公开密钥证书。<br>多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。  </p><ol><li>服务器把自己的公开密钥登录至数字证书认证机构</li><li>数字证书认证机构用自己的私有密钥向服务器的公开密钥部署数字签名并颁发公钥证书</li><li>服务器向客户端传输数据时会带上服务器的公开密钥和数字证书认证机构的数字签名及公钥证书</li><li>客户端拿到服务器的公钥证书后，使用数字证书认证机构的公开密钥，向数字认证机构验证公钥证书上的数字签名，以确认服务器的公开密钥的真实性</li><li>客户端使用服务器的公开密钥对报文加密后发送给服务器</li><li>服务器用私有密钥对报文解密</li></ol><h3 id="完整性保护"><a href="#完整性保护" class="headerlink" title="完整性保护"></a>完整性保护</h3><p>HTTP 可以通过 MD5 和 SHA-1 等散列值校验的方法来验证报文完整，但都需要客户端用户亲自检查验证，而且无法保证结果正确，因为 PGP（Pretty Good Privacy） 和 MD5 本身也可能被改写。SSL 会对报文进行信息摘要和加密，一旦篡改无法解密，也就达到了完整性保护的作用。  </p><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><p>虽然 HTTPS 解决了 HTTP 存在的很多问题，但 HTTPS 也不是万能的，也存在一些问题</p><h4 id="认证机构私钥丢失"><a href="#认证机构私钥丢失" class="headerlink" title="认证机构私钥丢失"></a>认证机构私钥丢失</h4><p>2011年7月，荷兰一家名叫 DigiNotar 的认证机构遭到入侵，颁布了多个网站的伪造证书。因为伪造证书有正规认证机构的数字签名，所以浏览器会判定该证书是正当的。虽然有可以将证书无效化的证书吊销列表（Certificate Revocation List CRL）机制，以及从客户端删除根证书颁发机构（Root Certificate Authority RCA）的对策，但距离生效都需要一定时间。  </p><h4 id="自认证"><a href="#自认证" class="headerlink" title="自认证"></a>自认证</h4><p>使用 OpenSSL 这套开源程序，每个人都可以构建一套属于自己的认证机构，从而给自己颁发服务器证书。  </p><h4 id="处理速度比-HTTP-慢"><a href="#处理速度比-HTTP-慢" class="headerlink" title="处理速度比 HTTP 慢"></a>处理速度比 HTTP 慢</h4><p>HTTPS 需要经过 SSL 层，额外的一层通信导致速度会比HTTP要慢 2-100 倍。另外 SSL层必须进行加密处理，在服务器和客户端都需要进行加密运算，会比 HTTP 消耗更多的资源。  </p><h4 id="证书开销"><a href="#证书开销" class="headerlink" title="证书开销"></a>证书开销</h4><p>要进行 HTTPS 通信，证书是必不可少的，想要获得 CA 认证的证书，需要向 CA 机构支付一定的费用，证书价格可能会根据不同认证机构略有不同，通常一年费用在上千人民币。  </p><h2 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h2><p>HTTP2 协议于 2015 年发布，由 RFC7540 和 RFC7541 两个规范组成，它基于 Google SPDY3 协议，主要在性能上进行了改进。</p><h3 id="HTTP2-特性"><a href="#HTTP2-特性" class="headerlink" title="HTTP2 特性"></a>HTTP2 特性</h3><ol><li><p>二进制分帧层 (Binary Framing Layer)<br>帧是数据传输的最小单位，以二进制传输代替原本的明文传输，原本的报文消息被划分为更小的数据帧</p></li><li><p>多路复用 (MultiPlexing)<br>在一个 TCP 连接上，我们可以向对方不断发送帧，每帧的 stream identifier 会标明这一帧属于哪个流，然后在对方接收时，根据 stream identifier 拼接每个流的所有帧组成一整块数据。<br>把 HTTP/1.1 每个请求都当作一个流，那么多个请求变成多个流，请求响应数据分成多个帧，不同流中的帧交错地发送给对方，这就是 HTTP/2 中的多路复用。</p></li><li><p>服务端推送 (Server Push)<br>浏览器发送一个请求，服务器主动向浏览器推送与这个请求相关的资源，这样浏览器就不用发起后续请求。同时，客户端也有权利选择是否接收，如果资源已经缓存，浏览器可以通过发送 RST_STREAM 帧来拒收，主动推送也遵守同源策略。</p></li><li><p>基于 HPACK 算法的 Header 压缩<br>使用 HPACK 算法（一种基于静态表、动态表和 Huffman 编码的编码算法）来压缩首部内容，避免了 header 字段数量多时每次都需要重复传输几百到几千字节的情况。</p></li><li><p>应用层的重置连接<br>对于 HTTP/1 来说，是通过设置 tcp segment 里的 reset flag 来通知对端关闭连接的。这种方式会直接断开连接，下次再发请求就必须重新建立连接。HTTP/2 引入 RST_STREAM 类型的 frame，可以在不断开连接的前提下取消某个 request 的 stream，表现更好。</p></li><li><p>请求优先级设置<br>HTTP/2 里的每个 stream 都可以设置依赖 (Dependency) 和权重，可以按依赖树分配优先级，解决了关键请求被阻塞的问题</p></li><li><p>流量控制<br>每个 http2 流都拥有自己的公示的流量窗口，它可以限制另一端发送数据。对于每个流来说，两端都必须告诉对方自己还有足够的空间来处理新的数据，而在该窗口被扩大前，另一端只被允许发送这么多数据。</p></li><li><p>HTTPS<br>强制必须使用 HTTPS</p></li></ol><h3 id="在HTTP2中不再适用的优化方法"><a href="#在HTTP2中不再适用的优化方法" class="headerlink" title="在HTTP2中不再适用的优化方法"></a>在HTTP2中不再适用的优化方法</h3><ol><li><p>域名分片<br>HTTP/2 对于同一域名使用一个 TCP 连接足矣，过多 TCP 连接浪费资源而且效果不见得一定好，而且资源分域会破坏 HTTP/2 的优先级特性，还会降低头部压缩效果</p></li><li><p>资源合并<br>资源合并会不利于缓存机制，而且单文件过大对于 HTTP/2 的传输不好，尽量做到细粒化更有利于 HTTP2 传输</p></li><li><p>资源内联<br>HTTP/2 支持 Server-Push，相比较内联优势更大效果更好，而且内联的资源不能有效缓存，如果有共用，多页面内联也会造成浪费</p></li></ol><h2 id="HTTP3"><a href="#HTTP3" class="headerlink" title="HTTP3"></a>HTTP3</h2><p>HTTP3 于 2018 年发布，它基于 Google 的 QUIC 协议，采用 UDP 协议进行传输，它主要解决了以下问题：</p><ul><li>HTTP3 基于 UDP 协议重新定义了连接，在 QUIC 层实现了无序、并发字节流的传输，解决了队头阻塞问题（包括基于QPACK解决了动态表的队头阻塞）</li><li>HTTP3 重新定义了 TLS 协议加密 QUIC 头部的方式，既提高了网络攻击成本，又降低了建立连接的速度（仅需1个 RTT 就可以同时完成建链与密钥协商）</li><li>HTTP3 将 Packet、QUIC Frame、HTTP3 Frame 分离，实现了连接迁移功能，降低了 5G 环境下高速移动设备的连接维护成本</li></ul><h3 id="HTTP3特性"><a href="#HTTP3特性" class="headerlink" title="HTTP3特性"></a>HTTP3特性</h3><ol><li><p>0-RTT（0 Round-trip Time）<br>在一次 TCP 连接中，需要进行3次握手（3-RTT），即使会话复用也需要至少2个RTT，QUIC 协议是建立在 UDP 的基础上的，在大部分情况下，只有在首次连接时需要 1 RTT，之后的链接只需要0-RTT。</p></li><li><p>基于 QUIC Stream 的多路复用<br>HTTP3 采用 UDP 作为传输层，又通过 QUIC 层实现了多路复用，保证实现数据流无序的并发传输和有序的交付。在 HTTP3 中，同一条 QUIC 连接上可以创建多个 stream 来发送多个 HTTP 请求，一个连接上的多个 stream 之间没有依赖，不会像 TCP 中存在队头阻塞。</p></li><li><p>连接迁移（Connection Migration）<br>TCP 基于 IP 和端口号识别客户端和服务器，在多变的移动端网络环境下会频繁的发起 TCP 连接。QUIC 通过基于连接上下文的 Connection ID 识别连接，无论网络环境如何变化，ID 不变就可以迅速连接上。</p></li><li><p>基于 QPACK 算法的 header 编码<br>HTTP3 中使用了类似 HPACK 算法的 QPACK 算法来进行 header 编码，旨在解决队头阻塞的问题</p></li><li><p>加密认证的报文<br>TCP 协议 header 没有经过加密和认证，在网络传输过程中容易被中间网络设备篡改、注入或窃听。QUIC 的传输单位是 Packet，加密单元也是 Packet，有效的降低了安全风险。</p></li><li><p>前向纠错机制（Forward Error Correction, FEC）<br>QUIC 使用前向纠错来增加协议的容错性。一段数据被切分为 10 个包后，对每个包进行异或运算，结果作为 FEC 包和数据包一起传输，如果有一个数据包丢失，可以根据剩余的 9 个包来推算出丢失的包数据，也即通过适当的数据冗余减少数据重传的操作。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue-keep-alive实现原理</title>
      <link href="/blog/2021/04/21/Vue-keep-alive%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/blog/2021/04/21/Vue-keep-alive%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本文介绍的内容包括：</p><ul><li>keep-alive用法：动态组件&amp;vue-router</li><li>keep-alive源码解析</li><li>keep-alive组件及其包裹组件的钩子</li><li>keep-alive组件及其包裹组件的渲染</li></ul><span id="more"></span><h2 id="二、keep-alive介绍与应用"><a href="#二、keep-alive介绍与应用" class="headerlink" title="二、keep-alive介绍与应用"></a>二、keep-alive介绍与应用</h2><h3 id="2-1-keep-alive是什么"><a href="#2-1-keep-alive是什么" class="headerlink" title="2.1 keep-alive是什么"></a>2.1 keep-alive是什么</h3><p>keep-alive是一个抽象组件：它自身不会渲染一个DOM元素，也不会出现在父组件链中；使用keep-alive包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。</p><h3 id="2-2-keep-alive适用场景"><a href="#2-2-keep-alive适用场景" class="headerlink" title="2.2 keep-alive适用场景"></a>2.2 keep-alive适用场景</h3><p>用户在某个列表页面选择筛选条件过滤出一份数据列表，由列表页面进入数据详情页面，再返回该列表页面，我们希望：列表页面可以保留用户的筛选（或选中）状态。</p><p>keep-alive就是用来解决这种场景。当然keep-alive不仅仅是能够保存页面/组件的状态这么简单，它还可以避免组件反复创建和渲染，有效提升系统性能。总的来说，keep-alive用于保存组件的渲染状态。</p><h3 id="2-3-keep-alive用法"><a href="#2-3-keep-alive用法" class="headerlink" title="2.3 keep-alive用法"></a>2.3 keep-alive用法</h3><p>在动态组件中的应用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">&quot;whiteList&quot;</span> <span class="attr">:exclude</span>=<span class="string">&quot;blackList&quot;</span> <span class="attr">:max</span>=<span class="string">&quot;amount&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;currentComponent&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在vue-router中的应用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">&quot;whiteList&quot;</span> <span class="attr">:exclude</span>=<span class="string">&quot;blackList&quot;</span> <span class="attr">:max</span>=<span class="string">&quot;amount&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><p>include定义缓存白名单，keep-alive会缓存命中的组件；exclude定义缓存黑名单，被命中的组件将不会被缓存；max定义缓存组件上限，超出上限使用LRU的策略置换缓存数据。</p><p>内存管理的一种页面置换算法，对于在内存中但又不用的数据块（内存块）叫做LRU，操作系统会根据哪些数据属于LRU而将其移出内存而腾出空间来加载另外的数据。</p><h2 id="三、源码剖析"><a href="#三、源码剖析" class="headerlink" title="三、源码剖析"></a>三、源码剖析</h2><p>keep-alive.js 内部还定义了一些工具函数，我们按住不动，先看它对外暴露的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/components/keep-alive.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">  <span class="attr">abstract</span>: <span class="literal">true</span>, <span class="comment">// 判断当前组件虚拟dom是否渲染成真实dom的关键</span></span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">include</span>: patternTypes, <span class="comment">// 缓存白名单</span></span><br><span class="line">      <span class="attr">exclude</span>: patternTypes, <span class="comment">// 缓存黑名单</span></span><br><span class="line">      <span class="attr">max</span>: [<span class="title class_">String</span>, <span class="title class_">Number</span>] <span class="comment">// 缓存的组件</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">cache</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>) <span class="comment">// 缓存虚拟dom</span></span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">keys</span> = [] <span class="comment">// 缓存的虚拟dom的键集合</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">destroyed</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="variable language_">this</span>.<span class="property">cache</span>) &#123;</span><br><span class="line">       <span class="comment">// 删除所有的缓存</span></span><br><span class="line">       <span class="title function_">pruneCacheEntry</span>(<span class="variable language_">this</span>.<span class="property">cache</span>, key, <span class="variable language_">this</span>.<span class="property">keys</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"> <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="comment">// 实时监听黑白名单的变动</span></span><br><span class="line">   <span class="variable language_">this</span>.$watch(<span class="string">&#x27;include&#x27;</span>, <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="title function_">pruneCache</span>(<span class="variable language_">this</span>, <span class="function"><span class="params">name</span> =&gt;</span> <span class="title function_">matched</span>(val, name))</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="variable language_">this</span>.$watch(<span class="string">&#x27;exclude&#x27;</span>, <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="title function_">pruneCache</span>(<span class="variable language_">this</span>, <span class="function"><span class="params">name</span> =&gt;</span> !<span class="title function_">matches</span>(val, name))</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;,</span><br><span class="line"></span><br><span class="line"> <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 先省略...</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，与我们定义组件的过程一样，先是设置组件名为keep-alive，其次定义了一个abstract属性，值为true。这个属性在vue的官方教程并未提及，却至关重要，后面的渲染过程会用到。props属性定义了keep-alive组件支持的全部参数。</p><p>keep-alive在它生命周期内定义了三个钩子函数：</p><ul><li><p>created<br>初始化两个对象分别缓存VNode(虚拟DOM)和VNode对应的键集合</p></li><li><p>destroyed<br>删除this.cache中缓存的VNode实例。我们留意到，这不是简单地将this.cache置为null，而是遍历调用pruneCacheEntry函数删除。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/components/keep-alive.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pruneCacheEntry</span> (</span><br><span class="line">  <span class="attr">cache</span>: <span class="title class_">VNodeCache</span>,</span><br><span class="line">  <span class="attr">key</span>: string,</span><br><span class="line">  <span class="attr">keys</span>: <span class="title class_">Array</span>&lt;string&gt;,</span><br><span class="line">  current?: <span class="title class_">VNode</span></span><br><span class="line">) &#123;</span><br><span class="line"> <span class="keyword">const</span> cached = cache[key]</span><br><span class="line"> <span class="keyword">if</span> (cached &amp;&amp; (!current || cached.<span class="property">tag</span> !== current.<span class="property">tag</span>)) &#123;</span><br><span class="line">    cached.<span class="property">componentInstance</span>.$destroyed() <span class="comment">// 执行组件的destroy钩子函数</span></span><br><span class="line"> &#125;</span><br><span class="line"> cache[key] = <span class="literal">null</span></span><br><span class="line"> <span class="title function_">remove</span>(keys, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除缓存的VNode还要对应组件实例的destory钩子函数</p><ul><li>mounted<br>在mounted这个钩子中对include和exclude参数进行监听，然后实时地更新（删除）this.cache对象数据。pruneCache函数的核心也是去调用pruneCacheEntry</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">pruneCache</span> (<span class="attr">keepAliveInstance</span>: any, <span class="attr">filter</span>: <span class="title class_">Function</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; cache, keys, _vnode &#125; = keepAliveInstance</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> cache) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">cachedNode</span>: ?<span class="title class_">VNode</span> = cache[key]</span><br><span class="line">    <span class="keyword">if</span> (cachedNode) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="attr">name</span>: ?string = <span class="title function_">getComponentName</span>(cachedNode.<span class="property">componentOptions</span>)</span><br><span class="line">      <span class="keyword">if</span> (name &amp;&amp; !<span class="title function_">filter</span>(name)) &#123;</span><br><span class="line">        <span class="title function_">pruneCacheEntry</span>(cache, key, keys, _vnode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>render</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">  <span class="keyword">const</span> slot = <span class="variable language_">this</span>.<span class="property">$slots</span>.<span class="property">defalut</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">vnode</span>: <span class="title class_">VNode</span> = <span class="title function_">getFirstComponentChild</span>(slot) <span class="comment">// 找到第一个子组件对象</span></span><br><span class="line">  <span class="keyword">const</span> componentOptions : ?<span class="title class_">VNodeComponentOptions</span> = vnode &amp;&amp; vnode.<span class="property">componentOptions</span></span><br><span class="line">  <span class="keyword">if</span> (componentOptions) &#123; <span class="comment">// 存在组件参数</span></span><br><span class="line">    <span class="comment">// check pattern</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">name</span>: ?string = <span class="title function_">getComponentName</span>(componentOptions) <span class="comment">// 组件名</span></span><br><span class="line">    <span class="keyword">const</span> &#123; include, exclude &#125; = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">// 条件匹配</span></span><br><span class="line">      <span class="comment">// not included</span></span><br><span class="line">      （include &amp;&amp; (!name || !<span class="title function_">matches</span>(include, name))）||</span><br><span class="line">      <span class="comment">// excluded</span></span><br><span class="line">        (exclude &amp;&amp; name &amp;&amp; <span class="title function_">matches</span>(exclude, name))</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">return</span> vnode</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> &#123; cache, keys &#125; = <span class="variable language_">this</span></span><br><span class="line">    <span class="comment">// 定义组件的缓存key</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">key</span>: ?string = vnode.<span class="property">key</span> === <span class="literal">null</span> ? componentOptions.<span class="property">Ctor</span>.<span class="property">cid</span> + (componentOptions.<span class="property">tag</span> ? <span class="string">`::<span class="subst">$&#123;componentOptions.tag&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>) : vnode.<span class="property">key</span></span><br><span class="line">     <span class="keyword">if</span> (cache[key]) &#123; <span class="comment">// 已经缓存过该组件</span></span><br><span class="line">        vnode.<span class="property">componentInstance</span> = cache[key].<span class="property">componentInstance</span></span><br><span class="line">        <span class="title function_">remove</span>(keys, key)</span><br><span class="line">        keys.<span class="title function_">push</span>(key) <span class="comment">// 调整key排序</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cache[key] = vnode <span class="comment">//缓存组件对象</span></span><br><span class="line">        keys.<span class="title function_">push</span>(key)</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">max</span> &amp;&amp; keys.<span class="property">length</span> &gt; <span class="built_in">parseInt</span>(<span class="variable language_">this</span>.<span class="property">max</span>)) &#123;</span><br><span class="line">          <span class="comment">//超过缓存数限制，将第一个删除</span></span><br><span class="line">          <span class="title function_">pruneCacheEntry</span>(cahce, keys[<span class="number">0</span>], keys, <span class="variable language_">this</span>.<span class="property">_vnode</span>)</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">      vnode.<span class="property">data</span>.<span class="property">keepAlive</span> = <span class="literal">true</span> <span class="comment">//渲染和执行被包裹组件的钩子函数需要用到</span></span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> vnode || (slot &amp;&amp; slot[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第一步：获取keep-alive包裹着的第一个子组件对象及其组件名；</li><li>第二步：根据设定的黑白名单（如果有）进行条件匹配，决定是否缓存。不匹配，直接返回组件实例（VNode），否则执行第三步；</li><li>第三步：根据组件ID和tag生成缓存Key，并在缓存对象中查找是否已缓存过该组件实例。如果存在，直接取出缓存值并更新该key在this.keys中的位置（更新key的位置是实现LRU置换策略的关键），否则执行第四步；</li><li>第四步：在this.cache对象中存储该组件实例并保存key值，之后检查缓存的实例数量是否超过max设置值，超过则根据LRU置换策略删除最近最久未使用的实例（即是下标为0的那个key）;</li><li>第五步：最后并且很重要，将该组件实例的keepAlive属性值设置为true。</li></ul><h2 id="四、重头戏：渲染"><a href="#四、重头戏：渲染" class="headerlink" title="四、重头戏：渲染"></a>四、重头戏：渲染</h2><h3 id="4-1-Vue的渲染过程"><a href="#4-1-Vue的渲染过程" class="headerlink" title="4.1 Vue的渲染过程"></a>4.1 Vue的渲染过程</h3><p>借助一张图看下Vue渲染的整个过程：<br><img src="/blog/static/imgs/vue/vue_render.webp" alt="vue渲染过程_inner.png"></p><p>Vue的渲染是从图中render阶段开始的，但keep-alive的渲染是在patch阶段，这是构建组件树（虚拟DOM树），并将VNode转换成真正DOM节点的过程。<br>简单描述从render到patch的过，我们从最简单的new Vue开始：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>Vue在渲染的时候先调用原型上的_render函数将组件对象转化成一个VNode实例；而_render是通过调用createElement和createEmptyVNode两个函数进行转化；<br>createElement的转化过程会根据不同的情形选择new VNode或者调用createComponent函数做VNode实例化；<br>完成VNode实例化后，这时候Vue调用原型上的_update函数把VNode渲染成真实DOM，这个过程又是通过调用patch函数完成的（这就是patch阶段了）<br>用一张图表达：<br><img src="/blog/static/imgs/vue/vue_process.webp" alt="渲染过程_inner.png"></p><h3 id="4-2-keep-alive组件的渲染"><a href="#4-2-keep-alive组件的渲染" class="headerlink" title="4.2 keep-alive组件的渲染"></a>4.2 keep-alive组件的渲染</h3><p>我们用过keep-alive都知道，它不会生成真正的DOM节点，这是怎么做到的？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/lifecycle.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">initLifecycle</span> (<span class="attr">vm</span>: <span class="title class_">Component</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> options= vm.<span class="property">$options</span></span><br><span class="line">    <span class="comment">// 找到第一个非abstract父组件实例</span></span><br><span class="line">    <span class="keyword">let</span> parent = options.<span class="property">parent</span></span><br><span class="line">    <span class="keyword">if</span> (parent &amp;&amp; !options.<span class="property">abstract</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (parent.<span class="property">$options</span>.<span class="property">abstract</span> &amp;&amp; parent.<span class="property">$parent</span>) &#123;</span><br><span class="line">              parent = parent.<span class="property">$parent</span></span><br><span class="line">        &#125;</span><br><span class="line">        parent.<span class="property">$children</span>.<span class="title function_">push</span>(vm)</span><br><span class="line">    &#125;</span><br><span class="line">    vm.<span class="property">$parent</span> = parent</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vue在初始化生命周期的时候，为组件实例建立父子关系会根据abstract属性决定是否忽略某个组件。在keep-alive中，设置了abstract:true，那Vue就会跳过该组件实例。</p><p>最后构建的组件树中就不会包含keep-alive组件，那么由组件树渲染成的DOM树自然也不会有keep-alive相关的节点了。</p><p><strong>keep-alive包裹的组件是如何使用缓存的？</strong><br>在patch阶段，会执行createComponent函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/vdom/patch.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createComponent</span> (vnode, insertedVnodeQueue, parentElm, refElm) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = vnode.<span class="property">data</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(i)) &#123;</span><br><span class="line">        <span class="keyword">const</span> isReactivated = <span class="title function_">isDef</span>(vnode.<span class="property">componentInstance</span>) &amp;&amp; i.<span class="property">keepAlive</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isDef</span>(i = i.<span class="property">hook</span>) &amp;&amp; <span class="title function_">isDef</span>(i = i.<span class="property">init</span>)) &#123;</span><br><span class="line">            <span class="title function_">i</span>(vnode, <span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isDef</span>(vnode.<span class="property">componentInstance</span>)) &#123;</span><br><span class="line">            <span class="title function_">initComponent</span>(vnode, insertedVnodeQueue)</span><br><span class="line">            <span class="title function_">insert</span>(parentElem, vnode.<span class="property">elem</span>, refElem) <span class="comment">// 将缓存的DOM(vnode.elem) 插入父元素中</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">isTrue</span>(isReactivated)) &#123;</span><br><span class="line">                <span class="title function_">reactivateComponent</span>(vnode, insertedVnodeQueue, parentEle, refElm)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在首次加载被包裹组建时，由keep-alive.js中的render函数可知，vnode.componentInstance的值是undfined，keepAlive的值是true，因为keep-alive组件作为父组件，它的render函数会先于被包裹组件执行；那么只执行到i(vnode,false)，后面的逻辑不执行；</li><li>再次访问被包裹组件时，vnode.componentInstance的值就是已经缓存的组件实例，那么会执行insert(parentElm, vnode.elm, refElm)逻辑，这样就直接把上一次的DOM插入到父元素中。</li></ul><h2 id="五、不可忽视：钩子函数"><a href="#五、不可忽视：钩子函数" class="headerlink" title="五、不可忽视：钩子函数"></a>五、不可忽视：钩子函数</h2><h3 id="5-1-只执行一次的钩子"><a href="#5-1-只执行一次的钩子" class="headerlink" title="5.1 只执行一次的钩子"></a>5.1 只执行一次的钩子</h3><p>一般的组件，每一次加载都会有完整的生命周期，即生命周期里面对于的钩子函数都会被触发，为什么被keep-alive包裹的组件却不是呢？<br>被缓存的组件实例会为其设置keepAlive= true，而在初始化组件钩子函数中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/vdom/create-component.js</span></span><br><span class="line"><span class="keyword">const</span> componentVNodeHooks = &#123;</span><br><span class="line">    init (<span class="attr">vnode</span>: <span class="title class_">VNodeWithData</span>, <span class="attr">hydrating</span>: boolean): ?boolean&#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">         vnode.<span class="property">componentInstance</span> &amp;&amp;       </span><br><span class="line">         !vnode.<span class="property">componentInstance</span>.<span class="property">_isDestroyed</span> &amp;&amp;</span><br><span class="line">         vnode.<span class="property">data</span>.<span class="property">keepAlive</span></span><br><span class="line">        ) &#123;</span><br><span class="line">          <span class="comment">// keep-alive components, treat as a patch</span></span><br><span class="line">          <span class="keyword">const</span> <span class="attr">mountedNode</span>:any = vnode</span><br><span class="line">          componentVNodeHooks.<span class="title function_">prepatch</span>(mountedNode, mountedNode)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> child = vnode.<span class="property">componentInstance</span> = createComponentInstanceForVnode (vnode, activeInstance)</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，当vnode.componentInstance和keepAlive同时为true时，不再进入$mount过程，那mounted之前的所有钩子函数（beforeCreate、created、mounted）都不再执行。</p><h3 id="5-2-可重复的activated"><a href="#5-2-可重复的activated" class="headerlink" title="5.2 可重复的activated"></a>5.2 可重复的activated</h3><p>在patch的阶段，最后会执行invokeInsertHook函数，而这个函数就是去调用组件实例（VNode）自身的insert钩子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/vdom/patch.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">invokeInsertHook</span> (vnode, queue, initial) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isTrue</span>(initial) &amp;&amp; <span class="title function_">isDef</span>(vnode.<span class="property">parent</span>)) &#123;</span><br><span class="line">          vnode.<span class="property">parent</span>.<span class="property">data</span>,pendingInsert = queue</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>; i&lt;queue.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">                queue[i].<span class="property">data</span>.<span class="property">hook</span>.<span class="title function_">insert</span>(queue[i]) <span class="comment">// 调用VNode自身的insert钩子函数</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看insert钩子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> componentVNodeHooks = &#123;</span><br><span class="line">      <span class="comment">// init()</span></span><br><span class="line">     insert (<span class="attr">vnode</span>: <span class="title class_">MountedComponentVNode</span>) &#123;</span><br><span class="line">           <span class="keyword">const</span> &#123; context, componentInstance &#125; = vnode</span><br><span class="line">           <span class="keyword">if</span> (!componentInstance.<span class="property">_isMounted</span>) &#123;</span><br><span class="line">                 componentInstance.<span class="property">_isMounted</span> = <span class="literal">true</span></span><br><span class="line">                 <span class="title function_">callHook</span>(componentInstance, <span class="string">&#x27;mounted&#x27;</span>)</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (vnode.<span class="property">data</span>.<span class="property">keepAlive</span>) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (context.<span class="property">_isMounted</span>) &#123;</span><br><span class="line">                     <span class="title function_">queueActivatedComponent</span>(componentInstance)</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      <span class="title function_">activateChildComponent</span>(componentInstance, <span class="literal">true</span><span class="comment">/* direct */</span>)</span><br><span class="line">                 &#125;</span><br><span class="line">          &#125;</span><br><span class="line">         <span class="comment">// ...</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个钩子里面，调用了activateChildComponent函数递归地去执行所有子组件的activated钩子函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/lifecycle.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">activateChildComponent</span> (<span class="attr">vm</span>: <span class="title class_">Component</span>, direct?: boolean) &#123;</span><br><span class="line">  <span class="keyword">if</span> (direct) &#123;</span><br><span class="line">    vm.<span class="property">_directInactive</span> = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isInInactiveTree</span>(vm)) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vm.<span class="property">_directInactive</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vm.<span class="property">_inactive</span> || vm.<span class="property">_inactive</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    vm.<span class="property">_inactive</span> = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; vm.<span class="property">$children</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="title function_">activateChildComponent</span>(vm.<span class="property">$children</span>[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">callHook</span>(vm, <span class="string">&#x27;activated&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相反地，deactivated钩子函数也是一样的原理，在组件实例（VNode）的destroy钩子函数中调用deactivateChildComponent函数。</p><p>原文： https://www.jianshu.com/p/9523bb439950</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> keep-alive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSBridge</title>
      <link href="/blog/2021/04/20/FE-jsBridge/"/>
      <url>/blog/2021/04/20/FE-jsBridge/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是JSBridge"><a href="#什么是JSBridge" class="headerlink" title="什么是JSBridge"></a>什么是JSBridge</h2><p>在 JavaScript 代码中提供调用 Native 功能的接口，让混合开发中的前端部分可以方便地使用 Native 的功能（例如：地址位置、摄像头）。  </p><p>它的核心是构建 Native 和非 Native 间消息通信的通道，而且这个通信的通道是双向的。  </p><span id="more"></span><h2 id="JSBridge-的实现原理"><a href="#JSBridge-的实现原理" class="headerlink" title="JSBridge 的实现原理"></a>JSBridge 的实现原理</h2><p>JavaScript 是运行在一个单独的 JS Context 中（例如，WebView 的 Webkit 引擎、JSCore）。由于这些 Context 与 Native 原生运行环境的天然隔离，我们必须通过一定的方法来实现 Native 和 JS Context 的双向通信。主要包括：   </p><ol><li>Native 调用 js 方法</li><li>js 调用 Native 方法</li></ol><h3 id="Native调用js方法"><a href="#Native调用js方法" class="headerlink" title="Native调用js方法"></a>Native调用js方法</h3><p>Native =&gt; JS</p><p>iOS</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webview.stringByEvaluatingJavaScriptFromString(<span class="string">&quot;Math.random()&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[webView stringByEvaluatingJavaScriptFromString:@&quot;Math.random();&quot;];</span><br></pre></td></tr></table></figure><p>Android<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mWebView.evaluateJavascript(<span class="string">&quot;javascript: Math.random();&quot;</span>, <span class="keyword">new</span> <span class="title class_">ValueCallback</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceiveValue</span><span class="params">(String value)</span> &#123;</span><br><span class="line">            <span class="comment">//这里的value即为对应JS方法的返回值</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>JS =&gt; Native</p><p>对于 Webview 中发起的网络请求，Native 都有能力去捕获/截取/干预。所以 JSBridge 的核心就是设计一套uri方案，让 Native 可以识别，从而做出响应，执行对应的操作。  </p><h3 id="js调用Native方法"><a href="#js调用Native方法" class="headerlink" title="js调用Native方法"></a>js调用Native方法</h3><p>JavaScript 调用 Native 的方式主要有两种，可以通过 <em>注入API</em> 和 <em>拦截URL SCHEME</em> 的方式来实现。</p><h4 id="注入API"><a href="#注入API" class="headerlink" title="注入API"></a>注入API</h4><p>注入 API 方式的主要原理是，通过 WebView 提供的接口，向 JavaScript 的 Context（window）中注入对象或者方法，让 JavaScript 调用时，直接执行相应的 Native 代码逻辑，达到 JavaScript 调用 Native 的目的。  </p><p>对于 iOS 的 UIWebView，实例如下：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JSContext *context = [uiWebView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];</span><br><span class="line"></span><br><span class="line">context[@&quot;postBridgeMessage&quot;] = ^(NSArray&lt;NSArray *&gt; *calls) &#123;</span><br><span class="line">    // Native 逻辑</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//前端调用方式：</span><br><span class="line">window.postBridgeMessage(message);</span><br></pre></td></tr></table></figure><p>对于 iOS 的 WKWebView 可以用以下方式：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@interface WKWebVIewVC ()&lt;WKScriptMessageHandler&gt;</span><br><span class="line"></span><br><span class="line">@implementation WKWebVIewVC</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    WKWebViewConfiguration* configuration = [[WKWebViewConfiguration alloc] init];</span><br><span class="line">    configuration.userContentController = [[WKUserContentController alloc] init];</span><br><span class="line">    WKUserContentController *userCC = configuration.userContentController;</span><br><span class="line">    // 注入对象，前端调用其方法时，Native 可以捕获到</span><br><span class="line">    [userCC addScriptMessageHandler:self name:@&quot;nativeBridge&quot;];</span><br><span class="line"></span><br><span class="line">    WKWebView wkWebView = [[WKWebView alloc] initWithFrame:self.view.frame configuration:configuration];</span><br><span class="line"></span><br><span class="line">    // 显示 WebView</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message &#123;</span><br><span class="line">    if ([message.name isEqualToString:@&quot;nativeBridge&quot;]) &#123;</span><br><span class="line">        NSLog(@&quot;前端传递的数据 %@: &quot;,message.body);</span><br><span class="line">        // Native 逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 前端调用方式：</span><br><span class="line">window.webkit.messageHandlers.nativeBridge.postMessage(message);</span><br></pre></td></tr></table></figure><p>Android 可以通过 <code>addJavascriptInterface</code> 方法 将 Native 的一个对象注入到页面中，供JS调用。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line">* 添加javascriptInterface </span><br><span class="line">* 第一个参数：这里需要一个与js映射的java对象 </span><br><span class="line">* 第二个参数：该java对象被映射为js对象后在js里面的对象名，在js中要调用该对象的方法就是通过这个来调用 </span><br><span class="line">*/  </span><br><span class="line"> webView.addJavascriptInterface(new JSInterface(), &quot;android&quot;);</span><br><span class="line"></span><br><span class="line"> private final class JSInterface&#123;  </span><br><span class="line">    /** </span><br><span class="line">     * 注意这里的@JavascriptInterface注解， target是4.2以上都需要添加这个注解，否则无法调用 </span><br><span class="line">     * @param text </span><br><span class="line">     */  </span><br><span class="line">    @JavascriptInterface  </span><br><span class="line">    public void showToast(String text)&#123;  </span><br><span class="line">         Toast.makeText(getApplicationContext(), text, Toast.LENGTH_SHORT).show();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">// 前端调用方式：</span><br><span class="line">android.showToast(&#x27;toast&#x27;);</span><br></pre></td></tr></table></figure><h4 id="拦截-URI-SCHEME"><a href="#拦截-URI-SCHEME" class="headerlink" title="拦截 URI SCHEME"></a>拦截 URI SCHEME</h4><p>URI SCHEME 是一种 uri 的链接，是为了方便app直接互相调用设计的，形式和普通的 uri 近似，主要区别是 protocol 和 host 是自定义的。<br>拦截 URI SCHEME 的主要流程是：Web 端通过某种方式（例如 iframe.src）发送 URI Scheme 请求，之后 Native 拦截到请求并根据 URI SCHEME（包括所带的参数）进行相关操作。  </p><p>在时间过程中，这种方式有一定的缺陷：  </p><ul><li>使用 iframe.src 发送 URL SCHEME 会有 url 长度的隐患。  </li><li>创建请求，需要一定的耗时，比注入 API 的方式调用同样的功能，耗时会较长。</li></ul><h2 id="JSBridge-接口实现"><a href="#JSBridge-接口实现" class="headerlink" title="JSBridge 接口实现"></a>JSBridge 接口实现</h2><p>从上面的剖析中，可以得知，JSBridge 的接口主要功能有两个：调用 Native（给 Native 发消息） 和 接被 Native 调用（接收 Native 消息）。因此，JSBridge 可以设计如下：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">JSBridge</span> = &#123;</span><br><span class="line">    <span class="comment">// 调用 Native</span></span><br><span class="line">    <span class="attr">invoke</span>: <span class="keyword">function</span>(<span class="params">bridgeName, data</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断环境，获取不同的 nativeBridge</span></span><br><span class="line">        nativeBridge.<span class="title function_">postMessage</span>(&#123;</span><br><span class="line">            <span class="attr">bridgeName</span>: bridgeName,</span><br><span class="line">            <span class="attr">data</span>: data || &#123;&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">receiveMessage</span>: <span class="keyword">function</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> bridgeName = msg.<span class="property">bridgeName</span>,</span><br><span class="line">            data = msg.<span class="property">data</span> || &#123;&#125;;</span><br><span class="line">        <span class="comment">// 具体逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于JSBridge的回调，和jsonp类似，url 参数里会有 callback 参数，其值是 当前页面唯一 的，而同时以此参数值为 key 将回调函数存到 window 上，随后，服务器返回 script 中，也会以此参数值作为句柄，调用相应的回调函数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js内存回收机制（垃圾处理机制）</title>
      <link href="/blog/2021/04/20/JS-js%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
      <url>/blog/2021/04/20/JS-js%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="js内存管理机制"><a href="#js内存管理机制" class="headerlink" title="js内存管理机制"></a>js内存管理机制</h2><p>JavaScript是在创建变量（对象，字符串等）时自动进行了分配内存，并且在不使用它们时“自动”释放。 释放的过程称为垃圾回收。  </p><span id="more"></span><h2 id="js存储"><a href="#js存储" class="headerlink" title="js存储"></a>js存储</h2><p>JavaScript中基础类型是保存在栈(stack)中的，会自动进行回收；而复合类型是保存在堆(dump)中的，通过 GC 操作进行空间释放。</p><h2 id="值的初始化"><a href="#值的初始化" class="headerlink" title="值的初始化"></a>值的初始化</h2><p>JavaScript 在定义变量时就完成了内存分配。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">123</span>; <span class="comment">// 给数值变量分配内存 存在栈中</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;azerty&quot;</span>; <span class="comment">// 给字符串分配内存 存在栈中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="literal">null</span></span><br><span class="line">&#125;; <span class="comment">// 给对象及其包含的值分配内存 指针存在栈中 值存在堆中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给数组及其包含的值分配内存（就像对象一样）</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="literal">null</span>, <span class="string">&quot;abra&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + <span class="number">2</span>;</span><br><span class="line">&#125; <span class="comment">// 给函数（可调用的对象）分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式也能分配一个对象</span></span><br><span class="line">someElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  someElement.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h2 id="通过函数调用分配内存"><a href="#通过函数调用分配内存" class="headerlink" title="通过函数调用分配内存"></a>通过函数调用分配内存</h2><p>有些函数调用结果是分配对象内存：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>(); <span class="comment">// 分配一个 Date 对象</span></span><br><span class="line"><span class="keyword">var</span> e = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>); <span class="comment">// 分配一个 DOM 元素</span></span><br></pre></td></tr></table></figure><p>有些方法分配新变量或者新对象：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;azerty&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = s.<span class="title function_">substr</span>(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// s2 是一个新的字符串</span></span><br><span class="line"><span class="comment">// 因为字符串是不变量，</span></span><br><span class="line"><span class="comment">// JavaScript 可能决定不分配内存，</span></span><br><span class="line"><span class="comment">// 只是存储了 [0-3] 的范围。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="string">&quot;ouais ouais&quot;</span>, <span class="string">&quot;nan nan&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> a2 = [<span class="string">&quot;generation&quot;</span>, <span class="string">&quot;nan nan&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> a3 = a.<span class="title function_">concat</span>(a2);</span><br><span class="line"><span class="comment">// 新数组有四个元素，是 a 连接 a2 的结果</span></span><br></pre></td></tr></table></figure><h2 id="使用值"><a href="#使用值" class="headerlink" title="使用值"></a>使用值</h2><p>使用值的过程实际上是对分配内存进行读取与写入的操作。读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数。  </p><h2 id="当内存不再需要使用时释放"><a href="#当内存不再需要使用时释放" class="headerlink" title="当内存不再需要使用时释放"></a>当内存不再需要使用时释放</h2><p>高级语言解释器嵌入了“垃圾回收器”，它的主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。  </p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。  </p><h3 id="引用计数器算法"><a href="#引用计数器算法" class="headerlink" title="引用计数器算法"></a>引用计数器算法</h3><p>引用计数器是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。该算法有个限制：无法处理循环引用的事例。  </p><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。这个算法假定设置一个叫做根（root）的对象（在 Javascript 里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。</p><p>从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。  </p><h2 id="js内存溢出的几种情况"><a href="#js内存溢出的几种情况" class="headerlink" title="js内存溢出的几种情况"></a>js内存溢出的几种情况</h2><ol><li>给DOM对象添加的属性是一个对象的引用  </li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyObject</span> = &#123;&#125;;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myDiv&#x27;</span>).<span class="property">myProp</span> = <span class="title class_">MyObject</span>;</span><br></pre></td></tr></table></figure><p>解决方法：<br>在window.onunload事件中写上:  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myDiv&#x27;</span>).<span class="property">myProp</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>DOM对象与JS对象相互引用  </li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Encapsulator</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">elementReference</span> = element;</span><br><span class="line">  element.<span class="property">myProp</span> = <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span>  <span class="title class_">Encapsulator</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myDiv&#x27;</span>));</span><br></pre></td></tr></table></figure><p>解决方法：<br>在onunload事件中写上:  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myDiv&#x27;</span>).<span class="property">myProp</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>给DOM对象用addEventListener绑定事件</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doClick</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&quot;onclick&quot;</span>, doClick);</span><br></pre></td></tr></table></figure><p>解决方法：<br>在onunload事件中写上:  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;onclick&#x27;</span>, doClick);</span><br></pre></td></tr></table></figure><ol start="4"><li>从外到内执行 appendChild 这时即使调用 removeChild 也无法释放</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parentDiv =  <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> childDiv = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(parentDiv);</span><br><span class="line">parentDiv.<span class="title function_">appendChild</span>(childDiv);</span><br></pre></td></tr></table></figure><p>解决方法：<br>从内到外执行appendChild:  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parentDiv =  <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> childDiv = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">parentDiv.<span class="title function_">appendChild</span>(childDiv);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(parentDiv);</span><br></pre></td></tr></table></figure><ol start="5"><li>反复重写同一个属性会造成内存大量占用</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">  hostElement.<span class="property">text</span> = <span class="string">&quot;asdfasdfasdf&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MVC MVP MVVM</title>
      <link href="/blog/2021/04/07/FE-MVC-MVP-MVVM/"/>
      <url>/blog/2021/04/07/FE-MVC-MVP-MVVM/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/blog/static/css/common.css"></link><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC最初是在研究Smalltalk-80（1979年）期间设计出来的，恐怕没有一本书能够回到计算机石器时代介绍一下Smalltalk的代码是如何实现MVC的，不仅如此，连想搞清楚当时的应用场景都很难了，都要追溯到80后出生以前的事了。在1995年出版的《设计模式：可复用面向对象软件的基础》对MVC进行了深入的阐述，在推广使用方面发挥了重要作用。  </p><p>MVC包括三类对象，将他们分离以提高灵活性和复用性。</p><ul><li><p>模型 model 用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法，会有一个或多个视图监听此模型。一旦模型的数据发生变化，模型将通知有关的视图。</p></li><li><p>视图 view 是它在屏幕上的表示，描绘的是model的当前状态。当模型的数据发生变化，视图相应地得到刷新自己的机会。</p></li><li><p>控制器 controller 定义用户界面对用户输入的响应方式，起到不同层面间的组织作用，用于控制应用程序的流程，它处理用户的行为和数据model上的改变。</p></li></ul><span id="more"></span><p><img src="/blog/static/imgs/typicalMVC.png" alt="经典MVC模式inner"></p><p class="caption">经典MVC模式</p><p>实线：方法调用 虚线：事件通知</p><p>其中涉及两种设计模式：  </p><ul><li>view 和 model 之间的观察者模式，view 观察 model，事先在此 model 上注册，以便 view 可以了解在数据 model 上发生的改变</li><li>view 和 controller 之间的策略模式</li></ul><p>一个策略是一个表述算法的对象，MVC 允许在不改变视图外观的情况下改变视图对用户输入的响应方式。例如，你可能希望改变视图对键盘的响应方式，或希望使用弹出菜单而不是原来的命令键方式。MVC 将响应机制封装在 controller 对象中。存在着一个 controller 的类层次结构，使得可以方便地对原有的 controller 做适当改变而创建新的controller。  </p><p>view 使用 controller 子类的实例来实现一个特定的响应策略。要实现不同的响应的策略只要用不同种类的 controller 实例替换即可。甚至可以在运行时刻通过改变 view 的 controller 来改变用户输入的响应方式。例如，一个 view 可以被禁止接受任何输入，只需给他一个忽略输入事件的 controller。  </p><h2 id="MVC-for-Javascript"><a href="#MVC-for-Javascript" class="headerlink" title="MVC for Javascript"></a>MVC for Javascript</h2><p><img src="/blog/static/imgs/javascriptMVC.png" alt="javascript MVC模式inner"></p><p class="caption">javascript MVC模式</p><p>如图所示，view 承接了部分 controller 的功能，负责处理用户输入，但是不必了解下一步做什么。它依赖于一个 controller 为它做决定或处理用户事件。事实上，前端的 view 已经具备了独立处理用户事件的能力，如果每个事件都要流经 controller ，势必增加复杂性。同时，view 也可以委托 controller 处理 model 的更改。model 数据变化后通知 view 进行更新，显示给用户。这个过程是一个圆，一个循环的过程。  </p><p>这种从经典 MVC 到 Javascript MVC 的1对1转化，导致控制器的角色有点尴尬。MVC 这样的结构的正确性在于，任何界面都需要面对一个用户，而 controller “是用户和系统之间的链接”。在经典 MVC 中，controller 要做的事情多数是派发用户输入给不同的 view，并且在必要的时候从 view 中获取用户输入来更改 model，而 Web 以及绝大多数现在的UI系统中，controller 的职责已经被系统实现了。由于某种原因，控制器和视图的分界线越来越模糊，也有认为， view 启动了 action 理论上应该把 view 归属于 controller。比如在 Backbone 中，Backbone.View 和 Backbone.Router 一起承担了 controller 的责任。这就为 MVC 中 controller 的衍变埋下了伏笔。  </p><h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>MVP（Model-View-Presenter）是经典 MVC 设计模式的一种衍生模式，是在1990年代 Taligent 公司创造的，一个用于 C++ CommonPoint 的模型。背景上不再考证，直接上图看一下与MVC的不同。  </p><p><img src="/blog/static/imgs/mvp.png" alt="MVP模式inner"></p><p class="caption">MVP模式</p><p>经典 MVC 中，一对 controller-view 捆绑起来表示一个 ui 组件，controller 直接接受用户输入，并将输入转为相应命令来调用 model 的接口，对 model 的状态进行修改，最后通过观察者模式对 view 进行重新渲染。  </p><p>进化为 MVP 的切入点是修改 controller-view 的捆绑关系，为了解决 controller-view 的捆绑关系，将进行改造，使 view 不仅拥有UI组件的结构，还拥有处理用户事件的能力，这样就能将 controller 独立出来。为了对用户事件进行统一管理，view 只负责将用户产生的事件传递给 controller，由 controller 来统一处理，这样的好处是多个 view 可共用同一个 controller。此时的 controller 也由组件级别上升到了应用级别，然而更新 view 的方式仍然与经典 MVC 一样：通过 Presenter 更新 model，通过观察者模式更新 view。  </p><p>另一个显而易见的不同在于，MVC 是一个圆，一个循环的过程，但 MVP 不是，依赖 Presenter 作为核心，负责从 model 中拿数据，填充到 view 中。常见的 MVP 的实现是被动视图（passive view），Presenter 观察 model，不再是 view 观察 model，一旦 model 发生变化，就会更新 view。Presenter 有效地绑定了 model 到 view。view 暴露了 setters 接口以便 Presenter 可以设置数据。对于这种被动视图的结构，没有直接数据绑定的概念。但是他的好处是在 view 和 model 直接提供更清晰的分离。但是由于缺乏数据绑定支持，意味着不得不单独关注某个任务。在 MVP 里，应用程序的逻辑主要在 Presenter 来实现，其中的 view 是很薄的一层。  </p><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>MVVM，Model-View-ViewModel，最初是由 Microsoft 在使用 Windows Presentation Foundation 和 SilverLight 时定义的，2005年 John Grossman 在一篇关于 Avalon（WPF 的代号）的博客文章中正式宣布了它的存在。其中最重要的特性之一就是数据绑定（Data-binding）。  </p><p><img src="/blog/static/imgs/mvvm.png" alt="MVVM模式inner"></p><p class="caption">MVVM模式</p><p>首先，view 和 model 是不知道彼此存在的，同 MVP 一样，将 view 和 model 清晰地分离开来。 其次，view 是对 viewmodel 的外在显示，与 viewmodel 保持同步，viewmodel 对象可以看作是 view 的上下文。view 绑定到 viewmodel 的属性上，如果 viewmodel 中的属性值变化了，这些新值通过数据绑定会自动传递给 view。反过来 viewmodel 会暴露 model 中的数据和特定状态给 view。 所以，view 不知道 model 的存在，viewmodel 和 model 也觉察不到 view。事实上，model 也完全忽略 viewmodel 和 view 的存在。这是一个非常松散耦合的设计。  </p><h2 id="MVVM的优缺点"><a href="#MVVM的优缺点" class="headerlink" title="MVVM的优缺点"></a>MVVM的优缺点</h2><p>优点:</p><ul><li>分离视图（View）和模型（Model），降低代码耦合，提⾼视图或者逻辑的重⽤性: ⽐如视图（View）可以独⽴于 Model 变化和修改，⼀个 ViewModel 可以绑定不同的 View 上，当 View 变化的时候 Model 不可以不变，当 Model 变化的时候 View 也可以不变。你可以把⼀些视图逻辑放在⼀个 ViewModel ⾥⾯，让很多 View 重⽤这段视图逻辑</li><li>⾃动更新dom，提升开发效率: 利⽤双向绑，数据更新后视图⾃动更新，让开发者从繁琐的⼿动dom操作中解放</li><li>提⾼可测试性: ViewModel 的存在可以帮助开发者更好地编写测试代码</li></ul><p>缺点:</p><ul><li>Bug很难被调试: 因为使⽤双向绑定的模式，当你看到界⾯异常了，有可能是你 View 的代码有 Bug，也可能是 Model 的代码有问题。数据绑定使得⼀个位置的 Bug 被快速传递到别的位置，要定位原始出问题的地⽅就变得不那么容易了。另外，数据绑定的声明是指令式地写在 View 的模版当中的，这些内容是没办法去打断点 debug 的</li><li>⼀个⼤的模块中 Model 也会很⼤，虽然使⽤⽅便了也很容易保证了数据的⼀致性，但如果⻓期持有，就会占用更多的内存</li><li>对于⼤型的图形应⽤程序，视图状态较多，ViewModel 的构建和维护的成本都会⽐较⾼。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> mvc </tag>
            
            <tag> mvvm </tag>
            
            <tag> framework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在ES6中管理类的私有数据</title>
      <link href="/blog/2021/04/06/JS-%E5%A6%82%E4%BD%95%E5%9C%A8ES6%E4%B8%AD%E7%AE%A1%E7%90%86%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE/"/>
      <url>/blog/2021/04/06/JS-%E5%A6%82%E4%BD%95%E5%9C%A8ES6%E4%B8%AD%E7%AE%A1%E7%90%86%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p>如何在ES6中管理类的私有数据？本文为你介绍四种方法：  </p><ul><li>在类的构造函数作用域中处理私有数据成员</li><li>遵照命名约定（例如前置下划线）标记私有属性</li><li>将私有数据保存在WeakMap中</li><li>使用Symbol作为私有属性的键</li></ul><span id="more"></span><p>对构造函数来说，前两种方法在 ES5 中已经很常见了，后两种方法是 ES6 中新出现的。现在我们在同一个案例上分别用这四种方法来实践一下：  </p><h2 id="1-在类的构造函数作用域中处理私有数据成员"><a href="#1-在类的构造函数作用域中处理私有数据成员" class="headerlink" title="1. 在类的构造函数作用域中处理私有数据成员"></a>1. 在类的构造函数作用域中处理私有数据成员</h2><p>我们要演示的这段代码是一个名为 <code>Countdown</code> 的类在 <code>counter</code>（初始值为 counter）变成0时触发一个名为 <code>action</code> 的回调函数。其中 <code>action</code> 和 <code>counter</code> 两个参数应被存储为私有数据。  </p><p>在这个实现方案中，我们将 <code>action</code> 和 <code>counter</code> 存储在 <code>constructor</code> 这个类的环境里面。环境是指JS引擎存储参数和本地变量的内部数据结构，变量存在即可，无论是否进入一个新的作用域（例如通过一个函数调用或者一个类调用）。来看看代码：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Countdown</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">counter, action</span>) &#123;</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="variable language_">this</span>, &#123;</span><br><span class="line">            <span class="title function_">dec</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (counter &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">                counter--;</span><br><span class="line">                <span class="keyword">if</span> (counter === <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="title function_">action</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后这样使用 Countdown：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title class_">Countdown</span>(<span class="number">2</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;DONE&#x27;</span>));</span><br><span class="line">&gt; c.<span class="title function_">dec</span>();</span><br><span class="line">&gt; c.<span class="title function_">dec</span>();</span><br><span class="line"><span class="variable constant_">DONE</span></span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>私有数据非常安全；</li><li>私有属性的命名不会与其他父类或子类的私有属性命名冲突。</li></ul><p>缺点：</p><ul><li>当你需要在构造函数内把所有方法（至少那些需要用到私有数据的方法）添加到实例的时候，代码看起来就没那么优雅了；</li><li>作为实例方法，代码会浪费内存；如果作为原型方法，则会被共享。</li></ul><p>关于此方法的更多内容请参考：《Speaking Javascript》的 <a href="http://speakingjs.com/es5/ch17.html#private_data_constructor_environment">Private Data in the Environment of a Constructor (Crockford Privacy Pattern)</a> (构造函数环境中的私有数据)章节。  </p><h2 id="2-通过命名约定来标记私有属性"><a href="#2-通过命名约定来标记私有属性" class="headerlink" title="2. 通过命名约定来标记私有属性"></a>2. 通过命名约定来标记私有属性</h2><p>下面的代码将私有数据保存在添加了前置下划线命名的属性中：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Countdown</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">counter, action</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_counter</span> = counter;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_action</span> = action;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">dec</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_counter</span> &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_counter</span>--;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_counter</span> === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">_action</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>代码比较美观；</li><li>可以使用原型方法。</li></ul><p>缺点：</p><ul><li>不够安全，只能用规范去约束用户代码；</li><li>私有属性的命名容易冲突。</li></ul><h2 id="3-通过-WeakMaps-保存私有数据"><a href="#3-通过-WeakMaps-保存私有数据" class="headerlink" title="3. 通过 WeakMaps 保存私有数据"></a>3. 通过 WeakMaps 保存私有数据</h2><p>有一个利用 WeakMap 的小技巧，结合了方法一和方法二各自的优点：安全性和能够使用原型方法。可以参考以下代码：我们利用 <code>_counter</code> 和 <code>_action</code> 两个WeakMap来存储私有数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _counter = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">let</span> _action = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Countdown</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">counter, action</span>) &#123;</span><br><span class="line">        _counter.<span class="title function_">set</span>(<span class="variable language_">this</span>, counter);</span><br><span class="line">        _action.<span class="title function_">set</span>(<span class="variable language_">this</span>, action);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">dec</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> counter = _counter.<span class="title function_">get</span>(<span class="variable language_">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (counter &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        counter--;</span><br><span class="line">        _counter.<span class="title function_">set</span>(<span class="variable language_">this</span>, counter);</span><br><span class="line">        <span class="keyword">if</span> (counter === <span class="number">0</span>) &#123;</span><br><span class="line">            _action.<span class="title function_">get</span>(<span class="variable language_">this</span>)();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_counter</code> 和 <code>_action</code> 这两个 WeakMap 都分别指向各自的私有数据。由于 WeakMap 的设计目的在于键名是对象的弱引用，其所对应的对象可能会被自动回收，只要不暴露 WeakMap ，私有数据就是安全的。如果想要更加保险一点，可以将 <code>WeakMap.prototype.get</code> 和 <code>WeakMap.prototype.set</code> 存储起来再调用（动态地代替方法）。这样即使有恶意代码篡改了可以窥探到私有数据的方法，我们的代码也不会受到影响。但是，我们只保护我们的代码不受在其之后执行的代码的干扰，并不能防御先于我们代码执行的代码。  </p><p>优点：</p><ul><li>可以使用原型方法；</li><li>比属性命名约定更加安全；</li><li>私有属性命名不会冲突。</li></ul><p>缺点:</p><ul><li>代码不如命名约定优雅。</li></ul><h2 id="4-使用Symbol作为私有属性的键名"><a href="#4-使用Symbol作为私有属性的键名" class="headerlink" title="4. 使用Symbol作为私有属性的键名"></a>4. 使用Symbol作为私有属性的键名</h2><p>另外一个存储私有数据的方式是用 Symbol 作为其属性的键名：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _counter = <span class="title class_">Symbol</span>(<span class="string">&#x27;counter&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> _action = <span class="title class_">Symbol</span>(<span class="string">&#x27;action&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Countdown</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">counter, action</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>[_counter] = counter;</span><br><span class="line">        <span class="variable language_">this</span>[_action] = action;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">dec</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>[_counter] &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="variable language_">this</span>[_counter]--;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>[_counter] === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>[_action]();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个 Symbol 都是唯一的，这就是为什么使用 Symbol 的属性键名之间不会冲突的原因。并且，Symbol 某种程度上来说是隐式的，但也并不完全是：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title class_">Countdown</span>(<span class="number">2</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;DONE&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(c));</span><br><span class="line"><span class="comment">// []</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(c));</span><br><span class="line"><span class="comment">// [Symbol(counter), Symbol(action)]</span></span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>可以使用原型方法；</li><li>私有属性命名不会冲突。</li></ul><p>缺点：</p><ul><li>代码不如命名约定优雅；</li><li>不太安全：可以通过 Reflect.ownKeys() 列出一个对象所有的属性键名（即使用了 Symbol）。</li></ul><p>延伸阅读：  </p><p>Sect. <a href="http://speakingjs.com/es5/ch17.html#private_data_for_objects">“Keeping Data Private”</a> in “Speaking JavaScript” (covers ES5 techniques)<br>Chap. <a href="http://exploringjs.com/es6/ch_classes.html">“Classes”</a> in “Exploring ES6”<br>Chap. <a href="http://exploringjs.com/es6/ch_symbols.html">“Symbols”</a> in “Exploring ES6”</p><p>原文：http://www.2ality.com/2016/01/private-data-classes.html</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sass、Scss、Less和Stylus的作用和区别</title>
      <link href="/blog/2021/04/01/FE-Sass%E3%80%81Less%E5%92%8CStylus%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%8C%BA%E5%88%AB/"/>
      <url>/blog/2021/04/01/FE-Sass%E3%80%81Less%E5%92%8CStylus%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS-预处理器"><a href="#CSS-预处理器" class="headerlink" title="CSS 预处理器"></a>CSS 预处理器</h2><p><a href="https://github.com/sass/sass">Sass</a> (Syntactically Awesome StyleSheets)，是由Ruby语言编写的一款css预处理语言，诞生于2007年，有着严格的缩进风格。官方样式库为 <a href="http://compass-style.org/">Compass</a>。  </p><p>Scss (Sassy CSS)，一款css预处理语言，SCSS 是 Sass 3 引入新的语法，其语法完全兼容 CSS3，并且继承了 Sass 的强大功能。SCSS 需要使用分号和花括号而不是换行和缩进。SCSS 对空白符号不敏感。兼容CSS。  </p><p><a href="https://github.com/less/less.js">Less</a> 是由 <a href="https://github.com/cloudhead">Alexis Sellier</a>于2009年编写的一个CSS 预处理器，最开始由 Ruby 书写，后来改为 JavaScript。Less 由 Sass 启发，语法更接近于CSS，完全兼容CSS。  </p><p><a href="https://github.com/stylus/stylus">Stylus</a> 是由 <a href="https://github.com/tj">TJ Holowaychuk</a> 编写的一款CSS预处理器，诞生于2010年。官方样式库为 <a href="https://github.com/stylus/nib">nib</a>  </p><p>这些CSS预处理器都支持一些常用的CSS语法扩展，比如<br>变量 (variables)、嵌套 (nested rules)、混合 (mixins)、继承(extends)、导入 (imports)、函数（functions）<br>但在语法和功能性上有些许差异。  </p><span id="more"></span><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>Scss 优点：功能更强大，文档丰富，缺点：在国内使用较少，安装不太方便<br>Less 优点：语法简单，国内使用量较多 缺点：功能支持上不丰富<br>Stylus 优点：功能强大，语法简洁，框架较新，社区活跃，缺点：与原生css语法差异较大</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>Less &amp; Scss：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sass &amp; Stylus:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span></span><br><span class="line">  <span class="attribute">display</span>: block</span><br></pre></td></tr></table></figure><h2 id="嵌套语法-nested-rule"><a href="#嵌套语法-nested-rule" class="headerlink" title="嵌套语法 nested rule"></a>嵌套语法 nested rule</h2><p>三者的嵌套语法都是一致的，引用父级选择器的标记均为 <code>&amp;</code> 以 less 为例。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.a</span> &#123;</span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-class">.b</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Scss支持属性嵌套：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.funky</span> &#123;</span><br><span class="line">  <span class="attribute">font</span>: &#123;</span><br><span class="line">    family: fantasy;</span><br><span class="line">    size: <span class="number">30em</span>;</span><br><span class="line">    weight: bold;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量-variable"><a href="#变量-variable" class="headerlink" title="变量 variable"></a>变量 variable</h2><p>Less：使用 <code>@</code> 声明变量  </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@red:</span> <span class="number">#c00</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">strong</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">@red</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Scss：使用 <code>$</code> 声明变量  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$red: <span class="number">#c00</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">strong</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: $red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Stylus：使用 <code>=</code> 声明变量</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">red = <span class="selector-id">#c00</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">strong</span></span><br><span class="line">  <span class="attribute">color</span>: red</span><br></pre></td></tr></table></figure><p><code>@</code> 该字符在css中是一种已经被多次使用的规则（例如 <code>@media</code> <code>@keyframes</code> <code>@supports</code>）,以后也可能被扩展，变量名用 <code>@</code> 开头很可能会和以后的新 <code>@</code> 规则冲突。  </p><p>Scss 和 Stylus 提供了仅当变量不存在时才赋值的功能：  </p><p>Scss:  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$x: <span class="number">1</span>;</span><br><span class="line">$x: <span class="number">5</span> !default;</span><br><span class="line">$y: <span class="number">3</span> !default;</span><br><span class="line"></span><br><span class="line">// $x = <span class="number">1</span>, $y = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>Stylus：  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line">x := <span class="number">5</span> // or x ?= <span class="number">5</span></span><br><span class="line">y = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">// x = <span class="number">1</span>, y = <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="混入-mixin"><a href="#混入-mixin" class="headerlink" title="混入 mixin"></a>混入 mixin</h2><p>混入（mixin）提供了样式层面的抽象。  </p><p>混入有两种方式：  </p><ol><li>直接在目标位置混入另一个类样式（输出已经确定，无法使用参数）；  </li><li>定义一个不输出的样式片段（可以输入参数），在目标位置输出。  </li></ol><p>Less支持无参和带参的混入，也支持对已有类样式的混入：  </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.alert</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">700</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.highlight</span>(<span class="variable">@color</span>: red) &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.2em</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">@color</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.heads-up</span> &#123;</span><br><span class="line">  <span class="selector-class">.alert</span>;</span><br><span class="line">  <span class="selector-class">.highlight</span>(red);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Scss 用 <code>@mixin</code> 和 <code>@include</code> 两个指令表明了混入的声明和引用：  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> large-text &#123;</span><br><span class="line">  <span class="attribute">font</span>: &#123;</span><br><span class="line">    family: Arial;</span><br><span class="line">    size: <span class="number">20px</span>;</span><br><span class="line">    weight: bold;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ff0000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.page-title</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> large-text;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Stylus 和 Sass 类似，但不用什么特殊的标记来引入：  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-radius</span>(n)</span><br><span class="line">  -webkit-<span class="attribute">border-radius</span>: n</span><br><span class="line">  -moz-border-radius: n</span><br><span class="line">  border-radius: n</span><br><span class="line"></span><br><span class="line">.circle</span><br><span class="line">  <span class="built_in">border-radius</span>(<span class="number">50%</span>)</span><br></pre></td></tr></table></figure><p>Stylus 支持像原生css语法一样使用 mixin 的功能：  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.circle</span></span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span></span><br></pre></td></tr></table></figure><h2 id="继承-extend"><a href="#继承-extend" class="headerlink" title="继承 extend"></a>继承 extend</h2><p>如果多个地方都混入同样的代码，会造成输出代码的多次重复。</p><p>Less 使用类似伪类的方式 <code>:extend()</code> 来实现继承：  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.message</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#eee</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.warning</span> &#123;</span><br><span class="line">  &amp;:<span class="built_in">extend</span>(.message);</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#e2e21e</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Or:</span></span><br><span class="line"><span class="comment">.warning:extend(.message) &#123;</span></span><br><span class="line"><span class="comment">  color: #e2e21e;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>同时，Less 默认只继承父类本身的样式，如果要同时继承嵌套定义在父类作用域下的样式，得使用关键字 all，例如 <code>&amp;:extend(.message all);</code> 。  </p><p>Stylus 和 Scss 使用 <code>@extend</code> 来实现继承：  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.message</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span></span><br><span class="line">  border: <span class="number">1px</span> solid <span class="number">#eee</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.warning</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> .message</span><br><span class="line">  <span class="attribute">color</span>: #e2e21e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="占位-placeholder"><a href="#占位-placeholder" class="headerlink" title="占位 placeholder"></a>占位 placeholder</h2><p>Scss 和 Stylus 支持占位操作符，Scss 的占位符为 <code>%</code> ，Stylus 的占位符为 <code>$</code>，占位只存在于预处理器的编译过程中（类似 mixin），但不同之处是它可以被继承。  </p><p>Scss 中的占位如下：  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%red-card &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#300</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ecc</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#c00</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.alert</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> %red-card;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Stylus 中的占位如下：  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$red-card</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#300</span></span><br><span class="line">  background-color: <span class="number">#ecc</span></span><br><span class="line">  color: <span class="number">#c00</span></span><br><span class="line"></span><br><span class="line">.alert</span><br><span class="line">  @extend $red-card</span><br></pre></td></tr></table></figure><h2 id="导入-import"><a href="#导入-import" class="headerlink" title="导入 import"></a>导入 import</h2><p>三种预处理器均支持 <code>@import</code> 导入样式文件，Stylus 还支持 <code>@require</code> 对同一个文件只导入一次  </p><h2 id="函数-functions"><a href="#函数-functions" class="headerlink" title="函数 functions"></a>函数 functions</h2><p>三种预处理器都自带了很多内置函数，三者调用函数的方式几乎一致，不同之处在于 Sass 和 Stylus 支持直接指定参数名的方式传入参数。Scss 和 Stylus 都支持添加自定义函数，Scss 中自定义函数需要用到 <code>@function</code> <code>@return</code> 关键字，在 Stylus 中，这些都是隐含的，最后一个表达式的值会作为返回值  </p><p>Stylus:  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">subtract(<span class="selector-tag">a</span>, <span class="selector-tag">b</span>)</span><br><span class="line">  <span class="selector-tag">a</span> - <span class="selector-tag">b</span></span><br><span class="line"></span><br><span class="line">subtract(<span class="selector-tag">b</span>: <span class="number">10</span>, a: <span class="number">25</span>) // same as <span class="built_in">substract</span>(<span class="number">25</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>Scss:  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$<span class="attribute">grid</span>-<span class="attribute">width</span>: <span class="number">40px</span>;</span><br><span class="line">$gutter-<span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@function</span> grid-width($n) &#123;</span><br><span class="line">  <span class="keyword">@return</span> $n * $grid-width + ($n - <span class="number">1</span>) * $gutter-width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#sidebar</span> &#123; <span class="attribute">width</span>: <span class="built_in">grid-width</span>($n: <span class="number">5</span>); &#125;</span><br></pre></td></tr></table></figure><h2 id="逻辑控制-control-directives-conditionals"><a href="#逻辑控制-control-directives-conditionals" class="headerlink" title="逻辑控制 control directives/conditionals"></a>逻辑控制 control directives/conditionals</h2><p>Scss 中通过常见的 @if、@else if、@else 实现条件分支，通过 @for、@each、@while 实现循环，配合 map 和 list 这两种数据类型可以轻松地实现多数编程语言提供的功能。  </p><p>在 Stylus 中，不需要使用 @ 规则，提供了 if、else if、else、unless、for…in 来实现类似功能，语法比 Sass 更简洁灵活。  </p><p>Less没有提供逻辑控制功能，可以通过 mixin 来模拟。  </p><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p>使用 scss 需要安装 node-sass 这个npm包，在不设置镜像的情况下安装十分缓慢，容易失败。  </p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> less </tag>
            
            <tag> sass </tag>
            
            <tag> stylus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 三栏常见布局</title>
      <link href="/blog/2021/04/01/CSS-%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80/"/>
      <url>/blog/2021/04/01/CSS-%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么会有这篇"><a href="#为什么会有这篇" class="headerlink" title="为什么会有这篇"></a>为什么会有这篇</h2><p>有些面试题会有这些，实际上并没有什么作用，可以用 flex 布局轻松实现。<br>在老旧浏览器中不支持 flex ，为了实现常见的三栏布局，即分左中右三部分，左右两部分宽度固定，中间部分宽度随浏览器变化。  </p><p>这些布局有以下特点：</p><ol><li>两侧宽度固定，中间宽度自适应</li><li>中间部分在DOM结构上优先，以便先行渲染</li><li>允许三列中的任意一列成为最高列</li><li>只需要使用一个额外的<div>标签</li></ol><span id="more"></span><h2 id="流体布局"><a href="#流体布局" class="headerlink" title="流体布局"></a>流体布局</h2><p><div class="lt-container"><div class="left"></div><div class="right"></div><div class="main"></div></div></p><style>.lt-container .left {        float: left;        width: 100px;        height: 200px;        background: red;    }.lt-container .right {    float: right;    width: 200px;    height: 200px;    background: blue;}.lt-container .main {    margin-left: 120px;    margin-right: 220px;    height: 200px;    background: green;}</style><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">        <span class="attribute">float</span>: left;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">background</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: right;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">120px</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">220px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h2><p>来源于 <a href="https://alistapart.com/article/holygrail">In Search of the Holy Grail</a>  </p><p><div class="sb-container"><div class="left"></div><div class="right"></div><div class="main"></div></div></p><style>.sb-container {    height: 200px;    margin-left: 120px;    margin-right: 220px;}.sb-container .main {    float: left;    width: 100%;    height: 200px;    background: green;}.sb-container .left {    position: relative;    float: left;    height: 200px;    width: 100px;    margin-left: -120px;    background: red;}.sb-container .right {    position: relative;    right: -220px;    float: right;    height: 200px;    width: 200px;    margin-left: -200px;    background: blue;}</style><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">120px</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">220px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">120px</span>;</span><br><span class="line">    <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">right</span>: -<span class="number">220px</span>;</span><br><span class="line">    <span class="attribute">float</span>: right;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h2><p><div class="sf-container"><div class="main"></div><br></div><div class="left"></div><div class="right"></div></p><style>.sf-container {    float: left;    width: 100%;}.sf-container .main {    height: 200px;    margin-left: 120px;    margin-right: 220px;    background: green;}.sf-container .main::after {    content: '';    display: block;    font-size:0;    height: 0;    zoom: 1;    clear: both;}.sf-container~.left {    float:left;    height: 200px;    width: 100px;    margin-left: -100%;    background: red;}.sf-container~.left~.right {    float: right;    height: 200px;    width: 200px;    margin-left: -200px;    background: blue;}</style><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">110px</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">220px</span>;</span><br><span class="line">    <span class="attribute">background</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    zoom: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: right;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS-阴影</title>
      <link href="/blog/2021/03/31/CSS-%E9%98%B4%E5%BD%B1/"/>
      <url>/blog/2021/03/31/CSS-%E9%98%B4%E5%BD%B1/</url>
      
        <content type="html"><![CDATA[<h2 id="box-shadow-元素阴影"><a href="#box-shadow-元素阴影" class="headerlink" title="box-shadow 元素阴影"></a>box-shadow 元素阴影</h2><p>box-shadow 属性用于在元素的框架上添加阴影效果。你可以在同一个元素上设置多个阴影效果，并用逗号将他们分隔开。该属性可设置的值包括阴影的X轴偏移量、Y轴偏移量、模糊半径、扩散半径和颜色。可以使用 inset 表示是内阴影。  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">blockquote</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>:</span><br><span class="line">        inset <span class="number">0</span> -<span class="number">3em</span> <span class="number">3em</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.1</span>),</span><br><span class="line">            <span class="number">0</span> <span class="number">0</span>  <span class="number">0</span> <span class="number">2px</span> <span class="built_in">rgb</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>),</span><br><span class="line">            <span class="number">0.3em</span> <span class="number">0.3em</span> <span class="number">1em</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染如下：  </p><p><blockquote class="box-shadow-block"><q>You may shoot me with your words,<br/><br>You may cut me with your eyes,<br/><br>You may kill me with your hatefulness,<br/><br>But still, like air, I’ll rise.</q></p><p><p>&mdash; Maya Angelou</p><br></blockquote></p><style>blockquote.box-shadow-block {    border-left: revert;    color: revert;    padding: 20px;    box-shadow:        inset 0 -3em 3em rgba(0,0,0,0.1),            0 0  0 2px rgb(255,255,255),            0.3em 0.3em 1em rgba(0,0,0,0.3);}</style><span id="more"></span><h2 id="text-shadow-文字阴影"><a href="#text-shadow-文字阴影" class="headerlink" title="text-shadow 文字阴影"></a>text-shadow 文字阴影</h2><p>text-shadow 为文字添加阴影。可以为文字与 text-decorations 添加多个阴影，阴影值之间用逗号隔开。每个阴影值由元素在X和Y方向的偏移量、模糊半径和颜色值组成。  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.white-with-blue-shadow</span> &#123;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">1px</span> <span class="number">1px</span> <span class="number">2px</span> black, <span class="number">0</span> <span class="number">0</span> <span class="number">1em</span> blue, <span class="number">0</span> <span class="number">0</span> <span class="number">0.2em</span> blue;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="attribute">font</span>: <span class="number">1.5em</span> Georgia, <span class="string">&quot;Bitstream Charter&quot;</span>, <span class="string">&quot;URW Bookman L&quot;</span>, <span class="string">&quot;Century Schoolbook L&quot;</span>, serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染如下：  </p><p><p class="white-with-blue-shadow"><br>    Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore<br>    veritatis et quasi architecto beatae vitae dicta sunt explicabo.<br></p></p><style>.white-with-blue-shadow {    text-shadow: 1px 1px 2px black, 0 0 1em blue, 0 0 0.2em blue;    color: white;    font: 1.5em Georgia, "Bitstream Charter", "URW Bookman L", "Century Schoolbook L", serif;}</style>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Grid布局</title>
      <link href="/blog/2021/03/31/CSS-Grid%E5%B8%83%E5%B1%80/"/>
      <url>/blog/2021/03/31/CSS-Grid%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Grid-布局"><a href="#Grid-布局" class="headerlink" title="Grid 布局"></a>Grid 布局</h2><p>CSS 网格布局擅长于将一个页面划分为几个主要区域，以及定义这些区域的大小、位置、层次等关系。  </p><span id="more"></span><h2 id="网格布局样例"><a href="#网格布局样例" class="headerlink" title="网格布局样例"></a>网格布局样例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;one&quot;</span>&gt;</span>One<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;two&quot;</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;three&quot;</span>&gt;</span>Three<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;four&quot;</span>&gt;</span>Four<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;five&quot;</span>&gt;</span>Five<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;six&quot;</span>&gt;</span>Six<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">1</span>fr);</span><br><span class="line">    <span class="attribute">grid-gap</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">grid-auto-rows</span>: <span class="built_in">minmax</span>(<span class="number">100px</span>, auto);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.one</span> &#123;</span><br><span class="line">    <span class="attribute">grid-column</span>: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">    <span class="attribute">grid-row</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.two</span> &#123;</span><br><span class="line">    <span class="attribute">grid-column</span>: <span class="number">2</span> / <span class="number">4</span>;</span><br><span class="line">    <span class="attribute">grid-row</span>: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.three</span> &#123;</span><br><span class="line">    <span class="attribute">grid-row</span>: <span class="number">2</span> / <span class="number">5</span>;</span><br><span class="line">    <span class="attribute">grid-column</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.four</span> &#123;</span><br><span class="line">    <span class="attribute">grid-column</span>: <span class="number">3</span>;</span><br><span class="line">    <span class="attribute">grid-row</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.five</span> &#123;</span><br><span class="line">    <span class="attribute">grid-column</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">grid-row</span>: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.six</span> &#123;</span><br><span class="line">    <span class="attribute">grid-column</span>: <span class="number">3</span>;</span><br><span class="line">    <span class="attribute">grid-row</span>: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><div class="wrapper"><div class="one">One</div><div class="two" >Two</div><div class="three">Three</div><div class="four" >Four</div><div class="five">Five</div><div class="six">Six</div></div></p><style type="text/css">.wrapper>div {    border: 2px solid rgb(233,171,88);    border-radius: 5px;    background-color: rgba(233,171,88,.5);    padding: 1em;    color: #d9480f;}.wrapper {  max-width: 940px;  display: grid;  grid-template-columns: repeat(3, 1fr);  grid-gap: 10px;  grid-auto-rows: minmax(100px, auto);}.one {  grid-column: 1 / 3;  grid-row: 1;}.two {  grid-column: 2 / 4;  grid-row: 1 / 3;}.three {  grid-row: 2 / 5;  grid-column: 1;}.four {  grid-column: 3;  grid-row: 3;}.five {  grid-column: 2;  grid-row: 4;}.six {  grid-column: 3;  grid-row: 4;}</style><h2 id="网格容器-amp-网格元素"><a href="#网格容器-amp-网格元素" class="headerlink" title="网格容器&amp;网格元素"></a>网格容器&amp;网格元素</h2><p>我们通过在元素上声明 <code>display：grid</code> 或 <code>display：inline-grid</code> 来创建一个网格容器。一旦我们这样做，这个元素的所有直系子元素将成为网格元素。  </p><h2 id="网格轨道"><a href="#网格轨道" class="headerlink" title="网格轨道"></a>网格轨道</h2><p>我们通过 <code>grid-template-columns</code> 和 <code>grid-template-rows</code> 属性来定义网格中的行和列。这些属性定义了网格的轨道。  </p><p>网格还引入了一个另外的长度单位来帮助我们创建灵活的网格轨道。新的 <code>fr</code> 单位代表网格容器中可用空间的一等份。  </p><p>有着多轨道的大型网格可使用 <code>repeat()</code> 标记来重复部分或整个轨道列表。  </p><p>你也可以在隐式网格中用 <code>grid-auto-rows</code> 和 <code>grid-auto-columns</code> 属性来定义一个设置大小尺寸的轨道。  </p><p>在设置一个显式的网格或者定义自动创建的行和列的大小的时候，可以通过 <code>minmax()</code> 函数来给网格轨道一个最小/最大尺寸</p><h2 id="网格线"><a href="#网格线" class="headerlink" title="网格线"></a>网格线</h2><p>当我们定义网格时，我们定义的是网格轨道，而不是网格线。网格轨道两边的线即是网格线。一个三列两行的网格中有三条横向的网格线，四条纵向的网格线。当放置元素时，我们使用网格线定位。  </p><p>网格元素中的 <code>grid-column-start</code>, <code>grid-column-end</code>, <code>grid-row-start</code> 和 <code>grid-row-end</code> 属性分别代表了网格线的横向开始、横向结束、纵向开始和纵向结束。  </p><h2 id="网格单元"><a href="#网格单元" class="headerlink" title="网格单元"></a>网格单元</h2><p>一个网格单元是在一个网格元素中最小的单位。  </p><h2 id="网格区域"><a href="#网格区域" class="headerlink" title="网格区域"></a>网格区域</h2><p>网格元素可以向行或着列的方向扩展一个或多个单元，并且会创建一个网格区域。网格区域的形状应该是一个矩形。  </p><h2 id="网格间距"><a href="#网格间距" class="headerlink" title="网格间距"></a>网格间距</h2><p>在两个网格单元之间的 <em>网格横向间距</em>  或 <em>网格纵向间距</em>  可使用 <code>grid-column-gap</code> 和 <code>grid-row-gap</code> 属性来创建，或者直接使用两个合并的缩写形式 <code>grid-gap</code>。  </p><h2 id="嵌套网格"><a href="#嵌套网格" class="headerlink" title="嵌套网格"></a>嵌套网格</h2><p>一个网格元素可以也成为一个网格容器。如果元素不是网格容器的直接子级元素，它们不会参与到网格布局中，并显示为正常的文档流。  </p><h2 id="使用-z-index-控制层级"><a href="#使用-z-index-控制层级" class="headerlink" title="使用 z-index 控制层级"></a>使用 z-index 控制层级</h2><p>多个网格项目可以占用同一个网格单位。默认覆盖顺序遵循文档流的原始顺序（后来居上）。可以使用 z-index 属性控制层级。  </p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3新功能和作用</title>
      <link href="/blog/2021/03/30/Vue-Vue3%E6%96%B0%E5%8A%9F%E8%83%BD%E5%92%8C%E4%BD%9C%E7%94%A8/"/>
      <url>/blog/2021/03/30/Vue-Vue3%E6%96%B0%E5%8A%9F%E8%83%BD%E5%92%8C%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>2020 年 9 月 18 日  Vue3.0  正式发布。</p><h2 id="Composition-API"><a href="#Composition-API" class="headerlink" title="Composition API"></a>Composition API</h2><p>新增 setup 组件选项，是一个接受 props 和 context 的函数，使用 <code>toRefs</code> 对 props 进行响应式解构，可以通过 context 获取组件的 attrs slots emit 属性。返回一个可以在组件模板中使用其属性的对象，或者返回一个渲染函数，该函数可以直接使用在同一作用域中声明的响应式状态。  </p><p>通过一个新的 ref/reactive 函数使任何响应式变量在任何地方起作用。  </p><p>在 setup 中注册生命周期钩子，因为 setup 是围绕 beforeCreate 和 created 生命周期钩子运行的，所以不需要显式地定义它们，在vue3中只有如下钩子：<code>onBeforeMount</code>、<code>onMounted</code>、<code>onBeforeUpdate</code>、<code>onUpdated</code>、<code>onBeforeUnmount</code>、<code>onUnmounted</code>、<code>onErrorCaptured</code>、<code>onRenderTracked</code>、<code>onRenderTriggered</code>。  </p><p>从 Vue 导入的 watch 函数执行相同的操作</p><p>从 Vue 导入的 computed 函数在 Vue 组件外部创建计算属性</p><p>从 Vue 导入的 provide/inject 函数进行深度传值</p><p>…</p><span id="more"></span><h3 id="Composition-API-好处"><a href="#Composition-API-好处" class="headerlink" title="Composition API 好处"></a>Composition API 好处</h3><ol><li>同功能代码组织结构放到一起，代码可读性更强</li><li>让相同的代码逻辑在不同的组件中可以复用</li></ol><h2 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h2><p>Teleport 提供了一种干净的方法，允许我们控制在 DOM 中哪个父节点下渲染了 HTML，而不必求助于全局状态或将其拆分为两个组件。一个典型的用法就是模态框组件的实现。  </p><h2 id="Fragments"><a href="#Fragments" class="headerlink" title="Fragments"></a>Fragments</h2><p>也就是多根节点的组件，可以通过 <code>v-bind=&quot;$attrs&quot;</code> 将外部 attribute 显式的应用于子节点。  </p><h2 id="Emits-组件选项"><a href="#Emits-组件选项" class="headerlink" title="Emits 组件选项"></a>Emits 组件选项</h2><p>可以通过 emits 选项在组件上定义已发出的事件，当在 emits 选项中定义了原生事件 (如 click) 时，将使用组件中的事件替代原生事件侦听器，如果使用对象语法而不是数组语法定义发出的事件，则可以验证事件选项是否符合要求。  </p><h2 id="来自-vue-runtime-core-的-createRenderer-API-创建自定义渲染器"><a href="#来自-vue-runtime-core-的-createRenderer-API-创建自定义渲染器" class="headerlink" title="来自 @vue/runtime-core 的 createRenderer API 创建自定义渲染器"></a>来自 <code>@vue/runtime-core</code> 的 <code>createRenderer</code> API 创建自定义渲染器</h2><h2 id="单文件组件-Composition-API-语法糖（-lt-script-setup-gt-）"><a href="#单文件组件-Composition-API-语法糖（-lt-script-setup-gt-）" class="headerlink" title="单文件组件 Composition API 语法糖（&lt;script setup&gt;）"></a>单文件组件 Composition API 语法糖（<code>&lt;script setup&gt;</code>）</h2><h2 id="单文件组件状态驱动的-CSS-变量-lt-style-vars-gt"><a href="#单文件组件状态驱动的-CSS-变量-lt-style-vars-gt" class="headerlink" title="单文件组件状态驱动的 CSS 变量 (&lt;style vars&gt;)"></a>单文件组件状态驱动的 CSS 变量 (<code>&lt;style vars&gt;</code>)</h2><h2 id="单文件组件-lt-style-scoped-gt-现在可以包含全局规则或只针对插槽内容的规则"><a href="#单文件组件-lt-style-scoped-gt-现在可以包含全局规则或只针对插槽内容的规则" class="headerlink" title="单文件组件 &lt;style scoped&gt; 现在可以包含全局规则或只针对插槽内容的规则"></a>单文件组件 <code>&lt;style scoped&gt;</code> 现在可以包含全局规则或只针对插槽内容的规则</h2><h2 id="vue3-和-vue2-相比有什么不同？"><a href="#vue3-和-vue2-相比有什么不同？" class="headerlink" title="vue3 和 vue2 相比有什么不同？"></a>vue3 和 vue2 相比有什么不同？</h2><ol><li><p>Object.defineProperty -&gt; Proxy<br>使用 Proxy 替代 Object.defineProperty 来实现对数据的监听</p></li><li><p>Virtual Dom 重构</p></li><li><p>编译时优化</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS gradient渐变</title>
      <link href="/blog/2021/03/29/CSS-%E6%B8%90%E5%8F%98/"/>
      <url>/blog/2021/03/29/CSS-%E6%B8%90%E5%8F%98/</url>
      
        <content type="html"><![CDATA[<h2 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h2><p>CSS linear-gradient() 函数用于创建一个表示两种或多种颜色线性渐变的图片。其结果属于 &lt;gradient> 数据类型，是一种特别的 &lt;image> 数据类型。  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 渐变轴为45度，从蓝色渐变到红色 */</span></span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(<span class="number">45deg</span>, blue, red);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从右下到左上、从蓝色渐变到红色 */</span></span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(to left top, blue, red);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从下到上，从蓝色开始渐变、到高度40%位置是绿色渐变开始、最后以红色结束 */</span></span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(<span class="number">0deg</span>, blue, green <span class="number">40%</span>, red);</span><br></pre></td></tr></table></figure><span id="more"></span><p>语法：<code>linear-gradient([ [ [ &lt;angle&gt; | to [top | bottom] || [left | right] ],]? &lt;color-stop&gt;[, &lt;color-stop&gt;]+);</code></p><p>第一个参数 angle 代表了渐变的角度，可以使用 <code>to [top|bottom|left|right]</code> 代表向上下左右，<code>top top</code> 相当于 0deg，角度顺时针增加。 color-stop 由一个 &lt;color> 值组成，并且跟随着一个可选的终点位置（可以是一个百分比值或者是沿着渐变轴的 &lt;length> ）。  </p><h2 id="径向渐变"><a href="#径向渐变" class="headerlink" title="径向渐变"></a>径向渐变</h2><p>CSS radial-gradient() CSS函数创建了一个图像，该图像是由从原点发出的两种或者多种颜色之间的逐步过渡组成。它的形状可以是圆形（circle）或椭圆形（ellipse）。这个方法得到的是一个CSS &lt;gradient> 数据类型的对象，其是 &lt;image> 的一种。  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background</span>: <span class="built_in">radial-gradient</span>(<span class="number">#e66465</span>, <span class="number">#9198e5</span>);</span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">radial-gradient</span>(closest-side, <span class="number">#3f87a6</span>, <span class="number">#ebf8e1</span>, <span class="number">#f69d3c</span>);</span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">radial-gradient</span>(circle at <span class="number">100%</span>, <span class="number">#333</span>, <span class="number">#333</span> <span class="number">50%</span>, <span class="number">#eee</span> <span class="number">75%</span>, <span class="number">#333</span> <span class="number">75%</span>);</span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">radial-gradient</span>(ellipse at top, <span class="number">#e66465</span>, transparent),</span><br><span class="line">            <span class="built_in">radial-gradient</span>(ellipse at bottom, <span class="number">#4d9f0c</span>, transparent);</span><br></pre></td></tr></table></figure><h2 id="重复渐变"><a href="#重复渐变" class="headerlink" title="重复渐变"></a>重复渐变</h2><p>重复多次渐变图案直到足够填满指定元素。由 repeating-linear-gradient() 和 repeating-radial-gradient() 函数产生。  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.linear-repeat</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">repeating-linear-gradient</span>(to top left,</span><br><span class="line">      lightpink, lightpink <span class="number">5px</span>, white <span class="number">5px</span>, white <span class="number">10px</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.radial-repeat</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">repeating-radial-gradient</span>(powderblue, powderblue <span class="number">8px</span>, white <span class="number">8px</span>, white <span class="number">16px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS3特性</title>
      <link href="/blog/2021/03/26/CSS-CSS3%E7%89%B9%E6%80%A7/"/>
      <url>/blog/2021/03/26/CSS-CSS3%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>CSS3 是层叠样式表（Cascading Style Sheets）语言的最新版本，旨在扩展CSS2.1。  </p><p>它带来了许多期待已久的新特性，例如 border-radius(圆角)、box-shadow(阴影)、gradients(渐变) 、transitions(过渡) 与 animations(动画) 。以及新的布局方式，如 multi-columns 、 flexible box 与 grid layouts。  </p><p><a href="https://www.w3.org/">W3C</a> 的 CSS Working Group(CSS 工作组)  作出了一项被称为 Beijing doctrine 的决定，将 CSS 划分为许多小组件，称之为模块。这些模块彼此独立，按照各自的进度来进行标准化。  </p><span id="more"></span><h2 id="新增css选择器"><a href="#新增css选择器" class="headerlink" title="新增css选择器"></a>新增css选择器</h2><p>参见 <a href="/blog/2018/09/03/CSS-选择器/">css选择器</a>  </p><p>CSS3新增多个伪类选择器<br><code>:first-of-type</code> <code>:last-of-type</code> <code>:only-of-type</code> <code>:nth-of-type(n)</code> <code>:nth-last-of-type(n)</code> <code>:last-child</code> <code>:only-child</code> <code>:nth-child(n)</code> <code>:nth-last-child(n)</code><br><code>:root</code> <code>:epmty</code> <code>:target</code> <code>:enabled</code> <code>:disabled</code> <code>:checked</code> <code>:not(selector)</code> </p><p>新增了后兄弟选择<br><code>element1~element2</code></p><p>新增了属性选择<br><code>[attribute^=value]</code>、<code>[attribute$=value]</code>、<code>[attribute*=value]</code></p><h2 id="border-radius-圆角"><a href="#border-radius-圆角" class="headerlink" title="border-radius 圆角"></a>border-radius 圆角</h2><p><code>border-radius</code> 允许设置元素的外边框圆角，该属性是一个 简写属性，是为了将这四个属性 <code>border-top-left-radius</code>、<code>border-top-right-radius</code>、<code>border-bottom-right-radius</code> 和 <code>border-bottom-left-radius</code> 简写为一个属性。即使元素没有 border，圆角也可以用到 background 上面。<br>可以使用 &lt;length> &lt;percentage> 类型，&lt;length> 定义圆形半径或椭圆的半长轴，半短轴。&lt;percentage> 定义圆形半径或椭圆的半长轴，半短轴。水平半轴相对于盒模型的宽度；垂直半轴相对于盒模型的高度</p><h2 id="columns-分列"><a href="#columns-分列" class="headerlink" title="columns 分列"></a>columns 分列</h2><p><code>columns</code> 用来设置元素的列宽和列数。它是一个简写属性，可在单个方便的声明中设置 <code>column-width</code> 和 <code>column-count</code> 属性。可以通过 <code>column-gap</code> 设置列间距。可以通过 <code>column-rule</code> 设置列间隔样式，该属性是 <code>column-rule-width</code> 、 <code>column-rule-style</code> 、 <code>column-rule-color</code> 三个属性的简写。  </p><h2 id="新增布局-flexible-box-grid"><a href="#新增布局-flexible-box-grid" class="headerlink" title="新增布局 flexible-box grid"></a>新增布局 flexible-box grid</h2><p>参见 <a href="/blog/2018/12/06/CSS-Flex布局/">flex</a>、<a href="/blog/2021/03/31/CSS-Grid布局/">grid</a></p><h2 id="box-shadow-阴影-text-shadow-文字阴影"><a href="#box-shadow-阴影-text-shadow-文字阴影" class="headerlink" title="box-shadow 阴影 text-shadow 文字阴影"></a>box-shadow 阴影 text-shadow 文字阴影</h2><p>参见 <a href="/blog/2021/03/31/CSS-阴影/">阴影</a></p><h2 id="gradients-渐变"><a href="#gradients-渐变" class="headerlink" title="gradients 渐变"></a>gradients 渐变</h2><p>参见 <a href="/blog/2021/03/29/CSS-渐变/">gradients</a>  </p><h2 id="transform-变换-transition-过渡-animation-动画"><a href="#transform-变换-transition-过渡-animation-动画" class="headerlink" title="transform 变换 transition 过渡 animation 动画"></a>transform 变换 transition 过渡 animation 动画</h2><p>参见 <a href="/blog/2021/03/16/CSS-transform-transition-animation/">transform &amp; transition &amp; animation</a>  </p><h2 id="text-overflow-文本溢出支持渐隐和文本"><a href="#text-overflow-文本溢出支持渐隐和文本" class="headerlink" title="text-overflow 文本溢出支持渐隐和文本"></a>text-overflow 文本溢出支持渐隐和文本</h2><p><code>text-overflow</code> 属性确定如何向用户发出未显示的溢出内容的形式，CSS4中可能会支持 fade（以及fade函数） 和 string 两种形式(workidng draft)</p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5特性</title>
      <link href="/blog/2021/03/25/HTML-HTML5%E7%89%B9%E6%80%A7/"/>
      <url>/blog/2021/03/25/HTML-HTML5%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>HTML5 是定义 HTML 标准的最新的版本。<a href="https://whatwg.org/">WHATWG</a> 致力于 web 表单和应用程序，而 <a href="https://www.w3.org/">W3C</a> 专注于 XHTML 2.0。在 2006 年，双方决定进行合作，来创建一个新版本的 HTML，这就是HTML5。  </p><span id="more"></span><h2 id="语义"><a href="#语义" class="headerlink" title="语义"></a>语义</h2><h3 id="新增元素"><a href="#新增元素" class="headerlink" title="新增元素"></a>新增元素</h3><p>HTML5新增了区块与段落元素：</p><table><thead><tr><th>元素名</th><th>含义</th></tr></thead><tbody><tr><td>section</td><td>表示一个包含在HTML文档中的独立部分，它没有更具体的语义元素来表示，一般来说会有包含一个标题</td></tr><tr><td>article</td><td>表示文档、页面、应用或网站中的独立结构，其意在成为可独立分配的或可复用的结构</td></tr><tr><td>nav</td><td>表示页面的一部分，其目的是在当前文档或其他文档中提供导航链接</td></tr><tr><td>header</td><td>用于展示介绍性内容，通常包含一组介绍性的或是辅助导航的实用元素</td></tr><tr><td>footer</td><td>表示最近一个章节内容(Sectioning content)或者根节点（Sectioning root）元素的页脚</td></tr><tr><td>aside</td><td>表示一个和其余页面内容几乎无关的部分，被认为是独立于该内容的一部分并且可以被单独的拆分出来而不会使整体受影响</td></tr><tr><td>main</td><td>呈现了文档的 &lt;body> 或应用的主体部分</td></tr><tr><td>hgroup</td><td>代表文档章节所属的多级别的目录</td></tr><tr><td>template</td><td>表示一种用于保存客户端内容的机制，该内容在加载页面时不会呈现，但随后可以在运行时使用JavaScript实例化</td></tr><tr><td>figure</td><td>代表一段独立的内容, 经常与说明（caption） &lt;figcaption> 配合使用, 并且作为一个独立的引用单元。</td></tr><tr><td>figcaption</td><td>是与其相关联的图片的说明/标题，用于描述其父节点 &lt;figure> 元素里的其他数据</td></tr></tbody></table><p>新增了音频与视频元素：</p><table><thead><tr><th>元素名</th><th>含义</th></tr></thead><tbody><tr><td>audio</td><td>元素用于在文档中嵌入音频内容</td></tr><tr><td>video</td><td>用于在HTML或者XHTML文档中嵌入媒体播放器，用于支持文档内的视频播放</td></tr><tr><td>source</td><td>为 &lt;video> 或 &lt;audio> 这类媒体元素指定媒体源</td></tr><tr><td>track</td><td>为 &lt;video> 或 &lt;audio> 这类媒体元素指定文本轨道（字幕）</td></tr></tbody></table><p>图表&amp;公式等嵌入内容：</p><table><thead><tr><th>元素名</th><th>含义</th></tr></thead><tbody><tr><td>canvas</td><td>代表位图区域 ，可以通过脚本在它上面实时呈现图形，如图表、游戏绘图等</td></tr><tr><td>svg</td><td>定义一个嵌入式矢量图</td></tr><tr><td>math</td><td>定义一段数学公式</td></tr><tr><td>embed</td><td>代表一个嵌入的外部资源，如应用程序或交互内容</td></tr></tbody></table><h3 id="iframe上的改进"><a href="#iframe上的改进" class="headerlink" title="iframe上的改进"></a>iframe上的改进</h3><p>新增了一些属性：  </p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>sandbox</td><td>属性对呈现在 iframe 框架中的内容启用一些额外的限制条件</td></tr><tr><td>seamless</td><td>规定了 &lt;iframe> 看上去像是包含文档的一部分（无边框或滚动条）</td></tr><tr><td>srcdoc</td><td>该属性是一段HTML代码，这些代码会被渲染到 iframe 中。如果浏览器不支持 srcdoc 属性，则会渲染 src 属性表示的内容</td></tr></tbody></table><h3 id="支持-MathML"><a href="#支持-MathML" class="headerlink" title="支持 MathML"></a>支持 MathML</h3><p>Mathematical Markup Language (MathML) 是一个用于描述数学公式、符号的一种 XML 标记语言。</p><h3 id="其他对于HTML4-1的优化"><a href="#其他对于HTML4-1的优化" class="headerlink" title="其他对于HTML4.1的优化"></a>其他对于HTML4.1的优化</h3><h4 id="doctype-声明"><a href="#doctype-声明" class="headerlink" title="doctype 声明"></a>doctype 声明</h4><p>HTML5的 doctype 非常简单</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="字符集声明"><a href="#字符集声明" class="headerlink" title="字符集声明"></a>字符集声明</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><h3 id="支持-WebSockets"><a href="#支持-WebSockets" class="headerlink" title="支持 WebSockets"></a>支持 WebSockets</h3><p>WebSockets 是一种先进的技术。它可以在用户的浏览器和服务器之间打开交互式通信会话。使用此API，您可以向服务器发送消息并接收事件驱动的响应，而无需通过轮询服务器的方式以获得响应。  </p><h3 id="支持-Server-sent-events"><a href="#支持-Server-sent-events" class="headerlink" title="支持 Server-sent events"></a>支持 Server-sent events</h3><p>允许服务器向客户端推送事件，而不是仅在响应客户端请求时服务器才能发送数据的传统范式。  </p><h3 id="支持-WebRTC"><a href="#支持-WebRTC" class="headerlink" title="支持 WebRTC"></a>支持 WebRTC</h3><p>这项技术，其中的 RTC 代表的是即时通信，允许连接到其他人，直接在浏览器中控制视频会议，而不需要一个插件或是外部的应用程序。WebRTC作为一项标准,使得所有浏览器无需安装插件或第三方软件，就可以点对点地分享应用数据和进行电话会议。  </p><h2 id="离线-amp-存储"><a href="#离线-amp-存储" class="headerlink" title="离线 &amp; 存储"></a>离线 &amp; 存储</h2><h3 id="支持-onLine-和-offline-事件"><a href="#支持-onLine-和-offline-事件" class="headerlink" title="支持 onLine 和 offline 事件"></a>支持 onLine 和 offline 事件</h3><p><code>navigator.onLine</code> 是一个值为 true/false  (true 表示在线， false 表示离线) 的属性。  </p><p>你可以使用几种熟悉的方式来注册事件：</p><ul><li>在 window，document，或 document.body 上使用 addEventListener</li><li>将 document 或 document.body 的 .ononline 或 .onoffline 属性设置为一个 JavaScript Function 对象。(注意：由于兼容性原因，不能使用 window.ononline 或 window.onoffline。)</li><li>在 HTML 标记中的 &lt;body> 标签上指定 ononline=”…” 或 onoffline=”…” 特性。</li></ul><h3 id="支持-Web-Storage（sessionStorage-amp-localStorage）"><a href="#支持-Web-Storage（sessionStorage-amp-localStorage）" class="headerlink" title="支持 Web Storage（sessionStorage &amp; localStorage）"></a>支持 Web Storage（sessionStorage &amp; localStorage）</h3><p>sessionStorage 和 localStorage 让 web 应用程序能够在客户端存储结构化数据。  </p><h3 id="支持-IndexedDB"><a href="#支持-IndexedDB" class="headerlink" title="支持 IndexedDB"></a>支持 IndexedDB</h3><p>IndexedDB 是一个为了能够在浏览器中存储大量结构化数据，并且能够在这些数据上使用索引进行高性能检索的 Web 标准。  </p><h3 id="支持-FileReader"><a href="#支持-FileReader" class="headerlink" title="支持 FileReader"></a>支持 FileReader</h3><p>FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。  </p><p>其中File对象可以是来自用户在一个&lt;input>元素上选择文件后返回的 FileList 对象,也可以来自拖放操作生成的 DataTransfer 对象,还可以是来自在一个HTMLCanvasElement 上执行 mozGetAsFile() 方法后返回结果。  </p><h3 id="支持使用Camera-API"><a href="#支持使用Camera-API" class="headerlink" title="支持使用Camera API"></a>支持使用Camera API</h3><p>通过Camera API,你可以使用手机的摄像头拍照，然后把拍到的照片发送给当前网页.这些操作主要是通过一个input元素来实现的，其中该元素的type属性必须为”file”，accept属性要允许图片格式，这样才能知道这个文件选择框是用来选择图片的。  </p><h2 id="性能-amp-集成"><a href="#性能-amp-集成" class="headerlink" title="性能 &amp; 集成"></a>性能 &amp; 集成</h2><h3 id="支持-Web-Workers"><a href="#支持-Web-Workers" class="headerlink" title="支持 Web Workers"></a>支持 Web Workers</h3><p>能够把 JavaScript 计算委托给后台线程，通过允许这些活动以防止使交互型事件变得缓慢。  </p><h3 id="XMLHttpRequest-Level-2"><a href="#XMLHttpRequest-Level-2" class="headerlink" title="XMLHttpRequest Level 2"></a>XMLHttpRequest Level 2</h3><p>允许异步读取页面的某些部分，允许其显示动态内容，根据时间和用户行为而有所不同。这是在 Ajax 背后的技术。  </p><h3 id="History-API"><a href="#History-API" class="headerlink" title="History API"></a>History API</h3><p>允许对浏览器历史记录进行操作。这对于那些交互地加载新信息的页面尤其有用。<br>通过 <code>window.history</code> 可以获取浏览器历史记录相关信息。使用 <code>back()</code>, <code>forward()</code> 和 <code>go()</code> 方法来完成在用户历史记录中向后和向前的跳转。<code>window.history.length</code> 来确定的历史堆栈中页面的数量。  </p><h3 id="contentEditable-属性"><a href="#contentEditable-属性" class="headerlink" title="contentEditable 属性"></a>contentEditable 属性</h3><p>在HTML中，任何元素都可以被编辑。通过使用一些JavaScript事件处理程序，您可以将您的网页转换为完整且快速的富文本编辑器。  </p><h3 id="Drag-amp-Drop-API"><a href="#Drag-amp-Drop-API" class="headerlink" title="Drag &amp; Drop API"></a>Drag &amp; Drop API</h3><p>HTML5 的拖放 API 能够支持在网站内部和网站之间拖放项目。  </p><h3 id="Web-based-protocol-handlers"><a href="#Web-based-protocol-handlers" class="headerlink" title="Web-based protocol handlers"></a>Web-based protocol handlers</h3><p>可以使用 navigator.registerProtocolHandler() 方法把 web 应用程序注册成一个协议处理程序。  </p><h3 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h3><p>允许控制动画渲染以获得更优性能。  </p><h3 id="Fullscreen-API"><a href="#Fullscreen-API" class="headerlink" title="Fullscreen API"></a>Fullscreen API</h3><p>全屏 API 为使用用户的整个屏幕展现网络内容提供了一种简单的方式，并且在不需要时退出全屏模式。通过 <code>element.requestFullscreen()</code> 请求浏览器（user agent）将特定元素（甚至延伸到它的后代元素）置为全屏模式。<code>document.exitFullscreen()</code> 用于请求从全屏模式切换到窗口模式。<del><code>document.fullscreen</code> 可以获取当前是否是全屏模式，</del> <code>document.fullscreenElement</code> 可以获取到当前全屏的元素。  </p><button type="button" class="appreciate-btn" onclick="document.fullscreenElement ? document.exitFullscreen() : document.querySelector('.content').requestFullscreen()">全屏/退出全屏</button><h3 id="Pointer-Lock-API"><a href="#Pointer-Lock-API" class="headerlink" title="Pointer Lock API"></a>Pointer Lock API</h3><p>允许锁定到内容的指针，这样游戏或者类似的应用程序在指针到达窗口限制时也不会失去焦点。  </p><h2 id="设备访问"><a href="#设备访问" class="headerlink" title="设备访问"></a>设备访问</h2><h3 id="支持触摸事件"><a href="#支持触摸事件" class="headerlink" title="支持触摸事件"></a>支持触摸事件</h3><p>对用户按下触控屏的事件做出反应的处理程序。即 <code>ontouchstart</code>、<code>ontouchmove</code>、<code>ontouchend</code>、<code>ontouchcancel</code> 事件 和 <code>TouchEvent</code> 。   </p><h3 id="Geolocation-API"><a href="#Geolocation-API" class="headerlink" title="Geolocation API"></a>Geolocation API</h3><p>让浏览器使用地理位置服务定位用户的位置。<br>地理位置 API 通过 <code>navigator.geolocation</code> 提供，可以通过 <code>navigator.geolocation.getCurrentPosition(success, error, options)</code> 来获取设备当前位置。  </p><h3 id="检测设备方向"><a href="#检测设备方向" class="headerlink" title="检测设备方向"></a>检测设备方向</h3><p>让用户在运行浏览器的设备变更方向时能够得到信息。<br>主要是在 window 对象添加事件监听器来实现，其中 <code>deviceorientation</code> 接收设备方向变化信息，<code>devicemotion</code> 接收设备移动信息。  </p>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 原型链</title>
      <link href="/blog/2021/03/24/JS-%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/blog/2021/03/24/JS-%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是原型链"><a href="#什么是原型链" class="headerlink" title="什么是原型链"></a>什么是原型链</h2><p>原型链是实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。这时，如果我们让原型对象等于另一个类型的实例，此时的原型对象将包含一个指向另一个原型的指针，相应的，另一个原型中也包含着一个指向另一个构造函数的指针。假如一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念。  </p><span id="more"></span><h2 id="利用原型链实现继承"><a href="#利用原型链实现继承" class="headerlink" title="利用原型链实现继承"></a>利用原型链实现继承</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">property</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSuperValue</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">property</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subproperty</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承了SuperType</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>();</span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">consturctor</span> = <span class="title class_">SubType</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加新方法</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSubValue</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">subproperty</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重写超类中的方法</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSuperValue</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> <span class="title class_">SubType</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="title function_">getSuperValue</span>()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现 Promise</title>
      <link href="/blog/2021/03/23/JS-Promise/"/>
      <url>/blog/2021/03/23/JS-Promise/</url>
      
        <content type="html"><![CDATA[<h2 id="Promise-有哪些方法？"><a href="#Promise-有哪些方法？" class="headerlink" title="Promise 有哪些方法？"></a><code>Promise</code> 有哪些方法？</h2><ul><li>Promise.prototype.then<br><code>then()</code> 方法需要两个参数，第一个参数作为处理 fulfilled 状态的回调函数，回调函数有一个入参即 fufilled 状态的结果，而第二个参数则作为处理 rejected 状态的回调函数，回调函数有一个入参即 rejected 的原因。返回一个新的 Promise。</li><li>Promise.prototype.catch<br><code>catch()</code> 方法返回一个新的 Promise，并且处理 rejected 的情况。它的行为与调用 <code>Promise.prototype.then(undefined, onRejected)</code> 相同</li><li>Promise.prototype.finally<br><code>finally()</code> 方法返回一个新的 Promise。在 promise 结束时，无论结果是 fulfilled 或者是 rejected，都会执行指定的回调函数。</li><li>Promise.resolve()<br><code>Promise.resolve()</code> 方法返回一个以给定值解析后的 Promise 对象。如果这个值是一个 promise，那么将返回这个 promise；如果这个值是 thenable（即带有 “then” 方法），返回的 promise 会“跟随”这个 thenable 的对象，采用它的最终状态；否则返回的 promise 将以此值完成。此函数将类 promise 对象的多层嵌套展平。</li><li>Promise.reject()<br><code>Promise.reject()</code> 方法返回一个带有拒绝原因的 Promise 对象。</li><li>Promise.all()<br><code>Promise.all()</code> 方法接收一个 promise 的 iterable 类型(Array Map Set)的输入，并且只返回一个Promise 实例。当输入的所有 promise 均 fulfilled 后，执行返回的 Promise 实例的 resolve 方法，只要有任何一个输入的 promise reject，执行返回的 Promise 实例的 reject 方法，reject 的 reason 是第一个 reject 的 promise 的 reason</li><li>Promise.allSettled()<br><code>Promise.allSettled()</code> 方法返回一个在所有给定的 promise 都已经 fulfilled 或 rejected 后的 promise，并带有一个对象数组，每个对象表示对应的 promise 结果</li><li>Promise.any()<br><code>Promise.any()</code> 方法接收一个由 Promise 所组成的可迭代对象，该方法会返回一个新的 promise，一旦可迭代对象内的任意一个 promise 变成了 fulfilled 状态，那么由该方法所返回的 promise 就会变成 fulfilled 状态，并且它的返回值就是可迭代对象内的首先 fulfilled 的 promise 的返回值。如果可迭代对象内的 promise 最终都没有 fulfilled（即所有 promise 都是 rejected），那么该方法所返回的 promise 就会变成 rejected 状态，并且它的拒因会是一个 AggregateError 实例，这是 Error 的子类，用于把单一的错误集合在一起</li><li>Promise.race()<br><code>Promise.race()</code> 方法接收一个由 Promise 所组成的可迭代对象，返回一个新的 Promise。一旦迭代器中的某个 promise fullfiled 或 rejected，返回的 promise 就会 fullfiled 或 rejected，值和原因均与第一个返回的 promise 相同。</li></ul><span id="more"></span><p>以下实现一个遵循 <a href="https://promisesaplus.com/">PromiseA+</a> 规范的 Promise 。</p><h2 id="实现基础框架-new-Promise-resolve-reject-gt"><a href="#实现基础框架-new-Promise-resolve-reject-gt" class="headerlink" title="实现基础框架 new Promise((resolve, reject) =&gt;{})"></a>实现基础框架 <code>new Promise((resolve, reject) =&gt;&#123;&#125;)</code></h2><p><code>new Promise()</code> 时接收一个 executor 函数作为参数，该函数会立即执行，函数中有两个参数，它们也是函数，分别是 resolve 和 reject ，函数同步执行一定要放在 try…catch 中，否则无法进行错误捕获。  </p><figure class="highlight js"><figcaption><span>MyPromise.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyPromise</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reject</span>(<span class="params">reason</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(reason);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">MyPromise</span>;</span><br></pre></td></tr></table></figure><p>resolve() 接收 Promise 成功值 value ， reject 接收 Promise 失败原因 reason 。</p><figure class="highlight js"><figcaption><span>test.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyPromise</span> = <span class="built_in">require</span>(<span class="string">&#x27;./MyPromise.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">123</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="添加状态机-pending-fulfilled-rejected"><a href="#添加状态机-pending-fulfilled-rejected" class="headerlink" title="添加状态机 pending fulfilled rejected"></a>添加状态机 pending fulfilled rejected</h2><p>Promise 是一个状态机的机制，初始状态为 pending，成功状态为 fulfilled，失败状态为 rejected。只能从 pending -&gt; fulfilled，或者从 pending -&gt; rejected，并且状态一旦转变，就永远不会再变了。<br>所以，我们需要为 Promise 添加一个状态流转的机制。  </p><figure class="highlight js"><figcaption><span>MyPromise.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyPromise</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="variable language_">this</span>;</span><br><span class="line">  self.<span class="property">state</span> = <span class="variable constant_">PENDING</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">state</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      self.<span class="property">state</span> = <span class="variable constant_">FULFILLED</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reject</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">state</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      self.<span class="property">state</span> = <span class="variable constant_">REJECTED</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(reason);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">MyPromise</span>;</span><br></pre></td></tr></table></figure><h2 id="添加-then-方法"><a href="#添加-then-方法" class="headerlink" title="添加 then 方法"></a>添加 then 方法</h2><p>Promise 拥有一个 then 方法，接收两个函数 onFulfilled 和 onRejected，分别作为 Promise 成功和失败的回调。所以，在 then 方法中我们需要对状态 state 进行判断，如果是 fulfilled ，则执行 onFulfilled(value) 方法，如果是 rejected ，则执行 onRejected(reason) 方法。  </p><p>由于成功值 value 和失败原因 reason 是由用户在 executor 中通过 resolve(value) 和 reject(reason) 传入的，所以我们需要有一个全局的 value 和 reason 供后续方法获取。  </p><figure class="highlight js"><figcaption><span>MyPromise.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyPromise</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  self.<span class="property">state</span> = <span class="variable constant_">PENDING</span>;</span><br><span class="line">  self.<span class="property">value</span> = <span class="literal">null</span>;</span><br><span class="line">  self.<span class="property">reason</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">state</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      self.<span class="property">state</span> = <span class="variable constant_">FULFILLED</span>;</span><br><span class="line">      self.<span class="property">value</span> = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reject</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">state</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      self.<span class="property">state</span> = <span class="variable constant_">REJECTED</span>;</span><br><span class="line">      self.<span class="property">reason</span> = reason;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(reason);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyPromise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span>(<span class="params">onFuifilled, onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">    <span class="title function_">onFuifilled</span>(self.<span class="property">value</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.<span class="property">state</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">    <span class="title function_">onRejected</span>(self.<span class="property">reason</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">MyPromise</span>;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>test.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">MyPromise</span> = <span class="built_in">require</span>(<span class="string">&#x27;./MyPromise.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">123</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;value&#x27;</span>, value);</span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reason&#x27;</span>, reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="实现异步调用-resolve"><a href="#实现异步调用-resolve" class="headerlink" title="实现异步调用 resolve"></a>实现异步调用 resolve</h2><p>当前的实现同步调用 resolve() 没有问题，但如果是异步调用，比如放到 setTimeout 中，因为目前的代码在调用 then() 方法时， state 仍是 pending 状态，当 timer 到时候调用 resolve() 把 state 修改为 fulfilled 状态，但是 onFulfilled() 函数已经没有时机调用了。  </p><p>所以我们需要添加回调堆栈，当处于 pending 状态时，将 onFulfilled() 函数和 onRejected() 函数放到相应的堆栈中去。  </p><figure class="highlight js"><figcaption><span>MyPromise.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyPromise</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  self.<span class="property">state</span> = <span class="variable constant_">PENDING</span>;</span><br><span class="line">  self.<span class="property">value</span> = <span class="literal">null</span>;</span><br><span class="line">  self.<span class="property">reason</span> = <span class="literal">null</span>;</span><br><span class="line">  self.<span class="property">onFulfilledCallbacks</span> = [];</span><br><span class="line">  self.<span class="property">onRejectedCallbacks</span> = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">state</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      self.<span class="property">state</span> = <span class="variable constant_">FULFILLED</span>;</span><br><span class="line">      self.<span class="property">value</span> = value;</span><br><span class="line"></span><br><span class="line">      self.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">fulfilledCallback</span>) &#123;</span><br><span class="line">        <span class="title function_">fulfilledCallback</span>();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reject</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">state</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      self.<span class="property">state</span> = <span class="variable constant_">REJECTED</span>;</span><br><span class="line">      self.<span class="property">reason</span> = reason;</span><br><span class="line"></span><br><span class="line">      self.<span class="property">onRejectedCallbacks</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">rejectedCallback</span>) &#123;</span><br><span class="line">        <span class="title function_">rejectedCallback</span>();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(reason);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyPromise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span>(<span class="params">onFuifilled, onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.<span class="property">state</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">    self.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">onFuifilled</span>(self.<span class="property">value</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    self.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">onRejected</span>(self.<span class="property">reason</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">    <span class="title function_">onFuifilled</span>(self.<span class="property">value</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.<span class="property">state</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">    <span class="title function_">onRejected</span>(self.<span class="property">reason</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">MyPromise</span>;</span><br></pre></td></tr></table></figure><p>我们添加了两个回调函数数组 onFulfilledCallbacks 和 onRejectedCallbacks ，用来存储 then() 方法中传入的成功和失败回调。然后，当用户调用 resolve() 或 reject() 的时候，修改 state 状态，并从相应的回调数组中依次取出回调函数执行。  </p><p>同时，通过这种方式我们也实现了可以注册多个 then() 函数，并且在成功或者失败时按照注册顺序依次执行。  </p><figure class="highlight js"><figcaption><span>test.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">MyPromise</span> = <span class="built_in">require</span>(<span class="string">&#x27;./MyPromise.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">123</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;value1&#x27;</span>, value);</span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reason1&#x27;</span>, reason);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;value2&#x27;</span>, value);</span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reason2&#x27;</span>, reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="链式调用-then-返回的仍是-Promise"><a href="#链式调用-then-返回的仍是-Promise" class="headerlink" title="链式调用 then 返回的仍是 Promise"></a>链式调用 then 返回的仍是 Promise</h2><p>读过 Promise A+ 规范的同学肯定知道，then() 方法返回的仍是一个 Promise ，并且返回 Promise 的 resolve 的值是上一个 Promise 的 onFulfilled() 函数或 onRejected() 函数的返回值。如果在上一个 Promise 的 then() 方法回调函数的执行过程中发生了错误，那么会将其捕获到，并作为返回的 Promise 的 onRejected 函数的参数传入。  </p><p>接下来我们就去实现 then() 方法依然返回一个 Promise 。  </p><figure class="highlight js"><figcaption><span>MyPromise.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">MyPromise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span>(<span class="params">onFuifilled, onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">let</span> promise2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  promise2 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">state</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      self.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = <span class="title function_">onFuifilled</span>(self.<span class="property">value</span>);</span><br><span class="line">          self.<span class="title function_">resolvePromise</span>(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(reason) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(reason);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      self.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = <span class="title function_">onRejected</span>(self.<span class="property">reason</span>);</span><br><span class="line">          self.<span class="title function_">resolvePromise</span>(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(reason) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(reason);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> x = <span class="title function_">onFuifilled</span>(self.<span class="property">value</span>);</span><br><span class="line">        self.<span class="title function_">resolvePromise</span>(promise2, x, resolve, reject);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(reason);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">state</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> x = <span class="title function_">onRejected</span>(self.<span class="property">reason</span>);</span><br><span class="line">        self.<span class="title function_">resolvePromise</span>(promise2, x, resolve, reject);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(reason);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，我们新增了一个 promise2 作为 then() 方法的返回值。通过 <code>let x = onFuifilled(self.value)</code> 或者 <code>let x = onRejected(self.reason)</code> 拿到 then() 方法回调函数的返回值，然后调用 <code>self.resolvePromise(promise2, x, resolve, reject)</code>，将新增的 promise2、x、promise2 的 resolve 和 reject 传入到 resolvePromise() 中。  </p><p>下面我们重点看一下 resolvePromise() 方法。  </p><figure class="highlight js"><figcaption><span>MyPromise.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">MyPromise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">resolvePromise</span> = <span class="keyword">function</span>(<span class="params">promise2, x, resolve, reject</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">let</span> called = <span class="literal">false</span>;   <span class="comment">// called 防止多次调用</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Chaining cycle detected for promise #&lt;MyPromise&gt;&#x27;</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Promises/A+ 希望自身能兼容其他规范下的 promise 对象，判断依据为该对象是否可 thenable</span></span><br><span class="line">  <span class="keyword">if</span> (x !== <span class="literal">null</span> &amp;&amp; (<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(x) === <span class="string">&#x27;[object Object]&#x27;</span> || <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(x) === <span class="string">&#x27;[object Function]&#x27;</span>)) &#123;</span><br><span class="line">    <span class="comment">// x是对象或者函数</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> then = x.<span class="property">then</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        then.<span class="title function_">call</span>(x, <span class="function">(<span class="params">y</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 别人的Promise的then方法可能设置了getter等，使用called防止多次调用then方法</span></span><br><span class="line">          <span class="keyword">if</span> (called) <span class="keyword">return</span> ;</span><br><span class="line">          called = <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">// 成功值y有可能还是promise或者是具有then方法等，再次resolvePromise，直到成功值为基本类型或者非thenable</span></span><br><span class="line">          self.<span class="title function_">resolvePromise</span>(promise2, y, resolve, reject);</span><br><span class="line">        &#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (called) <span class="keyword">return</span> ;</span><br><span class="line">          called = <span class="literal">true</span>;</span><br><span class="line">          <span class="title function_">reject</span>(reason);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (called) <span class="keyword">return</span> ;</span><br><span class="line">        called = <span class="literal">true</span>;</span><br><span class="line">        <span class="title function_">resolve</span>(x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span> ;</span><br><span class="line">      called = <span class="literal">true</span>;</span><br><span class="line">      <span class="title function_">reject</span>(reason);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// x是普通值，直接resolve</span></span><br><span class="line">    <span class="title function_">resolve</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>resolvePromise() 是用来解析 then() 回调函数中返回的仍是一个 Promise ，这个 Promise 有可能是我们自己的，有可能是别的库实现的，也有可能是一个具有 then() 方法的对象，所以这里靠 resolvePromise() 来实现统一处理。  </p><figure class="highlight js"><figcaption><span>test.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">MyPromise</span> = <span class="built_in">require</span>(<span class="string">&#x27;./MyPromise.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">123</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;value1&#x27;</span>, value);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">456</span>);</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="number">789</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reason1&#x27;</span>, reason);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;value2&#x27;</span>, value);</span><br><span class="line">&#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reason2&#x27;</span>, reason);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="让-then-方法的回调函数总是异步调用"><a href="#让-then-方法的回调函数总是异步调用" class="headerlink" title="让 then 方法的回调函数总是异步调用"></a>让 then 方法的回调函数总是异步调用</h2><p>Promise 属于 microTask，我们可以通过 <code>process.nextTick()</code> 来将 then 方法的回调函数改为异步  </p><figure class="highlight js"><figcaption><span>MyPromise.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">MyPromise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span>(<span class="params">onFuifilled, onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">let</span> promise2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  promise2 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">state</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      self.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        process.<span class="title function_">nextTick</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = <span class="title function_">onFuifilled</span>(self.<span class="property">value</span>);</span><br><span class="line">            self.<span class="title function_">resolvePromise</span>(promise2, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(reason);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">      self.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        process.<span class="title function_">nextTick</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = <span class="title function_">onRejected</span>(self.<span class="property">reason</span>);</span><br><span class="line">            self.<span class="title function_">resolvePromise</span>(promise2, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(reason);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">state</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">      process.<span class="title function_">nextTick</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = <span class="title function_">onFuifilled</span>(self.<span class="property">value</span>);</span><br><span class="line">          self.<span class="title function_">resolvePromise</span>(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(reason);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">state</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">      process.<span class="title function_">nextTick</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = <span class="title function_">onRejected</span>(self.<span class="property">reason</span>);</span><br><span class="line">          self.<span class="title function_">resolvePromise</span>(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(reason);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>test.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">MyPromise</span> = <span class="built_in">require</span>(<span class="string">&#x27;./MyPromise.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;step-&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">123</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;step--&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;value1&#x27;</span>, value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">打印结果：</span></span><br><span class="line"><span class="comment">start</span></span><br><span class="line"><span class="comment">step-</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">step--</span></span><br><span class="line"><span class="comment">value1 123</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>经过以上步骤，一个最基本的 Promise 就已经实现完了，下面我们会实现一些不在 PromiseA+ 规范的扩展方法。  </p><h2 id="实现-catch-方法"><a href="#实现-catch-方法" class="headerlink" title="实现 catch 方法"></a>实现 catch 方法</h2><p>then() 方法的 onFulfilled 和 onRejected 回调函数都不是必传项，如果不传，那么我们就无法接收 reject(reason) 中的错误，这时我们可以通过链式调用 catch() 方法用来接收错误。  </p><p>不仅如此，catch() 可以作为 Promise 链式调用的最后一步，前面 Promise 发生的错误会冒泡到最后一个 catch() 中，从而捕获异常。  </p><figure class="highlight js"><figcaption><span>MyPromise.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">MyPromise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span>(<span class="params">onFuifilled, onRejected</span>) &#123;</span><br><span class="line">  onFuifilled = <span class="keyword">typeof</span> onFuifilled === <span class="string">&#x27;function&#x27;</span> ? onFuifilled : <span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="keyword">return</span> value;&#125;;</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyPromise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">catch</span> = <span class="keyword">function</span>(<span class="params">onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">null</span>, onRejected);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，onRejected 的默认值是把错误 reason 通过 throw 抛出去。由于我们对于同步代码的执行都是在 try…catch 中的，所以如果 Promise 发生了错误，如果没传 onRejected ，默认的函数会把错误 reason 抛出，然后会被 promise2 捕捉到，作为 reject(reason) 决议。  </p><p>所以，我们在写 Promise 的链式调用的时候，在 then() 中可以不传 onRejected 回调，只需要在链式调用的最末尾加一个 catch() 就可以了，这样在该链条中的 Promise 发生的错误都会被最后的 catch 捕获到。  </p><h2 id="实现-finally-方法"><a href="#实现-finally-方法" class="headerlink" title="实现 finally 方法"></a>实现 finally 方法</h2><p>finally 是某些库对 Promise 实现的一个扩展方法，无论是 resolve 还是 reject ，都会走 finally 方法。  </p><figure class="highlight js"><figcaption><span>MyPromise.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">MyPromise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">finally</span> = <span class="keyword">function</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="title function_">fn</span>();</span><br><span class="line">       <span class="keyword">return</span> value;</span><br><span class="line">    &#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">fn</span>();</span><br><span class="line">        <span class="keyword">throw</span> reason;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="实现-done-方法"><a href="#实现-done-方法" class="headerlink" title="实现 done 方法"></a>实现 done 方法</h2><p>done 方法作为 Promise 链式调用的最后一步，用来向全局抛出没有被 Promise 内部捕获的错误，并且不再返回一个 Promise 。一般用来结束一个 Promise 链。  </p><figure class="highlight js"><figcaption><span>MyPromise.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">MyPromise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">done</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> reason;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="实现-Promise-all-方法"><a href="#实现-Promise-all-方法" class="headerlink" title="实现 Promise.all 方法"></a>实现 Promise.all 方法</h2><p>Promise.all() 接收一个包含多个 Promise 的数组，当所有 Promise 均为 fulfilled 状态时，返回一个结果数组，数组中结果的顺序和传入的 Promise 顺序一一对应。如果有一个 Promise 为 rejected 状态，则整个 Promise.all 为 rejected 。  </p><figure class="highlight js"><figcaption><span>MyPromise.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">MyPromise</span>.<span class="property">all</span> = <span class="keyword">function</span>(<span class="params">promiseArr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">let</span> fulfilledPromise = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    promiseArr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">promise, index</span>) =&gt;</span> &#123;</span><br><span class="line">      promise.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        result[index] = value;</span><br><span class="line">        <span class="keyword">if</span> (++fulfilledPromise === promiseArr.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, reject);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>test.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">MyPromise</span> = <span class="built_in">require</span>(<span class="string">&#x27;./MyPromise.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;aaaa&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">1111</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1111</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bbbb&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="number">2222</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2222</span>);</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise3 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;cccc&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">3333</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3333</span>);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([promise1, promise2, promise3]).<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;all value&#x27;</span>, value);</span><br><span class="line">&#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;all reason&#x27;</span>, reason);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">打印结果：</span></span><br><span class="line"><span class="comment">aaaa</span></span><br><span class="line"><span class="comment">bbbb</span></span><br><span class="line"><span class="comment">cccc</span></span><br><span class="line"><span class="comment">1111</span></span><br><span class="line"><span class="comment">2222</span></span><br><span class="line"><span class="comment">all reason 2222</span></span><br><span class="line"><span class="comment">3333</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="实现-Promise-race-方法"><a href="#实现-Promise-race-方法" class="headerlink" title="实现 Promise.race 方法"></a>实现 Promise.race 方法</h2><p>Promise.race() 接收一个包含多个 Promise 的数组，当有一个 Promise 为 fulfilled 状态时，则整个 Promise.race 为 onfulfilled ，并执行 onFulfilled 回调函数。如果有一个 Promise 为 rejected 状态，则整个 Promise.race 为rejected。  </p><figure class="highlight js"><figcaption><span>MyPromise.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">MyPromise</span>.<span class="property">race</span> = <span class="keyword">function</span>(<span class="params">promiseArr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    promiseArr.<span class="title function_">forEach</span>(<span class="function"><span class="params">promise</span> =&gt;</span> &#123;</span><br><span class="line">      promise.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(value);   </span><br><span class="line">      &#125;, reject);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>test.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">MyPromise</span> = <span class="built_in">require</span>(<span class="string">&#x27;./MyPromise.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;aaaa&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">1111</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1111</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bbbb&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="number">2222</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2222</span>);</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise3 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;cccc&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">3333</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3333</span>);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([promise1, promise2, promise3]).<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;all value&#x27;</span>, value);</span><br><span class="line">&#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;all reason&#x27;</span>, reason);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">打印结果：</span></span><br><span class="line"><span class="comment">aaaa</span></span><br><span class="line"><span class="comment">bbbb</span></span><br><span class="line"><span class="comment">cccc</span></span><br><span class="line"><span class="comment">1111</span></span><br><span class="line"><span class="comment">all reason 1111</span></span><br><span class="line"><span class="comment">2222</span></span><br><span class="line"><span class="comment">3333</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="实现-Promise-resolve-方法"><a href="#实现-Promise-resolve-方法" class="headerlink" title="实现 Promise.resolve 方法"></a>实现 Promise.resolve 方法</h2><p>Promise.resolve 用来生成一个 fulfilled 完成态的 Promise ，一般放在整个 Promise 链的开头，用来开始一个 Promise 链。  </p><figure class="highlight js"><figcaption><span>MyPromise.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">MyPromise</span>.<span class="property">resolve</span> = <span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> promise;</span><br><span class="line"></span><br><span class="line">  promise = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">resolvePromise</span>(promise, value, resolve, reject);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>test.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">MyPromise</span> = <span class="built_in">require</span>(<span class="string">&#x27;./MyPromise.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyPromise</span>.<span class="title function_">resolve</span>(<span class="number">1111</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;value1&#x27;</span>, value);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">2222</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;value2&#x27;</span>, value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">打印结果：</span></span><br><span class="line"><span class="comment">value1 1111</span></span><br><span class="line"><span class="comment">value2 2222</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="实现-Promise-reject-方法"><a href="#实现-Promise-reject-方法" class="headerlink" title="实现 Promise.reject 方法"></a>实现 Promise.reject 方法</h2><p>Promise.reject 用来生成一个 rejected 失败态的 Promise 。  </p><figure class="highlight js"><figcaption><span>MyPromise.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">MyPromise</span>.<span class="property">reject</span> = <span class="keyword">function</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(reason);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>test.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">MyPromise</span> = <span class="built_in">require</span>(<span class="string">&#x27;./MyPromise.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyPromise</span>.<span class="title function_">reject</span>(<span class="number">1111</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;value1&#x27;</span>, value);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">2222</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;value2&#x27;</span>, value);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reason&#x27;</span>, reason);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">打印结果：</span></span><br><span class="line"><span class="comment">reason 1111</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="实现-Promise-deferred-方法"><a href="#实现-Promise-deferred-方法" class="headerlink" title="实现 Promise.deferred 方法"></a>实现 Promise.deferred 方法</h2><figure class="highlight js"><figcaption><span>MyPromise.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">MyPromise</span>.<span class="property">deferred</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dfd = &#123;&#125;;</span><br><span class="line">    dfd.<span class="property">promise</span> = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      dfd.<span class="property">resolve</span> = resolve;</span><br><span class="line">      dfd.<span class="property">reject</span> = reject;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> dfd;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样，你就可以在外部通过调用 dfd.resolve() 和 dfd.reject() 来决议该 Promise。  </p><h2 id="实现-Promise-allSettled-方法"><a href="#实现-Promise-allSettled-方法" class="headerlink" title="实现 Promise.allSettled 方法"></a>实现 Promise.allSettled 方法</h2><p>Promise.allSettled 接收一个包含多个 Promise 的数组（实际只需要实现 Iterable ），当所有的 Promise 均不为 pending 状态时，返回一个结果数组，数组中结果的顺序和传入的 Promise 顺序一一对应，每个结果中的 status 字段表示结果的状态，value 或 reason 字段表示成功的结果或失败的原因。</p><figure class="highlight js"><figcaption><span>MyPromise.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">MyPromise</span>.<span class="property">allSettled</span> = <span class="keyword">function</span> (<span class="params">promiseArr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, _reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> result = [];</span><br><span class="line">        <span class="keyword">let</span> settledPromise = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">addToResult</span>(<span class="params">idx, value</span>) &#123;</span><br><span class="line">            result[idx] = value;</span><br><span class="line">            settledPromise++;</span><br><span class="line">            <span class="keyword">if</span> (settledPromise === promiseArr.<span class="property">length</span>) &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        promiseArr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">promise, idx</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (promise <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) &#123;</span><br><span class="line">                promise.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="title function_">addToResult</span>(idx, &#123;</span><br><span class="line">                        <span class="attr">status</span>: <span class="variable constant_">FULFILLED</span>,</span><br><span class="line">                        value</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="title function_">addToResult</span>(idx, &#123;</span><br><span class="line">                        <span class="attr">status</span>: <span class="variable constant_">REJECTED</span>,</span><br><span class="line">                        reason</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">addToResult</span>(idx, &#123;</span><br><span class="line">                <span class="attr">status</span>: <span class="variable constant_">FULFILLED</span>,</span><br><span class="line">                <span class="attr">value</span>: promise</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现中使用了 <code>promise instanceof MyPromise</code> 来判断是否可以使用 then 方法，更准确的方法应该判断是否实现了 thenable 接口。</p><h2 id="实现-Promise-any-方法"><a href="#实现-Promise-any-方法" class="headerlink" title="实现 Promise.any 方法"></a>实现 Promise.any 方法</h2><p>Promise.any 接收一个包含多个 Promise 的数组（实际只需要实现 Iterable ），当有一个 Promise 为 fulfilled 状态时，则整个 Promise.any 为 onfulfilled，并执行 onFulfilled 回调函数。如果所有的 Promise 均 rejected 了，则整个 Promise.andy 为 rejected.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">MyPromise</span>.<span class="property">any</span> = <span class="keyword">function</span>(<span class="params">promiseArr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> reasons = [];</span><br><span class="line">        <span class="keyword">let</span> rejectedPromise = <span class="number">0</span>;</span><br><span class="line">        promiseArr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">promise, idx</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (promise <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) &#123;</span><br><span class="line">                promise.<span class="title function_">then</span>(resolve, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">                    reasons[idx] = reason;</span><br><span class="line">                    rejectedPromise++;</span><br><span class="line">                    <span class="keyword">if</span> (rejectedPromise === promiseArr.<span class="property">length</span>) &#123;</span><br><span class="line">                        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">AggregateError</span>(reasons, <span class="string">&#x27;All Promises rejected&#x27;</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">resolve</span>(promise);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端工程化</title>
      <link href="/blog/2021/03/22/FE-%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
      <url>/blog/2021/03/22/FE-%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>前端工程化是使用软件工程的技术和方法来对前端项目的开发、测试、上线和维护进行管理的方法。前端工程化的目的是为了提升开发效率，提高产品质量。主要包括以下几个方面：</p><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>前端模块化是指前端项目中包括 Javascript、CSS、HTML 和图片、字体、文本、声音等各种资源文件的编译、拆分、合并和引用的过程。  </p><span id="more"></span><h3 id="js-模块化-amp-编译"><a href="#js-模块化-amp-编译" class="headerlink" title="js 模块化 &amp; 编译"></a>js 模块化 &amp; 编译</h3><p>在ES6之前，JavaScript一直没有模块系统，这对开发大型复杂的前端工程造成了巨大的障碍。对此社区制定了一些模块加载方案，如 CommonJS 、 AMD 和 CMD 等。<br>现在ES6已经在语言层面上规定了模块系统，完全可以取代现有的 CommonJS 和 AMD 规范，而且使用起来相当简洁，并且有静态加载的特性。<br>但是目前浏览器还没有完全支持这种规范，所以，要实现 ES6 Module 规范的话，还需要使用编译工具进行编译。我们可以使用 Babel(Javascript编译器) 对JS源码进行编译，将ES6特性编译为浏览器支持的语法，这样我们就可以在JS源码中使用ES6的新特性包括模块化编程。  </p><h3 id="css-模块化-amp-预编译"><a href="#css-模块化-amp-预编译" class="headerlink" title="css 模块化 &amp; 预编译"></a>css 模块化 &amp; 预编译</h3><p>CSS预编译器的工作原理是提供便捷的语法和特性供开发者编写源代码，随后经过专门的编译工具将源码转化为CSS语法。目前流行的CSS预编译器有 SASS 、LESS、 Stylus。  </p><p>css模块化 有三种解决方案包括 Shadow DOM、CSS in JS、CSS Modules</p><p>Shadow DOM 是 Web components 的标准。它能解决全局污染问题，但目前很多浏览器不兼容，对我们来说还很久远；<br>CSS in JS 是彻底抛弃CSS，使用JS或JSON来写样式。这种方法很激进，不能利用现有的CSS技术，而且处理伪类等问题比较困难；<br>CSS Modules 仍然使用CSS，只是让JS来管理依赖。它能够最大化地结合CSS生态和JS模块化能力，目前来看是比较好的解决方案。Vue的scoped style就是一种CSS Modules 方案。  </p><h3 id="HTML-模板"><a href="#HTML-模板" class="headerlink" title="HTML 模板"></a>HTML 模板</h3><p>HTML模板技术是为了将数据和模板结合可以动态的生成HTML页面。常用的模板引擎有 Jade、EJS、Mustache、Handlebars、JSHTML、Smarty（PHP）。</p><h3 id="资源模块化"><a href="#资源模块化" class="headerlink" title="资源模块化"></a>资源模块化</h3><p>web应用中不仅仅需要考虑 js/css资源，还需要考虑诸如文本，图片，字体等资源的管理。  </p><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>前端组件化是指从设计层面上对用户界面的拆分。从UI中拆分出来的一个结构单元，称为UI组件，一个UI组件单元包含了HTML模板、CSS样式、JS逻辑。组件是可以嵌套的，一个页面可以拆分成若干个大组件，大组件可以拆分成中型组件，中型组件可以拆分成小组件，直到拆分成DOM元素。组件的拆分是为了复用，一个组件应该包含完整的功能，可以在多个页面中复用，或者被多个更大型的组件复用。  </p><p>目前比较流行的js框架都有组件库，例如 Vue 有 <a href="https://github.com/ElemeFE/element">Element-ui</a>、<a href="https://github.com/iview/iview">iview</a>、<a href="https://github.com/vuetifyjs/vuetify">Vuetify</a>、<a href="https://github.com/vuematerial/vue-material">Vue Material</a> 等，React 有 <a href="https://github.com/ant-design/ant-design">Ant Design</a>、<a href="https://github.com/mui-org/material-ui">Material-UI</a>、<a href="https://github.com/react-bootstrap/react-bootstrap">React-Bootstrap</a>、<a href="https://github.com/react-toolbox/react-toolbox">React toolbox</a>、<a href="https://github.com/nikgraf/belle">React Belle</a>、<a href="http://grommet.io/">React Grommet</a>、<a href="https://github.com/ant-design/ant-design">Ant Design React</a></p><h2 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h2><p>前端规范化是指在前端项目进行过程中制定各种项目规范与标准。这又包括以下几个部分：  </p><h3 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h3><p>通常包括 JS编码规范、CSS编码规范、HTML编码规范。  </p><p><strong>JS编码规范</strong> 通常使用代码检查工具来进行代码格式检查，知名代码格式检查工具包括 <a href="https://github.com/douglascrockford/JSLint">JSlint</a>、<a href="https://github.com/jshint/jshint">JSHint</a>、<a href="https://github.com/eslint/eslint">ESLint</a> 等，其中 ESLint 目前较为流行，目前基于 ESLint 的知名的代码规范有 <a href="https://github.com/standard/standard">Standard Style Guide</a>、<a href="https://github.com/airbnb/javascript">Airbnb JavaScript Style Guide</a>、<a href="https://github.com/google/eslint-config-google">Google Style Guide</a>。  </p><p><strong>CSS编码规范</strong> 有代码检查工具 <a href="https://github.com/stylelint/stylelint">stylelint</a> 。为了保持同一个项目中的CSS代码复用和样式统一的问题，有些项目也会使用特殊的CSS编码规范，例如 BEM、OOCSS、SMACSS  </p><p><strong>HTML编码规范</strong> 规则较少，主要集中于使用语义化标签和HTML标签属性和值的使用习惯。  </p><h3 id="其他规范"><a href="#其他规范" class="headerlink" title="其他规范"></a>其他规范</h3><p>除了编码规范外的其他规范。  </p><p><strong>字体规范</strong> 主要体现在字体文件使用的一致性上。  </p><p><strong>图片规范</strong> 主要体现在图片的质量、图片引入方式、图片类型、图片合并、图片CDN的规范和约束上。  </p><p><strong>命名规范&amp;文件目录规范</strong> 主要体现在项目的资源命名、目录结构应该合理、清晰、可扩展。  </p><p><strong>接口规范</strong> 主要体现在前后端分离情况下，对联合调试时接口的认同上应符合一定的规范来避免责任不清的问题。接口规范一般应包括对以下内容的解释与样例，包括接口请求类型、接口请求地址、接口请求参数名、请求参数类型、请求参数是否必填、请求参数取值范围、请求参数样例、请求参数备注、请求返回结构（包括返回参数名&amp;类型&amp;是否必填&amp;取值范围&amp;样例&amp;备注）、请求返回错误码映射等。目前有多种接口工具用来约束接口规范，包括 Yapi、swagger、PostMan 等，这些工具一般还提供接口Mock甚至接口规范权限管理的功能，方便对接口进行调试和管理。  </p><p><strong>文档规范</strong> 主要体现在对项目开发、调试、检查、测试、上线、运维的说明文档的书写规范。目前较常用的文档均使用 Markdown 进行书写，或在 Markdown 的基础上进行进一步的扩展。  </p><p><strong>代码管理规范（git规范）</strong> 通常指代码管理流程中的一系列标准化问题。目前主要的代码管理工具有 SVN 和 Git，Git由于对分布式开发的友好基本上占据了绝大部分的市场分割。所以目前的代码管理规范主要包括 git工作流 &amp; branch命名管理 和 commit管理。  </p><h2 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h2><p>前端自动化是指在项目进行过程中的自动化构建、自动化测试、持续集成和线上监控的部分。  </p><h3 id="自动化构建"><a href="#自动化构建" class="headerlink" title="自动化构建"></a>自动化构建</h3><p>自动化构建是将源代码利用工具自动转换成用户可以使用的目标的过程。常用的前端项目构建工具包括 webpack、gulp、grunt、rollup、browserify、fis 等。  </p><h3 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h3><p>自动化测试是指测试的自动化，一般包括单元测试、集成测试和端到端测试的自动化。  </p><h4 id="单元测试-UT"><a href="#单元测试-UT" class="headerlink" title="单元测试(UT)"></a>单元测试(UT)</h4><p>单元测试是指对程序中最小可测试单元进行的测试。<br>Karma：Karma为前端自动化测试提供了跨浏览器测试的能力，可以在浏览器中执行测试用例<br>还有一些知名单元测试框架：Jasmine、Mocha、Jest、AVA、Tape<br>测试一般包含多个部分，除了基础测试框架，还可包括 数据模拟 Mock、测试运行环境配置、断言库、覆盖率统计，部分测试框架只是提供了基础测试框架并没有进行集成。<br>一些知名的测试周边:should.js、expect.js、chai.js、sinon.js、istanbul<br>关于他们之间的异同，可以查看 https://juejin.cn/post/6844903589488361486</p><h4 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h4><p>在单元测试的基础上，将所有模块按照设计要求（如根据结构图）组装成为子系统或系统，进行的测试称为集成测试。  </p><h4 id="端到端测试-E2E"><a href="#端到端测试-E2E" class="headerlink" title="端到端测试(E2E)"></a>端到端测试(E2E)</h4><p>前端的端到端测试是指从用户角度来测试web应用质量。<br>端到端测试需要web容器来运行用例，例如 Chromium, Electron, PhantomJS, WebDriver。  </p><p>知名端到端测试框架有：<a href="https://github.com/puppeteer/puppeteer">Puppeteer</a>、<a href="https://github.com/segmentio/nightmare">Nightmare</a>、<a href="https://github.com/nightwatchjs/nightwatch">Nightwatch</a>、<a href="https://github.com/cypress-io/cypress">Cypress</a></p><h3 id="持续集成（CI）"><a href="#持续集成（CI）" class="headerlink" title="持续集成（CI）"></a>持续集成（CI）</h3><p>持续集成(CI)是一种软件开发实践，它基于将代码频繁集成到共享代码仓中。 然后通过自动构建(automated build)验证每个签入(Check-In)。<br>常用的持续集成工具有 travis、jenkins。</p><h3 id="线上监控"><a href="#线上监控" class="headerlink" title="线上监控"></a>线上监控</h3><p>前端项目上线后，需要对线上情况进行监控，统计前端代码错误（包括错误堆栈信息、用户环境等）、记录用户行为、统计网站性能数据等。<br>Google Anaytics、 百度统计都可以对用户行为进行记录。而 <a href="https://github.com/getsentry/sentry">Sentry</a> 可以进行异常捕获与分析。</p>]]></content>
      
      
      
        <tags>
            
            <tag> front-end </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS Array 数组</title>
      <link href="/blog/2021/03/21/JS-Array-%E6%95%B0%E7%BB%84/"/>
      <url>/blog/2021/03/21/JS-Array-%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>在 js 中 Array 对象支持在单个变量名下存储多个元素，并具有执行常见数组操作的属性与方法。Array 不是基本类型，而是具有以下核心特征的 Array 对象：</p><ul><li>JavaScript 数组是可调整大小的，并且可以包含不同的数据类型。</li><li>JavaScript 数组不是关联数组，因此，不能使用任意字符串作为索引访问数组元素，但必须使用非负整数（或它们各自的字符串形式）作为索引访问。</li><li>JavaScript 数组的索引从 0 开始，最后一个元素是数组的 length 属性减去 1 的值。</li><li>JavaScript 数组复制操作创建浅拷贝。</li></ul><h2 id="Array-的属性-amp-方法"><a href="#Array-的属性-amp-方法" class="headerlink" title="Array 的属性&amp;方法"></a>Array 的属性&amp;方法</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li><code>Array.prototype.length</code>: 设置或返回数组中元素的数目，值是一个 0 到 2^32 - 1 的整数。</li><li><code>get Array[@@species]</code>: 访问器属性，返回数组的构造函数。</li><li><code>Array.prototype[@@unscopables]</code>: 包含了所有 ES2015 (ES6) 之后新定义的、且并未被更早的 ECMAScript 标准收纳的方法名。这些方法被排除在由 <code>with</code> 语句绑定的环境中。</li></ul><h3 id="原型方法（实例方法）"><a href="#原型方法（实例方法）" class="headerlink" title="原型方法（实例方法）"></a>原型方法（实例方法）</h3><h4 id="改变原数组的方法"><a href="#改变原数组的方法" class="headerlink" title="改变原数组的方法"></a>改变原数组的方法</h4><ul><li><code>Array.prototype.unshift()</code>: 将一个或多个元素添加到数组的开头，并返回该数组的新长度。</li><li><code>Array.prototype.shift()</code>: 从数组中删除第一个元素，并返回该元素的值。</li><li><code>Array.prototype.push()</code>: 将新元素添加到数组的最后，并返回数组的新长度值。</li><li><code>Array.prototype.pop()</code>: 从数组中删除最后一个元素，并返回该元素的值。</li><li><code>Array.prototype.splice(start[, deleteCount[, item1[, item2[, ...]]]])</code>: 通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回被修改的内容。</li><li><code>Array.prototype.reverse()</code>: 将数组中元素的位置颠倒，并返回该数组。</li><li><code>Array.prototype.sort([compareFunction])</code>: 用原地算法对数组的元素进行排序，并返回该数组。</li><li><code>Array.prototype.fill(value[, start[, end]])</code>: 用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。</li><li><code>Array.prototype.copyWithin(target[, start[, end]])</code>: 浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。</li></ul><span id="more"></span><h4 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h4><ul><li><code>Array.prototype.slice([begin[, end]])</code>: 返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括 end）。</li><li><code>Array.prototype.join(separator)</code>: 将数组的元素组起一个字符串，以separator为分隔符，省略的话则用默认用逗号为分隔符。</li><li><code>Array.prototype.concat(value1[, value2[, ...[, valueN]]])</code>: 用于合并两个或多个数组。</li><li><code>Array.prototype.includes(valueToFind[, fromIndex])</code>: 用来判断一个数组是否包含一个指定的值。</li><li><code>Array.prototype.indexOf(searchElement[, fromIndex])</code>: 返回在数组中可以找到一个给定元素的第一个索引。</li><li><code>Array.prototype.lastIndexOf(searchElement[, fromIndex])</code>: 返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引。</li><li><code>Array.prototype.flat([depth])</code>: 按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。</li><li><code>Array.prototype.flatMap(function callback(currentValue[, index[, array]]) &#123;/* return element for new_array */&#125;[, thisArg])</code>: 首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。</li></ul><h4 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h4><ul><li><code>Array.prototype[@@iterator]()</code>: 与 <code>Array.prototype.values()</code> 相同，返回一个新的 Array Iterator 对象，该对象包含数组每个索引的值。</li><li><code>Array.prototype.entries()</code>: 返回一个新的 Array Iterator 对象，该对象包含数组中每个索引的键/值对。</li><li><code>Array.prototype.keys()</code>: 返回一个包含数组中每个索引键的 Array Iterator 对象。</li><li><code>Array.prototype.values()</code>: 返回一个新的 Array Iterator 对象，该对象包含数组每个索引的值。</li></ul><h4 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h4><ul><li><code>Array.prototype.toLocaleString([locales[,options]])</code>: 返回一个字符串表示数组中的元素。数组中的元素将使用各自的 toLocaleString 方法转成字符串。</li><li><code>Array.prototype.toString()</code>: 返回一个字符串，表示指定的数组及其元素。</li></ul><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><ul><li><code>Array.prototype.forEach(callback(currentValue [, index [, array]])[, thisArg])</code>: 对数组的每个元素执行一次给定的函数。</li><li><code>Array.prototype.map(callback(currentValue[, index[, array]]) &#123;/* Return element for new_array */&#125;[, thisArg])</code>: 创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。</li><li><code>Array.prototype.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</code>: 对数组中的每个元素执行一个由你提供的 reducer 函数(升序执行)，将其结果汇总为单个返回值。</li><li><code>Array.prototype.reduceRight(callback(accumulator, currentValue[, index[, array]])[, initialValue])</code>: 和 <code>reduce</code> 相似，降序执行。</li><li><code>Array.prototype.some(callback(element[, index[, array]])[, thisArg])</code>: 测试数组中是不是至少有1个元素通过了被提供的函数测试。</li><li><code>Array.prototype.every(callback(element[, index[, array]])[, thisArg])</code>: 测试一个数组内的所有元素是否都能通过某个指定函数的测试。</li><li><code>Array.prototype.filter(callback(element[, index[, array]])[, thisArg])</code>: 创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。</li><li><code>Array.prototype.find(callback[, thisArg])</code>: 返回数组中满足提供的测试函数的第一个元素的值。</li><li><code>Array.prototype.findIndex(callback[, thisArg])</code>: 返回数组中满足提供的测试函数的第一个元素的索引。</li></ul><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><ul><li><code>Array.from(arrayLike[, mapFn[, thisArg]])</code>: 从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。</li><li><code>Array.of([element1[, element2[, ...[, elementN]]]])</code>: 创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。</li><li><code>Array.isArray()</code>: 用于确定传递的值是否是一个 Array 对象实例。</li></ul><h2 id="Array-of-静态方法和-Array-构造函数之间的区别"><a href="#Array-of-静态方法和-Array-构造函数之间的区别" class="headerlink" title="Array.of() 静态方法和 Array() 构造函数之间的区别"></a><code>Array.of()</code> 静态方法和 <code>Array()</code> 构造函数之间的区别</h2><p><code>Array.of()</code> 和 <code>Array()</code> 构造函数之间的区别在于对单个数字参数的处理：<code>Array.of(7)</code> 创建一个具有单个元素 7 的数组，而 <code>Array(7)</code> 创建一个 length 为 7 的空数组（这意味着一个由 7 个空属性组成的数组，而不是具有实际 undefined 值的槽）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 对象的对象特性</title>
      <link href="/blog/2021/03/21/JS-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7/"/>
      <url>/blog/2021/03/21/JS-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="对象特性（object-attribute）有哪些？分别有什么含义？"><a href="#对象特性（object-attribute）有哪些？分别有什么含义？" class="headerlink" title="对象特性（object attribute）有哪些？分别有什么含义？"></a>对象特性（object attribute）有哪些？分别有什么含义？</h3><p>对象除了包含属性外还拥有三个相关的对象特性：  </p><ol><li>原型 prototype: 指向另外一个对象，本对象的属性继承自它的原型对象<br>通过 <code>Object.getPropertyOf($object)</code> 可以获取对象的原型对象，或者通过非正式的 <code>$object.__proto__</code> 获取对象的原型对象  </li><li>类 class: 标志对象类型的字符串<br>通过 toString 方法获取第8到倒数第二个位置之间的字符可以获取  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">classof</span>(<span class="params">o</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (o === <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">&#x27;Null&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (o === <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="string">&#x27;Undefined&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(o).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>扩展标记 extensible flag: 指明了是否可以向该对象添加新属性<br>通过 <code>Object.isExtensible($object)</code> 来判断该对象是否可扩展，通过 <code>Object.preventExtensions($object)</code> 来将对象设置成不可扩展的。  </li></ol><p>tips:<br><code>Object.seal($object)</code> 可以将对象设置为不可扩展且所有自有（非继承）属性不能删除与配置。<br>通过 <code>Object.isSealed($object)</code> 判断对象是否被封闭。  </p><p><code>Object.freeze($object)</code> 可以将对象设置为不可扩展、不可配置且所有自有（非继承）属性设置为只读。<br>通过 <code>Object.isFrozen($object)</code> 判断对象是否冻结。  </p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> object </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 对象的属性特性</title>
      <link href="/blog/2021/03/21/JS-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E7%89%B9%E6%80%A7/"/>
      <url>/blog/2021/03/21/JS-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="对象的属性特性（property-attribute）有哪些？分别有什么含义？"><a href="#对象的属性特性（property-attribute）有哪些？分别有什么含义？" class="headerlink" title="对象的属性特性（property attribute）有哪些？分别有什么含义？"></a>对象的属性特性（property attribute）有哪些？分别有什么含义？</h3><ol><li>可写 writeable attribute: 表明是否可以设置该属性的值  </li><li>可枚举 enumerable attribute: 表明是否可以通过for/in循环返回该属性  </li><li>可配置 configurable attribute: 表明是否可以删除或修改该属性  </li></ol><p><code>Object.getOwnPropertyDescriptor($object, $property)</code> 可以获取对象的属性特性  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>($object, $property, &#123;</span><br><span class="line">    <span class="attr">value</span>: $value,</span><br><span class="line">    <span class="attr">writable</span>: $boolean,</span><br><span class="line">    enumerable; $boolean,</span><br><span class="line">    <span class="attr">configurable</span>: $boolean</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">definePropertys</span>($object, &#123;</span><br><span class="line">    <span class="attr">$property1</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: $value,</span><br><span class="line">        <span class="attr">writable</span>: $boolean,</span><br><span class="line">        enumerable; $boolean,</span><br><span class="line">        <span class="attr">configurable</span>: $boolean</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">$property2</span>: &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以设置对象的属性特性  </p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> object </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS this</title>
      <link href="/blog/2021/03/21/JS-this/"/>
      <url>/blog/2021/03/21/JS-this/</url>
      
        <content type="html"><![CDATA[<p><code>this</code> 是一个关键字。和变量不同，关键字 <code>this</code> 没有作用域限制，如果嵌套函数作为方法调用，其 <code>this</code> 的值指向调用它的对象，如果嵌套函数作为函数调用，其 <code>this</code> 的值是全局对象（非严格模式）或者 <code>undefined</code>（严格模式）。<br>如果希望在嵌套函数中调用外层函数的上下文，需要将外层函数的 <code>this</code> 值保存到一个变量（例如self、context或者_this）里，这个变量和内部函数都在同一个作用域里。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> this </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 声明提前</title>
      <link href="/blog/2021/03/21/JS-%E5%A3%B0%E6%98%8E%E6%8F%90%E5%89%8D/"/>
      <url>/blog/2021/03/21/JS-%E5%A3%B0%E6%98%8E%E6%8F%90%E5%89%8D/</url>
      
        <content type="html"><![CDATA[<p>var命令声明函数中的变量，不管在函数中什么位置，由于其函数作用域的特性，变量在函数中任何位置始终可见，相当于变量声明被“提升”到函数体的头部。“声明提前”这步操作是在JavaScript引擎的“预编译”时进行的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 作用域&amp;作用域链</title>
      <link href="/blog/2021/03/21/JS-%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
      <url>/blog/2021/03/21/JS-%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<p>一个变量的作用域（scope）指的是程序源代码中定义这个变量的区域。<br>JavaScript只有两种作用域，全局作用域、函数作用域（ES6中新增了块级作用域）。<br>函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。每一段JavaScript代码（全局代码或者函数）都有一个与之关联的作用域链（scope chain）。这个作用域链是一个对象列表或者链表，这组对象定义了这段代码“作用域中”的变量。当 JavaScript 需要查找变量 x 的值的时候（这个过程被称为“变量解析”（variable resolution）），它会从链中的第一个对象开始查找，如果这个对象有一个名为 x 的属性，则会直接使用这个属性的值，如果第一个对象中不存在名为 x 的属性，JavaScript 会继续查找链上的下一个对象，以此类推。如果作用域链上没有任何一个对象含有属性 x，那么就会抛出一个引用错误（ReferenceError）的异常。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 组件生命周期</title>
      <link href="/blog/2021/03/20/React-%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/blog/2021/03/20/React-%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="组件状态"><a href="#组件状态" class="headerlink" title="组件状态"></a>组件状态</h2><ul><li>Mounting：已插入真实 DOM</li><li>Updating：正在被重新渲染</li><li>Unmounting：已移出真实 DOM</li></ul><span id="more"></span><h2 id="组件生命周期钩子"><a href="#组件生命周期钩子" class="headerlink" title="组件生命周期钩子"></a>组件生命周期钩子</h2><ul><li><p><code>componentWillMount</code> 在渲染前调用,在客户端也在服务端。</p></li><li><p><code>componentDidMount</code> 在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。 如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异部操作阻塞UI)。</p></li><li><p><code>componentWillReceiveProps</code> 在组件接收到一个新的 prop (更新后)时被调用。这个方法在初始化render时不会被调用。</p></li><li><p><code>shouldComponentUpdate</code> 返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用。<br>可以在你确认不需要更新组件时使用。</p></li><li><p><code>componentWillUpdate</code> 在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用。</p></li><li><p><code>componentDidUpdate</code> 在组件完成更新后立即调用。在初始化时不会被调用。</p></li><li><p><code>componentWillUnmount</code> 在组件从 DOM 中移除的时候立刻被调用。</p></li></ul><h2 id="异步数据请求应在哪些生命周期里调用"><a href="#异步数据请求应在哪些生命周期里调用" class="headerlink" title="异步数据请求应在哪些生命周期里调用"></a>异步数据请求应在哪些生命周期里调用</h2><ul><li>通过网络请求获取数据或订阅数据更新 - <code>componentDidMount()</code><ul><li>首次挂载时执行</li><li>不会重复请求或订阅数据更新</li><li>无需条件不容易触发重复渲染</li></ul></li><li>有条件地通过网络请求数据 - <code>componentDidUpdate(prevProps, prevState, snapshot)</code><ul><li>可对比更新前后的 props 或 states</li><li>可以设置条件当且仅当条件满足时，通过网络请求数据，避免触发重复渲染</li></ul></li><li>取消网络请求或者清除在 <code>componentDidMount()</code> 中创建的订阅 - <code>componentWillUnmount()</code></li></ul><h2 id="为什么要用-React-Hook-代替拥有生命周期的类组件"><a href="#为什么要用-React-Hook-代替拥有生命周期的类组件" class="headerlink" title="为什么要用 React Hook 代替拥有生命周期的类组件"></a>为什么要用 React Hook 代替拥有生命周期的类组件</h2><p>React Hook 是 React 16.8 的新增特性，开发者可以在不编写 Class 的情况下使用 State 以及其他的 React 特性，React Hook 使得相似功能的代码在物理上可以更接近方便代码理解，同时更利于代码复用。</p><h3 id="类组件的弊端"><a href="#类组件的弊端" class="headerlink" title="类组件的弊端"></a>类组件的弊端</h3><ul><li>组件之间复用状态逻辑很难<ul><li>React 没有提供将可复用性行为“附加”到组件的途径</li><li>使用 render props 和 高阶组件<ul><li>需要重新组织组件结构，使得代码难以理解</li><li>形成“嵌套地域”，难以调试和维护</li></ul></li></ul></li><li>复杂组件变得难以理解<ul><li>组件被状态逻辑和副作用充斥</li><li>不相关逻辑被放在同一生命周期，相关逻辑被分散在不同生命周期<ul><li>componentDidMount/componentDidUpdate 获取数据</li><li>componentDidMount 可能还包含事件监听，需在 componentWillUnmount 清除</li></ul></li><li>大量的状态逻辑，许多人使用状态管理库，组件复用和调试都比较困难</li></ul></li><li>难以理解的类组件<ul><li>大量的 this 绑定，较高学习成本，区分函数组件和类组件的使用场景</li><li>类组件会无意中鼓励开发者使用一些让 Prepack 等组件预编译优化措施无效的方案</li><li>类组件不能被很好的压缩，热重载不稳定，实例化类组件有轻微额外性能消耗</li></ul></li><li>有限的是否渲染控制<ul><li>使用 PureComponent 执行一层浅比较 props 或 state，值变化时渲染</li><li>使用 shouldComponentUpdate 函数<ul><li>手动比较前后 props 或 state，返回 true 渲染，false 不渲染</li><li>若 state 为对象，使用不可变对象，简化并加速比较</li></ul></li><li>在 setState 前设置判断条件，满足条件后再 setState</li></ul></li></ul><h3 id="React-Hook-解决的问题"><a href="#React-Hook-解决的问题" class="headerlink" title="React Hook 解决的问题"></a>React Hook 解决的问题</h3><ul><li>提高组件复用<ul><li>Hook 在无需修改组件结构的情况下，复用状态逻辑，共享 Hook 变得更便捷</li></ul></li><li>简化组件<ul><li>Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据）</li><li>非按照生命周期划分，可以使用 Reducer 来管理组件内部状态，使其更加可预测</li></ul></li><li>函数组件代替类组件<ul><li>Hook 在不使用类组件的情况下使用 State 以及其他的 React 特性</li><li>Hook 改造类组件为函数组件，容易理解 this 和学习，便于预编译等优化措施</li><li>Hook 拥抱函数式声明式编程，而无需学习复杂的函数式或响应式编程技术</li></ul></li><li>丰富的更细粒度的是否渲染控制<ul><li>使用 React.memo 比较 props 再渲染组件<ul><li>不使用第二参数时，一层浅比较 props，变化时渲染</li><li>使用第二参数时，手动比较前后的 props，返回 false 渲染，true 不渲染</li></ul></li><li>使用 useMemo 指定依赖，细粒度渲染组件<ul><li>使用第二参数，传入依赖数组，当数组中的值发生变化时，更新返回值</li><li>通常包裹函数式组件的返回值，指定依赖的 props 或 state 的具体值</li><li>包裹任意需要复杂计算的函数，指定依赖的变量。能在同一组件中部分和多次使用</li></ul></li><li>使用 useCallback 避免函数重复创建引起渲染<ul><li>当函数式组件重新更新时，内部声明的函数可能会被重复创建<ul><li>将这些函数作为 props 传入的子组件会重复渲染</li><li>使用 useCallback 包裹函数，传入空数组，总是返回相同函数来避免重复创建引起的渲染</li></ul></li></ul></li></ul></li></ul><h2 id="useEffect-useLayoutEffect-与生命周期的对应关系"><a href="#useEffect-useLayoutEffect-与生命周期的对应关系" class="headerlink" title="useEffect useLayoutEffect 与生命周期的对应关系"></a>useEffect useLayoutEffect 与生命周期的对应关系</h2><ul><li>useLayoutEffect<ul><li>执行时机是组件挂载或更新之后，浏览器执行绘制之前<ul><li>与 componentDidMount + componentDidUpdate 一致</li></ul></li><li>支持返回清除函数，函数执行时机是组件卸载之前<ul><li>与 componentWillUnmout 一致</li></ul></li></ul></li><li>useEffect<ul><li>执行时机是组件挂载或更新之后，浏览器完成布局和绘制之后，在一个延迟事件中被调用<ul><li>与 componentDidMount + componentDidUpdate 不同</li></ul></li><li>支持返回清除函数，函数执行时机是组件卸载之前<ul><li>与 componentWillUnmout 一致</li></ul></li></ul></li></ul><p>两者都适用于在函数组件主体内，即 React 渲染阶段改变 DOM，添加订阅，设置定时器，记录日志以及执行其他包含副作用的操作。优先使用 useEffect 避免阻塞视觉更新，只在需要读取 DOM 布局，在浏览器绘制前，同步触发重渲染的场景使用 useLayoutEffect 。</p>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 数据类型</title>
      <link href="/blog/2021/03/20/JS-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/blog/2021/03/20/JS-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="js-有哪些数据类型"><a href="#js-有哪些数据类型" class="headerlink" title="js 有哪些数据类型"></a>js 有哪些数据类型</h2><p>js有八种数据类型： 数值number（包括整数和浮点数），字符串string，布尔值boolean，未定义undefined，空值null，对象object，符号symbol(ES6添加)，大数bigint(ES2020添加)<br>其中除对象外都是基本数据类型（primitive data type），没有方法，在js中用栈（stack）来存储，对象又被称为引用类型，在js中用堆（heap）来存储。<br>对象又分为多种 object array function date …<br>除了 null 和 undefined 之外，所有基本类型都有其对应的包装对象：</p><p><code>Number</code> 为数值基本类型的包装对象。<br><code>String</code> 为字符串基本类型的包装对象。<br><code>Boolean</code> 为布尔基本类型的包装对象。<br><code>Symbol</code> 为字面量基本类型(不支持 new Symbol())的包装对象。<br><code>BigInt</code> 为bigint类型(不支持 new BigInt())的包装对象。<br>一个包装对象的valueOf()方法将会返回它的基本类型值。  </p><span id="more"></span><h2 id="如何区分属于哪种数据类型"><a href="#如何区分属于哪种数据类型" class="headerlink" title="如何区分属于哪种数据类型"></a>如何区分属于哪种数据类型</h2><p><code>typeof</code> 运算符: <code>typeof</code> 操作符返回一个字符串，表示未经计算的操作数的类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">123</span> <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Infinity</span> <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">NaN</span> <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;123&#x27;</span> <span class="comment">// &#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">false</span> <span class="comment">// &#x27;boolean&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// &#x27;boolean&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// &#x27;object&#x27; 历史原因，判断一个值是否是 null 可以通过恒等 === 来区分</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="keyword">typeof</span> f <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>([]) <span class="comment">// true</span></span><br><span class="line"><span class="keyword">const</span> symbol = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">typeof</span> symbol <span class="comment">// &#x27;symbol&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">String</span> <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;string&#x27;</span> <span class="comment">// string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">String</span>() <span class="comment">// &#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="title class_">String</span>() <span class="comment">// &#x27;object&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="实用的返回数据类型的方法"><a href="#实用的返回数据类型的方法" class="headerlink" title="实用的返回数据类型的方法"></a>实用的返回数据类型的方法</h2><p>参见<a href="/blog/2021/03/19/JS-实践/#写一个方法返回入参类型">写一个方法返回入参类型</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS display属性</title>
      <link href="/blog/2021/03/19/CSS-display%E5%B1%9E%E6%80%A7/"/>
      <url>/blog/2021/03/19/CSS-display%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="display-属性的含义"><a href="#display-属性的含义" class="headerlink" title="display 属性的含义"></a>display 属性的含义</h2><p><code>display</code> 属性可以设置元素的内部和外部显示类型。元素的外部显示类型将决定该元素在流式布局中的表现。元素的内部显示类型可以控制其子元素的布局。  </p><p>CSS3规范详细说明了 <code>display</code> 属性的两个值—显式地启用外部和内部显示类型的规，但是浏览器还没有很好地支持这一点。</p><span id="more"></span><h2 id="display-属性语法"><a href="#display-属性语法" class="headerlink" title="display 属性语法"></a>display 属性语法</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* legacy values */</span></span><br><span class="line"><span class="attribute">display</span>: block;</span><br><span class="line"><span class="attribute">display</span>: inline;</span><br><span class="line"><span class="attribute">display</span>: inline-block;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line"><span class="attribute">display</span>: inline-flex;</span><br><span class="line"><span class="attribute">display</span>: grid;</span><br><span class="line"><span class="attribute">display</span>: inline-grid;</span><br><span class="line"><span class="attribute">display</span>: flow-root;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* box generation */</span></span><br><span class="line"><span class="attribute">display</span>: none;</span><br><span class="line"><span class="attribute">display</span>: contents;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* two-value syntax */</span></span><br><span class="line"><span class="attribute">display</span>: block flow;</span><br><span class="line"><span class="attribute">display</span>: inline flow;</span><br><span class="line"><span class="attribute">display</span>: inline flow-root;</span><br><span class="line"><span class="attribute">display</span>: block flex;</span><br><span class="line"><span class="attribute">display</span>: inline-flex;</span><br><span class="line"><span class="attribute">display</span>: block grid;</span><br><span class="line"><span class="attribute">display</span>: inline grid;</span><br><span class="line"><span class="attribute">display</span>: block flow-root;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* other values */</span></span><br><span class="line"><span class="attribute">display</span>: table;</span><br><span class="line"><span class="attribute">display</span>: table-row; <span class="comment">/* all table elements have an equivalent CSS display value */</span></span><br><span class="line"><span class="attribute">display</span>: list-item;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Global values */</span></span><br><span class="line"><span class="attribute">display</span>: inherit;</span><br><span class="line"><span class="attribute">display</span>: initial;</span><br><span class="line"><span class="attribute">display</span>: unset;</span><br></pre></td></tr></table></figure><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="外部显示类型"><a href="#外部显示类型" class="headerlink" title="外部显示类型"></a>外部显示类型</h3><p>这些关键字指定元素的外部显示类型，它本质上是元素在流布局中的角色。  </p><h4 id="block"><a href="#block" class="headerlink" title="block"></a>block</h4><p>元素生成块元素框，在正常流中生成元素前后的换行符。  </p><h4 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h4><p>元素生成一个或多个内联元素框，这些内联元素框不会在它们之前或之后生成换行符。在正常流中，如果有空间，下一个元素将在同一行上。  </p><h3 id="内部显示类型"><a href="#内部显示类型" class="headerlink" title="内部显示类型"></a>内部显示类型</h3><h4 id="flow-root"><a href="#flow-root" class="headerlink" title="flow-root"></a>flow-root</h4><p>元素生成一个块元素框，该框建立一个新的块格式化上下文（BFC），定义格式化根所在的位置。  </p><h4 id="table"><a href="#table" class="headerlink" title="table"></a>table</h4><p>这些元素的行为类似于HTML <code>&lt;table&gt;</code> 元素。它定义了一个块级框。  </p><h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><p>元素的行为类似于块元素，并根据弹性盒子（flexbox）模型布局其内容。  </p><h4 id="grid"><a href="#grid" class="headerlink" title="grid"></a>grid</h4><p>元素的行为类似于块元素，并根据网格模型（grid model）布局其内容。  </p><h3 id="列表项"><a href="#列表项" class="headerlink" title="列表项"></a>列表项</h3><h4 id="list-item"><a href="#list-item" class="headerlink" title="list-item"></a>list-item</h4><p>使元素表现的像一个列表项。  </p><h3 id="内部选项"><a href="#内部选项" class="headerlink" title="内部选项"></a>内部选项</h3><p>一些标签的默认display属性</p><table><thead><tr><th>display</th><th>html标签</th></tr></thead><tbody><tr><td>table-row-group</td><td><code>&lt;tbody&gt;</code></td></tr><tr><td>table-header-group</td><td><code>&lt;thead&gt;</code></td></tr><tr><td>table-footer-group</td><td><code>&lt;tfoot&gt;</code></td></tr><tr><td>table-row</td><td><code>&lt;tr&gt;</code></td></tr><tr><td>table-cell</td><td><code>&lt;td&gt;</code></td></tr><tr><td>table-column-group</td><td><code>&lt;colgroup&gt;</code></td></tr><tr><td>table-column</td><td><code>&lt;col&gt;</code></td></tr><tr><td>table-caption</td><td><code>&lt;caption&gt;</code></td></tr></tbody></table><h3 id="盒"><a href="#盒" class="headerlink" title="盒"></a>盒</h3><h4 id="contents"><a href="#contents" class="headerlink" title="contents"></a>contents</h4><p>伪元素</p><h4 id="none"><a href="#none" class="headerlink" title="none"></a>none</h4><p>关闭元素的显示，使其对布局没有影响。  </p><h3 id="遗留"><a href="#遗留" class="headerlink" title="遗留"></a>遗留</h3><p>由于CSS2对display属性采用了单关键字语法，对于相同布局模式的块级和内联级变体，需要单独的关键字。</p><h4 id="inline-block"><a href="#inline-block" class="headerlink" title="inline-block"></a>inline-block</h4><p>相当于 <code>inline flow-root</code></p><h4 id="inline-table"><a href="#inline-table" class="headerlink" title="inline-table"></a>inline-table</h4><p>相当于 <code>inline table</code></p><h4 id="inline-flex"><a href="#inline-flex" class="headerlink" title="inline-flex"></a>inline-flex</h4><p>相当于 <code>inline flex</code></p><h4 id="inline-grid"><a href="#inline-grid" class="headerlink" title="inline-grid"></a>inline-grid</h4><p>相当于 <code>inline grid</code></p><h3 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Global values */</span></span><br><span class="line">    <span class="attribute">display</span>: inherit;</span><br><span class="line">    <span class="attribute">display</span>: initial;</span><br><span class="line">    <span class="attribute">display</span>: unset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML 行内元素&amp;块状元素</title>
      <link href="/blog/2021/03/19/HTML-%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0-%E5%9D%97%E7%8A%B6%E5%85%83%E7%B4%A0/"/>
      <url>/blog/2021/03/19/HTML-%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0-%E5%9D%97%E7%8A%B6%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="行内元素与块状元素有什么区别"><a href="#行内元素与块状元素有什么区别" class="headerlink" title="行内元素与块状元素有什么区别?"></a>行内元素与块状元素有什么区别?</h2><p>行内元素：会在水平方向排列，不能包含块级元素，设置width无效，height无效（可以设置line-height），margin上下无效，padding上下无效<br>块级元素：各占据一行，垂直方向排列。从新行开始结束接着一个断行  </p><h2 id="列举常用行内与块状元素"><a href="#列举常用行内与块状元素" class="headerlink" title="列举常用行内与块状元素"></a>列举常用行内与块状元素</h2><p>块级元素：div, p, h1-h5, form, ul, li<br>行内元素：span, a, label, input, img, strong, em  </p>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML html5常用标签</title>
      <link href="/blog/2021/03/19/HTML-html5%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"/>
      <url>/blog/2021/03/19/HTML-html5%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="html5新增的常用标签有哪些"><a href="#html5新增的常用标签有哪些" class="headerlink" title="html5新增的常用标签有哪些"></a>html5新增的常用标签有哪些</h3><p><code>header</code> 定义一个页面或一个区域的头部<br><code>footer</code> 定义一个页面或一个区域的底部<br><code>nav</code> 定义导航链接<br><code>aside</code> 定义页面内容部分的侧边栏<br><code>artical</code> 定义一篇文章<br><code>section</code> 定义一个区域<br><code>hgroup</code> 定义文件中一个区块的相关信息<br><code>figure</code> 定义一组媒体内容以及它们的标题<br><code>dialog</code> 定义一个对话框(会话框)类似微信<br><code>audio</code> 定义声音内容<br><code>video</code> 定义视频内容<br><code>canvas</code> 定义图形<br><code>embed</code> 定义外部交互内容或插件<br><code>mark</code> 定义有记号的文本  </p>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML 语义化</title>
      <link href="/blog/2021/03/19/HTML-%E8%AF%AD%E4%B9%89%E5%8C%96/"/>
      <url>/blog/2021/03/19/HTML-%E8%AF%AD%E4%B9%89%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="语义化"><a href="#语义化" class="headerlink" title="语义化"></a>语义化</h2><p>语义化就是根据内容选择标签。</p><h2 id="语义化的好处"><a href="#语义化的好处" class="headerlink" title="语义化的好处"></a>语义化的好处</h2><p>语义化的好处是使代码结构清晰，便于阅读，同时充分利用了SEO。  </p>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP get post区别</title>
      <link href="/blog/2021/03/19/HTTP-get-post%E5%8C%BA%E5%88%AB/"/>
      <url>/blog/2021/03/19/HTTP-get-post%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>1.get传参方式是通过地址栏URL传递，是可以直接看到get传递的参数，post传参方式参数URL不可见，get把请求的数据在URL后通过？连接，通过&amp;进行参数分割。psot将参数存放在HTTP的包体内</p><p>2.get传递数据是通过URL进行传递，对传递的数据长度是受到URL大小的限制，URL最大长度是2048个字符。post没有长度限制</p><p>3.get后退不会有影响，post后退会重新进行提交</p><p>4.get请求可以被缓存，post不可以被缓存</p><p>5.get请求只URL编码，post支持多种编码方式</p><p>6.get请求的记录会留在历史记录中，post请求不会留在历史记录</p><p>7.get只支持ASCII字符，post没有字符类型限制</p>]]></content>
      
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> get </tag>
            
            <tag> post </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 笔试题实践</title>
      <link href="/blog/2021/03/19/JS-%E7%AC%94%E8%AF%95%E9%A2%98%E5%AE%9E%E8%B7%B5/"/>
      <url>/blog/2021/03/19/JS-%E7%AC%94%E8%AF%95%E9%A2%98%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="书写一个数组去重的方法"><a href="#书写一个数组去重的方法" class="headerlink" title="书写一个数组去重的方法"></a>书写一个数组去重的方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用ES6 Set数据结构去重</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deduplication</span>(<span class="params">array</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(array));</span><br><span class="line">    <span class="comment">// return [...new Set(array)];</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历一遍 利用对象的属性不能相同的特点去重</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deduplication</span>(<span class="params">array</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;, result = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; array.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!obj[array[i]])&#123; <span class="comment">//如果能查找到，证明数组元素重复了</span></span><br><span class="line">            obj[array[i]] = <span class="number">1</span>;</span><br><span class="line">            result.<span class="title function_">push</span>(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双层遍历，内层遍历改用indexOf</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deduplication</span>(<span class="params">array</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    array.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item, index ,arr</span>)&#123;  <span class="comment">//这里利用map，filter方法也可以实现外层遍历</span></span><br><span class="line">        <span class="keyword">if</span>(arr.<span class="title function_">indexOf</span>(item, index + <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            result.<span class="title function_">push</span>(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双层遍历, 遇到重复则跳过，不重复的插入到新数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deduplication</span>(<span class="params">array</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; array.<span class="property">length</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] === array[j])&#123;</span><br><span class="line">                j = ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="title function_">push</span>(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双层遍历，删除重复，返回原数组 *对原数组有修改</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deduplication</span>(<span class="params">array</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> len = array.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] == array[j])&#123;</span><br><span class="line">                array.<span class="title function_">splice</span>(j, <span class="number">1</span>);</span><br><span class="line">                len--;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="书写将数组打乱顺序的方法"><a href="#书写将数组打乱顺序的方法" class="headerlink" title="书写将数组打乱顺序的方法"></a>书写将数组打乱顺序的方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用 Array.prototype.sort 对数组排序，排序比较函数随机返回</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">disorder</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">random</span>() &gt; <span class="number">.5</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 洗牌算法，遍历一遍与随机位置交换</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">shuffle</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> j, x, i = <span class="variable language_">this</span>.<span class="property">length</span> - <span class="number">1</span>; i; i--) &#123;</span><br><span class="line">    j = <span class="built_in">parseInt</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * i);</span><br><span class="line">    x = <span class="variable language_">this</span>[i];</span><br><span class="line">    <span class="variable language_">this</span>[i] = <span class="variable language_">this</span>[j];</span><br><span class="line">    <span class="variable language_">this</span>[j] = x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="书写一个方法将一个字符串倒序输出"><a href="#书写一个方法将一个字符串倒序输出" class="headerlink" title="书写一个方法将一个字符串倒序输出"></a>书写一个方法将一个字符串倒序输出</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用 String.prototype.split 拆分字符，利用 Array.prototype.reverse 逆序，利用 Array.prototype.join 合并</span></span><br><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">reverse</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用 Array.prototype.reduceRight 从后向前遍历</span></span><br><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">reverse</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">reduceRight</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, <span class="keyword">function</span>(<span class="params">result, char</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> result += char;</span><br><span class="line">  &#125;, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for 循环从后向前遍历</span></span><br><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">reverse</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="variable language_">this</span>.<span class="property">length</span> - <span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">    result += <span class="variable language_">this</span>.<span class="title function_">charAt</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="书写一个方法使用reduce模拟map-使用map来模拟reduce"><a href="#书写一个方法使用reduce模拟map-使用map来模拟reduce" class="headerlink" title="书写一个方法使用reduce模拟map/使用map来模拟reduce"></a>书写一个方法使用reduce模拟map/使用map来模拟reduce</h2><p>使用reduce模拟map<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_map</span> = <span class="keyword">function</span>(<span class="params">fn, callbackThis</span>) &#123;</span><br><span class="line">    <span class="comment">// 定义回调函数的执行环境</span></span><br><span class="line">    <span class="comment">// call第一个参数传入null，则 this 指向全局对象，同 map 的规则</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">CBThis</span> = callbackThis || <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">res, ele, idx, arr</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 传入map回调函数拥有的参数</span></span><br><span class="line">        <span class="comment">// 把每一项的执行结果push进res中</span></span><br><span class="line">        res.<span class="title function_">push</span>(fn.<span class="title function_">call</span>(<span class="title class_">CBThis</span>, ele, idx, arr));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;, []);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="解析url，将url中的参数转化为对象"><a href="#解析url，将url中的参数转化为对象" class="headerlink" title="解析url，将url中的参数转化为对象"></a>解析url，将url中的参数转化为对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getQueryString</span>(<span class="params">name</span>) &#123; </span><br><span class="line">    <span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;(^|&amp;)&quot;</span> + name + <span class="string">&quot;=([^&amp;]*)(&amp;|$)&quot;</span>, <span class="string">&quot;i&quot;</span>); </span><br><span class="line">    <span class="keyword">var</span> r = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">search</span>.<span class="title function_">substr</span>(<span class="number">1</span>).<span class="title function_">match</span>(reg); </span><br><span class="line">    <span class="keyword">if</span> (r != <span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">unescape</span>(r[<span class="number">2</span>]); <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">GetRequest</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> url = location.<span class="property">search</span>; <span class="comment">//获取url中&quot;?&quot;符后的字串</span></span><br><span class="line">    <span class="keyword">var</span> theRequest = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">if</span> (url.<span class="title function_">indexOf</span>(<span class="string">&quot;?&quot;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> str = url.<span class="title function_">substr</span>(<span class="number">1</span>);</span><br><span class="line">        strs = str.<span class="title function_">split</span>(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; strs.<span class="property">length</span>; i ++) &#123;</span><br><span class="line">            theRequest[strs[i].<span class="title function_">split</span>(<span class="string">&quot;=&quot;</span>)[<span class="number">0</span>]] = <span class="built_in">unescape</span>(strs[i].<span class="title function_">split</span>(<span class="string">&quot;=&quot;</span>)[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> theRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环体中不含有break语句时使用while循环来模拟for循环"><a href="#循环体中不含有break语句时使用while循环来模拟for循环" class="headerlink" title="循环体中不含有break语句时使用while循环来模拟for循环"></a>循环体中不含有break语句时使用while循环来模拟for循环</h2><p>for循环：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(initialize; test; increment)body;</span><br></pre></td></tr></table></figure></p><p>while循环：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">initialize;</span><br><span class="line"><span class="keyword">while</span> (test) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; body;&#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; increment;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="试写出-bind-的-polyfill-方法"><a href="#试写出-bind-的-polyfill-方法" class="headerlink" title="试写出 bind() 的 polyfill 方法"></a>试写出 bind() 的 polyfill 方法</h2><p>MDN上的实现：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Does not work with `new funcA.bind(thisArg, args)`</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span>) (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> slice = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>;</span><br><span class="line">  <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> thatFunc = <span class="variable language_">this</span>, thatArg = <span class="variable language_">arguments</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> args = slice.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> thatFunc !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// closest thing possible to the ECMAScript 5</span></span><br><span class="line">      <span class="comment">// internal IsCallable function</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Function.prototype.bind - &#x27;</span> +</span><br><span class="line">             <span class="string">&#x27;what is trying to be bound is not callable&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">var</span> funcArgs = args.<span class="title function_">concat</span>(slice.<span class="title function_">call</span>(<span class="variable language_">arguments</span>))</span><br><span class="line">      <span class="keyword">return</span> thatFunc.<span class="title function_">apply</span>(thatArg, funcArgs);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="实现-emit-on-观察者模式-发布-订阅模式"><a href="#实现-emit-on-观察者模式-发布-订阅模式" class="headerlink" title="实现 emit/on 观察者模式 发布/订阅模式"></a>实现 emit/on 观察者模式 发布/订阅模式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Event</span> = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> list = &#123;&#125;,</span><br><span class="line">        on,</span><br><span class="line">        emit,</span><br><span class="line">        remove;</span><br><span class="line">    on = <span class="keyword">function</span>(<span class="params">key,fn</span>)&#123; <span class="comment">//监听事件函数</span></span><br><span class="line">        <span class="keyword">if</span>(!list[key])&#123;</span><br><span class="line">            list[key] = []; <span class="comment">//如果事件列表中还没有key值命名空间，创建</span></span><br><span class="line">        &#125;</span><br><span class="line">        list[key].<span class="title function_">push</span>(fn); <span class="comment">//将回调函数推入对象的“键”对应的“值”回调数组</span></span><br><span class="line">    &#125;;</span><br><span class="line">    emit = <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">//触发事件函数</span></span><br><span class="line">        <span class="keyword">var</span> key = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>); <span class="comment">//第一个参数指定“键”</span></span><br><span class="line">        msg = list[key];</span><br><span class="line">        <span class="keyword">if</span>(!msg || msg.<span class="property">length</span> === <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//如果回调数组不存在或为空则返回false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; msg.<span class="property">length</span>; i++)&#123;</span><br><span class="line">            msg[i].<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>); <span class="comment">//循环回调数组执行回调函数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    remove = <span class="keyword">function</span>(<span class="params">key, fn</span>)&#123; <span class="comment">//移除事件函数</span></span><br><span class="line">        <span class="keyword">var</span> msg = list[key];</span><br><span class="line">        <span class="keyword">if</span>(!msg)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//事件不存在直接返回false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!fn)&#123;</span><br><span class="line">            <span class="keyword">delete</span> list[key]; <span class="comment">//如果没有后续参数，则删除整个回调数组</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; msg.<span class="property">length</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(fn === msg[i])&#123;</span><br><span class="line">                    msg.<span class="title function_">splice</span>(i, <span class="number">1</span>); <span class="comment">//删除特定回调数组中的回调函数</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">on</span>: on,</span><br><span class="line">        <span class="attr">emit</span>: emit,</span><br><span class="line">        <span class="attr">remove</span>: remove</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data + <span class="string">&#x27;的推送消息：xxxxxx......&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Event</span>.<span class="title function_">on</span>(<span class="string">&#x27;action&#x27;</span>, fn);</span><br><span class="line"><span class="title class_">Event</span>.<span class="title function_">emit</span>(<span class="string">&#x27;action&#x27;</span>, <span class="string">&#x27;2016.11.26&#x27;</span>);</span><br><span class="line"><span class="title class_">Event</span>.<span class="title function_">remove</span>(<span class="string">&#x27;action&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="对象object深拷贝"><a href="#对象object深拷贝" class="headerlink" title="对象object深拷贝"></a>对象object深拷贝</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否是对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Object | Array</span>&#125; obj 需要判断的数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125; 是否是对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isObject</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span>) &amp;&amp; (obj !== <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深拷贝</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Object | Array</span>&#125; source 需要拷贝的数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">&#123;</span>&#125; | []&#125; 深拷贝后的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">source</span>) &#123;</span><br><span class="line">    <span class="comment">// 非对象返回自身</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">isObject</span>(source)) &#123;</span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> target = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(source) ? [] : &#123;&#125;;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">entries</span>(source).<span class="title function_">forEach</span>(<span class="function">(<span class="params">[key, val]</span>) =&gt;</span> &#123;</span><br><span class="line">        target[key] = <span class="title function_">deepClone</span>(val);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断两个对象内容是否一样"><a href="#判断两个对象内容是否一样" class="headerlink" title="判断两个对象内容是否一样"></a>判断两个对象内容是否一样</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断两个对象内容（值）是否相等</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Object | Array</span>&#125; a 对象a</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Object | Array</span>&#125; b 对象b</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125; true/false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isObjectValueEqual</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断不是对象</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">isObject</span>(a) || !<span class="title function_">isObject</span>(b)) &#123;</span><br><span class="line">        <span class="keyword">return</span> a === b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 键值长度相等</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="title function_">keys</span>(a).<span class="property">length</span> !== <span class="title class_">Object</span>.<span class="title function_">keys</span>(b).<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> target = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 逐个值判断</span></span><br><span class="line">    <span class="title class_">Object</span></span><br><span class="line">        .<span class="title function_">entries</span>(a)</span><br><span class="line">        .<span class="title function_">forEach</span>(<span class="function">(<span class="params">[key, val]</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="title function_">isObjectValueEqual</span>(a[key], b[key])) &#123;</span><br><span class="line">                target = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如下代码，分别弹出什么信息？"><a href="#如下代码，分别弹出什么信息？" class="headerlink" title="如下代码，分别弹出什么信息？"></a>如下代码，分别弹出什么信息？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">create</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="title function_">create</span>()</span><br><span class="line"><span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">invoke</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">200</span>;</span><br><span class="line">    <span class="title function_">fn</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">invoke</span>(fn)</span><br></pre></td></tr></table></figure><p>返回 200 100<br>函数的执行依赖于变量作用域，这个作用域是函数定义时决定的。<br>第一段代码中 fn 实际是 create() 函数返回的函数，这个函数中使用的 a 是 create() 函数中定义的 a 变量，它覆盖了外部定义的 a。<br>第二段代码中 fn 在 invoke 函数外部定义，这个函数中的 a 是外部定义的 a，所以即使通过 invoke 函数包了一层，还是会返回外部定义的 a。<br>第二段代码也可以通过将 a 作为 fn 的 入参来使用，这样入参 a 就可以覆盖外部的 a。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">invoke</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">200</span>;</span><br><span class="line">    <span class="title function_">fn</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">invoke</span>(fn)</span><br></pre></td></tr></table></figure><p>以上代码返回 200  </p><h2 id="现有瀑布流式页面（页面下拉式无限加载图片），用js监听每个图片的点击事件"><a href="#现有瀑布流式页面（页面下拉式无限加载图片），用js监听每个图片的点击事件" class="headerlink" title="现有瀑布流式页面（页面下拉式无限加载图片），用js监听每个图片的点击事件"></a>现有瀑布流式页面（页面下拉式无限加载图片），用js监听每个图片的点击事件</h2><p>采用事件委托的方式实现</p><h2 id="执行如下代码，然后点击每个-a-标签分别弹出什么信息？并写明原因"><a href="#执行如下代码，然后点击每个-a-标签分别弹出什么信息？并写明原因" class="headerlink" title="执行如下代码，然后点击每个 a 标签分别弹出什么信息？并写明原因"></a>执行如下代码，然后点击每个 a 标签分别弹出什么信息？并写明原因</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> $body = $(<span class="string">&#x27;body&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> i,length = arr.<span class="property">length</span>, $a</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;length; i++) &#123;</span><br><span class="line">    $a = $(<span class="string">`&lt;a&gt;<span class="subst">$&#123;i&#125;</span>&lt;/a&gt;`</span>)</span><br><span class="line">    $body.<span class="title function_">append</span>($a)</span><br><span class="line">    $a.<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(i)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>弹出5，因为click绑定了的方法弹出i，i循环结束时为5.若想输出 0 1 2 3 4，可将绑定方法改为自执行函数形成闭包。代码如下：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> $body = $(<span class="string">&#x27;body&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> i,length = arr.<span class="property">length</span>, $a</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;length; i++) &#123;</span><br><span class="line">    $a = $(<span class="string">`&lt;a&gt;<span class="subst">$&#123;i&#125;</span>&lt;/a&gt;`</span>)</span><br><span class="line">    $body.<span class="title function_">append</span>($a);</span><br><span class="line">    (<span class="keyword">function</span>(<span class="params">i</span>) &#123;</span><br><span class="line">        $a.<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="title function_">alert</span>(i)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="执行下面代码会输出什么信息？"><a href="#执行下面代码会输出什么信息？" class="headerlink" title="执行下面代码会输出什么信息？"></a>执行下面代码会输出什么信息？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj1 = obj;</span><br><span class="line"><span class="keyword">let</span> a1 = obj.<span class="property">a</span>;</span><br><span class="line"></span><br><span class="line">obj1.<span class="property">a</span> = <span class="number">200</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">a</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1);</span><br><span class="line">a1= <span class="number">300</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">a</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">a</span>)</span><br></pre></td></tr></table></figure><p>200<br>100<br>200<br>200</p><h2 id="执行如下代码会输出什么信息？"><a href="#执行如下代码会输出什么信息？" class="headerlink" title="执行如下代码会输出什么信息？"></a>执行如下代码会输出什么信息？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">100</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">200</span>)</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">300</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>200<br>300<br>100</p><p>同步代码最先执行<br>Promise 属于 microTask 第二个执行<br>setTimeout 属于 macroTask 最后执行</p><h2 id="执行如下代码，分别打印出什么？"><a href="#执行如下代码，分别打印出什么？" class="headerlink" title="执行如下代码，分别打印出什么？"></a>执行如下代码，分别打印出什么？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span> <span class="keyword">instanceof</span> <span class="title class_">Number</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">123</span>) <span class="keyword">instanceof</span> <span class="title class_">Number</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="number">123</span>) isntanceof <span class="title class_">Number</span></span><br></pre></td></tr></table></figure><p>false<br>ture<br>false</p><p>第一个 首先左侧为number类型，并不是一个对象，更不是由 Number 实例化出来的（基本包装类型），所以为false<br>第二个 左侧使用 Number 构造实例化对象 右侧为 Number 构造 ，所以为true<br>第三个 左侧没有使用 new 所以并不是使用构造函数实例化 而是使用 Number 这个函数返回了一个数字， 所以为false</p><h2 id="写一个方法返回入参类型"><a href="#写一个方法返回入参类型" class="headerlink" title="写一个方法返回入参类型"></a>写一个方法返回入参类型</h2><p>number string boolean null undefined object symbol(ES6) bigint(ES2020)</p><p>如果只需要返回基本数据类型：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">typeOf</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> value === <span class="literal">null</span> ? <span class="string">&#x27;null&#x27;</span> : (<span class="keyword">typeof</span> value === <span class="string">&#x27;function&#x27;</span> ? <span class="string">&#x27;object&#x27;</span> : <span class="keyword">typeof</span> value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要返回类型：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">typeOf</span>(<span class="params">param</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(param).<span class="title function_">splice</span>(<span class="number">8</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写一个方法完成如下输入输出"><a href="#写一个方法完成如下输入输出" class="headerlink" title="写一个方法完成如下输入输出"></a>写一个方法完成如下输入输出</h2><p>输入为一个二维数组，每一项都是由两个 string 组成的数组，将输入参数的每一项与其他项相拼接，返回扁平化的数组。<br>输入： [[‘a’, ‘b’], [‘n’, ‘m’], [‘0’, ‘1’]]<br>输出：[‘an0’, ‘an1’, ‘am0’, ‘am1’, ‘bn0’, ‘bn1’, ‘bm0’, ‘bm1’]  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> input = [[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], [<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;m&#x27;</span>], [<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>]];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatArr</span>(<span class="params">param</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = [<span class="string">&#x27;&#x27;</span>];</span><br><span class="line">    param.<span class="title function_">forEach</span>(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 采用如下注释的方法输出参数顺序和给出的不同</span></span><br><span class="line">        <span class="comment">// result = [result.map(item =&gt; item + element[0]),</span></span><br><span class="line">        <span class="comment">//     result.map(item =&gt; item + element[1])].flat();</span></span><br><span class="line">        result = result.<span class="title function_">reduce</span>(<span class="function">(<span class="params">res, ele</span>) =&gt;</span> &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(ele + element[<span class="number">0</span>], ele + element[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;, []);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">flatArr</span>(input);</span><br></pre></td></tr></table></figure><h2 id="写一个方法按照层级将对象进行扁平化处理"><a href="#写一个方法按照层级将对象进行扁平化处理" class="headerlink" title="写一个方法按照层级将对象进行扁平化处理"></a>写一个方法按照层级将对象进行扁平化处理</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入</span></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    <span class="attr">a</span>: &#123;</span><br><span class="line">        <span class="attr">b</span>: &#123;</span><br><span class="line">            <span class="attr">c</span>: &#123;</span><br><span class="line">                <span class="attr">d</span>: <span class="string">&#x27;e&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">f</span>: &#123;</span><br><span class="line">        <span class="attr">a</span>: &#123;</span><br><span class="line">            <span class="attr">x</span>: <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">i</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;v&#x27;</span>],</span><br><span class="line">    <span class="attr">k</span>: &#123;</span><br><span class="line">        <span class="attr">l</span>: <span class="string">&#x27;m&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">[[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;k&#x27;</span>], [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;l&#x27;</span>], [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;x&#x27;</span>], [<span class="string">&#x27;d&#x27;</span>]]</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = [];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isObj</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span> &amp;&amp; obj !== <span class="literal">null</span> &amp;&amp; !<span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatObj</span>(<span class="params">obj, n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">isObj</span>(obj)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!result[n]) &#123;</span><br><span class="line">            returl[n] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        result[n].<span class="title function_">push</span>(key);</span><br><span class="line">        <span class="title function_">flatObj</span>(obj[key], n + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">flatObj</span>(object, <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure><h2 id="实现-sleep-方法"><a href="#实现-sleep-方法" class="headerlink" title="实现 sleep 方法"></a>实现 sleep 方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 setTimeout 回调</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sleep</span>(<span class="params">time, callback</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(callback, time);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sleep</span>(<span class="number">10000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用 setTimeout</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sleep</span>(<span class="params">time</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> _start = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>() - _start &lt; time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写一个方法进行对输入参数进行累加，入参多于5个时输出"><a href="#写一个方法进行对输入参数进行累加，入参多于5个时输出" class="headerlink" title="写一个方法进行对输入参数进行累加，入参多于5个时输出"></a>写一个方法进行对输入参数进行累加，入参多于5个时输出</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add(1,2,3,4,5) -&gt; 15</span></span><br><span class="line"><span class="comment">// add(1)(2)(3)(4)(5) -&gt; 15</span></span><br><span class="line"><span class="comment">// add(1,2,3)(4,5,6) -&gt; 15 or 21</span></span><br></pre></td></tr></table></figure><p>使用全局变量和递归<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">forEach</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        result += item;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> count &lt; <span class="number">5</span> ? add : result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>));</span><br></pre></td></tr></table></figure></p><p>使用闭包<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">append</span>(<span class="params"></span>) &#123;</span><br><span class="line">        count += <span class="variable language_">arguments</span>.<span class="property">length</span>;</span><br><span class="line">        result += +<span class="built_in">eval</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">join</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="string">&#x27;+&#x27;</span>));</span><br><span class="line">        <span class="comment">// Array.prototype.forEach.call(arguments, item =&gt; &#123;</span></span><br><span class="line">        <span class="comment">//     count ++;</span></span><br><span class="line">        <span class="comment">//     result += item;</span></span><br><span class="line">        <span class="comment">// &#125;);</span></span><br><span class="line">        <span class="keyword">return</span> count &lt; <span class="number">5</span> ? append : result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">append</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>));</span><br></pre></td></tr></table></figure></p><h2 id="连续正整数数组，去掉中间一个数字之后乱序，求去掉的数字"><a href="#连续正整数数组，去掉中间一个数字之后乱序，求去掉的数字" class="headerlink" title="连续正整数数组，去掉中间一个数字之后乱序，求去掉的数字"></a>连续正整数数组，去掉中间一个数字之后乱序，求去掉的数字</h2><p>使用排序和循环遍历 时间复杂度为 O(nlogn + n) = O(nlogn)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [2,4,6,8,7,3] -&gt; 5</span></span><br><span class="line"><span class="keyword">let</span> input = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">find</span>(<span class="params">param</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = param.<span class="title function_">sort</span>();</span><br><span class="line">    result.<span class="title function_">forEach</span>(<span class="function">(<span class="params">element, idx</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(element + <span class="number">1</span> !== result[idx + <span class="number">1</span>] &amp;&amp; idx !== result.<span class="property">length</span> -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> element + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">find</span>(input));</span><br></pre></td></tr></table></figure></p><p>利用数组下标 时间复杂度为 O(2n) = O(n)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> input = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">find</span>(<span class="params">param</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> tmp = [];</span><br><span class="line">    param.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        tmp[item] = <span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = tmp.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!tmp[i])</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">find</span>(input));</span><br></pre></td></tr></table></figure></p><h3 id="如果连续正整数从1开始（或者知道起始位置），可以从数组的和来获知"><a href="#如果连续正整数从1开始（或者知道起始位置），可以从数组的和来获知" class="headerlink" title="如果连续正整数从1开始（或者知道起始位置），可以从数组的和来获知"></a>如果连续正整数从1开始（或者知道起始位置），可以从数组的和来获知</h3><p>只需要遍历一次，时间复杂度为 O(n)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">find</span>(<span class="params">param</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = param.<span class="property">length</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> n * (n + <span class="number">1</span>) / <span class="number">2</span> - param.<span class="title function_">reduce</span>(<span class="function">(<span class="params">result, item</span>) =&gt;</span> &#123;<span class="keyword">return</span> result + item;&#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">find</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">3</span>));</span><br></pre></td></tr></table></figure></p><h2 id="合并两个长度很大的数组"><a href="#合并两个长度很大的数组" class="headerlink" title="合并两个长度很大的数组"></a>合并两个长度很大的数组</h2><ol><li>使用 <code>concat</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = a.<span class="title function_">concat</span>(b);</span><br></pre></td></tr></table></figure><p>concat 方法连接a、b两个数组后，a、b 两个数组的数据不变，同时会返回一个新的数组。如果 a、b 合并后不再使用，因为 a、b 数据量大会该方法会占用较多内存。  </p><ol start="2"><li>使用循环 + <code>push</code></li></ol><p>遍历其中一个数组，把该数组中的所有元素依次添加到另外一个数组中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    a.<span class="title function_">push</span>(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在循环之前可以先比较下 a、b 的长度，对短的进行循环，减少遍历插入次数。  </p><ol start="3"><li>使用 <code>push.apply</code></li></ol><p><code>Function.prototype.apply</code> 的第二个参数是数组，利用该特性，可以简化循环写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="property">push</span>.<span class="title function_">apply</span>(a, b);</span><br></pre></td></tr></table></figure><h2 id="取得当前正在执行的function的名字"><a href="#取得当前正在执行的function的名字" class="headerlink" title="取得当前正在执行的function的名字"></a>取得当前正在执行的function的名字</h2><p>可以从 arguments.callee 中获取到</p><p>如果支持 name</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> funcName = <span class="variable language_">arguments</span>.<span class="property">callee</span>.<span class="property">name</span>; <span class="comment">// 通过 arguments.callee.name 即可获取到当前 function 的名字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>否则可以通过正则匹配</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getFuncName</span>(<span class="params">fn</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="regexp">/^[\s\(]*function(?:\s+([\w$_][\w\d$_]*))?\(/</span>).<span class="title function_">exec</span>(fn.<span class="title function_">toString</span>())[<span class="number">1</span>] || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">getFuncName</span>(<span class="variable language_">arguments</span>.<span class="property">callee</span>); <span class="comment">// 通过对 arguments.callee 进行正则匹配</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是严格模式中无法获取callee</p><p>也可以从 Error 的错误堆栈中获取当前 function 名字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getExecFunctionName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> names = <span class="keyword">new</span> <span class="title class_">Error</span>().<span class="property">stack</span>.<span class="title function_">match</span>(<span class="regexp">/at (.*?) /g</span>);</span><br><span class="line">    <span class="keyword">return</span> names[<span class="number">1</span>].<span class="title function_">replace</span>(<span class="string">&#x27;at &#x27;</span>, <span class="string">&#x27;&#x27;</span>).<span class="title function_">trim</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="以下代码的输出顺序"><a href="#以下代码的输出顺序" class="headerlink" title="以下代码的输出顺序"></a>以下代码的输出顺序</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">async2</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;d&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;i&#x27;</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;j&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;e&#x27;</span>);</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;f&#x27;</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;h&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同步 a c e h /异步microTask b i f j g / 异步macroTask d</p><h2 id="输出一个字符串中不重复的连续字符串的最大长度"><a href="#输出一个字符串中不重复的连续字符串的最大长度" class="headerlink" title="输出一个字符串中不重复的连续字符串的最大长度"></a>输出一个字符串中不重复的连续字符串的最大长度</h2><p>例如 <code>abcddbca</code> ，其中符合的字符串为 abcd 和 dbca， 所以需要输出 4</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getNum</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> strArr = str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    strArr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">char, idx</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> tmpArr = [char];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = idx + <span class="number">1</span>; i &lt; strArr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!tmpArr.<span class="title function_">includes</span>(strArr[i])) &#123;</span><br><span class="line">                tmpArr.<span class="title function_">push</span>(strArr[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmpArr.<span class="property">length</span> &gt; maxLen) &#123;</span><br><span class="line">            maxLen = tmpArr.<span class="property">length</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断一个字符串是否是回文字符串"><a href="#判断一个字符串是否是回文字符串" class="headerlink" title="判断一个字符串是否是回文字符串"></a>判断一个字符串是否是回文字符串</h2><p>需要将字符串先将大写转换成小写，去除符号和数字，如果从前往后和从后往前都是同样的，则是回文字符串。</p><p>例如 <code>001ABCD,dcba.</code>是回文字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isRightStr</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> str1 = str.<span class="title function_">toLowerCase</span>().<span class="title function_">replace</span>(<span class="regexp">/[0-9\s,.]+/g</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="title class_">Math</span>.<span class="title function_">floor</span>(str1.<span class="property">length</span> / <span class="number">2</span>) + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str1[i] !== str1[str1.<span class="property">length</span> - i - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="点击inner元素输出结果"><a href="#点击inner元素输出结果" class="headerlink" title="点击inner元素输出结果"></a>点击inner元素输出结果</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.outer</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.inner</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background</span>: green;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> outer = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.outer&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> inner = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.inner&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// Let&#x27;s listen for attribute changes on outer element</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;mutate&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;).<span class="title function_">observe</span>(outer, &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">attributes</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// Here&#x27;s a click listener...</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">onClick</span>(<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;click&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;, <span class="number">0</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        outer.<span class="title function_">setAttribute</span>(<span class="string">&#x27;data-random&#x27;</span>, <span class="title class_">Math</span>.<span class="title function_">random</span>());</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// ...which we&#x27;ll attach to both elements</span></span></span><br><span class="line"><span class="language-javascript">    inner.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, onClick);</span></span><br><span class="line"><span class="language-javascript">    outer.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, onClick);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结果：<br>click<br>promise<br>mutate<br>click<br>promise<br>mutate<br>timeout<br>timeout</p><p>步骤：</p><ol><li>点击 inner 触发 inner 元素的 onClick 入栈 macroTask</li><li>触发 outer 元素的 onclick 入栈 macroTask<br>—- microTask 为空，执行 macroTask</li><li>执行 onClick 方法中的 <code>console.log(&#39;click&#39;)</code> 打印 <strong>click</strong></li><li>setTimeout() 中的 <code>console.log(&#39;timeout&#39;)</code> 入栈 macroTask</li><li>Promise.resolve().then() 中的 <code>console.log(&#39;promise&#39;)</code> 入栈 microTask</li><li><code>outer.setAttribute(&#39;data-random&#39;, Math.random());</code> 变更了 outer 的 attritube 触发了 MutationObserver(), 导致 <code>console.log(&#39;mutate&#39;)</code>入栈 microTask<br>—- 执行 microTask</li><li>打印 <strong>promise</strong>, 打印 <strong>mutate</strong><br>—- microTask 为空，执行 macroTask</li><li>执行 onClick， 按照 3-7 执行一遍<br>—- 执行 macroTask</li><li>打印 <strong>timeout</strong><br>—- 执行 macroTask</li><li>打印 <strong>timeout</strong></li></ol><h2 id="限制并发数量的多请求执行"><a href="#限制并发数量的多请求执行" class="headerlink" title="限制并发数量的多请求执行"></a>限制并发数量的多请求执行</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// options 是形如 &#123;url: &#x27;&#x27;, method: &#x27;GET&#x27;, params: &#123;&#125;&#125; 的请求相关参数对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">request</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;options&#125;</span> is start`</span>)</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;options&#125;</span> is finished`</span>)</span><br><span class="line">            <span class="title function_">resolve</span>(&#123; <span class="attr">data</span>: options &#125;);</span><br><span class="line">        &#125;, <span class="number">3000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fetch</span>(<span class="params">options</span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">request</span>(options).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多请求并行执行</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">parallelRequest</span>(<span class="params">optionsList</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(optionsList.<span class="title function_">map</span>(<span class="function"><span class="params">options</span> =&gt;</span> <span class="title function_">request</span>(options)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">parallelRequest</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多请求串行执行</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">serialRequest</span>(<span class="params">optionsList</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; optionsList.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="title function_">request</span>(optionsList[i]);</span><br><span class="line">        res.<span class="title function_">push</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">serialRequest</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 限制并发数量的多请求执行</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">multiRequest</span>(<span class="params">optionsList = [], maxNum</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> len = optionsList.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>(len).<span class="title function_">fill</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count &lt; maxNum) &#123;</span><br><span class="line">            <span class="title function_">next</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> current = count++;</span><br><span class="line">            <span class="keyword">if</span> (current &gt;= len) &#123;</span><br><span class="line">                !result.<span class="title function_">includes</span>(<span class="literal">false</span>) &amp;&amp; <span class="title function_">resolve</span>(result);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> options = optionsList[current];</span><br><span class="line">            <span class="title function_">request</span>(options)</span><br><span class="line">                .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">                    result[current] = res;</span><br><span class="line">                    <span class="keyword">if</span> (current &lt; len) &#123;</span><br><span class="line">                        <span class="title function_">next</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">                    result[current] = err;</span><br><span class="line">                    <span class="keyword">if</span> (current &lt; len) &#123;</span><br><span class="line">                        <span class="title function_">next</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">multiRequest</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>], <span class="number">3</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供给第三方使用的 request 方法，内部实现支持限制并发数量的请求，并发量为3</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LimitRequest</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">limit</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">limit</span> = limit;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tasks</span> = [];</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">current</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">addRequest</span>(<span class="params">reqFn</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!reqFn || !(reqFn <span class="keyword">instanceof</span> <span class="title class_">Function</span>)) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;当前请求不是一个Function&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tasks</span>.<span class="title function_">push</span>(reqFn);</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">current</span> &lt; <span class="variable language_">this</span>.<span class="property">limit</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">run</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">current</span>++;</span><br><span class="line">            <span class="keyword">const</span> fn = <span class="variable language_">this</span>.<span class="property">tasks</span>.<span class="title function_">shift</span>();</span><br><span class="line">            <span class="keyword">await</span> <span class="title function_">fn</span>();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(err);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">current</span>--;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">tasks</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">run</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> limitRequest = <span class="keyword">new</span> <span class="title class_">LimitRequest</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">limitRequest.<span class="title function_">addRequest</span>(fetch.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="string">&#x27;1&#x27;</span>));</span><br><span class="line">limitRequest.<span class="title function_">addRequest</span>(fetch.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="string">&#x27;2&#x27;</span>));</span><br><span class="line">limitRequest.<span class="title function_">addRequest</span>(fetch.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="string">&#x27;3&#x27;</span>));</span><br><span class="line">limitRequest.<span class="title function_">addRequest</span>(fetch.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="string">&#x27;4&#x27;</span>));</span><br><span class="line">limitRequest.<span class="title function_">addRequest</span>(fetch.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="string">&#x27;5&#x27;</span>));</span><br><span class="line">limitRequest.<span class="title function_">addRequest</span>(fetch.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="string">&#x27;6&#x27;</span>));</span><br><span class="line">limitRequest.<span class="title function_">addRequest</span>(fetch.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="string">&#x27;7&#x27;</span>));</span><br><span class="line">limitRequest.<span class="title function_">addRequest</span>(fetch.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="string">&#x27;8&#x27;</span>));</span><br><span class="line">limitRequest.<span class="title function_">addRequest</span>(fetch.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="string">&#x27;9&#x27;</span>));</span><br><span class="line">limitRequest.<span class="title function_">addRequest</span>(fetch.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="string">&#x27;10&#x27;</span>));</span><br></pre></td></tr></table></figure><p>优化下，无需每次都 bind</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LimitRequest</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">limit</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">limit</span> = limit; <span class="comment">// 并发限制数量</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tasks</span> = []; <span class="comment">// 等待的请求队列</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">current</span> = <span class="number">0</span>;  <span class="comment">// 当前进行中的请求数量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">request</span>(<span class="params">options</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> reqFn = request.<span class="title function_">bind</span>(<span class="literal">null</span>, options);</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">tasks</span>.<span class="title function_">push</span>([reqFn, resolve, reject]);</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">current</span> &lt; <span class="variable language_">this</span>.<span class="property">limit</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">run</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">current</span>++;</span><br><span class="line">            <span class="keyword">const</span> [fn, resolve, reject] = <span class="variable language_">this</span>.<span class="property">tasks</span>.<span class="title function_">shift</span>();</span><br><span class="line">            <span class="keyword">await</span> <span class="title function_">fn</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(res);</span><br><span class="line">            &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">reject</span>(err);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(err);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">current</span>--;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">tasks</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">run</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> limitRequest = <span class="keyword">new</span> <span class="title class_">LimitRequest</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> newRequest = limitRequest.<span class="property">request</span>.<span class="title function_">bind</span>(limitRequest);</span><br><span class="line"><span class="title function_">newRequest</span>(<span class="string">&#x27;1&#x27;</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="title function_">newRequest</span>(<span class="string">&#x27;2&#x27;</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="title function_">newRequest</span>(<span class="string">&#x27;3&#x27;</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="title function_">newRequest</span>(<span class="string">&#x27;4&#x27;</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="title function_">newRequest</span>(<span class="string">&#x27;5&#x27;</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="title function_">newRequest</span>(<span class="string">&#x27;6&#x27;</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="title function_">newRequest</span>(<span class="string">&#x27;7&#x27;</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="title function_">newRequest</span>(<span class="string">&#x27;8&#x27;</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="title function_">newRequest</span>(<span class="string">&#x27;9&#x27;</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="title function_">newRequest</span>(<span class="string">&#x27;10&#x27;</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br></pre></td></tr></table></figure><p>utils写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> limit = <span class="number">3</span>; <span class="comment">// 并发限制数量</span></span><br><span class="line"><span class="keyword">let</span> tasks = []; <span class="comment">// 等待的请求队列</span></span><br><span class="line"><span class="keyword">let</span> current = <span class="number">0</span>;  <span class="comment">// 当前进行中的请求数量</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">newRequest</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> reqFn = request.<span class="title function_">bind</span>(<span class="literal">null</span>, options);</span><br><span class="line">        tasks.<span class="title function_">push</span>([reqFn, resolve, reject]);</span><br><span class="line">        <span class="keyword">if</span> (current &lt; limit) &#123;</span><br><span class="line">            <span class="title function_">run</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        current++;</span><br><span class="line">        <span class="keyword">const</span> [fn, resolve, reject] = <span class="variable language_">this</span>.<span class="property">tasks</span>.<span class="title function_">shift</span>();</span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">fn</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(res);</span><br><span class="line">        &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(err);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(err);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        current--;</span><br><span class="line">        <span class="keyword">if</span> (tasks.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="title function_">run</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">newRequest</span>(<span class="string">&#x27;1&#x27;</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="title function_">newRequest</span>(<span class="string">&#x27;2&#x27;</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="title function_">newRequest</span>(<span class="string">&#x27;3&#x27;</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="title function_">newRequest</span>(<span class="string">&#x27;4&#x27;</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="title function_">newRequest</span>(<span class="string">&#x27;5&#x27;</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="title function_">newRequest</span>(<span class="string">&#x27;6&#x27;</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="title function_">newRequest</span>(<span class="string">&#x27;7&#x27;</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="title function_">newRequest</span>(<span class="string">&#x27;8&#x27;</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="title function_">newRequest</span>(<span class="string">&#x27;9&#x27;</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="title function_">newRequest</span>(<span class="string">&#x27;10&#x27;</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br></pre></td></tr></table></figure><h2 id="版本号比较"><a href="#版本号比较" class="headerlink" title="版本号比较"></a>版本号比较</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compareVersion</span>(<span class="params">version1, version2</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr1 = version1.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> arr2 = version2.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> len = <span class="title class_">Math</span>.<span class="title function_">max</span>(arr1.<span class="property">length</span>, arr2.<span class="property">length</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> n1 = <span class="title class_">Number</span>(arr1[i]||<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">const</span> n2 = <span class="title class_">Number</span>(arr2[i]||<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (n1 &gt; n2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n1 &lt; n2) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="m-个红球-n-个白球，依次全部取出，求共有多少种不同的取出顺序"><a href="#m-个红球-n-个白球，依次全部取出，求共有多少种不同的取出顺序" class="headerlink" title="m 个红球, n 个白球，依次全部取出，求共有多少种不同的取出顺序"></a>m 个红球, n 个白球，依次全部取出，求共有多少种不同的取出顺序</h2><p>即求概率论中C(m+n)n</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">number</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (number === <span class="number">0</span> ||number === <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= number; i++) &#123;</span><br><span class="line">        result *= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getNum</span>(<span class="params">m, n</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">factorial</span>(m + n)/<span class="title function_">factorial</span>(m)/<span class="title function_">factorial</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> interview </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 闭包</title>
      <link href="/blog/2021/03/19/JS-%E9%97%AD%E5%8C%85/"/>
      <url>/blog/2021/03/19/JS-%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><p>和其他大多数现代编程语言一样，JavaScript也采用词法作用域(lexical scoping)。也就是，函数的执行依赖于变量作用域，这个作用域是函数定义时决定的。而不是函数执行时决定的。为了实现这种词法作用域，JavaScript函数对象的内部状态不仅包含函数的代码逻辑，还必须引用当前的作用域链(scope chain)。函数可以通过作用域链(scope chain)相互关联起来，函数内部的变量都可以保存在函数作用域内，这种特性称为”闭包”。<br><span id="more"></span><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    n = <span class="number">999</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f2;<span class="comment">// f2就是一个闭包</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">f1</span>();</span><br><span class="line"><span class="title function_">result</span>(); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure></p><h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2><p>作用：  </p><ol><li>隐藏变量，避免全局污染</li><li>可以读取函数内部的变量</li></ol><p>缺点：  </p><ol><li>导致变量不会被垃圾回收机制回收，造成内存消耗</li><li>不恰当的使用闭包可能会造成内存泄漏的问题</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 的异步运行机制</title>
      <link href="/blog/2021/03/19/JS-js%E7%9A%84%E5%BC%82%E6%AD%A5%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
      <url>/blog/2021/03/19/JS-js%E7%9A%84%E5%BC%82%E6%AD%A5%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>我们都知道 JavaScript 是单线程的，但是却很适合做 IO 密集型操作，那么 Javascript 为什么是单线程的又是如何处理异步操作的？下面我们来探究下 Jascript 的异步处理机制。</p><span id="more"></span><h2 id="进程与线程-process-amp-thread"><a href="#进程与线程-process-amp-thread" class="headerlink" title="进程与线程 - process &amp; thread"></a>进程与线程 - process &amp; thread</h2><p>Javascript 代码是有运行环境的，例如在 浏览器 或者 Nodejs 等环境中，我们以浏览器为例，解释下浏览器中 Javascript 的异步运行机制。<br>我们知道浏览器是多进程的，它主要包括以下进程：</p><ul><li>Browser 进程(Browser Process)：浏览器的主进程，唯一，负责创建和销毁其它进程、网络资源的下载与管理、浏览器界面的展示、前进后退等。</li><li>GPU 进程(GPU Process)：用于 3D 绘制等，最多一个。</li><li>第三方插件进程(Plugin Process)：每种类型的插件对应一个进程，仅当使用该插件时才创建。</li><li>浏览器渲染进程（Renderer Process）：内部是多线程的，每打开一个新网页就会创建一个进程，主要用于页面渲染，脚本执行，事件处理等。</li></ul><p>页面的渲染，JavaScript 的执行，事件的循环均是在浏览器渲染进程（浏览器内核）中进行的，而是浏览器渲染进程（浏览器内核）是多线程的，主要包括以下线程：</p><ul><li>GUI 渲染线程：负责渲染浏览器界面HTML，当界面需要重绘（Repaint）或由于某种操作引发回流（Reflow）时，该线程就会执行;GUI 渲染线程与 JavaScript 引擎线程是互斥的，当 JavaScript 引擎执行时 GUI 线程会被挂起。</li><li>JavaScript 引擎线程：也称为 JavaScript 内核，负责处理 Javascript 脚本程序、解析 Javascript 脚本、运行代码等。如果 JavaScript 执行的时间过长，会阻塞GUI渲染县城，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</li><li>事件触发线程：用来控制浏览器事件循环，注意这不归 JavaScript 引擎线程管，当事件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JavaScript 引擎的处理。</li><li>定时触发器线程：setInterval 与 setTimeout 所在线程，注意，W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms 。</li><li>异步 http 请求线程：在 XMLHttpRequest 连接后通过浏览器新开一个线程请求，将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由 JavaScript 引擎执行。</li></ul><p>Tip: 浏览器 - 浏览器内核 - javascript内核 关系参考 Chromium - Blink - v8</p><p>所谓单线程，是指在 JavaScript 引擎中负责解释和执行 JavaScript 代码的线程唯一，同一时间上只能执行一件任务。</p><h3 id="为什么采用单线程"><a href="#为什么采用单线程" class="headerlink" title="为什么采用单线程"></a>为什么采用单线程</h3><p>我们知道浏览器是需要渲染 DOM 的，而 JavaScript 可以修改 DOM 结构，如果 JavaScript 引擎线程不是单线程的，那么可以同时执行多段 JavaScript，如果这多段 JavaScript 都修改 DOM，那么就会出现 DOM 冲突。JavaScript从诞生开始就选择了简单的单线程执行来避免产生这个问题。单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这样的优点是实现比较简单，但也会带来一些问题，只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段 Javascript 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。</p><h2 id="同步与异步-synchronization-amp-asynchronous"><a href="#同步与异步-synchronization-amp-asynchronous" class="headerlink" title="同步与异步 - synchronization &amp; asynchronous"></a>同步与异步 - synchronization &amp; asynchronous</h2><p>为了解决这个问题，JavaScript 将任务的执行模式分为两种：同步和异步。<br>如果在函数 func 返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>(a)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>如果在函数 func 返回的时候，调用者还不能够得到预期结果，需要经过一定时间，而且需要在将来通过一定的手段（比如回调）得到，那么这个函数就是异步的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;foo.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在执行上面的这段异步代码时，<code>fs.readFile</code> 函数执行时，并不会立刻打印 <code>data</code> ，只有 <code>foo.txt</code> 读取完成时才打印。即异步函数 <code>fs.readFile</code> 不会在主线程中完成读取文件的操作，会由工作线程执行异步任务、通知主线程、主线程回调等操作，这个过程就叫做异步。<br>如果我们需要处理一些耗时的操作，例如：IO操作、定时/延时执行时，就可以使用异步的方法，不阻塞主线程，充分的利用CPU。<br>那么 Javascript 又是如何实现异步机制的呢？答案就是通过消息队列（task queue）与事件循环（event loop）。</p><h2 id="任务队列与事件循环-task-queue-amp-event-loop"><a href="#任务队列与事件循环-task-queue-amp-event-loop" class="headerlink" title="任务队列与事件循环 - task queue &amp; event loop"></a>任务队列与事件循环 - task queue &amp; event loop</h2><p>任务队列(消息队列)：任务队列是一个先进先出的队列，它里面存放着各种异步任务。<br>事件循环：事件循环是指主线程重复从任务队列中取任务、执行任务的过程。</p><h3 id="任务队列-task-queue"><a href="#任务队列-task-queue" class="headerlink" title="任务队列 - task queue"></a>任务队列 - task queue</h3><p>任务就是注册异步任务时设定的事件与添加的回调函数。以 Ajax 异步请求为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(<span class="string">&#x27;XXX&#x27;</span>, <span class="keyword">function</span>(<span class="params">res</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>主线程在发起 Ajax 请求后，会继续执行其它代码，Ajax 线程负责 HTTP 请求，拿到请求响应后，会封装成 JavaScript 对象，然后构造一条任务：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消息队列里的消息</span></span><br><span class="line"><span class="keyword">var</span> task = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">callback</span>(response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 callback 是 Ajax 网络请求成功响应时的回调函数。</p><p>主线程在执行完当前循环中的所有代码后，就会到任务队列取出这条任务(也就是 task 函数)，并执行它。到此为止，就完成了工作线程对主线程的通知 ，异步回调函数也就得到了执行。如果一开始主线程就没有提供回调函数，Ajax 线程在收到 HTTP 响应后，也就没必要通知主线程，从而也没必要往任务队列放消息。</p><p><img src="/blog/static/imgs/async.png" alt="async_inner"></p><h3 id="事件循环-event-loop"><a href="#事件循环-event-loop" class="headerlink" title="事件循环 - event loop"></a>事件循环 - event loop</h3><p>主线程不断的从任务队列中取任务，执行任务，其运行机制称为事件循环（event loop）。每执行一次任务被称作一个循环。事件循环是 JavaScript 实现异步的具体解决方案。在代码执行过程中，同步方法会直接执行，异步的方法先放在任务队列中，待同步方法执行完毕后，轮询执行任务队列中的回调函数。</p><h2 id="微任务与（宏）任务-microtask-amp-macrotask-task"><a href="#微任务与（宏）任务-microtask-amp-macrotask-task" class="headerlink" title="微任务与（宏）任务 - microtask &amp; macrotask(task)"></a>微任务与（宏）任务 - microtask &amp; macrotask(task)</h2><p>每执行完一次任务队列中的任务之后，GUI 渲染线程便不会再被 Javascript 线程阻塞，从而进行一次渲染，渲染之后会执行任务队列中的异步任务。那么如果我们想要执行异步任务就必须触发一次渲染吗？不是的，Javascript 提供了另外一种机制微任务机制来在渲染进程之前执行异步的操作。</p><p>JavaScript 中有 microtask 和 macrotask（task），它们是均为异步任务的类型，microtask 的优先级（这里指执行顺序）要高于 macrotask。macrotask 用于处理 I/O 和计时器等事件，每次执行一个。microtask 在每个同步 task 结束时执行，并且在每一个事件循环之前，microtask 队列总是被清空（全部执行）。</p><p>Microtask 包括如下行为</p><ul><li>process.nextTick （Nodejs）</li><li>Promise</li><li>Object.observe (废弃)</li><li>MutationObserver</li></ul><p>Macrotask（task）包括如下行为</p><ul><li>setTimeout</li><li>setImmediate</li><li>setInterval</li><li>I/O</li><li>DOM事件监听</li></ul><p>需要注意的是：</p><ol><li>每一个 event loop 都有一个 microtask queue</li><li>每个 event loop 之后会有一个或多个 macrotask ( task queue )</li><li>一个异步任务 task 可以放入 macrotask queue 也可以放入 microtask queue 中</li><li>每一次event loop，会首先执行 microtask queue， 执行完毕后，会提取 macrotask queue 的第一个任务执行，如果这时又有异步任务加入 microtask queue， 会在同步任务执行结束后接着继续执行 microtask queue 里的任务，循环往复</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML 事件绑定&amp;事件委托</title>
      <link href="/blog/2021/03/19/HTML-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/"/>
      <url>/blog/2021/03/19/HTML-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</url>
      
        <content type="html"><![CDATA[<h2 id="如何给一个元素绑定事件，分别有几种方式？各有什么好处？"><a href="#如何给一个元素绑定事件，分别有几种方式？各有什么好处？" class="headerlink" title="如何给一个元素绑定事件，分别有几种方式？各有什么好处？"></a>如何给一个元素绑定事件，分别有几种方式？各有什么好处？</h2><ol><li>监听方法绑定方式<br>事件冒泡 事件捕获<br>js事件流是先由 window-&gt;document-&gt;body-&gt;div-&gt;(text) 触发一遍捕获 capture ，<br>再由（text）-&gt;div-&gt;body-&gt;document-&gt;window触发一遍冒泡bubbling</li></ol><p>element.addEventListener(type, listener, useCapture);<br>type:事件类型<br>listener:监听方法<br>useCapture:是否捕获，默认false，即在冒泡时触发</p><p>listener的入参event可以获取到event.target event.currentTarget<br>其中，target是真正发生事件的DOM元素，而currentTarget是当前事件发生在哪个DOM元素上。</p><span id="more"></span><p>优点：</p><ul><li>同时支持捕获和冒泡</li><li>可以同时绑定多个事件</li></ul><p>缺点：</p><ul><li>旧的IE不支持，需要用attachEvent替代 element.attachEvent(‘onclick’, function(){})</li><li>IE只支持冒泡</li><li>在IE中，this指向window对象而不是当前元素，获取event需要获取window.event</li></ul><ol start="2"><li>直接绑定事件方式<br>target.onclick = function(){}<br>缺点：</li></ol><ul><li>只会在事件冒泡中运行，</li><li>一个元素一次只能绑定一个事件处理函数，</li><li>新绑定的事件处理函数会覆盖旧的</li><li>事件对象参数（event）仅非IE浏览器可用</li></ul><p>优点：</p><ul><li>在不同浏览器中表现一致</li><li>this指向当前元素</li></ul><ol start="3"><li>直接在元素里使用事件属性<div onclick="func"/></li></ol><h2 id="实现一个事件委托（事件代理）"><a href="#实现一个事件委托（事件代理）" class="headerlink" title="实现一个事件委托（事件代理）"></a>实现一个事件委托（事件代理）</h2><p>事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能。  </p><p>事件委托示例：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;ul1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;li1&quot;</span>&gt;</span>111<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;li2&quot;</span>&gt;</span>222<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;li3&quot;</span>&gt;</span>333<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;li4&quot;</span>&gt;</span>444<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 非事件委托</span></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> oUl = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;ul1&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> aLi = oUl.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;li&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;aLi.<span class="property">length</span>;i++)&#123;</span></span><br><span class="line"><span class="language-javascript">        aLi[i].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// do something</span></span></span><br><span class="line"><span class="language-javascript">            ...</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 事件委托</span></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> oUl = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;ul1&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    oUl.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">ev</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> ev = ev || <span class="variable language_">window</span>.<span class="property">event</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> target = ev.<span class="property">target</span> || ev.<span class="property">srcElement</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(target.<span class="property">nodeName</span>.<span class="title function_">toLowerCase</span>() == <span class="string">&#x27;li&#x27;</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">switch</span>(target.<span class="property">id</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">case</span> <span class="string">&#x27;li1&#x27;</span>:</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// do something</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line"><span class="language-javascript">                    ...</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="event-中的-target-和-currentTarget-有什么区别？"><a href="#event-中的-target-和-currentTarget-有什么区别？" class="headerlink" title="event 中的 target 和 currentTarget 有什么区别？"></a>event 中的 target 和 currentTarget 有什么区别？</h2><p>currentTarget当前所绑定事件的元素</p><p>target当前被点击的元素</p>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cookie、sessionStorage、localStorage区别与作用</title>
      <link href="/blog/2021/03/19/HTML-cookie%E3%80%81sessionStorage%E3%80%81localStorage%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%9C%E7%94%A8/"/>
      <url>/blog/2021/03/19/HTML-cookie%E3%80%81sessionStorage%E3%80%81localStorage%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>相同点：  </p><ol><li>都是客户端临时信息对象</li><li>只能存储字符串类型对象</li></ol><p>不同点：   </p><ol><li>生命周期不同，cookie可以设置过期时间，localStorage始终有效，sessionStorage在关闭窗口后失效</li><li>cookie的主要内容包括：名字、值、过期时间、路径和域,有路径的概念，可以限制cookie只属于某个路径下</li><li>存储大小限制不同，cookie 4k localStorage/sessionStorage 5M</li><li>cookie始终在http请求中携带，Web Storage仅在本地保存</li><li>作用域不同，sessionStorage在不同的浏览器窗口中不共享，即使是同一个页面，localStorage/cookie在所有同源的窗口中是共享的。</li><li>Web Storage 有API setItem getItem removeItem clear， cookie需要自己解析</li><li>document.cookie window.localStorage window.sessionStorage</li><li>web storage是html5引入的，部分老旧浏览器不支持</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Web API </tag>
            
            <tag> cookie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>页面渲染html的过程</title>
      <link href="/blog/2021/03/19/HTML-%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93html%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
      <url>/blog/2021/03/19/HTML-%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93html%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>浏览器渲染页面的一般过程：</p><p>1.浏览器解析html源码，然后创建一个 DOM树。并行请求 css/image/js 在DOM树中，每一个HTML标签都有一个对应的节点，并且每一个文本也都会有一个对应的文本节点。DOM树的根节点就是 documentElement，对应的是 html 标签。</p><p>2.浏览器解析CSS代码，计算出最终的样式数据。构建CSSOM树。对CSS代码中非法的语法它会直接忽略掉。解析CSS的时候会按照如下顺序来定义优先级：浏览器默认设置 &lt; 用户设置 &lt; 外链样式 &lt; 内联样式 &lt; html中的style。</p><p>3.DOM Tree + CSSOM –&gt; 渲染树（rendering tree）。渲染树和DOM树有点像，但是是有区别的。</p><p>DOM树完全和html标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如 head、display:none 的元素等。而且一大段文本中的每一个行在渲染树中都是独立的一个节点。渲染树中的每一个节点都存储有对应的css属性。</p><p>4.一旦渲染树创建好了，浏览器就可以根据渲染树直接把页面绘制到屏幕上。</p><p>以上四个步骤并不是一次性顺序完成的。如果DOM或者CSSOM被修改，以上过程会被重复执行。实际上， CSS 和 JavaScript 往往会多次修改 DOM 或者 CSSOM 。</p>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 伪元素&amp;伪类</title>
      <link href="/blog/2021/03/19/CSS-%E4%BC%AA%E5%85%83%E7%B4%A0-%E4%BC%AA%E7%B1%BB/"/>
      <url>/blog/2021/03/19/CSS-%E4%BC%AA%E5%85%83%E7%B4%A0-%E4%BC%AA%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h2><p>CSS伪元素(pseudo-elements)创建了一个有内容的虚拟容器，用于向某些选择器设置特殊效果<br>用法 <code>selector:pseudo-element &#123;property: value;&#125;</code>  </p><p><code>::first-line</code> : 用于向文本的首行设置特殊样式<br><code>::first-letter</code> : 用于向文本的首字母设置特殊样式<br><code>::before</code> : 可以在元素的内容前面插入新内容<br><code>::after</code> : 可以在元素的内容之后插入新内容  </p><span id="more"></span><h2 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h2><p>CSS伪类(pseudo-classes)为了弥补常规CSS选择器的不足，以便获取到更多信息，用于向某些选择器添加特殊的效果<br>用法 <code>selector:pseudo-class &#123;property: value;&#125;</code>  </p><p><code>:active</code> : 向被激活的元素添加样式<br><code>:focus</code> : 向拥有键盘输入焦点的元素添加样式<br><code>:hover</code> : 当鼠标悬浮在元素上方时，向元素添加样式<br><code>:link</code> : 向未被访问的链接添加样式<br><code>:visited</code> : 向已被访问的链接添加样式<br><code>:first-child</code> : 向元素的第一个子元素添加样式<br><code>:lang(language)</code> : 向带有指定 lang 属性的元素添加样式  </p><p>其它CSS3伪类参见 <a href="/blog/2018/09/03/CSS-选择器/">CSS选择器</a>  </p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 清除（闭合）浮动</title>
      <link href="/blog/2021/03/19/CSS-%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/"/>
      <url>/blog/2021/03/19/CSS-%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是浮动？"><a href="#什么是浮动？" class="headerlink" title="什么是浮动？"></a>什么是浮动？</h2><p><code>float</code> CSS属性指定一个元素应沿其容器的左侧或右侧放置，允许文本和内联元素环绕它。该元素从网页的正常流动(normal flow)中移除，尽管仍然保持部分的流动性。<br>本属于普通流中的元素，在使用 <code>float</code> 属性后，包含框内部由于不存在其他普通流元素了，也就表现出高度为0的情况。在实际布局中，往往这并不是我们所希望的，所以需要闭合浮动元素，使其包含框表现出正常的高，也就是让浮动内容和周围的内容等高。  </p><span id="more"></span><h2 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h2><h3 id="添加额外标签"><a href="#添加额外标签" class="headerlink" title="添加额外标签"></a>添加额外标签</h3><p>通过在浮动元素末尾添加一个空的标签例如 <code>&lt;div style=”clear:both”&gt;&lt;/div&gt;</code> 。  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span> <span class="attr">id</span>=<span class="string">&quot;float&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>1）添加额外标签<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span>.main&#123;float:left;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;side&quot;</span>&gt;</span>.side&#123;float:right;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;clear:both;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer&quot;</span>&gt;</span>.footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用br标签和其自身的html属性"><a href="#使用br标签和其自身的html属性" class="headerlink" title="使用br标签和其自身的html属性"></a>使用br标签和其自身的html属性</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span> <span class="attr">id</span>=<span class="string">&quot;float&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>2）使用 br标签和其自身的 html属性<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span>.main&#123;float:left;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;side&quot;</span>&gt;</span>.side&#123;float:right;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> <span class="attr">clear</span>=<span class="string">&quot;all&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer&quot;</span>&gt;</span>.footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="父元素设置-overflow：hidden"><a href="#父元素设置-overflow：hidden" class="headerlink" title="父元素设置 overflow：hidden"></a>父元素设置 <code>overflow：hidden</code></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span> <span class="attr">id</span>=<span class="string">&quot;float&quot;</span> <span class="attr">style</span>=<span class="string">&quot;overflow:hidden; *zoom:1;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>3)父元素设置 overflow: hidden <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span>.main&#123;float:left;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;side&quot;</span>&gt;</span>.side&#123;float:right;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer&quot;</span>&gt;</span>.footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="父元素设置-overflow：auto"><a href="#父元素设置-overflow：auto" class="headerlink" title="父元素设置 overflow：auto"></a>父元素设置 <code>overflow：auto</code></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span> <span class="attr">id</span>=<span class="string">&quot;float3&quot;</span> <span class="attr">style</span>=<span class="string">&quot;overflow:auto;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>4)父元素设置 overflow: auto <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span>.main&#123;float:left;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;side&quot;</span>&gt;</span>.side&#123;float:right;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer&quot;</span>&gt;</span>.footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="父元素也设置浮动"><a href="#父元素也设置浮动" class="headerlink" title="父元素也设置浮动"></a>父元素也设置浮动</h3><h3 id="父元素设置-display-table"><a href="#父元素设置-display-table" class="headerlink" title="父元素设置 display: table"></a>父元素设置 <code>display: table</code></h3><h3 id="父元素设置-display-flow-root"><a href="#父元素设置-display-flow-root" class="headerlink" title="父元素设置 display: flow-root"></a>父元素设置 <code>display: flow-root</code></h3><h3 id="使用-after-伪元素"><a href="#使用-after-伪元素" class="headerlink" title="使用 :after 伪元素"></a>使用 <code>:after</code> 伪元素</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">content</span>: <span class="string">&quot;.&quot;</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">clear</span>: both;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">visibility</span>: hidden;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.clearfix</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="language-css">&#125;  <span class="comment">/* for IE/Mac */</span></span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if IE]&gt;</span></span><br><span class="line"><span class="comment">&lt;style type=&quot;text/css&quot;&gt;</span></span><br><span class="line"><span class="comment">.clearfix &#123;</span></span><br><span class="line"><span class="comment">    zoom: 1;/* triggers hasLayout */</span></span><br><span class="line"><span class="comment">    display: block;/* resets display for IE/Win */</span></span><br><span class="line"><span class="comment">&#125; &lt;/style&gt;</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure><h2 id="什么是块级格式上下文"><a href="#什么是块级格式上下文" class="headerlink" title="什么是块级格式上下文"></a>什么是块级格式上下文</h2><p>块级格式上下文（Block Formatting Context，BFC ），是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。</p><ul><li>默认布局时，区域高度包含浮动元素高度</li><li>不同区域间相互独立，区域内的盒子和区域外的盒子互不影响</li><li>不同区域不会发生外边距折叠</li></ul><h3 id="如何创建BFC"><a href="#如何创建BFC" class="headerlink" title="如何创建BFC"></a>如何创建BFC</h3><p>我们可以根据布局、溢出处理和有限布局，用不同方法创建块级格式上下文</p><ul><li>根元素 <code>&lt;html&gt;</code></li><li>无副作用：<code>display: flow-root</code></li><li>默认布局<ul><li>绝对定位：<code>position: absolute</code> 和 <code>position: fixed</code></li><li>浮动：<code>float: left</code> <code>float: right</code></li><li>行内块元素：<code>display: inline-block</code></li></ul></li><li>溢出处理<ul><li>隐藏滚动条，裁剪溢出内容 <code>overflow: hidden</code></li><li>显示滚动条，裁剪溢出内容 <code>overflow: scroll</code></li><li>未溢出，隐藏滚动条，溢出，显示滚动条 <code>overflow:auto</code></li></ul></li><li>有限布局<ul><li>contain 属性值不为 none</li></ul></li><li>弹性布局<ul><li><code>display: flex</code> 直接子元素</li><li><code>display: inline-flex</code> 直接子元素</li></ul></li><li>网格布局<ul><li><code>display: gird</code> 直接子元素</li><li><code>display: inline-gird</code> 直接子元素</li></ul></li><li>多列布局（分栏布局）<ul><li>column-count 分栏数属性值不为 auto</li><li>column-width 分栏列宽属性值不为 auto</li><li><code>column-span: all</code> 跨越所有列，表现为不分栏</li></ul></li><li>表格布局<ul><li><code>display: table</code> 表格</li><li><code>display: inline-table</code> 内联表格</li><li><code>display: table-cell</code> 单元格</li><li><code>display: table-caption</code> 表格标题</li><li><code>display: table-row</code> 行</li><li><code>display: table-row-grouptbody</code></li><li><code>display:table-header-groupthead</code></li><li><code>display:table-footer-grouptfoot</code></li></ul></li></ul><p>用途 通过创建块级格式上下文，我们可以：</p><ul><li>清除浮动</li><li>解决外边距折叠</li><li>限定布局范围，提高渲染性能</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上列举的方法，无非有两类：  </p><p>其一，通过在浮动元素的末尾添加一个空元素，设置 <code>clear：both</code> 属性，<code>after</code> 伪元素其实也是通过 <code>content</code> 在元素的后面生成了内容为一个点的块级元素；  </p><p>其二，通过设置父元素 <code>overflow</code> 或者 <code>display：table</code> 属性来闭合浮动。  </p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 面试题实践</title>
      <link href="/blog/2021/03/19/CSS-%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AE%9E%E8%B7%B5/"/>
      <url>/blog/2021/03/19/CSS-%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="画一条0-5px的直线"><a href="#画一条0-5px的直线" class="headerlink" title="画一条0.5px的直线"></a>画一条0.5px的直线</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.line</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="画一个三角形箭头朝上，鼠标放上后箭头朝下"><a href="#画一个三角形箭头朝上，鼠标放上后箭头朝下" class="headerlink" title="画一个三角形箭头朝上，鼠标放上后箭头朝下"></a>画一个三角形箭头朝上，鼠标放上后箭头朝下</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.trigle-btn</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">border-style</span>: solid;</span><br><span class="line">    <span class="attribute">border-color</span>: transparent transparent <span class="number">#999</span>;</span><br><span class="line">    <span class="attribute">transform-origin</span>: center <span class="number">75%</span>;</span><br><span class="line">    <span class="attribute">transition</span>: transform .<span class="number">5s</span>;</span><br><span class="line">    &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">180deg</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现元素吸底-固定显示在浏览器底部"><a href="#实现元素吸底-固定显示在浏览器底部" class="headerlink" title="实现元素吸底(固定显示在浏览器底部)"></a>实现元素吸底(固定显示在浏览器底部)</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.bottom</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两列自适应布局-两列，左列宽度固定，右列宽度占满"><a href="#两列自适应布局-两列，左列宽度固定，右列宽度占满" class="headerlink" title="两列自适应布局(两列，左列宽度固定，右列宽度占满)"></a>两列自适应布局(两列，左列宽度固定，右列宽度占满)</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#div1</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">background-color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#div2</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="按钮鼠标悬停逐渐高亮"><a href="#按钮鼠标悬停逐渐高亮" class="headerlink" title="按钮鼠标悬停逐渐高亮"></a>按钮鼠标悬停逐渐高亮</h2><p><button class="menuButton">按钮</button></p><style>.menuButton {  position: relative;  transition-property: background-color, color;  transition-duration: .5s;  transition-timing-function: ease-out;  text-align: left;  background-color: grey;  left: 5px;  top: 5px;  height: 26px;  color: white;  border-color: black;  border-radius: 5px;  font-family: sans-serif;  text-decoration: none;  box-shadow: 2px 2px 1px black;  padding: 2px 4px;  border: 1px solid black;}.menuButton:hover {  position: relative;  transition-property: background-color, color;  transition-duration: .5s;  transition-timing-function: ease-out;  background-color:white;  color:black;  box-shadow: 2px 2px 1px black;}</style><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.menuButton</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">transition-property</span>: background-color, color;</span><br><span class="line">  <span class="attribute">transition-duration</span>: .<span class="number">5s</span>;</span><br><span class="line">  <span class="attribute">transition-timing-function</span>: ease-out;</span><br><span class="line">  <span class="attribute">text-align</span>: left;</span><br><span class="line">  <span class="attribute">background-color</span>: grey;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">26px</span>;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">border-color</span>: black;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: sans-serif;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">1px</span> black;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">2px</span> <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.menuButton</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">transition-property</span>: background-color, color;</span><br><span class="line">  <span class="attribute">transition-duration</span>: .<span class="number">5s</span>;</span><br><span class="line">  <span class="attribute">transition-timing-function</span>: ease-out;</span><br><span class="line">  <span class="attribute">background-color</span>:white;</span><br><span class="line">  <span class="attribute">color</span>:black;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">1px</span> black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-flex-实现如下效果"><a href="#使用-flex-实现如下效果" class="headerlink" title="使用 flex 实现如下效果"></a>使用 flex 实现如下效果</h2><table><thead><tr><th style="background: gray;"></th><th></th><th></th></tr></thead><tbody><tr><td></td><td style="background: gray;"></td><td></td></tr><tr><td></td><td></td><td style="background: gray;"></td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item0</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: flex-start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item2</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: flex-end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="执行如下代码-abc会是什么颜色？说明原因"><a href="#执行如下代码-abc会是什么颜色？说明原因" class="headerlink" title="执行如下代码 abc会是什么颜色？说明原因"></a>执行如下代码 abc会是什么颜色？说明原因</h2><p><style>  #p1 {color: red;}p.container {color: blue;}.p {color: yellow;}</style><p id="p1" class="container p">abc</p></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-id">#p1</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">p</span><span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: blue;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.p</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: yellow;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;container p&quot;</span>&gt;</span>abc<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>红色 和css选择器优先级有关 id &gt; 类</p><h2 id="如何給一个页面元素打码"><a href="#如何給一个页面元素打码" class="headerlink" title="如何給一个页面元素打码"></a>如何給一个页面元素打码</h2><div style="filter: blur(2px)">高斯模糊</div><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.filter</span> &#123;</span><br><span class="line">    <span class="attribute">filter</span>: <span class="built_in">blur</span>(<span class="number">2px</span>); <span class="comment">/* 高斯模糊 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何将简体字显示为繁体字"><a href="#如何将简体字显示为繁体字" class="headerlink" title="如何将简体字显示为繁体字"></a>如何将简体字显示为繁体字</h2><div style="font-variant-east-asian: traditional">繁体字</div><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.font-variant-east-asian</span> &#123;</span><br><span class="line">    <span class="attribute">font-variant-east-asian</span>: traditional; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 盒模型</title>
      <link href="/blog/2021/03/19/CSS-%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
      <url>/blog/2021/03/19/CSS-%E7%9B%92%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>任何HTML元素都可以看作一个盒子，它包括：外边距，边框，内边距，和实际内容。<br>Margin(外边距) - 边框外的区域，外边距区域是透明的。<br>Border(边框) - 围绕在内边距和内容外的边框。<br>Padding(内边距) -内容周围的区域，内边距区域是透明的。<br>Content(内容) - 盒子的内容，显示文本和图像。  </p><p>box-sizing 属性定义了浏览器应该如何计算一个元素的总宽度和总高度，可以通过 box-sizing 属性来设置盒模型。</p><ul><li><p>内容盒模型 <code>box-sizing: content-box</code><br>content-box:<br>width = content width;<br>height = content height</p></li><li><p>边框盒模型 <code>box-sizing: border-box</code><br>border-box:<br>width = border + padding + content width<br>heigth = border + padding + content heigth</p></li><li><p>内边距盒模型 <code>box-sizing: padding-box</code> （这不是一个标准的 box-sizing 选项，大部分浏览器不支持）<br>padding-box:<br>width = padding + content width<br>heigth = padding + content heigth</p></li></ul><p>浏览器默认使用内容盒模型，在ie8以下的浏览器中默认使用边框盒模型。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 水平&amp;垂直居中</title>
      <link href="/blog/2021/03/19/CSS-%E6%B0%B4%E5%B9%B3-%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/"/>
      <url>/blog/2021/03/19/CSS-%E6%B0%B4%E5%B9%B3-%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="html-布局"><a href="#html-布局" class="headerlink" title="html 布局"></a>html 布局</h2><p>水平居中&amp;垂直居中指的都是子元素相对于父元素位置，所以页面中需要有两个元素，假设外层元素id为out，内层元素id为in。  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;out&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;in&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--p id=&quot;in&quot;/--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 水平居中 <span class="number">1</span></span><br><span class="line"><span class="selector-id">#in</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line">// 水平居中 <span class="number">2</span></span><br><span class="line"><span class="selector-id">#out</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-direction</span>: column;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#in</span> &#123;</span><br><span class="line">    <span class="attribute">align-self</span>: center;</span><br><span class="line">&#125;</span><br><span class="line">// 水平居中 <span class="number">3</span></span><br><span class="line"><span class="selector-id">#out</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#in</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">150px</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 水平居中 <span class="number">4</span></span><br><span class="line"><span class="selector-id">#out</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#in</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">150px</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 水平居中 <span class="number">5</span></span><br><span class="line"><span class="selector-id">#in</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: fit-content;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line">// 水平居中 <span class="number">6</span></span><br><span class="line"><span class="selector-id">#out</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#in</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line">// 水平居中 <span class="number">7</span></span><br><span class="line"><span class="selector-id">#out</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#in</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">150px</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 水平居中 <span class="number">8</span></span><br><span class="line"><span class="selector-id">#in</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">25%</span>, <span class="number">25%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// 垂直居中 <span class="number">1</span></span><br><span class="line"><span class="selector-id">#in</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line">// 垂直居中 <span class="number">2</span></span><br><span class="line"><span class="selector-id">#out</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-direction</span>: row;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#in</span> &#123;</span><br><span class="line">    <span class="attribute">align-self</span>: center;</span><br><span class="line">&#125;</span><br><span class="line">// 垂直居中 <span class="number">3</span></span><br><span class="line"><span class="selector-id">#out</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#in</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line">// 垂直居中 <span class="number">4</span></span><br><span class="line"><span class="selector-id">#in</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br><span class="line">// 垂直居中 <span class="number">5</span></span><br><span class="line"><span class="selector-id">#out</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#in</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">tranlateY</span>(-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br><span class="line">// 垂直居中 <span class="number">6</span> (如果子元素为文本)</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-id">#in</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS viewport/mediaquery</title>
      <link href="/blog/2021/03/19/CSS-viewport-mediaquery/"/>
      <url>/blog/2021/03/19/CSS-viewport-mediaquery/</url>
      
        <content type="html"><![CDATA[<p>viewport 和 Mediaquery 都是为了进行响应式Web设计，即面对不同的设备有不同的样式而又不用开发不同的页面。<br>viewport 视口，移动设备上的viewport就是设备的屏幕上能用来显示我们的网页的那一块区域,最常见用法  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>width=device-width</code> : 当前viewport的宽度等于设备的宽度<br><code>initial-scale=1.0</code> : 初始缩放比例1.0<br><code>maximum-scale=1.0</code> : 最大缩放比例1.0<br><code>minimum-scale=1.0</code> : 最小缩放比例1.0 <em><br><code>user-scalable=no</code> : 不允许用户手动缩放 </em></p><span id="more"></span><p>Media query 媒体查询，针对不同的媒体类型定义不同的样式。最常见用法，根据屏幕宽度设置不同样式。  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Default wide-screen styles */</span></span><br><span class="line"><span class="keyword">@media</span> all <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">1024px</span>) &#123;</span><br><span class="line">    <span class="comment">/* styles for narrow desktop browsers and iPad landscape */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> all <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">768px</span>) &#123;</span><br><span class="line">    <span class="comment">/* styles for narrower desktop browsers and iPad portrait */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> all <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">480px</span>) &#123;</span><br><span class="line">    <span class="comment">/* styles for iPhone/Android landscape (and really narrow browser windows) */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> all <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">320px</span>) &#123;</span><br><span class="line">    <span class="comment">/* styles for iPhone/Android portrait */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">240px</span>) &#123;</span><br><span class="line">    <span class="comment">/* styles for smaller devices */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css @supports 作用</title>
      <link href="/blog/2021/03/19/CSS-supports-%E7%89%B9%E6%80%A7%E6%9F%A5%E8%AF%A2/"/>
      <url>/blog/2021/03/19/CSS-supports-%E7%89%B9%E6%80%A7%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<p><code>@supports</code> 可以指定依赖于浏览器中的一个或多个特定的CSS功能的支持声明，这被称为特性查询。  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@supports</span> (<span class="attribute">display</span>: <span class="attribute">grid</span>) &#123;</span><br><span class="line">  <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@supports</span> <span class="keyword">not</span> (<span class="attribute">display</span>: <span class="attribute">grid</span>) &#123;</span><br><span class="line">  <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="声明语法"><a href="#声明语法" class="headerlink" title="声明语法"></a>声明语法</h2><p>最基本的支持条件就是 CSS 声明，也就是一个 CSS 属性后跟一个值，中间用冒号分开。  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@supports</span> (<span class="attribute">transform-origin</span>: <span class="number">5%</span> <span class="number">5%</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="函数语法"><a href="#函数语法" class="headerlink" title="函数语法"></a>函数语法</h2><p>测试浏览器是否支持经过测试的选择器语法。  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@supports</span> selector(A &gt; B) &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="not操作符"><a href="#not操作符" class="headerlink" title="not操作符"></a>not操作符</h2><p>将 <code>not</code> 操作符放在任何表达式之前就能否定一条表达式。  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@supports</span> <span class="keyword">not</span> (<span class="attribute">transform-origin</span>: <span class="number">10em</span> <span class="number">10em</span> <span class="number">10em</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="and操作符"><a href="#and操作符" class="headerlink" title="and操作符"></a>and操作符</h2><p><code>and</code> 操作符用来将两个原始的表达式做逻辑与后生成一个新的表达式，如果两个原始表达式的值都为真，则生成的表达式也为真。  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@supports</span> (<span class="attribute">display</span>: table-cell) <span class="keyword">and</span> (<span class="attribute">display</span>: list-item) &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="or操作符"><a href="#or操作符" class="headerlink" title="or操作符"></a>or操作符</h2><p><code>or</code> 操作符用来将两个原始的表达式做逻辑或后生成一个新的表达式，如果两个原始表达式的值有一个或者都为真，则生成的表达式也为真。  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@supports</span> (<span class="attribute">transform-style</span>: preserve) <span class="keyword">or</span> (<span class="attribute">-moz-transform-style</span>: preserve) &#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS transform &amp; transition &amp; animation属性</title>
      <link href="/blog/2021/03/16/CSS-transform-transition-animation/"/>
      <url>/blog/2021/03/16/CSS-transform-transition-animation/</url>
      
        <content type="html"><![CDATA[<h2 id="transition-过渡"><a href="#transition-过渡" class="headerlink" title="transition 过渡"></a>transition 过渡</h2><p>transition 属性是 transition-property，transition-duration，transition-timing-function 和 transition-delay 的一个简写属性。transition 可以为一个元素在不同状态之间切换的时候定义不同的过渡效果。</p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>transition-property</td><td>指定应用过渡属性的名称</td></tr><tr><td>transition-duration</td><td>以秒或毫秒为单位指定过渡动画所需的时间，默认为0s</td></tr><tr><td>transition-timing-function</td><td>用来描述 <code>transition-property</code> 中间值是怎样计算的, 默认 ease, 可选 ease-in，ease-out，ease-in-out，linear，step-start，step-end，steps(4, end)，inherit，cubic-bezier(0.1, 0.7, 1.0, 0.1)</td></tr><tr><td>transition-delay</td><td>规定了在过渡效果开始作用之前需要等待的时间, 默认0s</td></tr></tbody></table><p>在符合标准的浏览器中，transition效果结束时会触发 <code>transitionend(propertyName, elapsedTime)</code> 事件</p><span id="more"></span><h2 id="transform-转变"><a href="#transform-转变" class="headerlink" title="transform 转变"></a>transform 转变</h2><p>transform 属性允许你旋转，缩放，倾斜或平移给定元素。可以指定为关键字值 none 或一个或多个 &lt;transform-function> 值。  </p><p>&lt;transform-function> CSS数据类型用于对元素的显示做变换。通常，这种变换可以由矩阵表示，并且可以使用每个点上的矩阵乘法来确定所得到的图像。在CSS（和大部分的计算机图形学）中，原点 (0, 0) 在元素的左上角。  </p><table><thead><tr><th>transfrom-function</th><th>含义</th></tr></thead><tbody><tr><td><code>matrix(a, b, c, d, tx, ty)</code></td><td>matrix() 用六个指定的值来指定一个均匀的二维（2D）变换矩阵。</td></tr><tr><td><code>matrix3d(a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3, a4, b4, c4, d4)</code></td><td>matrix3d() 用一个 4 × 4 的齐次矩阵来描述一个三维（3D）变换。</td></tr><tr><td><code>perspective(l)</code></td><td>perspective() 函数定义了 z=0 平面与用户之间的距离，以便给三维定位元素一定透视度。</td></tr><tr><td><code>rotate(a)</code></td><td>rotate() 函数定义一个旋转属性，将元素在不变形的情况下旋转到不动点周围。</td></tr><tr><td><code>rotate3d(x, y, z, a)</code></td><td>rotate3d() 函数定义一个3D旋转功能，该旋转使元素能够绕固定轴移动而不变形。</td></tr><tr><td><code>rotateX(a)</code></td><td>rotateX() 函数定义了将元素在横坐标上旋转而不使其变形的方法。</td></tr><tr><td><code>rotateY(a)</code></td><td>rotateY() 函数定义了将元素在纵坐标上旋转而不使其变形的方法。</td></tr><tr><td><code>rotateZ(a)</code></td><td>rotateZ() 函数定义了将元素在z轴上旋转而不使其变形的方法。</td></tr><tr><td><code>scale(sx)</code>  <code>scale(sx, sy)</code></td><td>scale() 函数可改变元素的大小。 它可以增大或减小元素的大小，并且缩放量由矢量定义，并且它可以使在一个方向上比另一个方向更多。</td></tr><tr><td><code>scale3d(sx, sy, sz)</code></td><td>scale3d() 函数可改变元素的大小。由于缩放的量由矢量定义，因此可以改变不同方向的尺寸。</td></tr><tr><td><code>scaleX()</code></td><td>scaleX() 函数是用一个常数因子来修改每个单元点的横坐标，在比例因子是1的情况下该函数是恒等变换。</td></tr><tr><td><code>scaleY()</code></td><td>scaleY() 函数用一个常数因子修改每个元素点的纵坐标，在比例因子是1的情况下该函数是恒等变换。</td></tr><tr><td><code>scaleZ()</code></td><td>scaleZ() 函数是用一个常数因子来修改每个单元点的z轴坐标，在比例因子是1的情况下该函数是恒等变换。</td></tr><tr><td><code>skew(ax)</code> 或 <code>skew(ax, ay)</code></td><td>skew() 函数是一种用于拉伸，或者说是平移，该函数会使得在每个方向上扭曲元素上的每个点以一定角度。</td></tr><tr><td><code>skewX(a)</code></td><td>skewX() 函数是用于水平拉伸，它将元素的每个点在水平方向上扭曲一定角度。</td></tr><tr><td><code>skewY(a)</code></td><td>skewY() 函数是用于垂直拉伸，它将元素的每个点在垂直方向上扭曲一定角度。</td></tr><tr><td><code>translate(tx)</code> 或 <code>translate(tx, ty)</code></td><td>translate() 函数用于移动元素在平面上的位置。</td></tr><tr><td><code>translate3d(tx, ty, tz)</code></td><td>translate3d() 函数用于移动元素在3D空间中的位置。</td></tr><tr><td><code>translateX(t)</code></td><td>translateX() 函数用于在平面上水平移动元素。</td></tr><tr><td><code>translateY(t)</code></td><td>translateY() 函数用于在平面上垂直移动元素。</td></tr><tr><td><code>translateZ()</code></td><td>translateZ() 函数用于3D空间的z轴方向移动元素， 这个转换的特点是通过 &lt;length> 定义了它的z轴方向移动量。</td></tr></tbody></table><h2 id="animation-动画"><a href="#animation-动画" class="headerlink" title="animation 动画"></a>animation 动画</h2><p>animation 属性是 animation-name，animation-duration, animation-timing-function，animation-delay，animation-iteration-count，animation-direction，animation-fill-mode 和 animation-play-state 属性的一个简写属性形式。用来指定一组或多组动画，每组之间用逗号相隔。  </p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>animation-name</td><td>指定应用的一系列动画，每个名称代表一个由 <code>@keyframes</code> 定义的动画序列。默认 none。</td></tr><tr><td>animation-duration</td><td>指定一个动画周期的时长。默认值为0s，表示无动画。</td></tr><tr><td>animation-timing-function</td><td>定义CSS动画在每一动画周期中执行的节奏。默认为 ease。</td></tr><tr><td>animation-delay</td><td>定义动画于何时开始，即从动画应用在元素上到动画开始的这段时间的长度。默认为0。</td></tr><tr><td>animation-iteration-count</td><td>定义动画在结束前运行的次数 可以是1次/无限循环（infinite）</td></tr><tr><td>animation-direction</td><td>指示动画是否反向播放。默认为 normal。只可以为: <br/>normal（正向） <br/> reverse（反向） <br/> alternate（交替反向） <br/> alternate-reverse（反向交替）</td></tr><tr><td>animation-fill-mode</td><td>设置CSS动画在执行之前和之后如何将样式应用于其目标。默认为none。只可以为: <br/> none（当动画未执行时，动画将不会将任何样式应用于目标，而是已经赋予给该元素的 CSS 规则来显示该元素）<br/> forwards（目标将保留由执行期间遇到的最后一个关键帧计算值）<br/>backwards（动画将在应用于目标时立即应用第一个关键帧中定义的值，并在animation-delay期间保留此值）<br/>both（动画将遵循forwards和backwards的规则，从而在两个方向上扩展动画属性）</td></tr><tr><td>animation-play-state</td><td>定义一个动画是否运行或者暂停。可以通过查询它来确定动画是否正在运行，它的值可以被设置为暂停和恢复的动画的重放。默认值 running。只可以为:<br/> running(当前动画正在运行)<br/>paused(当前动画已被停止)</td></tr></tbody></table><p>animation 属性通常需要和关键帧 <code>@keyframes</code> 配合来使用，关键帧 <code>@keyframes</code> 规则通过在动画序列中定义关键帧（或waypoints）的样式来控制CSS动画序列中的中间步骤。和 过渡 <code>transition</code> 相比，关键帧 <code>@keyframes</code> 可以控制动画序列的中间步骤。<br>要使用关键帧, 先创建一个带名称的 <code>@keyframes</code> 规则，以便后续使用 <code>animation-name</code> 属性将动画同其关键帧声明匹配。每个 <code>@keyframes</code> 规则包含多个关键帧，也就是一段样式块语句，每个关键帧有一个百分比值作为名称，代表在动画进行中，在哪个阶段触发这个帧所包含的样式。  </p><p>例如：  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 如果一个关键帧规则没有指定动画的开始或结束状态，浏览器将使用元素的现有样式作为起始/结束状态。 */</span></span><br><span class="line"><span class="keyword">@keyframes</span> move &#123; <span class="comment">/* move 为关键帧名称 */</span></span><br><span class="line">  <span class="selector-tag">from</span> &#123; <span class="attribute">margin-top</span>: <span class="number">50px</span>; &#125; <span class="comment">/* from 相当于 0% */</span></span><br><span class="line">  <span class="number">50%</span>  &#123; <span class="attribute">margin-top</span>: <span class="number">150px</span> <span class="meta">!important</span>; &#125; <span class="comment">/* !important 会被忽略 */</span></span><br><span class="line">  <span class="number">50%</span>  &#123; <span class="attribute">margin-top</span>: <span class="number">200px</span>; &#125; <span class="comment">/* 如果多个关键帧使用同一个名称，以最后一次定义的为准。 */</span></span><br><span class="line">  <span class="selector-tag">to</span>   &#123; <span class="attribute">margin-top</span>: <span class="number">100px</span>; &#125; <span class="comment">/* to 相当于 100% */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 如果在关键帧的样式中使用了不能用作动画的属性，那么这些属性会被忽略掉，支持动画的属性仍然是有效的，不受波及。 */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eslint小抄</title>
      <link href="/blog/2021/02/01/FE-Eslint%E5%B0%8F%E6%8A%84/"/>
      <url>/blog/2021/02/01/FE-Eslint%E5%B0%8F%E6%8A%84/</url>
      
        <content type="html"><![CDATA[<p>ESLint 是在 ECMAScript/JavaScript 代码中识别和报告模式匹配的工具，它的目标是保证代码的一致性和避免错误。ESLint 首先使用 AST 分析工具分析代码，然后使用插件配置生效的规则，针对预设的规则对代码进行检查，在不符合规则的时候提示&amp;自动修复。你可以配置自己的代码检查规则，也可以根据已有的规则进行个性化的定制、扩展，甚至可以定制自己的规则。而在检查时，你也可以通过 js 注释在检查过程中灵活的开启、关闭和改变规则。  </p><span id="more"></span><h2 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h2><p>使用 npm 安装 ESLint：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install eslint --save-dev</span></span><br></pre></td></tr></table></figure></p><p>初始化配置文件<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npx eslint --init</span></span><br></pre></td></tr></table></figure></p><p>运行 ESLint 进行代码检查<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npx eslint yourfile.js</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="comment"># 自动修复问题</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npx eslint yourfile.js --fix</span></span><br></pre></td></tr></table></figure></p><p>通常， ESLint 通过类似 <code>.eslintrc.&#123;js,yml,json&#125;</code> 的配置文件或者通过在 <code>package.json</code> 文件中添加 <code>eslintConfig</code> 键来对目录中的文件进行检查，这个文件可以通过执行 <code>eslint --init</code> 命令然后根据选择自动生成，生成后可以自由配置。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>以下介绍 <code>.eslintrc.&#123;js,yml,json&#125;</code> 配置文件中各字段含义：  </p><h3 id="env-环境"><a href="#env-环境" class="headerlink" title="env 环境"></a>env 环境</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .eslintrc.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;env&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;browser&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;es2021&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>指定脚本的运行环境。每种环境都有一组特定的预定义全局变量。可以指定多个运行环境。在执行 <code>eslint</code> 命令时可以通过添加 <code>--env</code> 指定检查的环境。在代码中可以通过添加 <code>/* eslint-env node, mocha */</code> 指定特定的环境。</p><p>常用的环境包括:</p><table><thead><tr><th>env名</th><th>含义</th></tr></thead><tbody><tr><td>browser</td><td>浏览器全局变量</td></tr><tr><td>node</td><td>Nodejs全局变量和Nodejs范围</td></tr><tr><td>commonjs</td><td>CommonJS全局变量和CommonJS范围（使用Browserify/webpack且仅运行在浏览器时使用）</td></tr><tr><td>es6</td><td>打开所有 ECMAScript 6 功能除了 modules（自动设置 <code>parserOptions.ecmaVersion</code> 为6）</td></tr><tr><td>es2021</td><td>添加所有 ECMAScript 2021 全局变量并自动将 <code>parserOptions.ecmaVersion</code> 设置为12</td></tr></tbody></table><h3 id="globals-全局变量"><a href="#globals-全局变量" class="headerlink" title="globals 全局变量"></a>globals 全局变量</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .eslintrc.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;globals&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;app&quot;</span><span class="punctuation">:</span> <span class="string">&quot;writable&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;swan&quot;</span><span class="punctuation">:</span> <span class="string">&quot;readonly&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Promise&quot;</span><span class="punctuation">:</span> <span class="string">&quot;off&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>添加全局变量。 <code>globals</code> 下的 <code>app</code> <code>swan</code> 代表了为 ESLint 添加的全局变量。在代码中可以通过添加  <code>/* global app:writable, swan:writable */</code> 指定添加全局环境变量。值 <code>writeable</code> 表示该全局变量可以被重写， <code>readonly</code> 表示不允许被重写, <code>off</code> 表示禁用该全局变量。</p><h3 id="parser-解析器"><a href="#parser-解析器" class="headerlink" title="parser 解析器"></a>parser 解析器</h3><p>指定 ESLint 使用的解析器。ESLint 默认使用 Espree 解析器。以下列出了ESLint支持的AST解析器  </p><table><thead><tr><th>parser名</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://github.com/jquery/esprima">Esprima</a></td><td>jquery 团队提供的解析器，支持 ES9 ，符合 ESTree 标准语法树格式</td></tr><tr><td><a href="https://github.com/eslint/espree">Espree</a></td><td>ESLint 默认解析器，基于 Esprima 发展而来并兼容 Esprima，支持 ES6</td></tr><tr><td><a href="https://www.npmjs.com/package/@babel/eslint-parser">@babel/eslint-parser</a></td><td>Babel 解析器的扩展，兼容 ESLint</td></tr><tr><td><a href="https://www.npmjs.com/package/@typescript-eslint/parser">@typescript-eslint/parser</a></td><td>支持 typescript 的 AST 解析器</td></tr></tbody></table><h3 id="parserOptions-解析器选项"><a href="#parserOptions-解析器选项" class="headerlink" title="parserOptions 解析器选项"></a>parserOptions 解析器选项</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .eslintrc.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;parserOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;ecmaVersion&quot;</span><span class="punctuation">:</span> <span class="number">6</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;sourceType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;module&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ecmaFeatures&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;jsx&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>通过 <code>parserOptions</code> 来选择支持特定的 JavaScript 版本和功能。ESLint 默认支持 ECMAScript5 语法。  </p><p>以下是 <code>parserOptions</code> 的选项及其含义：  </p><table><thead><tr><th>parserOptions选项</th><th>含义</th></tr></thead><tbody><tr><td>ecmaVersion</td><td>js 版本，默认5</td></tr><tr><td>sourceType</td><td>js 类型，默认 “script”，”module” 表示是 ECMAScript 包</td></tr><tr><td>ecmaFeatures</td><td>表名额外支持的 js 功能，可取值 “globalReturn” 表示在全局范围允许 <code>return</code> ; “impliedStrict” 表示打开全局严格模式; “jsx” 表示支持 JSX</td></tr></tbody></table><h3 id="plugins-插件"><a href="#plugins-插件" class="headerlink" title="plugins 插件"></a>plugins 插件</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .eslintrc.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;plugin1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;eslint-plugin-plugin2&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>添加插件。 ESLint 支持添加插件来进行额外的处理。 <code>plugins</code> 是数组结构，包括了插件的名字，插件需要通过 <code>npm install</code> 来安装，在 <code>plugins</code> 配置中可以省略插件的前缀 <code>eslint-plugin-</code> 。</p><h3 id="processor-处理器"><a href="#processor-处理器" class="headerlink" title="processor 处理器"></a>processor 处理器</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .eslintrc.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;a-plugin&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;a-plugin/a-processor&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>插件可以包含处理器。处理器可以将其他类型的文件转换成 Javascript 代码，然后可以使用 ESLint 进行一些预处理。</p><h3 id="overrides-重写"><a href="#overrides-重写" class="headerlink" title="overrides 重写"></a>overrides 重写</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .eslintrc.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;a-plugin&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;overrides&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;files&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;*.md&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;processor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;a-plugin/markdown&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;files&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;**/*.md/*.js&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;rules&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;strict&quot;</span><span class="punctuation">:</span> <span class="string">&quot;off&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>使用 <code>overrides</code>  可以对符合特定 glob 规则的文件进行特殊处理，包括执行特殊的规则或进行预处理。v4.1.0+版本支持。</p><h3 id="rules-规则"><a href="#rules-规则" class="headerlink" title="rules 规则"></a>rules 规则</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .eslintrc.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;rules&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;semi&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;error&quot;</span><span class="punctuation">,</span> <span class="string">&quot;always&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;quotes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;error&quot;</span><span class="punctuation">,</span> <span class="string">&quot;double&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;plugin1/rule1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;error&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>指定脚本执行的规则。<code>rules</code> 下的 <code>semi</code> <code>quotes</code> 代表了 ESLint 规则， <code>plugin1/rule1</code> 代表了插件 plugin1 下的 rule1 规则。 第一个值代表了规则的错误等级，取值有以下三个</p><table><thead><tr><th>rules key取值</th><th>数值</th><th>含义</th></tr></thead><tbody><tr><td>“off”</td><td>0</td><td>将规则关闭</td></tr><tr><td>“warn”</td><td>1</td><td>规则作为一个警告打开</td></tr><tr><td>“error”</td><td>2</td><td>规则作为一个错误打开（不符合规则将会退出）</td></tr></tbody></table><p>第二个之后的值代表了规则的额外选项。<br>在代码中可以通过 <code>/* eslint eqeqeq: &quot;off&quot;, curly: 2, quotes: [&quot;error&quot;, &quot;double&quot;] */</code> 修改规则。可以通过 <code>/* eslint-disable eqeqeq, curly*/</code> 取消规则，通过 <code>/* eslint-enable eqeqeq, curly*/</code> 打开某个规则。</p><p>可以通过以下写法对单行代码禁用 ESLint 规则（所有或单条、多条）： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;foo&#x27;</span>); <span class="comment">// eslint-disable-line no-alert, plugin1/rule1 -- Here&#x27;s a description about why this configuration is necessary.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// eslint-disable-next-line no-alert</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br></pre></td></tr></table></figure><p>可以在ESLint代码规则后添加 <code>--</code> 来对该条规则进行解释，例如：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* eslint eqeqeq: &quot;off&quot;, curly: &quot;error&quot; -- Here&#x27;s a description about why this configuration is necessary. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint eqeqeq: &quot;off&quot;, curly: &quot;error&quot;</span></span><br><span class="line"><span class="comment">    --------</span></span><br><span class="line"><span class="comment">    Here&#x27;s a description about why this configuration is necessary. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint eqeqeq: &quot;off&quot;, curly: &quot;error&quot;</span></span><br><span class="line"><span class="comment"> * --------</span></span><br><span class="line"><span class="comment"> * This will not work due to the line above starting with a &#x27;*&#x27; character.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><a href="https://eslint.org/docs/rules/">ESLint Rules</a> 记录了所有的 ESLint 规则，你也可以 <a href="https://eslint.org/docs/developer-guide/working-with-rules">自定义自己的规则</a>。</p><h3 id="extends-继承"><a href="#extends-继承" class="headerlink" title="extends 继承"></a>extends 继承</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .eslintrc.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;extends&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eslint:recommended&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>指定脚本执行的继承来源。 <code>extends</code> 表示你的规则继承自另一个配置，例如 <code>eslint:recommended</code> 代表所有 <a href="https://eslint.org/docs/rules/">ESLint推荐规则（打✓的规则）</a> 将会开启。<br><code>extends</code> 可以配置成一个字符串来表示 配置文件的路径、可共享配置的名称、 <code>eslint:recommended</code> 或 <code>eslint:all</code> ，也可以配置成字符串数组来表示每个配置继承它前面的配置。</p><p>一些常用的继承配置包括：  </p><table><thead><tr><th>extends名</th><th>包</th><th>介绍</th><th>特点</th></tr></thead><tbody><tr><td>eslint:recommended</td><td>-</td><td>启用 ESLint 推荐规则</td></tr><tr><td>eslint:all</td><td>-</td><td>启用当前安装的 ESLint 中所有的核心规则(不推荐在产品中使用)</td></tr><tr><td>airbnb-base</td><td>eslint-config-airbnb-base</td><td>Airbnb推荐的代码风格</td><td>Airbnb号称是“最合理的编写 JavaScript 代码的方式”规范，规范写得比较全面，几乎覆盖了JavaScript的每一项特性</td></tr><tr><td>airbnb</td><td>eslint-config-airbnb</td><td>Airbnb推荐的代码风格，包括ES6和React</td></tr><tr><td>standard</td><td>eslint-config-standard</td><td>Standard代码风格</td><td>standard 号称是为了节省团队在代码风格上消耗的时间，规范十分简洁，0配置，提供了工具进行自动格式化，不支持修改。风格上使用两个空格缩进，使用单引号，不使用分号作为语句结束，不允许有多余的行末逗号</td></tr><tr><td>google</td><td>eslint-config-google</td><td>Google推荐的代码风格</td></tr><tr><td>react-app</td><td>eslint-config-react-app</td><td>Create React App 使用的代码风格</td></tr></tbody></table><h3 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h3><table><thead><tr><th>配置名</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>noInlineConfig</td><td>true</td><td>禁用所有的内联配置注释，在命令中添加 <code>--no-inline-config</code> 可以起到同样的效果</td></tr><tr><td>reportUnusedDisableDirectives</td><td>true</td><td>报告未使用的 <code>eslint-disable</code> 注释，在命令中添加 <code>--report-unused-disable-directives</code> 可以起到同样的作用</td></tr><tr><td>root</td><td>true</td><td>表示该配置文件为项目根配置文件，无需向上检索（ESLint 对文件进行检查时会将离要检测的文件最近的配置文件作为最高优先级，然后检索父目录的配置）</td></tr></tbody></table><h2 id="检查优先级"><a href="#检查优先级" class="headerlink" title="检查优先级"></a>检查优先级</h2><p>ESLint 检查文件时的规则按照以下顺序执行  </p><ol><li>行内配置<ol><li><code>/*eslint-disable*/</code> 和 <code>/*eslint-enable*/</code></li><li><code>/*global*/</code></li><li><code>/*eslint*/</code></li><li><code>/*eslint-env*/</code></li></ol></li><li>命令行选项（或 CLIEngine 等价物）：<ol><li><code>--global</code></li><li><code>--rule</code></li><li><code>--env</code></li><li><code>-c、--config</code></li></ol></li><li>项目级配置：<ol><li>与要检测的文件在同一目录下的 <code>.eslintrc.*</code> 或 <code>package.json</code> 文件，优先级 .js &gt; .yaml &gt; .yml &gt; .json &gt; .eslintrc(弃用) &gt; package.json </li><li>继续在父级目录寻找 <code>.eslintrc</code> 或 <code>package.json</code> 文件，直到根目录（包括根目录）或直到发现一个有 <code>&quot;root&quot;: true</code> 的配置。</li></ol></li><li>如果不是 1 到 3 中的任何一种情况，退回到 <code>~/.eslintrc</code> 中自定义的默认配置。</li></ol><h2 id="忽略检查"><a href="#忽略检查" class="headerlink" title="忽略检查"></a>忽略检查</h2><p>可以通过在项目根目录创建一个 .eslintignore 文件告诉 ESLint 去忽略特定的文件和目录。.eslintignore 文件是一个纯文本文件，其中的每一行都是一个 glob 模式表明哪些路径应该忽略检测。 也可以在命令中添加参数 <code>--ignore-pattern</code> 来忽略指定文件、目录。除了 .eslintignore 文件中的模式，ESLint总是忽略 <code>/node_modules/*</code> 和 <code>/bower_components/*</code> 中的文件。除了使用 .eslintignore 文件，也可以在命令中添加参数 <code>--ignore-path</code> 来指定一个包含所有忽略文件的文本文件。如果没有发现 .eslintignore 文件，也没有指定替代文件，ESLint 将会在 package.json 中寻找 <code>eslintIgnore</code> 键，来检查要忽略的文件。 </p><h2 id="ESLint-命令"><a href="#ESLint-命令" class="headerlink" title="ESLint 命令"></a>ESLint 命令</h2><p>ESLint 除了可以安装到本地，也可以全局安装。ESLint 安装后可以直接执行 <code>eslint -h</code> 命令查看所有可选项</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm i -g eslint</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">eslint [options] [file|<span class="built_in">dir</span>|glob]*</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="comment"># 执行  eslint -h 命令可以查看有关 eslint 命令的帮助</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">eslint -h</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> eslint </tag>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack小抄</title>
      <link href="/blog/2021/01/19/FE-webpack%E5%B0%8F%E6%8A%84/"/>
      <url>/blog/2021/01/19/FE-webpack%E5%B0%8F%E6%8A%84/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-webpack"><a href="#什么是-webpack" class="headerlink" title="什么是 webpack"></a>什么是 webpack</h2><p><a href="https://webpack.js.org/">webpack</a> 是一个用于现代 JavaScript 应用程序的静态模块绑定器。当webpack处理你的应用程序时，它会在内部构建一个依赖关系图，映射项目所需的每个模块，并生成一个或多个包（bundles）。  </p><p>webpack 可以转换打包多种类型的文件、模块、资源，包括 ES Modules 、CommonJS 和 AMD 模块， 也可以将 TypeScript 转换为 JavaScript，将 Handlebars 字符串转换为函数，将图片转换为 Base64，你也可以自己编写插件（plugins）来实现将任何你的应用程序需要的资源进行转换与打包。  </p><p>webpack 支持所有兼容 ES5 的浏览器。webpack 需要 Promise 来 import() 和 require.ensure() ，在更老旧的浏览器中使用 webpack 时，需要使用 polyfill。  </p><p>当前（2021年1月19日）最新版本的 webpack 是 v5.15.0， 以下内容默认适用于该版本， 另外 webpack5 运行时需要 Nodejs 版本在 10.13.0 以上。  </p><p>(2021年12月2日)做了部分更新，当前最新版本的 webpack 是 v5.64.4。</p><span id="more"></span><h2 id="webpack可以做什么"><a href="#webpack可以做什么" class="headerlink" title="webpack可以做什么"></a>webpack可以做什么</h2><h3 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h3><p>将各种类型的文件/模块作为资源进行统一的处理，webpack 通过 资源视图 和 loader 来实现对项目资源的管理。</p><h3 id="输出管理"><a href="#输出管理" class="headerlink" title="输出管理"></a>输出管理</h3><p>通过丰富的插件，webpack 可以在打包过程中进行一系列的处理，同时支持多个入口和输出。</p><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><p>区分 开发 模式和 生产 模式，可以对开发模式进行更有利于 debug 的编译(source map)，热更新等。提供了 webpack-dev-server 本地简易服务器进行开发调试。 </p><h3 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h3><p>支持将代码拆分为不同的包，然后可以按需或并行加载。它可以用来拆分更小的包和控制资源负载优先级，如果使用正确，会对负载时间产生重大影响。</p><p>多种方法可以实现代码分割，包括</p><ol><li>使用 SplitChunksPlugin 插件将公用依赖导出到特定包</li><li>使用 mini-css-extract-plugin 来将 CSS 从主应用中拆分出来</li><li>使用动态 import</li><li>使用 预获取/预加载 (prefetch/preload)</li><li>包解析<ol><li>使用官方提供的 <code>webpack --profile --json &gt; stats.json</code> 生成分析的JSON文件</li><li>webpack-chart</li><li>webpack-visualizer</li><li>webpack-bundle-analyzer</li><li>webpack bundle optimize helper</li><li>bundle-stats</li></ol></li></ol><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>浏览器使用缓存来避免无用的请求以及让资源加载更快，webpack 可以根据文件内容在输出文件名中添加 hash 串来控制浏览器的缓存更新策略。通常，可以将 node_modules 中的依赖打包为 vendors.js 然后固定 MODULE id，这样 vendors.[conenthash].js 便不会一直更新。</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>通过设置 <code>--env</code> 参数设置环境变量，在不同的环境下执行不同的编译方案。</p><h2 id="webpack的核心配置"><a href="#webpack的核心配置" class="headerlink" title="webpack的核心配置"></a>webpack的核心配置</h2><h3 id="Mode"><a href="#Mode" class="headerlink" title="Mode"></a>Mode</h3><p>通过将 mode 参数设置为 development 、 production 或 none，可以启用与每个环境相对应的 webpack 内置优化。默认值为 production 。</p><h3 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h3><p>entry 指示 webpack 应该使用哪个模块来开始构建其内部依赖关系图。 webpack 将找出 entry 所依赖的其他模块和库（直接和间接）。</p><p>默认情况下，其值为 <code>./src/index.js</code>，但可以通过在 webpack 配置中设置 entry 属性来指定不同的（或多个入口点）。例如：</p><figure class="highlight js"><figcaption><span>webpack.config.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./path/to/my/entry/file.js&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>output 属性告诉 webpack 在何处导出它创建的包以及如何命名这些文件。对于主输出文件，默认为 <code>./dist/main.js</code> ，对于任何其他生成的文件，默认为<code>./dist</code> 文件夹。</p><p>可以通过在配置中指定输出字段来配置流程的这一部分：</p><figure class="highlight js"><figcaption><span>webpack.config.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./path/to/my/entry/file.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;my-first-webpack.bundle.js&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Module-Loaders"><a href="#Module-Loaders" class="headerlink" title="Module Loaders"></a>Module Loaders</h3><p>默认情况下， webpack 只理解 JavaScript 和 JSON 文件。Loaders 允许 webpack 处理其他类型的文件，并将它们转换为有效的模块，这些模块可以被应用程序使用并添加到依赖关系图中。  </p><p>Loaders 是按照规则（rules）进行的，module 的 rules 是一个数组，其中每个 rule 在配置中有两个重要属性，test 属性标识应转换的文件，use 属性指示应该使用哪个加载程序进行转换。  </p><p>Loaders可以是链式的，在链中的每个loader都会按照反向的顺序被执行。  </p><figure class="highlight js"><figcaption><span>webpack.config.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;my-first-webpack.bundle.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>常用 loaders :</p><table><thead><tr><th>loader名字</th><th>作用</th><th>文件扩展名</th></tr></thead><tbody><tr><td>style-loader</td><td>将 CSS 注入 DOM</td><td>.css</td></tr><tr><td>css-loader</td><td>css-loader 将会像 <code>import/require()</code> 那样解析 <code>@import</code> 和 <code>url()</code></td><td>.css</td></tr><tr><td>postcss-loader</td><td>用于对css文件进行预处理，比如添加前缀</td><td>.css</td></tr><tr><td>file-loader</td><td>file-loader 将文件的 <code>import/require()</code> 解析为 url，并将文件发送到输出目录，在 webpack5 中使用自带的 asset/resource 来代替</td><td>.png .jpg .jpeg .gif</td></tr><tr><td>url-loader</td><td>将文件转换为 base64 url ，在 webpack5 中使用自带的 asset/resource 来代替</td><td>.png .jpg .gif</td></tr><tr><td>raw-loader</td><td>允许导入文件作为字符串，在 webpack5 中使用自带的 asset/resource 来代替</td><td>.txt</td></tr><tr><td>csv-loader</td><td>允许导入csv文件作为字符串</td><td>.csv</td></tr><tr><td>xml-loader</td><td>允许导入xml文件作为字符串</td><td>.xml</td></tr><tr><td>less-loader</td><td>将 less 文件编译为 css</td><td>.less</td></tr><tr><td>sass-loader</td><td>将 sass 文件编译为 css</td><td>.sass</td></tr><tr><td>stylus-loader</td><td>将 styl 文件编译为 css</td><td>.styl</td></tr><tr><td>markdown-loader</td><td>将 md 文件编译为 html</td><td>.md</td></tr><tr><td>babel-loader</td><td>用于对js文件进行预处理，例如将js文件中的语法进行兼容</td><td>.js</td></tr><tr><td>ts-loader</td><td>将ts文件编译为js</td><td>.ts tsx</td></tr><tr><td>html-loader</td><td>将html文档以字符串形式导出</td><td>.html</td></tr></tbody></table><h3 id="Resolve"><a href="#Resolve" class="headerlink" title="Resolve"></a>Resolve</h3><p>Resolve 决定了当导入一个模块时，模块应当如何被解析，最常用的用法是定义 import 模块的别名。</p><figure class="highlight js"><figcaption><span>webpack.config.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="comment">// 解析模块请求的选项</span></span><br><span class="line">    <span class="attr">modules</span>: [</span><br><span class="line">      <span class="string">&quot;node_modules&quot;</span>,</span><br><span class="line">      path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;app&quot;</span>)</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 用于查找模块的目录</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">extensions</span>: [<span class="string">&quot;.js&quot;</span>, <span class="string">&quot;.json&quot;</span>, <span class="string">&quot;.jsx&quot;</span>, <span class="string">&quot;.css&quot;</span>],</span><br><span class="line">    <span class="comment">// 使用的扩展名</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">alias</span>: &#123;</span><br><span class="line">      <span class="comment">// 模块别名列表</span></span><br><span class="line"></span><br><span class="line">      <span class="string">&quot;module&quot;</span>: <span class="string">&quot;new-module&quot;</span>,</span><br><span class="line">      <span class="comment">// 起别名：&quot;module&quot; -&gt; &quot;new-module&quot; 和 &quot;module/path/file&quot; -&gt; &quot;new-module/path/file&quot;</span></span><br><span class="line"></span><br><span class="line">      <span class="string">&quot;only-module$&quot;</span>: <span class="string">&quot;new-module&quot;</span>,</span><br><span class="line">      <span class="comment">// 起别名 &quot;only-module&quot; -&gt; &quot;new-module&quot;，但不匹配 &quot;only-module/path/file&quot; -&gt; &quot;new-module/path/file&quot;</span></span><br><span class="line"></span><br><span class="line">      <span class="string">&quot;module&quot;</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;app/third/module.js&quot;</span>),</span><br><span class="line">      <span class="comment">// 起别名 &quot;module&quot; -&gt; &quot;./app/third/module.js&quot; 和 &quot;module/file&quot; 会导致错误</span></span><br><span class="line">      <span class="comment">// 模块别名相对于当前上下文导入</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h3><p>Loaders 用于转换某些类型的模块，但可以利用 plugins 执行更广泛的任务，如包优化、资源管理和环境变量的注入。<br>为了使用 plugin ，你需要先引入它并将其添加到配置文件的 plugins 数组中。大多数插件都可以通过选项进行定制。由于可以在配置中多次使用插件以实现不同的目的，因此需要通过使用 New 操作符调用插件来创建插件的实例。</p><figure class="highlight js"><figcaption><span>webpack.config.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>); <span class="comment">// 通过 npm 引入的 plugin</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>); <span class="comment">// 使用 webpack 自带的 plugin</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.txt$/</span>, <span class="attr">use</span>: <span class="string">&#x27;raw-loader&#x27;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123; <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span> &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">DefinePlugin</span>(&#123;</span><br><span class="line">        <span class="string">&#x27;process.env.NODE_ENV&#x27;</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(process.<span class="property">env</span>.<span class="property">NODE_ENV</span>),</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>常用 plugins :</p><table><thead><tr><th>plugin 名字</th><th>作用</th><th>包</th></tr></thead><tbody><tr><td>webpack.BannerPlugin</td><td>在每个生成的块的顶部添加一些信息，比如版权信息</td></tr><tr><td>CleanWebpackPlugin</td><td>编译前自动清除输出目录</td><td>clean-webpack-plugin</td></tr><tr><td>webpack.optimize.CommonsChunkPlugin</td><td>提取块之间共享的公共模块</td></tr><tr><td>CompressionWebpackPlugin</td><td>准备资源的压缩版本，为其提供内容编码</td><td>compression-webpack-plugin</td></tr><tr><td>webpack.ContextReplacementPlugin</td><td>重写require表达式的推断上下文</td></tr><tr><td>CopyWebpackPlugin</td><td>将单个文件或整个目录复制到生成目录</td><td>copy-webpack-plugin</td></tr><tr><td>webpack.DefinePlugin</td><td>允许在编译时配置全局常量</td></tr><tr><td>webpack.DllPlugin</td><td>拆分捆绑包以显著缩短构建时间</td></tr><tr><td>webpack.EnvironmentPlugin</td><td>使用 DefinePlugin 的 process.env 更便捷的方法</td></tr><tr><td>EslintWebpackPlugin</td><td>ESLint 的 webpack插件</td><td>eslint-webpack-plugin</td></tr><tr><td>webpack.HotModuleReplacementPlugin</td><td>允许热替换(HMR)</td></tr><tr><td>HtmlWebpackPlugin</td><td>为包创建HTML</td><td>html-webpack-plugin</td></tr><tr><td>webpack.IgnorePlugin</td><td>从包中排除某些模块</td></tr><tr><td>webpack.optimize.LimitChunkCountPlugin</td><td>设置分块的最小/最大限制以更好地控制分块</td></tr><tr><td>webpack.optimize.MinChunkSizePlugin</td><td>保持块大小高于指定的限制</td></tr><tr><td>MiniCssExtractPlugin</td><td>为每个需要CSS的JS文件创建一个CSS文件</td><td>mini-css-extract-plugin</td></tr><tr><td>webpack.NoEmitOnErrorsPlugin</td><td>出现编译错误时不再抛出</td></tr><tr><td>webpack.NormalModuleReplacementPlugin</td><td>替换与 regexp 匹配的资源</td></tr><tr><td>NpmInstallWebpackPlugin</td><td>开发时自动安装缺失的依赖</td><td>npm-install-webpack-plugin</td></tr><tr><td>OccurrenceOrderPlugin</td><td>通过模块调用次数给模块分配ids，常用的ids就会分配更短的id，使ids可预测，减小文件大小</td></tr><tr><td>webpack.ProgressPlugin</td><td>汇报编译进度</td><td></td></tr><tr><td>webpack.ProvidePlugin</td><td>使用模块而不必使用import/require</td></tr><tr><td>webpack.SourceMapDevToolPlugin</td><td>支持对源映射进行更细粒度的控制</td></tr><tr><td>webpack.EvalSourceMapDevToolPlugin</td><td>支持对eval源映射进行更细粒度的控制</td></tr><tr><td>TerserPlugin</td><td>使用 Terser 压缩混淆项目中的JS</td><td>terser-webpack-plugin</td></tr><tr><td>UglifyJsPlugin</td><td>js压缩插件</td><td>uglifyjs-webpack-plugin</td></tr><tr><td>WebpackBarPlugin</td><td>优化webpack加载命令行界面为进度条格式</td><td>progress-bar-webpack-plugin</td></tr></tbody></table><h3 id="DevServer"><a href="#DevServer" class="headerlink" title="DevServer"></a>DevServer</h3><p>DevServer 用来配置和 webpack-dev-server 相关的选项。</p><h3 id="Externals"><a href="#Externals" class="headerlink" title="Externals"></a>Externals</h3><p>Externals 用来防止将某些 import 的包打包到 bundle 中，而是在运行时再去从外部获取这些扩展依赖。</p><h2 id="webpack安装"><a href="#webpack安装" class="headerlink" title="webpack安装"></a>webpack安装</h2><p>使用npm/yarn安装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">yarn add webpack --dev</span><br><span class="line"><span class="comment">// webpack4以上的版本需要同时安装webpack-cli</span></span><br><span class="line">npm install --save-dev webpack-cli</span><br></pre></td></tr></table></figure><p>添加 build 脚本到 package.json 中</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack --config webpack.config.js&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="配合使用的npm包"><a href="#配合使用的npm包" class="headerlink" title="配合使用的npm包"></a>配合使用的npm包</h2><p>webpack webpack包<br>webpack-cli webpack工具包，从webpack4开始需要安装该包<br>webpack-bundle-analyzer webpack打包文件分析工具<br>webpack-dev-server webpack开发服务器<br>webpack-merge webpack配置文件合并工具，可以将两个配置文件合并为一个</p><h2 id="哪些方法可以缩减webpack编译时间"><a href="#哪些方法可以缩减webpack编译时间" class="headerlink" title="哪些方法可以缩减webpack编译时间?"></a>哪些方法可以缩减webpack编译时间?</h2><p>详见 <a href="https://webpack.js.org/guides/build-performance/">build performance</a><br>以下提供了一些常见的方法</p><ol><li>将加载程序应用到所需的最小模块数 <code>module.rules[n].include</code></li><li>每个额外的加载程序/插件都有一个启动时间。尽量少用工具。</li><li>使用 DllPlugin 将更改较少的代码移动到单独的编译中</li><li>开发时在内存中编译 使用 <code>webpack-dev-server</code></li><li>了解 devtool 选项的区别，大部分情况下使用 <code>eval-cheap-module-source-map</code></li><li>开发时避免使用生产环境工具 例如 [contenthash]、TerserPlugin、AggressiveSplittingPlugin</li><li>勿使用 Node.js 8.9.10-9.11.1版本，这些版本的 Map Set 实现有<a href="https://github.com/nodejs/node/issues/19769">性能问题</a></li><li>使用多线程编译 parallel-webpack &amp; cache-loader</li></ol><p>##　webpack编译流程</p><ol><li>初始化参数: 从配置文件 webpack.config.js 和 cli args 参数中读取参数 options 并进行合并</li><li>开始编译: 根据输入参数初始化 Compiler 对象，加载配置的插件 plugin，调用插件的的 apply 方法，执行 Compiler 对象的 run 方法开始执行编译(实例化 Compilation 对象)</li><li>确认入口: 根据配置中的 entry 找出所有的入口文件</li><li>编译模块: 从入口文件开始解析，调用配置的 loader 对不同类型的模块进行载入，递归这个过程直到所有的入口文件都经过处理，得到所有模块的依赖关系 Module Chain</li><li>输出资源: 根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 chunk, 每个 chunk 生成一个资源列表 chunk assets, 之后会把多个 chunk 合并转换成单独的文件 bundle 加入到输出列表</li><li>输出完成: 根据 output 配置确定输出的路径和文件名，把文件内容写入到文件系统中</li></ol><h2 id="loader-和-plugin-的区别"><a href="#loader-和-plugin-的区别" class="headerlink" title="loader 和 plugin 的区别"></a>loader 和 plugin 的区别</h2><ol><li>loader 是资源加载器，通过链式调用，loader 赋予了 webpack 加载不同类型资源的能力，例如解析 Less文件、解析图片资源等。</li><li>plugin 是插件，通过在 webpack 编译过程中预先设置钩子函数，plugin 可以在 webpack 编译过程中实现各种各样的功能，例如打包优化、资源管理、环境变量注入等。</li></ol><h2 id="webpack-生命周期"><a href="#webpack-生命周期" class="headerlink" title="webpack 生命周期"></a>webpack 生命周期</h2><ol><li>environment</li><li>afterEnvironment</li><li>entryOption</li><li>afterPlugins</li><li>afterResolvers</li><li>initalize</li><li>beforeRun</li><li>run</li><li>normalModuleFactory</li><li>contextModuleFactory</li><li>beforeComlile</li><li>compile</li><li>thisCompilation</li><li>compilation</li><li>make</li><li>finishMake</li><li>afterCompile</li><li>shouldEmit</li><li>emit</li><li>afterEmit</li><li>done</li><li>afterDone</li></ol><h2 id="如何编写一个loader"><a href="#如何编写一个loader" class="headerlink" title="如何编写一个loader"></a>如何编写一个loader</h2><p>loader 是导出为一个函数的 node 模块。该函数在 loader 转换资源的时候调用。给定的函数将调用 Loader API，并通过 this 上下文访问。</p><ol><li>一个 loader 只能传入一个参数,一个包含资源文件内容的字符串。</li><li>loader 会返回一个或者两个值,第一个值的类型是 string 或者 Buffer 类型的数据,第二个可选值是 SourceMap。</li><li>如果是单个处理结果，可以在 <em>同步模式</em> 中直接 <code>return</code>。如果有多个处理结果，则必须调用 <code>this.callback()</code>。</li><li>在 <em>异步模式</em> 中，必须调用 <code>this.async()</code> 来告知 loader runner 等待异步结果，它会返回 <code>callback</code> 回调函数。随后 loader 必须返回 undefined 并且调用该回调函数。</li><li>loader 可以提供 pitch 方法来在 pitching 阶段执行一些操作，在 pitch 方法中返回数据可以跳过之后的 loader。</li><li>loader 函数中的 this 可以访问 loader 上下文中的方法和属性</li></ol><figure class="highlight js"><figcaption><span>loader.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params">source</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> callback = <span class="variable language_">this</span>.<span class="title function_">async</span>();</span><br><span class="line">  <span class="keyword">var</span> headerPath = path.<span class="title function_">resolve</span>(<span class="string">&#x27;header.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">addDependency</span>(headerPath);</span><br><span class="line"></span><br><span class="line">  fs.<span class="title function_">readFile</span>(headerPath, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, header</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="title function_">callback</span>(err);</span><br><span class="line">    <span class="title function_">callback</span>(<span class="literal">null</span>, header + <span class="string">&#x27;\n&#x27;</span> + source);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何自定义plugin"><a href="#如何自定义plugin" class="headerlink" title="如何自定义plugin"></a>如何自定义plugin</h2><p>plugin 向第三方开发者提供了 webpack 引擎中完整的能力。使用阶段式的构建回调，开发者可以在 webpack 构建流程中引入自定义的行为。</p><p>webpack 插件由以下组成：</p><ol><li>一个 JavaScript 命名函数或 JavaScript 类。</li><li>在插件函数的 prototype 上定义一个 apply 方法。</li><li>指定一个绑定到 webpack 自身的事件钩子。</li><li>处理 webpack 内部实例的特定数据。</li><li>功能完成后调用 webpack 提供的回调。</li></ol><figure class="highlight js"><figcaption><span>MyExampleWebpackPlugin.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个 JavaScript 类</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">MyExampleWebpackPlugin</span> &#123;</span><br><span class="line">  <span class="comment">// 在插件函数的 prototype 上定义一个 `apply` 方法，以 compiler 为参数。</span></span><br><span class="line">  <span class="title function_">apply</span>(<span class="params">compiler</span>) &#123;</span><br><span class="line">    <span class="comment">// 指定一个挂载到 webpack 自身的事件钩子。</span></span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">emit</span>.<span class="title function_">tapAsync</span>(</span><br><span class="line">      <span class="string">&#x27;MyExampleWebpackPlugin&#x27;</span>,</span><br><span class="line">      <span class="function">(<span class="params">compilation, callback</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;这是一个示例插件！&#x27;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">          <span class="string">&#x27;这里表示了资源的单次构建的 `compilation` 对象：&#x27;</span>,</span><br><span class="line">          compilation</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用 webpack 提供的插件 API 处理构建过程</span></span><br><span class="line">        compilation.<span class="title function_">addModule</span>(<span class="comment">/* ... */</span>);</span><br><span class="line"></span><br><span class="line">        <span class="title function_">callback</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="webpack-Tree-shaking原理"><a href="#webpack-Tree-shaking原理" class="headerlink" title="webpack Tree-shaking原理"></a>webpack Tree-shaking原理</h2><ol><li>Tree-shaking 是一种通过清除多余代码的方式来优化项目打包体积的技术。</li><li>Tree-shaking 利用了 ES6 模块的特点，ES6 的模块加载是静态的，因此整个依赖树可以在编译时被静态的推导出解析语法树（AST），从而在编译时删除未使用的部分</li><li>webpack2 开始就已经支持 Tree-shaking 的特性，webpack4 中 mode 设置为 production 时默认开启 Tree-shaking</li><li>确保没有把 compiler 将 ES6 模块语法转换为 CommonJS 模块。这一块很重要，在你使用 babel-loader 或者 ts-loader 编译代码时，一定要保留 import 和 export。</li><li>如果打包的代码有副作用（Side Effects），并且需要导出，可以通过 package.json 的 sideEffect 属性来声明</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> tool </tag>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6特性</title>
      <link href="/blog/2020/08/28/JS-ES6%E7%89%B9%E6%80%A7/"/>
      <url>/blog/2020/08/28/JS-ES6%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>ES6 是 ECMA 为 JavaScript 制定的第 6 个版本的标准，标准委员会 <a href="https://tc39.es/">TC39</a> 最终决定，标准在每年的 6 月份正式发布一次，作为当年的正式版本。ECMAscript 2015 是在2015年6月份发布的ES6的第一个版本。依次类推 ECMAscript 2016 是 ES6 的第二个版本、 ECMAscript 2017 是 ES6 的第三个版本。<a href="https://kangax.github.io/compat-table/es6/">查看浏览器对ES6的语法支持情况</a>。以下记录了 ES6 的比较常见的特性，并做了简单的解释，默认为 ES2015 引入（finished）的，如果不是则在后面用（）标志引入的版本。也可以<a href="https://github.com/tc39/proposals/blob/master/finished-proposals.md">从这里查看从哪个版本支持</a>。</p><span id="more"></span><h2 id="语句-amp-声明-amp-表达式-amp-运算符"><a href="#语句-amp-声明-amp-表达式-amp-运算符" class="headerlink" title="语句 &amp; 声明 &amp; 表达式 &amp; 运算符"></a>语句 &amp; 声明 &amp; 表达式 &amp; 运算符</h2><ol><li>let 和 const 变量声明<br>let const 声明的变量具有块级作用域，不会变量提升，不能重复声明。<br>const 声明常量，声明时必须立即初始化。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> y = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>变量的解构赋值<br>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>globalThis 对象<br>引入globalThis作为顶层对象。也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。(ES2020)</p></li><li><p>for…of 循环表达式<br>for…of语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。</p></li><li><p>new.target<br>new.target属性允许你检测函数或构造函数是否是通过new运算符被调用的。在通过new运算符被初始化的函数或构造函数中，new.target返回一个指向构造函数或函数的引用。在普通的函数调用中，new.target 的值是undefined。</p></li><li><p>… spread扩展操作符<br>扩展运算符 … 将一个数组或arguments或对象的可遍历属性（ES2018）转为用逗号分隔的参数序列。</p></li><li><p>Hashbang<br>Unix命令脚本都支持 <code>#!</code> 命令，又称为 Hashbang，这个命令放在脚本文件或者模块文件的第一行，用来指定脚本的执行器。（ES2023）</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ol><li>支持 Unicode 表示，允许采用 \uxxxx 形式表示一个字符</li><li>行分隔符（U + 2028）和段分隔符（U + 2029）符号现在允许在字符串文字中，与JSON匹配 （ES2019）</li><li>为字符串添加了遍历器接口，支持使用for…of循环遍历字符串</li><li>模板字符串，可以使用反引号 ``来拼接多行字符串，将变量名写在 ${} 中</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#result&#x27;</span>).<span class="title function_">append</span>(<span class="string">`</span></span><br><span class="line"><span class="string">  There are &lt;b&gt;<span class="subst">$&#123;basket.count&#125;</span>&lt;/b&gt; items</span></span><br><span class="line"><span class="string">   in your basket, &lt;em&gt;<span class="subst">$&#123;basket.onSale&#125;</span>&lt;/em&gt;</span></span><br><span class="line"><span class="string">  are on sale!</span></span><br><span class="line"><span class="string">`</span>);</span><br></pre></td></tr></table></figure><ol start="5"><li>标签模板<br>模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。标签模板可以用来过滤 HTML 字符串，防止用户输入恶意内容，也可以用来解决多语言转换的问题（i18n）。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b &#125;</span>`</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="title function_">tag</span>([<span class="string">&#x27;Hello &#x27;</span>, <span class="string">&#x27; world &#x27;</span>, <span class="string">&#x27;&#x27;</span>], <span class="number">15</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><ol start="6"><li>新添加的字符串方法及实例方法</li></ol><table><thead><tr><th>方法</th><th>作用</th><th>例子</th></tr></thead><tbody><tr><td>String.raw()</td><td>String.raw() 是一个模板字符串的标签函数，是用来获取一个模板字符串的原始字符串的，占位符（例如 ${foo}）会被处理为它所代表的其他字符串，而转义字符（例如 \n）不会。</td><td><code>String.raw(&#39;Hi\n$&#123;2+3&#125;!&#39;) ===  &#39;Hi\\n5!&#39;</code></td></tr><tr><td>String.fromCodePoint()</td><td>返回使用指定的代码点序列创建的字符串</td><td><code>String.fromCodePoint(0x1D306, 0x61, 0x1D307) === &quot;\uD834\uDF06a\uD834\uDF07&quot;</code></td></tr><tr><td>String.prototype.codePointAt()</td><td>返回一个 Unicode 编码点值的非负整数</td><td><code>&#39;d&#39;.codePointAt() === 100</code></td></tr><tr><td>String.prototype.startsWith()</td><td>用来判断当前字符串是否以另外一个给定的子字符串开头，并根据判断结果返回 true 或 false。</td><td><code>&#39;i love u&#39;.startsWith(&#39;i lo&#39;)</code></td></tr><tr><td>String.prototype.endsWith()</td><td>用来判断当前字符串是否是以另外一个给定的子字符串“结尾”的，根据判断结果返回 true 或 false。</td><td><code>&#39;i love u&#39;.endsWith(&#39;e u&#39;)</code></td></tr><tr><td>String.prototype.repeat()</td><td>构造并返回一个新字符串，该字符串包含被连接在一起的指定数量的字符串的副本。</td><td><code>&#39;isee &#39;.repeat(3) === &#39;isee isee isee &#39;</code></td></tr><tr><td>String.prototype.normalize()</td><td>按照指定的一种 Unicode 正规形式将当前字符串正规化。（如果该值不是字符串，则首先将其转换为一个字符串）。</td><td><code>&#39;\u00F1&#39;.normalize() === &#39;\u006E\u0303&#39;.normalize()</code></td></tr><tr><td>String.prototype.includes()</td><td>用于判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false。</td><td><code>&#39;To be, or not to be, that is the question.&#39;.includes(&#39;To be&#39;)</code></td></tr><tr><td>String.prototype.padStart()</td><td>用另一个字符串填充当前字符串(如果需要的话，会重复多次)，以便产生的字符串达到给定的长度。从当前字符串的左侧开始填充。(ES2017)</td><td><code>&#39;abc&#39;.padStart(10, &quot;foo&quot;) === &#39;foofoofabc&#39;</code></td></tr><tr><td>String.prototype.padEnd()</td><td>用一个字符串填充当前字符串（如果需要的话则重复填充），返回填充后达到指定长度的字符串。从当前字符串的末尾（右侧）开始填充。(ES2017)</td><td><code>&#39;abc&#39;.padEnd(10, &#39;foo&#39;) === &#39;abcfoofoof&#39;</code></td></tr><tr><td>String.prototype.trimStart()</td><td>从字符串的开头删除空格。trimLeft() 是此方法的别名。(ES2019)</td><td><code>&#39;   Hello world!   &#39;.trimStart() === &#39;Hello world!   &#39;</code></td></tr><tr><td>String.prototype.trimEnd()</td><td>从一个字符串的末端移除空白字符。trimRight() 是这个方法的别名。(ES2019)</td><td><code>&#39;   Hello world!   &#39;.trimStart() === &#39;   Hello world!&#39;</code></td></tr><tr><td>String.prototype.matchAll()</td><td>返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器。(ES2020)</td><td><code>&#39;test1test2&#39;.matchAll(/t(e)(st(\d?))/g)</code></td></tr><tr><td>String.prototype.replaceAll()</td><td>被用来在正则表达式和字符串直接比较，然后用新的子串来替换所有被匹配的子串。（ES2021）</td></tr></tbody></table><ol start="7"><li>JSON.stringify 行为改变   (ES2019)<br>如果遇到0xD800到0xDFFF之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。</li></ol><h2 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h2><ol><li>从 ES2015 开始，当第一个参数为正则表达式而第二个标志参数存在时，不再抛错</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="regexp">/xyz/</span>, <span class="string">&#x27;i&#x27;</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。ES6 将这 4 个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。</li></ol><p>String.prototype.match 调用 RegExp.prototype[Symbol.match]<br>String.prototype.replace 调用 RegExp.prototype[Symbol.replace]<br>String.prototype.search 调用 RegExp.prototype[Symbol.search]<br>String.prototype.split 调用 RegExp.prototype[Symbol.split]</p><ol start="3"><li>新添加了实例属性与对应的修饰符</li></ol><table><thead><tr><th>实例属性</th><th>修饰符</th><th>含义</th></tr></thead><tbody><tr><td>RegExp.prototype.unicode</td><td>u</td><td>用来正确处理大于\uFFFF的 Unicode 字符(ES2018)</td></tr><tr><td>RegExp.prototype.sticky</td><td>y</td><td>反映了搜索是否具有粘性（ 仅从正则表达式的 lastIndex 属性表示的索引处搜索 ）</td></tr><tr><td>RegExp.prototype.flags</td><td></td><td>返回一个字符串，由当前正则表达式对象的标志组成。</td></tr><tr><td>RegExp.prototype.dotAll</td><td>s</td><td>使得.可以匹配任意单个字符(ES2018)</td></tr></tbody></table><ol start="4"><li>支持后行断言 (ES2018)</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先行断言 先行否定断言</span></span><br><span class="line">/\d+(?=%)/.<span class="title function_">exec</span>(<span class="string">&#x27;100% of US presidents have been male&#x27;</span>)  <span class="comment">// [&quot;100&quot;]</span></span><br><span class="line">/\d+(?!%)/.<span class="title function_">exec</span>(<span class="string">&#x27;that’s all 44 of them&#x27;</span>)                 <span class="comment">// [&quot;44&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//后行断言 后行否定断言</span></span><br><span class="line">/(?&lt;=\$)\d+<span class="regexp">/.exec(&#x27;Benjamin Franklin is on the $100 bill&#x27;)  /</span><span class="regexp">/ [&quot;100&quot;]</span></span><br><span class="line"><span class="regexp">/</span>(?&lt;!\$)\d+<span class="regexp">/.exec(&#x27;it’s is worth about €90&#x27;)                /</span><span class="regexp">/ [&quot;90&quot;]</span></span><br></pre></td></tr></table></figure><ol start="5"><li>Unicode 属性类 \P \p (ES2018)<br>引入了一种新的类的写法\p{…}和\P{…}，允许正则表达式匹配符合 Unicode 某种属性的所有字符。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> regexGreekSymbol = <span class="regexp">/\p&#123;Script=Greek&#125;/u</span>; <span class="comment">// \p&#123;Script=Greek&#125;指定匹配一个希腊文字母</span></span><br><span class="line">regexGreekSymbol.<span class="title function_">test</span>(<span class="string">&#x27;π&#x27;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ol start="6"><li>具名组匹配 &amp; 具名组匹配的引用 (ES2018)<br>正则表达式可以使用圆括号进行组匹配</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">RE_DATE</span> = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matchObj = <span class="variable constant_">RE_DATE</span>.<span class="title function_">exec</span>(<span class="string">&#x27;1999-12-31&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> year = matchObj.<span class="property">groups</span>.<span class="property">year</span>; <span class="comment">// 1999</span></span><br><span class="line"><span class="keyword">const</span> month = matchObj.<span class="property">groups</span>.<span class="property">month</span>; <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">const</span> day = matchObj.<span class="property">groups</span>.<span class="property">day</span>; <span class="comment">// 31</span></span><br></pre></td></tr></table></figure><p>如果要在正则表达式内部引用某个“具名组匹配”，可以使用 <code>\k&lt;组名&gt;</code> 的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">RE_TWICE</span> = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;$/</span>;</span><br><span class="line"><span class="variable constant_">RE_TWICE</span>.<span class="title function_">test</span>(<span class="string">&#x27;abc!abc&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable constant_">RE_TWICE</span>.<span class="title function_">test</span>(<span class="string">&#x27;abc!ab&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h2><ol><li>数值二进制和八进制表示法<br>分别用前缀0b（或0B）和0o（或0O）表示。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0b111110111</span> === <span class="number">503</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0o767</span> === <span class="number">503</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ol start="2"><li>方法 Number.isFinite(), Number.isNaN()<br>与全局方法isFinite()和isNaN()相比，这两个新方法只对数值有效，非数值返回 false</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isFinite</span>(<span class="number">25</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="string">&quot;25&quot;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isFinite</span>(<span class="number">25</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isFinite</span>(<span class="string">&quot;25&quot;</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="title class_">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;NaN&quot;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="title class_">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&quot;NaN&quot;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="number">1</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>Number.parseInt(), Number.parseFloat()<br>与全局方法 parseInt() 和 parseFloat() 相同</p></li><li><p>Number.isInteger()<br>用来判断一个数值是否为整数</p></li><li><p>Number.EPSILON 属性<br>常量，表示 1 与大于 1 的最小浮点数之间的差</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="property">EPSILON</span> === <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, -<span class="number">52</span>)</span><br></pre></td></tr></table></figure><ol start="6"><li>Number.MAX_SAFE_INTEGER 与 Number.MIN_SAFE_INTEGER，Number.isSafeInteger()<br>Number.MAX_SAFE_INTEGER 和 Number.MIN_SAFE_INTEGER这两个常量，用来表示JavaScript能够准确表示的整数范围的上下限。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span> === <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="property">MIN_SAFE_INTEGER</span> === -<span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。</p><ol start="7"><li>Math 对象的新方法（17个）</li></ol><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>Math.trunc(x)</td><td>返回一个数的整数部分，直接去除其小数点及之后的部分。</td></tr><tr><td>Math.sign(x)</td><td>返回一个数的符号，得知一个数是正数、负数还是 0。</td></tr><tr><td>Math.cbrt(x)</td><td>返回一个数的立方根。</td></tr><tr><td>Math.clz32(x)</td><td>返回一个 32 位整数的前导零的数量。</td></tr><tr><td>Math.imul(x, y)</td><td>返回 32 位整数乘法的结果。</td></tr><tr><td>Math.fround(x)</td><td>返回最接近一个数的单精度浮点型表示。</td></tr><tr><td>Math.imul(x, y)</td><td>返回 32 位整数乘法的结果。</td></tr><tr><td>Math.hypot([x[, y[, …]]])</td><td>返回其所有参数平方和的平方根。</td></tr><tr><td>Math.expm1(x)</td><td>返回 exp(x) - 1 的值。</td></tr><tr><td>Math.log1p(x)</td><td>返回一个数加 1 的和的自然对数（㏒e，即 ㏑）。</td></tr><tr><td>Math.log10(x)</td><td>返回一个数以 10 为底数的对数。</td></tr><tr><td>Math.log2(x)</td><td>返回一个数以 2 为底数的对数。</td></tr><tr><td>Math.sinh(x)</td><td>返回x的双曲正弦</td></tr><tr><td>Math.cosh(x)</td><td>返回x的双曲余弦</td></tr><tr><td>Math.tanh(x)</td><td>返回x的双曲正切</td></tr><tr><td>Math.asinh(x)</td><td>返回x的反双曲正弦</td></tr><tr><td>Math.acosh(x)</td><td>返回x的反双曲余弦</td></tr><tr><td>Math.atanh(x)</td><td>返回x的反双曲正切</td></tr></tbody></table><ol start="8"><li>指数运算符 **(ES2016)<br>右结合的指数运算符</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">2</span> === <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">2</span> ** <span class="number">3</span> ** <span class="number">2</span> === <span class="number">2</span> ** (<span class="number">3</span> ** <span class="number">2</span>)</span><br></pre></td></tr></table></figure><ol start="9"><li><p>BitInt 数据类型 (ES2020)<br>BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示</p></li><li><p>_ 数字分隔符 （ES2021）<br>可以使用下划线来分割数字，下划线没有实际的意义数字的值不会变化，更具有可读性</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1_000_000_000</span> === <span class="number">1000000000</span>;</span><br><span class="line"><span class="number">101_475_938.38</span> === <span class="number">101475938.38</span>;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ol><li>函数参数的默认值</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Point</span>(<span class="params">x = <span class="number">0</span>, y = <span class="number">0</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Point</span>();</span><br><span class="line">p <span class="comment">// &#123; x: 0, y: 0 &#125;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>rest 参数<br>允许将一个不定数量的参数表示为一个数组</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">...values</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式</p></li><li><p>函数 Function.name 属性，返回该函数的函数名</p></li><li><p>箭头函数<br>(1) 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。<br>(2) 不可以当作构造函数<br>(3) 不可以使用arguments对象<br>(4) 不可以使用yield命令</p></li><li><p>尾递归调用优化</p></li><li><p>允许函数的最后一个参数有尾逗号 (ES2017)</p></li><li><p>Function.prototype.toString() 将会包含注释空格 (ES2019)</p></li><li><p>catch 命令的参数可省略 (ES2019)</p></li></ol><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol><li>扩展运算符 … 将一个数组转为用逗号分隔的参数序列</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure><ol start="2"><li>Array.from() 方法 类似数组的对象（array-like object）和可遍历（iterable）的对象 转换为数组</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NodeList对象</span></span><br><span class="line"><span class="keyword">let</span> ps = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(ps).<span class="title function_">filter</span>(<span class="function"><span class="params">p</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> p.<span class="property">textContent</span>.<span class="property">length</span> &gt; <span class="number">100</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="comment">// [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set 对象</span></span><br><span class="line"><span class="keyword">let</span> namesSet = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(namesSet) <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;]</span></span><br></pre></td></tr></table></figure><ol start="3"><li>Array.of() 将一组值，转换为数组</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>) <span class="comment">// [3]</span></span><br></pre></td></tr></table></figure><ol start="4"><li><p>数组实例方法 copyWithin() 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度</p></li><li><p>数组实例方法 find() 和 findIndex() 用于找出第一个符合条件的数组成员和位置</p></li><li><p>数组实例方法 fill() 使用给定值，填充一个数组</p></li><li><p>数组实例方法 entries() keys() values() 对健值对、健名、健值进行遍历，返回Interator对象</p></li><li><p>数组实例方法 includes() 返回一个布尔值，表示某个数组是否包含给定的值 (ES2016)</p></li><li><p>数组实例方法 flat() flatMap() 对数组进行扁平化，映射后扁平化 (ES2019)</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]].<span class="title function_">flat</span>()</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><ol start="10"><li><p>Array.prototype.sort() 的默认排序算法稳定 (ES2019)</p></li><li><p>数组实例方法 groupBy() 该方法允许根据指定的键将数组元素分组（ES2022）</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> grouped = arr.<span class="title function_">groupBy</span>(<span class="function">(<span class="params">num</span>) =&gt;</span> num % <span class="number">2</span> === <span class="number">0</span> ? <span class="string">&#x27;even&#x27;</span> : <span class="string">&#x27;odd&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(grouped);</span><br><span class="line"><span class="comment">// 输出：&#123; odd: [1, 3, 5], even: [2, 4, 6] &#125;</span></span><br></pre></td></tr></table></figure><ol start="12"><li><p>数组实例方法 findLast() 和 findLastIndex() 用于从数组的末尾开始遍历找出符合条件的数组成员和位置（ES2023）</p></li><li><p>数组实例方法 toReversed() 返回数组的逆转数组副本（ES2023）</p></li><li><p>数组实例方法 toSorted() 返回数组的排序数组副本（ES2023）</p></li><li><p>数组实例方法 toSpliced() 返回数组的替换（或删除）多个元素后的数组副本（ES2023）</p></li><li><p>数组实例方法 with() 返回数组的替换单个元素后的数组副本（ES2023）</p></li></ol><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ol><li>对象属性的简洁表示法</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> baz = &#123;foo&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> baz = &#123;<span class="attr">foo</span>: foo&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>定义对象时，属性名允许使用表达式</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> propKey = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [propKey]: <span class="literal">true</span>,</span><br><span class="line">  [<span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;bc&#x27;</span>]: <span class="number">123</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>super 关键字 代表对象的原型对象</p></li><li><p>扩展运算符 … 将一个对象的可遍历属性转为用逗号分隔的参数序列（ES2018）</p></li><li><p>可选链操作符 ?. 用于在获取对象属性或调用对象方法时预先判断对象的属性方法是否存在 （ES2020）</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> firstName = (message</span><br><span class="line">  &amp;&amp; message.<span class="property">body</span></span><br><span class="line">  &amp;&amp; message.<span class="property">body</span>.<span class="property">user</span></span><br><span class="line">  &amp;&amp; message.<span class="property">body</span>.<span class="property">user</span>.<span class="property">firstName</span>) || <span class="string">&#x27;default&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">const</span> firstName = message?.<span class="property">body</span>?.<span class="property">user</span>?.<span class="property">firstName</span> || <span class="string">&#x27;default&#x27;</span>;</span><br></pre></td></tr></table></figure><ol start="6"><li>空值合并操作符 ?? 用于对 null 与 undefined的值赋值默认值 （ES2020）</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与逻辑或操作符（||）不同，逻辑或操作符会在左侧操作数为假值时返回右侧操作数。也就是说，如果使用 || 来为某些变量设置默认值，可能会遇到意料之外的行为。比如为假值（例如，&#x27;&#x27; 或 0 或 false）时。</span></span><br><span class="line"><span class="keyword">const</span> showMask = settings.<span class="property">showMask</span> || <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> showMask = settings.<span class="property">showMask</span> ?? <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><ol start="7"><li>对象方法 Object.is() 用于判断两个值是否同值相等<br>与 === 基本一致，有两个例外</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0</span> === -<span class="number">0</span> <span class="comment">//true</span></span><br><span class="line"><span class="title class_">NaN</span> === <span class="title class_">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(+<span class="number">0</span>, -<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, <span class="title class_">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ol start="8"><li><p>对象方法 Object.assign() 用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p></li><li><p>对象方法 Object.getOwnPropertyDescriptors() 用于获取所指定对象的所有自身属性的描述符 （ES2017）</p></li><li><p>对象方法 Object.getPrototypeOf() 与 Object.setPrototypeOf()</p></li></ol><p>在 ES2015中 Object.getPrototypeOf() 的入参如果不是对象将会被转换成对象<br>Object.setPrototypeOf() 用设置一个指定的对象的原型 (即, 内部[[Prototype]]属性）到另一个对象或 null。同样如果入参不是对象将会被转换成对象。</p><ol start="11"><li><p>对象方法 Object.entries() (ES2017) Object.keys() Object.values() (ES2017) 对健值对、健名、健值进行遍历，返回Interator对象</p></li><li><p>对象方法 Object.fromEntries() 用于把键值对列表转换为一个对象。(ES2019)</p></li></ol><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值，一个symbol值能作为对象属性的标识符</p><ol><li><p>Symbol的实例属性 Symbol.prototype.description 返回Symbol 的描述 (ES2019)</p></li><li><p>Symbol方法 Symbol.for()，Symbol.keyFor()<br>Symbol.for(key) 方法会根据给定的键 key，来从运行时的 symbol 注册表中找到对应的 symbol，如果找到了，则返回它，否则，新建一个与该键关联的 symbol，并放入全局 symbol 注册表中。<br>Symbol.keyFor(sym) 方法用来获取 symbol 注册表中与某个 symbol 关联的键。</p></li><li><p>Symbol的属性<br>这些属性存在的意义为，子类可以重载这些属性来改变默认的行为。<br>这些属性都是不可写不可枚举不可配置的。</p></li></ol><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>Symbol.hasInstance</td><td>Symbol.hasInstance用于判断某对象是否为某构造器的实例。因此你可以用它自定义 instanceof 操作符在某个类上的行为。</td></tr><tr><td>Symbol.isConcatSpreadable</td><td>Symbol.isConcatSpreadable用于配置某对象作为Array.prototype.concat()方法的参数时是否展开其数组元素。</td></tr><tr><td>Symbol.species</td><td>Symbol.species 是个函数值属性，其被构造函数用以创建派生对象</td></tr><tr><td>Symbol.match</td><td>Symbol.match 指定了匹配的是正则表达式而不是字符串。String.prototype.match() 方法会调用此函数</td></tr><tr><td>Symbol.replace</td><td>Symbol.replace 这个属性指定了当一个字符串替换所匹配字符串时所调用的方法。String.prototype.replace() 方法会调用此方法。</td></tr><tr><td>Symbol.search</td><td>Symbol.search 指定了一个搜索方法，这个方法接受用户输入的正则表达式，返回该正则表达式在字符串中匹配到的下标，这个方法由以下的方法来调用 String.prototype.search()</td></tr><tr><td>Symbol.split</td><td>Symbol.split 指向 一个正则表达式的索引处分割字符串的方法。 这个方法通过 String.prototype.split() 调用</td></tr><tr><td>Symbol.iterator</td><td>Symbol.iterator 为每一个对象定义了默认的迭代器。该迭代器可以被 for…of 循环使用</td></tr><tr><td>Symbol.toPrimitive</td><td>Symbol.toPrimitive 是一个内置的 Symbol 值，它是作为对象的函数值属性存在的，当一个对象转换为对应的原始值时，会调用此函数。</td></tr><tr><td>Symbol.toStringTag</td><td>Symbol.toStringTag 是一个内置 symbol，它通常作为对象的属性键使用，对应的属性值应该为字符串类型，这个字符串用来表示该对象的自定义类型标签，通常只有内置的 Object.prototype.toString() 方法会去读取这个标签并把它包含在自己的返回值里。</td></tr><tr><td>Symbol.unscopables</td><td>Symbol.unscopables 指用于指定对象值，其对象自身和继承的从关联对象的 with 环境绑定中排除的属性名称。</td></tr><tr><td>Symbol.asyncIterator</td><td>Symbol.asyncIterator 符号指定了一个对象的默认异步迭代器。如果一个对象设置了这个属性，它就是异步可迭代对象，可用于for await…of循环（ES2018）</td></tr></tbody></table><ol start="4"><li>Symbol 可以作为 WeakMap 的键（ES2023）</li></ol><h2 id="Set-amp-Map"><a href="#Set-amp-Map" class="headerlink" title="Set &amp; Map"></a>Set &amp; Map</h2><p>Set对象是值的集合，你可以按照插入的顺序迭代它的元素。 Set中的元素只会出现一次，即 Set 中的元素是唯一的。</p><ol><li><p>Set的实例属性 Set.prototype.size 返回 Set 对象中的值的个数</p></li><li><p>Set的实例方法</p></li></ol><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>Set.prototype.add(value)</td><td>在Set对象尾部添加一个元素。返回该Set对象。</td></tr><tr><td>Set.prototype.delete(value)</td><td>删除某个值，返回一个布尔值，表示删除是否成功。</td></tr><tr><td>Set.prototype.has(value)</td><td>返回一个布尔值，表示该值是否为Set的成员。</td></tr><tr><td>Set.prototype.clear()</td><td>移除Set对象内的所有元素。</td></tr><tr><td>Set.prototype.entries()</td><td>返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值的[value, value]数组。为了使这个方法和Map对象保持相似， 每个值的键和值相等。</td></tr><tr><td>Set.prototype.keys()</td><td>与values()方法相同，返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。</td></tr><tr><td>Set.prototype.values()</td><td>返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。</td></tr><tr><td>Set.prototype.forEach(callbackFn[, thisArg])</td><td>按照插入顺序，为Set对象中的每一个值调用一次callBackFn。如果提供了thisArg参数，回调中的this会是这个参数。</td></tr></tbody></table><p>WeakSet 对象允许你将弱保持对象存储在一个集合中。<br>与Set有两点不同<br>（1）与Set相比，WeakSet 只能是对象的集合，而不能是任何类型的任意值。<br>（2）WeakSet持弱引用：集合中对象的引用为弱引用。 如果没有其他的对WeakSet中对象的引用，那么这些对象会被当成垃圾回收掉。 这也意味着WeakSet中没有存储当前对象的列表。 正因为这样，WeakSet 是不可枚举的。</p><p>Map 对象保存键值对，并且能够记住键的原始插入顺序。任何值(对象或者原始值) 都可以作为一个键或一个值。和Object类似，最大的不同的是Map的key可以是任意值，而Object的key必须是string 或者Symbol。</p><ol><li><p>Map的实例属性 Map.prototype.size 返回 Map 对象中键值对的个数。</p></li><li><p>Map的实例方法</p></li></ol><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>Map.prototype.get(key)</td><td>返回键对应的值，如果不存在，则返回undefined。</td></tr><tr><td>Map.prototype.set(key, value)</td><td>设置Map对象中键的值。返回该Map对象。</td></tr><tr><td>Map.prototype.delete(key)</td><td>如果 Map 对象中存在该元素，则移除它并返回 true；否则如果该元素不存在则返回 false。</td></tr><tr><td>Map.prototype.has(key)</td><td>返回一个布尔值，表示Map实例是否包含键对应的值。</td></tr><tr><td>Map.prototype.clear()</td><td>移除Map对象的所有键/值对</td></tr><tr><td>Map.prototype.entries()</td><td>返回一个新的 Iterator 对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。</td></tr><tr><td>Map.prototype.keys()</td><td>返回一个新的 Iterator对象， 它按插入顺序包含了Map对象中每个元素的键 。</td></tr><tr><td>Map.prototype.values()</td><td>返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的值 。</td></tr><tr><td>Map.prototype.forEach(callbackFn[, thisArg])</td><td>按插入顺序，为 Map对象里的每一键值对调用一次callbackFn函数。如果为forEach提供了thisArg，它将在每次回调中作为this值。</td></tr></tbody></table><p>WeakMap 对象是一组键/值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的。</p><h2 id="Proxy-amp-Reflect"><a href="#Proxy-amp-Reflect" class="headerlink" title="Proxy &amp; Reflect"></a>Proxy &amp; Reflect</h2><p>Proxy 对象用于代理基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）</p><p>用法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure><p>target 要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。<br>handler 一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。</p><p>Reflect 是一个内置反射对象，它提供拦截 JavaScript 操作的方法。这些方法与proxy handlers的方法相同。Reflect不是一个函数对象，因此它是不可构造的。<br>Reflect可以和Proxy配合使用来完成默认行为的基础上定制自定义的行为。</p><p>handler 对象的方法</p><table><thead><tr><th>proxy handler方法</th><th>含义</th><th>Reflect方法</th><th>含义</th></tr></thead><tbody><tr><td>get(target, propKey, receiver)</td><td>拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。</td><td>Reflect.get(target, propKey, receiver)</td><td>获取对象身上某个属性的值，类似于 target[propKey]。</td></tr><tr><td>set(target, propKey, value, receiver)</td><td>拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。</td><td>Reflect.set(target, propKey, value, receiver)</td><td>将值分配给属性的函数。返回一个Boolean，如果更新成功，则返回true。</td></tr><tr><td>has(target, propKey)</td><td>拦截propKey in proxy的操作，返回一个布尔值。</td><td>Reflect.has(target, propKey)</td><td>判断一个对象是否存在某个属性，和 in 运算符 的功能完全相同。</td></tr><tr><td>deleteProperty(target, propKey)</td><td>拦截delete proxy[propKey]的操作，返回一个布尔值。</td><td>Reflect.deleteProperty(target, propKey)</td><td>作为函数的delete操作符，相当于执行 delete target[propKey]。</td></tr><tr><td>ownKeys(target)</td><td>拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。</td><td>Reflect.ownKeys(target)</td><td>返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 Object.keys(), 但不会受enumerable影响).</td></tr><tr><td>getOwnPropertyDescriptor(target, propKey)</td><td>拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</td><td>Reflect.getOwnPropertyDescriptor(target, propKey)</td><td>类似于 Object.getOwnPropertyDescriptor()。如果对象中存在该属性，则返回对应的属性描述符,  否则返回 undefined.</td></tr><tr><td>defineProperty(target, propKey, propDesc)</td><td>拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</td><td>Reflect.defineProperty(target, propKey, propDesc)</td><td>和 Object.defineProperty() 类似。如果设置成功就会返回 true</td></tr><tr><td>preventExtensions(target)</td><td>拦截Object.preventExtensions(proxy)，返回一个布尔值。</td><td>Reflect.preventExtensions(target)</td><td>类似于 Object.preventExtensions()。返回一个Boolean。</td></tr><tr><td>getPrototypeOf(target)</td><td>拦截Object.getPrototypeOf(proxy)，返回一个对象。</td><td>Reflect.getPrototypeOf(target)</td><td>类似于 Object.getPrototypeOf()。</td></tr><tr><td>isExtensible(target)</td><td>拦截Object.isExtensible(proxy)，返回一个布尔值。</td><td>Reflect.isExtensible(target)</td><td>类似于 Object.isExtensible().</td></tr><tr><td>setPrototypeOf(target, proto)</td><td>拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</td><td>Reflect.setPrototypeOf(target, proto)</td><td>设置对象原型的函数. 返回一个 Boolean， 如果更新成功，则返回true。</td></tr><tr><td>apply(target, object, args)</td><td>拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。</td><td>Reflect.apply(target, thisArgument, args)</td><td>对一个函数进行调用操作，同时可以传入一个数组作为调用参数。和 Function.prototype.apply() 功能类似。</td></tr><tr><td>construct(target, args)</td><td>拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。</td><td>Reflect.construct(target, args)</td><td>对构造函数进行 new 操作，相当于执行 new target(…args)。</td></tr></tbody></table><p>Proxy 方法 Proxy.revocable() 创建一个可销毁的代理对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;proxy, revoke&#125; = <span class="title class_">Proxy</span>.<span class="title function_">revocable</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用revoke()可销毁proxy</span></span><br><span class="line"><span class="title function_">revoke</span>()</span><br></pre></td></tr></table></figure><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise 对象用于表示一个异步操作的最终完成 (或失败), 及其结果值.<br>Promise 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象。<br>一个 Promise有以下几种状态:</p><ul><li>pending: 初始状态，既不是成功，也不是失败状态。</li><li>fulfilled: 意味着操作成功完成。</li><li>rejected: 意味着操作失败。</li></ul><ol><li><p>Promise实例方法 Promise.prototype.then() 用来执行resolved状态的回调</p></li><li><p>Promise实例方法 Promise.prototype.catch() 用来执行错误时的回调（包括reject和抛出错误）</p></li><li><p>Promise实例方法 Promise.prototype.finally() 用来执行不管 Promise 对象最后状态如何，都会执行的操作（ES2018）</p></li><li><p>Promise方法 Promise.all(iterable) 方法返回一个 Promise 实例，此实例在 iterable 参数内所有的 promise 都“完成（resolved）”或参数中不包含 promise 时回调完成（resolve）；如果参数中  promise 有一个失败（rejected），此实例回调失败（reject），失败的原因是第一个失败 promise 的结果。</p></li><li><p>Promise方法 Promise.race(iterable) 方法返回一个 promise，一旦迭代器中的某个promise resolve 或 reject，返回的 promise 就会 resolve 或 reject。</p></li><li><p>Promise方法 Promise.allSettled()返回一个在所有给定的promise都已经 fulfilled 或rejected 后的 promise ，并带有一个对象数组，每个对象表示对应的promise结果。 (ES2020)</p></li><li><p>Promise方法 Promise.any(iterable) 接收一个Promise对象的集合，当其中的一个promise 成功，就返回那个成功的 promise 的值。 (ES2021)</p></li><li><p>Promise方法 Promise.reject(reason) 方法返回一个带有拒绝原因的Promise对象。</p></li><li><p>Promise方法 Promise.resolve(value)方法返回一个以给定值解析后的Promise 对象。</p></li></ol><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><p>Generator 是由一个 generator function(function*) 或 GeneratorFunction 构造器生成新的 返回的符合 iterator 和 iterable 的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>();</span><br><span class="line"><span class="comment">// &quot;Generator &#123; &#125;&quot;</span></span><br></pre></td></tr></table></figure><p>Gnerator对象实例方法</p><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>Generator.prototype.next()</td><td>返回一个由 yield表达式生成的值。</td></tr><tr><td>Generator.prototype.return()</td><td>返回给定的值并结束生成器。</td></tr><tr><td>Generator.prototype.throw()</td><td>向生成器抛出一个错误。</td></tr></tbody></table><p>GeneratorFunction构造器生成新的 Generator 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">GeneratorFunction</span> ([arg1[, arg2[, ...argN]],] functionBody)</span><br></pre></td></tr></table></figure><h2 id="async-await-ES2017"><a href="#async-await-ES2017" class="headerlink" title="async await (ES2017)"></a>async await (ES2017)</h2><p>async function 用来定义一个返回 AsyncFunction 对象的异步函数。异步函数是指通过事件循环异步执行的函数，它会通过一个隐式的 Promise 返回其结果。</p><h2 id="Module-import-amp-export"><a href="#Module-import-amp-export" class="headerlink" title="Module(import &amp; export)"></a>Module(import &amp; export)</h2><p>静态的import 语句用于导入由另一个模块导出的绑定。<br>export 语句用于从模块中导出实时绑定的函数、对象或原始值，以便其他程序可以通过 import 语句使用它们。</p><p>用法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> defaultExport <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> name <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">export</span> &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">export</span> <span class="keyword">as</span> alias &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; export1 , export2 &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; foo , bar &#125; <span class="keyword">from</span> <span class="string">&quot;module-name/path/to/specific/un-exported/file&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; export1 , export2 <span class="keyword">as</span> alias2 , [...] &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> defaultExport, &#123; <span class="keyword">export</span> [ , [...] ] &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> defaultExport, * <span class="keyword">as</span> name <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">import</span>(<span class="string">&quot;module-name&quot;</span>); <span class="comment">// 动态import (ES2020)</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo =<span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">cube</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;foo <span class="keyword">as</span> bar&#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; es6 <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./someModule&#x27;</span>;  <span class="comment">// 支持引入导出重命名</span></span><br></pre></td></tr></table></figure><p>由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。<br>同时import命令具有提升效果，会提升到整个模块的头部，首先执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> * <span class="keyword">as</span> ns <span class="keyword">from</span> <span class="string">&quot;mod&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ns <span class="keyword">from</span> <span class="string">&quot;mod&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;ns&#125;;</span><br></pre></td></tr></table></figure><ol><li>import.meta是一个给JavaScript模块暴露特定上下文的元数据属性的对象。它包含了这个模块的信息，比如说这个模块的URL。(ES2020)</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.mjs?someURLInfo=5&#x27;</span>;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">import</span>.<span class="property">meta</span>); <span class="comment">// &#123; url: &quot;file:///home/user/my-module.mjs&quot; &#125;</span></span><br></pre></td></tr></table></figure><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p>class 声明创建一个基于原型继承的具有给定名称的新类。类声明不存在变量提升。</p><p>用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> [<span class="keyword">extends</span>] &#123;</span><br><span class="line">  <span class="keyword">static</span> #privateProp = <span class="number">0</span>; <span class="comment">// 静态私有属性 (不会被实例继承，不会被子类继承)</span></span><br><span class="line">  #privateProp = <span class="number">0</span>; <span class="comment">// 私有属性 (不会被子类继承)</span></span><br><span class="line">  _prop = <span class="number">0</span>; <span class="comment">// 类实例属性 (实例继承)</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 类的构造函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_prop</span> = <span class="number">1</span>; <span class="comment">// this代表了实例</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">someMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 类实例方法(实例继承，子类继承)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">staticMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 静态方法（不会被实例继承，可以被子类继承）</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> #privateMethod = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 私有静态方法 （ES2020 stage3 不会被实例继承，不会被子类继承）</span></span><br><span class="line">  &#125;</span><br><span class="line">  #privateSomeMethod = <span class="function">()=&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 私有方法 （ES2020 stage3 实例继承，不会被子类继承）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> <span class="title class_">ClassName</span>(); <span class="comment">// 声明类的实例</span></span><br><span class="line">inst.<span class="title function_">someMethod</span>(); <span class="comment">// 调用实例的方法</span></span><br><span class="line"><span class="title class_">ClassName</span>.<span class="title function_">staticMethod</span>(); <span class="comment">// 调用类的静态方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChildClass</span> <span class="keyword">extends</span> <span class="title class_ inherited__">ClassName</span> &#123; <span class="comment">// 子类</span></span><br><span class="line">  <span class="title function_">someMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">staticMethod</span>(); <span class="comment">// 可以通过super调用父类上的方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ChildClass</span>.<span class="title function_">staticMethod</span>() <span class="comment">// 子类可以继承父类的静态方法</span></span><br></pre></td></tr></table></figure><h2 id="SharedArrayBuffer-amp-Atomics-ES2017"><a href="#SharedArrayBuffer-amp-Atomics-ES2017" class="headerlink" title="SharedArrayBuffer &amp; Atomics (ES2017)"></a>SharedArrayBuffer &amp; Atomics (ES2017)</h2><p>SharedArrayBuffer 对象用来表示一个通用的，固定长度的原始二进制数据缓冲区，类似于 ArrayBuffer 对象，它们都可以用来在共享内存（shared memory）上创建视图。与 ArrayBuffer 不同的是，SharedArrayBuffer 不能被分离。<br>Atomics 对象提供了一组静态方法用来对 SharedArrayBuffer 对象和 ArrayBuffer 对象进行原子操作。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初始化一个从0到99的数组</title>
      <link href="/blog/2020/07/28/JS-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AA%E4%BB%8E0%E5%88%B099%E7%9A%84%E6%95%B0%E7%BB%84/"/>
      <url>/blog/2020/07/28/JS-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AA%E4%BB%8E0%E5%88%B099%E7%9A%84%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>开发过程中遇到了一个问题，需要mock一些数据。一开始直接用的静态常量，后来想想这实在是太占地方了，尤其为了符合eslint需要写很多行，找其它部分代码的时候也不方便，而且很显然，我们可以用“时间换取空间”，通过程序简化这一部分。<br>我需要mock的是一个数组，数组里有一些固定的或是随机的数据（这里不妨假设只需要填满不同的数字），那么如何才能简便的mock一个这样的数组呢？</p><span id="more"></span><h2 id="如何初始化一个从0到99的数组"><a href="#如何初始化一个从0到99的数组" class="headerlink" title="如何初始化一个从0到99的数组"></a>如何初始化一个从0到99的数组</h2><p>通常最简单的能想到的方法，不就是个循环嘛  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span> ; i++) &#123;</span><br><span class="line">    result.<span class="title function_">push</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这实在是太笨了，“高级程序员是不会使用for循环的（偷笑）”，在js中，我们可以用其它的方法循环。比如 <code>map</code>。 利用 <code>map</code> 方法会看起来更简便些，但我们首先要构造一个长度为100并且初始化了的数组。</p><h3 id="如何构造一个长度为100的数组"><a href="#如何构造一个长度为100的数组" class="headerlink" title="如何构造一个长度为100的数组"></a>如何构造一个长度为100的数组</h3><ol><li>Array的构造函数 + …扩展运算符</li></ol><p>通过 Array 的构造函数 <code>Array(100)</code> 我们可以创建长度为100的数组，但是并没有初始化。</p><p>我们可以通过…来初始化它</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="title class_">Array</span>(<span class="number">100</span>)];</span><br></pre></td></tr></table></figure><ol start="2"><li>将类数组对象初始化为数组 - <code>Array.from</code></li></ol><p>类数组对象比较好写 <code>&#123;length: 100&#125;</code> ，那如何把它变成初始化了的数组呢？</p><p>可以直接用 <code>Array.from</code> ，这个方法本身就是为了从一个类似数组或可迭代对象创建一个新的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: <span class="number">100</span>&#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li>将类数组对象初始化为数组 - <code>Array.apply</code></li></ol><p>使用 <code>Array(&#123;length: 100&#125;)</code> 并不会创建长度为100的数组，这是因为 Array 的构造函数把入参当成了一个对象进行了初始化，如何让Array的构造函数把入参作为类数组对象呢？可以使用 <code>apply</code> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, &#123;<span class="attr">length</span>: <span class="number">100</span>&#125;);</span><br></pre></td></tr></table></figure><ol start="4"><li><code>Array.prototype.slice</code> + …扩展运算符</li></ol><p>Array 的 slice 方法可以对数组进行拷贝，也可以用它来将类数组对象拷贝成长度为100的数组，直接使用是不行的，因为毕竟类数组对象还不是数组，我们可以用 <code>call</code> 或者 <code>apply</code> 、 <code>bind</code> 来调用它  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(&#123;<span class="attr">length</span>: <span class="number">100</span>&#125;)];</span><br><span class="line">[...<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">apply</span>(&#123;<span class="attr">length</span>: <span class="number">100</span>&#125;)];</span><br><span class="line">[...<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">bind</span>(&#123;<span class="attr">length</span>: <span class="number">100</span>&#125;)()];</span><br></pre></td></tr></table></figure><h3 id="利用-Array-prototype-map-初始化"><a href="#利用-Array-prototype-map-初始化" class="headerlink" title="利用 Array.prototype.map 初始化"></a>利用 <code>Array.prototype.map</code> 初始化</h3><p>有了已经初始化为undefined的数组后面就是将数组填满值了  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="title class_">Array</span>(<span class="number">100</span>)].<span class="title function_">map</span>(<span class="function">(<span class="params">_, i</span>) =&gt;</span> i);</span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: <span class="number">100</span>&#125;, <span class="function">(<span class="params">_, i</span>) =&gt;</span> i);</span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, &#123;<span class="attr">length</span>: <span class="number">100</span>&#125;).<span class="title function_">map</span>(<span class="function">(<span class="params">_, i</span>) =&gt;</span> i);</span><br><span class="line"><span class="comment">// 上面4的写法已经够长了，我就不加map了</span></span><br></pre></td></tr></table></figure><p>因为 <code>mapFn</code> 可以随意写，我们还可以用以上两种方法构造诸如全是1的数组  </p><h3 id="利用-Object-keys-获取初始化数组的key"><a href="#利用-Object-keys-获取初始化数组的key" class="headerlink" title="利用 Object.keys() 获取初始化数组的key"></a>利用 <code>Object.keys()</code> 获取初始化数组的key</h3><p>注意，我们要初始化的值其实和数组的key是相同的！这样我们其实可以有一些取巧的方法，比如，可以通过 <code>Object.keys()</code> 来得到这样一个符合条件的新的数组。<code>Object.keys()</code> 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>([...<span class="title class_">Array</span>(<span class="number">100</span>)]);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: <span class="number">100</span>&#125;));</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">Array</span>.<span class="title function_">apply</span>(<span class="literal">null</span>,&#123;<span class="attr">length</span>:<span class="number">100</span>&#125;));</span><br></pre></td></tr></table></figure><h3 id="利用-Array-prototype-keys-生成迭代器"><a href="#利用-Array-prototype-keys-生成迭代器" class="headerlink" title="利用 Array.prototype.keys 生成迭代器"></a>利用 <code>Array.prototype.keys</code> 生成迭代器</h3><p>如果我们构造了一个长度为100的数组但是没有初始化，我们可以生成从0到99的数组吗？其实也是可以的，我们可以通过 <code>Array.prototype.keys</code> 生成一个数组迭代器对象，然后再通过 …扩展运算符 来生成一个从0到99的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="title class_">Array</span>(<span class="number">100</span>).<span class="title function_">keys</span>()]</span><br><span class="line">[...<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(&#123;<span class="attr">length</span>: <span class="number">100</span>&#125;).<span class="title function_">keys</span>()]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试常用简单算法实现</title>
      <link href="/blog/2020/05/27/CS-%E9%9D%A2%E8%AF%95%E5%B8%B8%E7%94%A8%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
      <url>/blog/2020/05/27/CS-%E9%9D%A2%E8%AF%95%E5%B8%B8%E7%94%A8%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h2><p>在数学上, 自然数n的阶乘写作n!。一个正整数 n 的阶乘, 就是所有小于等于 n 的正整数的乘积，0的阶乘为1。比如:</p><p>5！ = 5 <em> 4 </em> 3 <em> 2 </em> 1 = 120</p><table><thead><tr><th>n</th><th style="text-align:right">n!</th></tr></thead><tbody><tr><td>0</td><td style="text-align:right">1</td></tr><tr><td>1</td><td style="text-align:right">1</td></tr><tr><td>2</td><td style="text-align:right">2</td></tr><tr><td>3</td><td style="text-align:right">6</td></tr><tr><td>4</td><td style="text-align:right">24</td></tr><tr><td>5</td><td style="text-align:right">120</td></tr><tr><td>6</td><td style="text-align:right">720</td></tr><tr><td>7</td><td style="text-align:right">5 040</td></tr><tr><td>8</td><td style="text-align:right">40 320</td></tr><tr><td>9</td><td style="text-align:right">362 880</td></tr><tr><td>10</td><td style="text-align:right">3 628 800</td></tr><tr><td>11</td><td style="text-align:right">39 916 800</td></tr><tr><td>12</td><td style="text-align:right">479 001 600</td></tr><tr><td>13</td><td style="text-align:right">6 227 020 800</td></tr><tr><td>14</td><td style="text-align:right">87 178 291 200</td></tr><tr><td>15</td><td style="text-align:right">1 307 674 368 000</td></tr></tbody></table><p>问题： 求自然数n的阶乘  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">number</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">number</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 0 或 1 返回 1</span></span><br><span class="line">  <span class="keyword">if</span> (number === <span class="number">0</span> || number === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 大于等于2时循环相乘</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= number; i++) &#123;</span><br><span class="line">    result *= i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用尾递归的方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">total</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">n, total = <span class="number">1</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> n === <span class="number">1</span> ? total : <span class="title function_">factorial</span>(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><span id="more"></span><h2 id="斐波那契"><a href="#斐波那契" class="headerlink" title="斐波那契"></a>斐波那契</h2><p>斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=3，n∈N*）在现代物理、准晶体结构、化学等领域，斐波纳契数列都有直接的应用。  </p><table><thead><tr><th>n</th><th style="text-align:right">Fibonacci (n)</th></tr></thead><tbody><tr><td>1</td><td style="text-align:right">1</td></tr><tr><td>2</td><td style="text-align:right">1</td></tr><tr><td>3</td><td style="text-align:right">2</td></tr><tr><td>4</td><td style="text-align:right">3</td></tr><tr><td>5</td><td style="text-align:right">5</td></tr><tr><td>6</td><td style="text-align:right">8</td></tr><tr><td>7</td><td style="text-align:right">13</td></tr></tbody></table><p>问题： 求斐波那契数列的第n个数字  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采用递归方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Fibonacci</span> (n) &#123;</span><br><span class="line">   <span class="keyword">if</span>(n === <span class="number">1</span> || n === <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 递归结束的条件，求前两项</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是求其它项，先要求出它前面两项，然后做和。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Fibonacci</span>(n-<span class="number">1</span>) + <span class="title class_">Fibonacci</span>(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用尾递归优化</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Fibonacci</span> (n , prev = <span class="number">1</span> , curr = <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n === <span class="number">1</span> || n === <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Fibonacci</span> (n - <span class="number">1</span>, curr, prev + curr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用解构赋值+循环</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Fibonacci</span> (n)&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span> || n === <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="number">1</span>, curr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i = n; i++)&#123;</span><br><span class="line">        [prev, curr] = [curr, prev + curr];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用生成器</span></span><br><span class="line"><span class="comment">// fibonacci generator</span></span><br><span class="line"><span class="keyword">function</span> * fibonacci () &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> [prev, curr] = [<span class="number">1</span>, <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        [prev, curr] = [curr, prev + curr];</span><br><span class="line">        <span class="keyword">yield</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// fibonacci function</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Fibonacci</span> (n)&#123;</span><br><span class="line">    <span class="keyword">let</span> ac = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> fibo = <span class="title function_">fibonacci</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      ac = fibo.<span class="title function_">next</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ac.<span class="property">value</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h2><p>素数（又叫质数）是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。<br>例如： 2，3，5，7，11，13，17，19，23，29，31，37…</p><p>问题： 判断自然数n是否是素数  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">number</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">trialDivision</span>(<span class="params">number</span>) &#123;</span><br><span class="line">  <span class="comment">// Check if number is integer.</span></span><br><span class="line">  <span class="keyword">if</span> (number % <span class="number">1</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (number &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// If number is less than one then it isn&#x27;t prime by definition.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (number &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="comment">// All numbers from 2 to 3 are prime.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the number is not divided by 2 then we may eliminate all further even dividers.</span></span><br><span class="line">  <span class="keyword">if</span> (number % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If there is no dividers up to square root of n then there is no higher dividers as well.</span></span><br><span class="line">  <span class="keyword">const</span> dividerLimit = <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(number);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> divider = <span class="number">3</span>; divider &lt;= dividerLimit; divider += <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (number % divider === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h2><p>在数学中，欧几里德算法，是计算两个数的最大公约数（GCD）的一种有效方法。两个数的最大公约数是指不留余数即可将两个数整除的数中最大的数。<br>欧几里德算法是基于如果用大数与小数的差代替大数，两个数的最大公约数不变的原理。例如，21 是 252（21 <em> 21） 与 105 （21 </em> 5）的最大公约数，那么 21 同时也是 105 和 252 - 105 = 147 的最大公约数。由于这个替换减少了两个数字中较大的一个，重复这个过程会连续地给出较小的一对数字，直到两个数字相等为止。当出现这种情况时，它们是原始两个数字的GCD。<br>通过颠倒这些步骤，GCD可以表示为每个原始数乘以正整数或负整数的和，例如21=5×105+（-2）×252。GCD总是可以用这种方式表达的事实被称为裴蜀定理。</p><p>问题： 利用欧几里得算法求两个数的最大公约数  </p><p>递归<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursive version of Euclidean Algorithm of finding greatest common divisor (GCD).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">originalA</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">originalB</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">euclideanAlgorithm</span>(<span class="params">originalA, originalB</span>) &#123;</span><br><span class="line">  <span class="comment">// Make input numbers positive.</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="title class_">Math</span>.<span class="title function_">abs</span>(originalA);</span><br><span class="line">  <span class="keyword">const</span> b = <span class="title class_">Math</span>.<span class="title function_">abs</span>(originalB);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// To make algorithm work faster instead of subtracting one number from the other</span></span><br><span class="line">  <span class="comment">// we may use modulo operation.</span></span><br><span class="line">  <span class="keyword">return</span> (b === <span class="number">0</span>) ? a : <span class="title function_">euclideanAlgorithm</span>(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>循环<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Iterative version of Euclidean Algorithm of finding greatest common divisor (GCD).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">originalA</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">originalB</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">euclideanAlgorithmIterative</span>(<span class="params">originalA, originalB</span>) &#123;</span><br><span class="line">  <span class="comment">// Make input numbers positive.</span></span><br><span class="line">  <span class="keyword">let</span> a = <span class="title class_">Math</span>.<span class="title function_">abs</span>(originalA);</span><br><span class="line">  <span class="keyword">let</span> b = <span class="title class_">Math</span>.<span class="title function_">abs</span>(originalB);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Subtract one number from another until both numbers would become the same.</span></span><br><span class="line">  <span class="comment">// This will be out GCD. Also quit the loop if one of the numbers is zero.</span></span><br><span class="line">  <span class="keyword">while</span> (a &amp;&amp; b &amp;&amp; a !== b) &#123;</span><br><span class="line">    [a, b] = a &gt; b ? [a - b, b] : [a, b - a];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the number that is not equal to zero since the last subtraction (it will be a GCD).</span></span><br><span class="line">  <span class="keyword">return</span> a || b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h2><p>在算术和数论中，两个整数a和b的最小公倍数、最小公倍数或最小公倍数，通常用LCM（a，b）表示，是可被a和b整除的最小正整数。由于整数被零除是未定义的，只有当a和b都不等于0时，这个定义才有意义。但也有些人定义 <code>lcm(a, 0) = 0</code>  </p><p>最小公倍数可以这样计算 <code>lcm(a, b) = |a * b| / gcd(a, b)</code> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> euclideanAlgorithm <span class="keyword">from</span> <span class="string">&#x27;./euclideanAlgorithm&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">a</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">b</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">leastCommonMultiple</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> ((a === <span class="number">0</span>) || (b === <span class="number">0</span>)) ? <span class="number">0</span> : <span class="title class_">Math</span>.<span class="title function_">abs</span>(a * b) / <span class="title function_">euclideanAlgorithm</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript模块化</title>
      <link href="/blog/2020/05/22/FE-Javascript%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
      <url>/blog/2020/05/22/FE-Javascript%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><h3 id="什么是模块化"><a href="#什么是模块化" class="headerlink" title="什么是模块化"></a>什么是模块化</h3><p>Javascript在最初的时候没有自己的模块化标准和引入外部模块的方法，类似于 c 的 <code>#include</code> java 的 <code>package</code> ，一个完备的编程语言会考虑一个工程在运行时各个模块的引用和依赖关系。但显然 Javascript 在设计之初只是被当作了一个网页端的脚本语言，既然 HTML 中可以引用js，为什么还要设计 js 中引入 js 的方法呢。可是 Javascript 的发展实在是太快了，我们知道现在 Javascript 不仅在网页中使用，服务器(Nodejs)，PC客户端(Electron)甚至移动客户端都有Js的程序。如何更好的定义模块并进行模块间的引用成了Javascript的当务之重。<br>模块化是一种将系统分离成独立功能部分的方法，可将系统分割成独立的功能部分，严格定义模块接口、模块间具有透明性。  </p><span id="more"></span><h3 id="为什么模块化"><a href="#为什么模块化" class="headerlink" title="为什么模块化"></a>为什么模块化</h3><ul><li>可以解决命名冲突</li><li>更好的管理依赖</li><li>提高代码的可读性</li><li>代码解耦，提高代码的复用性</li></ul><h3 id="目前常见的JS模块化规范"><a href="#目前常见的JS模块化规范" class="headerlink" title="目前常见的JS模块化规范"></a>目前常见的JS模块化规范</h3><p><strong>CommonJS规范</strong> 是在服务器端模块的规范，是同步加载的。应用有 Nodejs。<br><strong>AMD规范</strong>（Asynchronous Module Definition）是 RequireJS 在推广过程中对模块定义的规范化产出，主要用于浏览器端。其特点是：依赖前置，需要在定义时就写好需要的依赖，提前执行依赖，应用有require.js<br><strong>CMD规范</strong> （Common Module Definition）是 Sea.js 在推广过程中对模块定义的规范化产出，主要用于浏览器端。其主要特点是：对于依赖的模块是延迟执行，依赖可以就近书写，等到需要用这个依赖的时候再引入这个依赖，应用有sea.js<br><strong>ES6 module</strong> 在 ES6 中定义了js语言的模块化规范。从此 AMD 和 CMD 退出了历史舞台。</p><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p>CommonJS规范参见 http://wiki.commonjs.org/wiki/CommonJS</p><p>Nodejs采用了CommonJS的模块化规范，下面列出了CommonJS中模块部分相关的变量，并以 Nodejs 的实现来解释含义和用法。  </p><h3 id="require"><a href="#require" class="headerlink" title="require"></a>require</h3><p>require 方法用于加载模块文件。require 方法的基本功能是，接受一个模块标示符，返回外部模块的 exports 对象或方法。如果没有发现指定模块，会报错。如果有循环调用，require 返回的对象必须至少包含外部模块在调用 require 之前准备好的导出，该调用导致当前模块的执行。<br>模块标示符是指由正斜杠分隔的特殊字符串。这些字符串需要是驼峰化的，或者 . (代表当前路径)或者 .. (代表上一个路径)。可以省略文件后缀（例如.js）。顶层标识符从模块名称空间根解析。相对标识符是相对于写入和调用 require 的模块的位置来解析。  </p><p>在 Nodejs 中，require 方法有以下方法 &amp; 属性  </p><ul><li><p>resolve 方法<br>使用内部的 require 机制查询模块的位置，此操作只返回解析后的文件名，不会加载该模块。</p></li><li><p>resolve.paths 方法<br>返回一个数组，其中包含解析 request 过程中被查询的路径，如果 request 字符串指向核心模块（例如 http 或 fs）则返回 null。</p></li><li><p>main 对象<br>Module 对象实例，表示当 Node.js 进程启动时加载的入口脚本。</p></li><li><p>extensions 对象<br>可以加载的文件类型及方法，node中默认支持 <code>.js</code> <code>.json</code> <code>.node</code> 文件，如果省略后缀，也会按照这三种的次序依次补足扩展名然后尝试加载。可以通过例如以下方法来让node加载不同的文件后缀。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.<span class="property">extensions</span>[<span class="string">&#x27;.sjs&#x27;</span>] = <span class="built_in">require</span>.<span class="property">extensions</span>[<span class="string">&#x27;.js&#x27;</span>];</span><br></pre></td></tr></table></figure></li><li><p>cache 对象<br>require缓存，文件的绝对路径和 Module 对象实例的健值对数组。当再次require时，会返回缓存的模块。从此对象中删除键值对将会导致下一次 require 重新加载被删除的模块。</p></li></ul><p>和标准稍微有些不同的是：<br>如果模块标志符是 Nodejs 默认携带的核心模块，会加载响应的核心模块，例如<code>fs</code>、<code>net</code>，或者一个位于各级 <code>node_modules</code> 目录的已安装模块。<br>如果 <code>require</code> 通过分析文件扩展名之后，可能没有查找到对应文件，但却得到一个目录，Nodejs 会将目录当做一个 Nodejs 包来处理，首先，Nodejs 在当前目录下查找 package.json (CommonJS包规范定义的包描述文件)，通过 <code>JSON.parse()</code> 解析出包描述对象，从中取出 <code>main</code> 属性指定的文件名进行定位。如果文件名缺少扩展名，将会进入扩展名分析的步骤。而如果 <code>main</code> 属性指定的文件名错误，或者压根没有 package.json 文件，Nodejs 会将 index 当做默认文件名，然后依次查找 index.js、index.json、index.node。</p><h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><p>module 指加载后的模块。CommonJS 规范中，module 中应包括变量 require 指向 require 方法，变量 exports 指向当外部其它模块导入时可以引用的对，变量 module 对象 包括唯一的可被追溯的 id 属性以及 uri 属性指向模块的资源位置。</p><p>在 Node.js 中，稍微有些不同，module对象是一个 Module 类的实例，这个对象包括以下属性 &amp; 方法：</p><ul><li>id<br>模块的标识符。 通常是完全解析后的文件名。</li><li>exports<br>将期望导出的对象赋值给 module.exports 可以让其它模块使用</li><li>parent<br>最先引用该模块的模块。</li><li>filename<br>模块的完全解析后的文件名。<br>相当于 require.resolve(\/<em>模块标志符</em>\/)</li><li>loaded<br>模块是否已经加载完成，或正在加载中。</li><li>children<br>被该模块引用的模块对象。</li><li>paths<br>模块的搜索路径。<br>相当于 require.resolve.paths(module.filenname)</li><li>require 方法<br>和require方法类似，也是引入其它模块，但是相对path是当前的module</li></ul><h3 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h3><p>exports 变量是在模块的文件级作用域内可用的，且在模块执行之前赋值给 module.exports。<br>它允许使用快捷方式，因此 <code>module.exports.f = ...</code> 可以更简洁地写成 <code>exports.f = ...</code> 。 但是，就像任何变量一样，如果为 exports 赋予了新值，则它将不再绑定到 module.exports。<br>当 module.exports 属性被新对象完全替换时，通常也会重新赋值 exports。</p><h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p>AMD 规范采用异步方式加载模块，模块的加载不影响之后语句的执行。所有依赖这个模块的语句，都定义在一个回调函数中，等到模块加载完成之后，这个回调函数才会运行。</p><p>实现了AMD的 <a href="https://github.com/requirejs/requirejs">RequireJS</a></p><p>RequireJS 实现了 AMD 规范的模块化：用 <code>require.config()</code> 指定引用路径等参数，用 <code>definde()</code> 定义模块，用 <code>require()</code> 加载模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 网页中引入require.js及main.js **/</span></span><br><span class="line">&lt;script src=<span class="string">&quot;js/require.js&quot;</span> data-main=<span class="string">&quot;js/main&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** main.js 入口文件/主模块 **/</span></span><br><span class="line"><span class="comment">// 首先用config()指定各模块路径和引用名</span></span><br><span class="line"><span class="built_in">require</span>.<span class="title function_">config</span>(&#123;</span><br><span class="line">  <span class="attr">baseUrl</span>: <span class="string">&quot;js/lib&quot;</span>,</span><br><span class="line">  <span class="attr">paths</span>: &#123;</span><br><span class="line">    <span class="string">&quot;jquery&quot;</span>: <span class="string">&quot;jquery.min&quot;</span>,  <span class="comment">//实际路径为js/lib/jquery.min.js</span></span><br><span class="line">    <span class="string">&quot;underscore&quot;</span>: <span class="string">&quot;underscore.min&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 执行基本操作</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&quot;jquery&quot;</span>,<span class="string">&quot;underscore&quot;</span>],<span class="keyword">function</span>(<span class="params">$,_</span>)&#123;</span><br><span class="line">  <span class="comment">// some code here</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>引用模块的时候，我们将模块名放在 <code>[]</code> 中作为 <code>reqiure()</code> 的第一参数；如果我们定义的模块本身也依赖其他模块,那就需要将它们放在 <code>[]</code> 中作为 <code>define()</code> 的第一参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义math.js模块</span></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> basicNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> add = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">add</span>: add,</span><br><span class="line">        <span class="attr">basicNum</span>: basicNum</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个依赖underscore.js的模块</span></span><br><span class="line"><span class="title function_">define</span>([<span class="string">&#x27;underscore&#x27;</span>], <span class="keyword">function</span>(<span class="params">_</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> classify = <span class="keyword">function</span>(<span class="params">list</span>) &#123;</span><br><span class="line">    _.<span class="title function_">countBy</span>(list, <span class="keyword">function</span>(<span class="params">num</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> num &gt; <span class="number">30</span> ? <span class="string">&#x27;old&#x27;</span> : <span class="string">&#x27;young&#x27;</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">classify</span>: classify</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用模块，将模块放在[]内</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;jquery&#x27;</span>, <span class="string">&#x27;math&#x27;</span>], <span class="keyword">function</span>(<span class="params">$, math</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> sum = math.<span class="title function_">add</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">  $(<span class="string">&quot;#sum&quot;</span>).<span class="title function_">html</span>(sum);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>AMD的实现者 <code>require.js</code> 在申明依赖的模块时，会在第一时间加载并执行模块内的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">define</span>([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>], <span class="keyword">function</span>(<span class="params">a, b, c, d, e, f</span>) &#123; </span><br><span class="line">    <span class="comment">// 等于在最前面声明并初始化了要用到的所有模块</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="comment">// 即便没用到某个模块 b，但 b 还是提前执行了。</span></span><br><span class="line">      b.<span class="title function_">foo</span>()</span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>遇到如上所述情况时，即使没有使用到某些模块，由于依赖关系仍旧需要等待加载，这在一定程度上浪费了时间。</p><p>CMD 是另一种js模块化方案，它与 AMD 很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。</p><p>实现了CMD的 <a href="https://github.com/seajs/seajs">Sea.js</a> 作者 <a href="https://github.com/lifesinger">王保平 玉伯 阿里p10</a> <a href="https://www.zhihu.com/people/lifesinger">知乎达人</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** AMD写法 **/</span></span><br><span class="line"><span class="title function_">define</span>([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>], <span class="keyword">function</span>(<span class="params">a, b, c, d, e, f</span>) &#123; </span><br><span class="line">     <span class="comment">// 等于在最前面声明并初始化了要用到的所有模块</span></span><br><span class="line">    a.<span class="title function_">doSomething</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">// 即便没用到某个模块 b，但 b 还是提前执行了</span></span><br><span class="line">        b.<span class="title function_">doSomething</span>()</span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** CMD写法 **/</span></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="variable language_">module</span></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a&#x27;</span>); <span class="comment">//在需要时申明</span></span><br><span class="line">    a.<span class="title function_">doSomething</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b&#x27;</span>);</span><br><span class="line">        b.<span class="title function_">doSomething</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Sea.js 的用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** sea.js **/</span></span><br><span class="line"><span class="comment">// 定义模块 math.js</span></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="variable language_">module</span></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">&#x27;jquery.js&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> add = <span class="keyword">function</span>(<span class="params">a, b</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exports</span>.<span class="property">add</span> = add;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line">seajs.<span class="title function_">use</span>([<span class="string">&#x27;math.js&#x27;</span>], <span class="keyword">function</span>(<span class="params">math</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = math.<span class="title function_">add</span>(<span class="number">1</span> + <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h2><p>UMD（Universal Module Definition） 并不是一个规范而是 AMD 规范和 CommonJS 规范的一个兼容性的糅合。AMD 是浏览器优先，异步加载；CommonJS 是服务器优先，同步加载。UMD 通过判断是否支持 Node.js 的模块来决定是按照 COMMONJS 规范来加载还是按照 AMD 规范来加载。</p><p>UMD 实现参见 <a href="https://github.com/umdjs/umd">umd</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">(<span class="params">root, factory</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&#x27;function&#x27;</span> &amp;&amp; define.<span class="property">amd</span>) &#123;</span><br><span class="line">    <span class="comment">//AMD</span></span><br><span class="line">    <span class="title function_">define</span>([<span class="string">&#x27;jquery&#x27;</span>], factory);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">exports</span> === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">//CommonJS</span></span><br><span class="line">    <span class="keyword">var</span> $ = <span class="title function_">requie</span>(<span class="string">&#x27;jquery&#x27;</span>);</span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">factory</span>($);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//都不是，浏览器全局定义</span></span><br><span class="line">    root.<span class="property">testModule</span> = <span class="title function_">factory</span>(root.<span class="property">jQuery</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="variable language_">this</span>, <span class="function">(<span class="params">$</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//do something...  这里是真正的函数体</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="ES6-module"><a href="#ES6-module" class="headerlink" title="ES6 module"></a>ES6 module</h2><p><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-modules">ES6 module</a> 为Javascript 引入了模块化的标准。模块功能主要由两个关键字构成： <code>export</code> 和 <code>import</code> 。 <code>export</code> 关键字用于规定模块的对外接口， <code>import</code> 关键字用于输入其他模块提供的功能。  </p><h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用 export 关键字输出该变量。<br>可以导出变量、方法和类。可以直接导出，也可以在文件中将待导出的变量、方法或类作为对象的属性导出。<br>export 关键字可以出现在模块的任何位置，但不能处于块级作用域内。<br>使用 export default 关键字，为模块指定默认输出。一个模块只能有一个默认输出，因此 export default 命令只能使用一次  </p><figure class="highlight js"><figcaption><span>profile.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> firstName = <span class="string">&#x27;Michael&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> lastName = <span class="string">&#x27;Jackson&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">multiply</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>profile1.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstName = <span class="string">&#x27;Michael&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">&#x27;Jackson&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;firstName, lastName, year&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>export-default.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>使用 export 命令定义了模块的对外接口以后，其他 JS 文件就可以通过 import 命令加载这个模块。<br>import 命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块对外接口的名称相同。<br>import 后面的 from 指定模块文件的位置，可以是相对路径，也可以是绝对路径，.js 路径可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。<br>import 命令是编译阶段执行的，在代码运行之前。由于 import 是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。<br>import 语句会执行所加载的模块。<br>如果多次重复执行同一句 import 语句，那么只会执行一次，而不会执行多次。<br>除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。<br>当用到 export default 命令，为模块指定默认输出时，其他模块加载该模块时，import 命令可以为该匿名函数指定任意名字(此时不使用{})。</p><figure class="highlight js"><figcaption><span>main.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;firstName, lastName, year&#125; <span class="keyword">from</span> <span class="string">&#x27;./profile&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setName</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  element.<span class="property">textContent</span> = firstName + <span class="string">&#x27; &#x27;</span> + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>circle.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">area</span>(<span class="params">radius</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">circumference</span>(<span class="params">radius</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span> * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>calculate.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">&#x27;./circle&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;圆面积：&#x27;</span> + circle.<span class="title function_">area</span>(<span class="number">4</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;圆周长：&#x27;</span> + circle.<span class="title function_">circumference</span>(<span class="number">14</span>));</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>import-default.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">&#x27;./export-default&#x27;</span>;</span><br><span class="line"><span class="title function_">customName</span>(); <span class="comment">// &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="as"><a href="#as" class="headerlink" title="as"></a>as</h3><p>可以使用as关键字重命名导出或导入的变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; lastName <span class="keyword">as</span> surname &#125; <span class="keyword">from</span> <span class="string">&#x27;./profile&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">v1</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">v2</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  v1 <span class="keyword">as</span> streamV1,</span><br><span class="line">  v2 <span class="keyword">as</span> streamV2,</span><br><span class="line">  v2 <span class="keyword">as</span> streamLatestVersion</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="require-和-import-引入的区别"><a href="#require-和-import-引入的区别" class="headerlink" title="require 和 import 引入的区别"></a>require 和 import 引入的区别</h2><ol><li>require 是 Commonjs 规范的模块化引入语法， import 是 ES6 的模块化引入语法</li><li>require 是运行时加载，import 是编译时加载，执行时效率更高</li><li>require 可以在任意位置引入包括语句块里，import 会提升到整个模块的头部</li><li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用</li><li>CommonJs 是单个值导出，ES6 Module可以导出多个</li><li>CommonJs 的 this 是当前模块，ES6 Module 的 this 是 undefined</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> interview </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript引擎介绍</title>
      <link href="/blog/2020/05/12/FE-Javascript%E5%BC%95%E6%93%8E/"/>
      <url>/blog/2020/05/12/FE-Javascript%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="Javascript历史"><a href="#Javascript历史" class="headerlink" title="Javascript历史"></a>Javascript历史</h2><p>ECMAScript 最初是由网景的 Brendan Eich 开发的一种脚本语言的标准化规范；一开始命名为Mocha，后来改名为LiveScript，最后重命名为JavaScript。1995年12月，Sun 与 Netscape 联合发表了JavaScript。1996年11月，网景公司将 JavaScript 提交给欧洲计算机制造商协会进行标准化。ECMA-262的第一个版本于1997年6月被Ecma组织采纳。ECMA Script是ECMA-262标准化的脚本语言的名称。尽管JavaScript和JScript与ECMAScript兼容，但包含超出ECMA Script的功能。  </p><span id="more"></span><p>ECMAScript是一种可以在宿主环境中执行计算并能操作可计算对象的基于对象的程序设计语言。ECMAScript最先被设计成一种Web脚本语言，用来支持Web页面的动态表现以及为基于Web的客户机—服务器架构提供服务器端的计算能力。但作为一种脚本语言， ECMAScript具备同其他脚本语言一样的性质，即“用来操纵、定制一个已存在系统所提供的功能，以及对其进行自动化”。  </p><p>1999年12月，ECMAScript 3.0版发布，成为JavaScript的通行标准，得到了广泛支持。<br>2009年12月，ECMAScript 5.0版正式发布。<br>2015年6月17日，ECMAScript 6发布正式版本，即ECMAScript 2015。</p><p>ECMA的第39号技术专家委员会（Technical Committee 39，简称TC39）负责制订ECMAScript标准，成员包括Microsoft、Mozilla、Google等公司。</p><p>Javascript 语言规范 <a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">ECMA-262</a>。</p><p>理论上，实现了上述规范能够提供执行 JavaScript 代码的运行环境都可以称为 Javascript 引擎，下面我们来了解下比较流行的 Javascript 引擎。  </p><table><thead><tr><th>公司</th><th>浏览器</th><th>浏览器内核</th><th>js 引擎</th></tr></thead><tbody><tr><td><a href="https://www.microsoft.com/">Microsoft</a></td><td><a href="https://www.microsoft.com/en-us/download/internet-explorer.aspx">Internet Exporler(IE)</a> -&gt; <a href="https://www.microsoft.com/zh-cn/edge">Edge</a></td><td>Trident(MSHTML，IE11-)-&gt;EdgeHTML/MSHTML(Edge)-&gt;Blink（基于WebKit）</td><td>JScript（IE3.0-IE8.0） -&gt; <a href="https://github.com/chakra-core/ChakraCore">ChakraCore</a>（IE9+之后）-&gt; v8</td></tr><tr><td><a href="https://www.google.com/">Google</a></td><td><a href="https://www.google.com/intl/zh-CN/chrome/">Chrome</a>/<a href="https://github.com/chromium/chromium">Chromium</a></td><td>WebKit-&gt;Blink（28.0.1469.0+，基于Webkit）</td><td><a href="https://github.com/v8/v8">v8</a></td></tr><tr><td><a href="https://www.apple.com/">Apple</a></td><td><a href="https://www.apple.com.cn/safari/">Safari</a></td><td><a href="https://github.com/WebKit/WebKit">WebKit</a></td><td><a href="https://trac.webkit.org/wiki/JavaScriptCore">JavaScriptCore</a>-&gt;SquirrelFish（Nitro）</td></tr><tr><td><a href="https://www.mozilla.org/">Mozilla</a></td><td><a href="http://www.firefox.com.cn/">Firefox</a></td><td><a href="https://github.com/mozilla/gecko-dev">Gecko</a></td><td>SpiderMonkey（1.0-3.0）-&gt; TraceMonkey（3.5-3.6）-&gt; JägerMonkey（4.0-）-&gt; IonMonkey (18.0+) -&gt; OdinMonkey（22.0+）</td></tr><tr><td><a href="https://www.opera.com/">Opera</a></td><td><a href="https://www.opera.com/zh-cn">Opera</a></td><td>Elektra(4-6)-&gt;Presto(7.0-12.18)-&gt;WebKit-&gt;Blink（基于Webkit）</td><td>Linear A（4.0-6.1）-&gt; Linear B（7.0-9.2）-&gt; Futhark（9.5-10.2）-&gt; Carakan（10.5-）-&gt; V8</td></tr></tbody></table><p>其他js引擎还有：<br>Tamarin，由 Adobe Labs 编写，被用于 Flash Player 9</p><h2 id="ChakraCore"><a href="#ChakraCore" class="headerlink" title="ChakraCore"></a>ChakraCore</h2><p><a href="https://github.com/Microsoft/ChakraCore">ChakraCore</a> 是 Micosoft Edge 所使用的Javascript引擎。支持JIT，垃圾回收机制。</p><h2 id="JavaScriptCore"><a href="#JavaScriptCore" class="headerlink" title="JavaScriptCore"></a>JavaScriptCore</h2><p>Apple 开发的开源 JavaScript 引擎，<a href="https://github.com/WebKit/webkit/tree/master/Source/JavaScriptCore">JavaScriptCore</a> 引擎是 WebKit 中默认的引擎。2008 年重写了，叫做 SquirrelFish，后来是 SquirrelFish Extreme，又叫 Nitro。它主要是将源代码翻译成抽象语法树，之后是平台无关的字节码，在最初的版本中，字节码会被 JavaScriptCore 引擎解释执行。在后面的版本中，逐渐加入了JIT编译器，将热点函数生成本地代码。</p><h2 id="v8"><a href="#v8" class="headerlink" title="v8"></a>v8</h2><p>Google 开发的开源 JavaScript 引擎，以高性能著称。 <a href="https://github.com/v8/v8">v8</a>最开始是一帮语言方面的专家设计出来的，之后被 Google 收购，成为了 JavaScript 引擎和众多相关技术的引领者。为了达到高性能的 JavaScript 代码执行效率从而获得更好的网页浏览效果，V8 采用直接将 JavaScript 编译成本地代码的方式。V8 支持众多的操作系统，包括但是不限于 Windows、Linux、Android、Mac OS X 等。同时它也是能够支持众多的硬件架构，例如 IA32、X64、ARM、MIPS 等。</p><h2 id="SpiderMonkey"><a href="#SpiderMonkey" class="headerlink" title="SpiderMonkey"></a>SpiderMonkey</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Mozilla/Projects/SpiderMonkey/Releases">SpiderMonkey</a> 是 Mozilla 使用 C/C++ 编写的 JavaScript 引擎。它被用于包括 Firefox 在内的多个 Mozilla 产品中，使用的是 MPL 2 授权协议。</p><h2 id="Rhino"><a href="#Rhino" class="headerlink" title="Rhino"></a>Rhino</h2><p><a href="https://github.com/mozilla/rhino">Rhino</a> 是一个完全使用Java语言编写的开源JavaScript实现，由 Mozilla 开发。Rhino 通常用于在 Java 程序中，为最终用户提供脚本化能力。它被作为J2SE 6上的默认Java脚本化引擎。</p><h2 id="Nashorn"><a href="#Nashorn" class="headerlink" title="Nashorn"></a>Nashorn</h2><p>从 JDK 1.8 开始，<a href="https://github.com/openjdk/nashorn">Nashorn</a> 取代 Rhino(JDK 1.6, JDK1.7) 成为 Java 的嵌入式 JavaScript 引擎。Nashorn 完全支持 ECMAScript 5.1 规范以及一些扩展。它使用基于 JSR 292 的新语言特性，其中包含在 JDK 7 中引入的 invokedynamic，将 JavaScript 编译成 Java 字节码。从 Java15 开始，Nashorn 已经不被默认包含在 JDK 中。</p><h2 id="JerryScript"><a href="#JerryScript" class="headerlink" title="JerryScript"></a>JerryScript</h2><p><a href="https://github.com/jerryscript-project/jerryscript">JerryScript</a> 是三星推出的适用于嵌入式设备的小型 Javascript 引擎。</p><h2 id="KJS"><a href="#KJS" class="headerlink" title="KJS"></a>KJS</h2><p><a href="https://kde.org/">KDE</a> 下的 <a href="https://github.com/KDE/konqueror">Konqueror</a> 浏览器采用了 <a href="https://github.com/KDE/kjs">KJS</a>作为js引擎</p><h2 id="Narcissus"><a href="#Narcissus" class="headerlink" title="Narcissus"></a>Narcissus</h2><p><a href="https://github.com/mozilla/narcissus">Narcissus</a> 是一款用纯 Javascript 编写的 js 引擎，被用作 Javascript 新功能快速原型的一个测试平台。已停止更新。</p><h2 id="Tamarin"><a href="#Tamarin" class="headerlink" title="Tamarin"></a>Tamarin</h2><p>在 2006 年 11 月 7 日，Adobe Systems 宣布将 ActionScript Virtual Machine 的代码捐献给 Mozilla Foundation。因此，Mozilla 启动了一个新的开放源码项目 <a href="https://github.com/Mangon/tamarin-redux">Tamarin</a>。Adobe 和 Mozilla 希望以此促进这种创建 Web 应用程序的标准化语言的推广。Tamarin 项目的目标是实现一个高性能的开放源码的 ECMAScript 第四版（ES4）语言规范实现。已停止更新。</p><h2 id="QuickJS"><a href="#QuickJS" class="headerlink" title="QuickJS"></a>QuickJS</h2><p><a href="https://github.com/bellard/quickjs">QuickJS</a> 是一款小型嵌入式 Javascript 引擎，使用C编写，只有 210KB，支持大部分 ES2020 语法。</p><h2 id="Hermes"><a href="#Hermes" class="headerlink" title="Hermes"></a>Hermes</h2><p><a href="https://github.com/facebook/hermes">Hermes</a> 是一款对 RN 应用快速启动进行了优化的 Javascript 引擎，由 facebook 支持。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript中call,apply,bind的作用&amp;模拟实现</title>
      <link href="/blog/2020/03/31/JS-Javascript%E4%B8%ADcall,apply,bind%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/"/>
      <url>/blog/2020/03/31/JS-Javascript%E4%B8%ADcall,apply,bind%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="call-apply-bind的作用"><a href="#call-apply-bind的作用" class="headerlink" title="call,apply,bind的作用"></a>call,apply,bind的作用</h2><p>都是Function的原型方法</p><p><strong>Function.prototype.bind()</strong></p><p>bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p><p><strong>Function.prototype.apply()</strong></p><p>apply() 方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。</p><p><strong>Function.prototype.call()</strong></p><p>call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。</p><p>call() 方法的语法和作用与 apply() 方法类似，只有一个区别，就是 call() 方法接受的是一个参数列表，而 apply() 方法接受的是一个包含多个参数的数组。</p><p>bind() 方法和call方法的不同之处在于，bind() 方法返回一个新的函数，而call方法会直接调用此函数。</p><span id="more"></span><h2 id="call-的模拟实现"><a href="#call-的模拟实现" class="headerlink" title="call 的模拟实现"></a>call 的模拟实现</h2><p><strong>Function.prototype.call()</strong></p><p>call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。  </p><p>我们所要做的和注意的有以下几点：  </p><ol><li>call 函数是 Function 的一个原型方法</li><li>call 改变了原函数 this 的指向，this 变成了给定的第一个参数</li><li>call 函数的第一个参数应该是对象或者能转换成对象</li><li>该函数执行了，并返回了结果</li><li>给出多个参数时，从第二个参数到最后一个参数作为函数的实参进行调用</li><li>call 的第一个参数可以传 null/undefined，当为 null/undefined 的时候，视为指向全局对象</li></ol><p>实际实现如下：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">call</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="title class_">Object</span>(context) || <span class="variable language_">window</span>; <span class="comment">// 1 当context为 字符串、数字或布尔值时进行转换 2 传null/undefined时指向window</span></span><br><span class="line">    <span class="keyword">var</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (context[<span class="string">&#x27;_fn&#x27;</span> + id]) &#123;</span><br><span class="line">        id++;</span><br><span class="line">    &#125;</span><br><span class="line">    context[<span class="string">&#x27;_fn&#x27;</span> + id] = <span class="variable language_">this</span>; <span class="comment">// 为 context 添加新方法，避免context已有同名方法需要找到不重复的函数名</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="variable language_">arguments</span>.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">        args.<span class="title function_">push</span>(<span class="string">&#x27;arguments[&#x27;</span> + i + <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">    &#125; <span class="comment">// 拼接从第二个参数到最后一个参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result = <span class="built_in">eval</span>(<span class="string">&#x27;context._fn&#x27;</span> + id + <span class="string">&#x27;(&#x27;</span> + args + <span class="string">&#x27;)&#x27;</span>); <span class="comment">// 调用eval执行函数，args 会自动调用 toString()转换为字符串</span></span><br><span class="line">    <span class="keyword">delete</span> context[<span class="string">&#x27;_fn&#x27;</span> + id]; <span class="comment">// 删除添加的属性</span></span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">// 返回函数执行结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="apply-的模拟实现"><a href="#apply-的模拟实现" class="headerlink" title="apply 的模拟实现"></a>apply 的模拟实现</h2><p><strong>Function.prototype.apply()</strong></p><p>apply() 方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。  </p><p>apply的模拟实现和call类似，需要注意的是apply的第二个参数是一个数组（或类似数组对象）。  </p><p>实际实现如下：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">apply</span> = <span class="keyword">function</span>(<span class="params">context, arr</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="title class_">Object</span>(context) || <span class="variable language_">window</span>;</span><br><span class="line">    <span class="keyword">var</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (context[<span class="string">&#x27;_fn&#x27;</span> + id]) &#123;</span><br><span class="line">        id++;</span><br><span class="line">    &#125;</span><br><span class="line">    context[<span class="string">&#x27;_fn&#x27;</span> + id] = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="keyword">if</span> (!arr) &#123;</span><br><span class="line">        result = context[<span class="string">&#x27;_fn&#x27;</span> + id]();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> arr !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;CreateListFromArrayLike called on non-object&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> args = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">           args.<span class="title function_">push</span>(<span class="string">&#x27;arr[&#x27;</span> + i + <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="built_in">eval</span>(<span class="string">&#x27;context._fn&#x27;</span> + id + <span class="string">&#x27;(&#x27;</span> + args + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> context[<span class="string">&#x27;_fn&#x27;</span> + id];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bind-的模拟实现"><a href="#bind-的模拟实现" class="headerlink" title="bind 的模拟实现"></a>bind 的模拟实现</h2><p><strong>Function.prototype.bind()</strong></p><p>bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p><p>我们所要做的和注意的有以下几点：  </p><ol><li>bind 函数是 Function 的一个原型方法</li><li>直接调用时 bind 改变了 this 的指向，this 变成了给定的第一个参数</li><li>bind 函数的第一个参数应该是对象或者能转换成对象</li><li>bind 函数返回的是一个函数而不是函数执行的结果</li><li>给出多个参数时，从第二个参数到最后一个参数作为函数的实参进行调用</li><li>bind 返回的函数在调用时，可以继续添加参数</li><li>当 bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效。</li></ol><p>实际实现如下：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span> = <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span> || <span class="keyword">function</span> (<span class="params">context</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123; <span class="comment">// </span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">var</span> slice = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>;</span><br><span class="line">    <span class="keyword">var</span> args = slice.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>); <span class="comment">// 获取bind函数从第二个参数到最后一个参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fNOP = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fBound = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> bindArgs = slice.<span class="title function_">call</span>(<span class="variable language_">arguments</span>); <span class="comment">// 这个时候的 arguments 是指 fBound 函数传入的参数</span></span><br><span class="line">        <span class="keyword">return</span> self.<span class="title function_">apply</span>(<span class="variable language_">this</span> <span class="keyword">instanceof</span> fBound ? <span class="variable language_">this</span> : context, args.<span class="title function_">concat</span>(bindArgs)); <span class="comment">// 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fNOP.<span class="property"><span class="keyword">prototype</span></span> = <span class="variable language_">this</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">    fBound.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">fNOP</span>(); <span class="comment">// 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值</span></span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="es5-shim"><a href="#es5-shim" class="headerlink" title="es5-shim"></a>es5-shim</h2><p>完整的模拟实现参考 <a href="https://github.com/es-shims/es5-shim">es5-shim</a> </p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> bind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>作为一个面试官应该思考的问题</title>
      <link href="/blog/2019/12/26/CS-%E4%BD%9C%E4%B8%BA%E4%B8%80%E4%B8%AA%E9%9D%A2%E8%AF%95%E5%AE%98%E5%BA%94%E8%AF%A5%E6%80%9D%E8%80%83%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/blog/2019/12/26/CS-%E4%BD%9C%E4%B8%BA%E4%B8%80%E4%B8%AA%E9%9D%A2%E8%AF%95%E5%AE%98%E5%BA%94%E8%AF%A5%E6%80%9D%E8%80%83%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="我需要什么样的同事"><a href="#我需要什么样的同事" class="headerlink" title="我需要什么样的同事"></a>我需要什么样的同事</h2><p>招人首先应该明确招收人的性质。看，如果我需要的是一个技术专家我肯定不会提出和实习生一样的要求。如果我只是要招收一个打杂的人，我也不会要求他非得具有研究生学历。成本是很好的衡量一个人价值的方法，当老板（或者你自己就是老板）告诉你有一个HC时，首先应当明确的是这是一个什么样的HC。</p><span id="more"></span><h3 id="我需要知道他的薪资范围-amp-职级"><a href="#我需要知道他的薪资范围-amp-职级" class="headerlink" title="我需要知道他的薪资范围&amp;职级"></a>我需要知道他的薪资范围&amp;职级</h3><p>薪资应该与要求匹配，你可以对比下和他一样的的同事的薪资，然后确定要招收的这个人的能力水平。如果薪资无法知道，那就用职级对比。</p><h3 id="我需要明确他在团队中的角色"><a href="#我需要明确他在团队中的角色" class="headerlink" title="我需要明确他在团队中的角色"></a>我需要明确他在团队中的角色</h3><p>有的人天生就是很好的实干家，而有的人却善于组织和沟通。一个团队的人一定不是一个模子里刻印出来的，它需要各式各样的人来组成一个有机体，明确需要一个什么角色的人很重要。需要注意的是，在一个技术团队中，首先是技术要过关，其次才会考虑角色因素。需要考虑的角色因素有很多，一个有机的、可紧密联合的团队，要考虑职级，性格，性别，年龄等多种因素。职级的配比要正常，一个高职级的人最多可与5个左右的低一级别的人构成很好的小团队，更多的人就要考虑进行拆分。一个团队整体的氛围和人的性格是息息相关的，一个团队的人如果都性格相近很容易就会融合在一起，凝聚力更强，但是团队效率却不如性格上合理配比，互相补充高。性别也是需要考虑的因素，虽然没有严格的性格比推荐，但是走向极端是很不合适的。年龄上，虽然不是绝对，但还是有一些需要注意的地方，比如通常，比一个年纪比自己小的人领导很可能会让人不愉快；如果没有和自己相近年龄的人，可能会觉得被孤立。</p><h3 id="我需要知道他未来要承担的任务"><a href="#我需要知道他未来要承担的任务" class="headerlink" title="我需要知道他未来要承担的任务"></a>我需要知道他未来要承担的任务</h3><p>对的人做对的事，如果这个人对于他未来在团队中要承担的任务十分的了解（通常之前做过类似的事），那最好不过。</p><h2 id="他需要有什么样的能力"><a href="#他需要有什么样的能力" class="headerlink" title="他需要有什么样的能力"></a>他需要有什么样的能力</h2><p>优秀的人有很多种，完美的人却几乎是不存在的。每个人都有自己的特色和引以为傲的地方，但没有十全十美的人。当我们想要招收一个人时，必须有取有舍。我认为，一个优秀的人，一个我想要和他一起工作的人，应当具备以下能力。</p><h3 id="持续学习的能力"><a href="#持续学习的能力" class="headerlink" title="持续学习的能力"></a>持续学习的能力</h3><p>世界变化很快，技术更是如此，无论技术上多么强大的人，如果不懂得学习，几年后也会一无是处。他应当有自己的学习计划和学习的途径，有的人喜欢读书，有的人习惯从论坛学习，但无论如何他都应当有自己的一套计划并能坚持下去。</p><h3 id="解决问题的能力"><a href="#解决问题的能力" class="headerlink" title="解决问题的能力"></a>解决问题的能力</h3><p>事实上，工作就是不停的在解决问题。如果他接到一个问题后不知道从哪里入手，那就实在太糟糕了。他可以去搜索（他得知道搜索什么关键词），可以去询问（如果别人会告诉他），也可以自己摸索着解决（如果知道从哪里开始）。总之，他得有一套自己的方法。如何评判解决问题的能力？要知道，有时解决问题的方法不只一种，最终采取哪一种这和自身的经验&amp;习惯有关系。我觉得在不违背价值观的前提下，当然是越快速的找到越简单的正确答案最好。</p><h3 id="正常沟通的能力"><a href="#正常沟通的能力" class="headerlink" title="正常沟通的能力"></a>正常沟通的能力</h3><p>沟通是理解和表达的合集。<br>一个有能力的人应该可以理解对方的诉求，获取到对方真正的含义。这个能力通常在需求调研的时候用的最多，开发者需要聆听产品经理/用户的诉求，然后在脑中将其转换成一段段的伪代码。当同事来找你的时候也应当尽快的了解到他的诉求，采取对应的办法。<br>表达能力也十分重要。如果能够表达的有顺序，有结构，有逻辑，理解起来也会更方便。有的人说起话来口若悬河，实际上却是一种在重复一件事，甚至翻来覆去表达重复的观点，那也是十分讨厌的。<br>聆听与表达，这两点是相辅相成的。其实我到不是希望每个同事都巧舌如簧，只希望和我一起工作的人能够听懂我的意思，同时让我理解他想要表达的观点。</p><h2 id="怎样才能鉴别出他是否是我想要的人"><a href="#怎样才能鉴别出他是否是我想要的人" class="headerlink" title="怎样才能鉴别出他是否是我想要的人"></a>怎样才能鉴别出他是否是我想要的人</h2><h3 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h3><p>简历是快速了解一个人的最佳方式，但通常简历上的字并不能完全相信。这也是最让人头痛的一个地方。我通常希望一个人在简历上描述清楚，自己做过什么，自己擅长什么。你不用担心他希望做什么，你放出了一个职位而他投出了他的简历，那就说明这个职位符合他的要求。在过滤简历的时候，你大可以把简历上的事情都当作事实，如果这样的一份简历还不能够入你的法眼，那完全不用进入下一步的考察。</p><h3 id="技术面试"><a href="#技术面试" class="headerlink" title="技术面试"></a>技术面试</h3><p>技术面试通常以简历中提到的能力和项目经验为主进行的扩展，作为前端，不可避免的会问到前端基础，包括CSS、HTML、JS、计算机网络、前端工程化。还有一些一定会问的问题包括，ES6语法，Git的使用。会针对面试者的简历，对他熟悉的框架进行提问（Vue React Angular 小程序 Electron）。nodejs、数据库有了解更好。</p><h3 id="能力面试"><a href="#能力面试" class="headerlink" title="能力面试"></a>能力面试</h3><p>一些通用的能力是职场中必备的，如果想要在职场中发展的更远，除了硬实力（技术与业务能力），还应当有一定的“软实力”。除了上面提到的“学习的能力”、“解决问题的能力”、“沟通的能力”。还有哪些能力是我比较看重的呢？排在第一位的是“目标”，我希望面试者有自己明确的目标与规划，短期的和长期的都有最好。我希望面试者有强大的执行力，对一件事能够坚持做下去，至少有那么一件事，无论是自己的爱好，还是坚持一个习惯。最后一个，我希望面试者有总结归纳的能力，这在回报和回顾的时候十分有用，不会总结归纳的人生活是杂乱无章的，也很难指望在工作中有什么亮点。</p><h2 id="能力面试题库"><a href="#能力面试题库" class="headerlink" title="能力面试题库"></a>能力面试题库</h2><p>能力面试一般采用 STAR 行为面试法， Situation Task Action Result。<br>以下是一些面试问题：</p><h4 id="客户为先"><a href="#客户为先" class="headerlink" title="客户为先"></a>客户为先</h4><ol><li>为了满足客户的需求，你在部门中推动了哪些变革？</li><li>请分享一个你关注客户需求来提升客户体验的具体事例。</li><li>请分享一个你需要平衡客户需求和公司需求的案例，你是如何处理这种情况的？结果如何？</li><li>请讲述一个你遇到客户投诉的例子？为什么遭到投诉？第一时间做了什么？最后结果如何？</li><li>请结合过往激励谈谈，你不断了解市场趋势和竞争对手，以更好地为客户提供服务的例子。</li></ol><h4 id="专业奋斗"><a href="#专业奋斗" class="headerlink" title="专业奋斗"></a>专业奋斗</h4><ol><li>说说你最近一个考核周期的业绩指标？达成情况如何？用了什么关键策略来达到目的？</li><li>你在工作中遇到的最难解决的问题是什么？如何解决的？结果怎么样？有什么收获？</li><li>你所在团队的高绩效人员的画像是什么样子的？你觉得你和他们的差距是什么？你认为应该如何补足？</li><li>请讲述一个你的工作方法论和专业经验有效帮助他人的经历？</li><li>要想成为领域级专家？你觉得需要在哪些方向努力提高？</li></ol><h4 id="持续创新"><a href="#持续创新" class="headerlink" title="持续创新"></a>持续创新</h4><ol><li>在你之前的工作中，你经历的最大变化是什么？当时是什么样的情况，你做了什么？为什么这样做？最后结果如何？</li><li>请分享一次你发现了现有方案的缺陷，并成功的提出改进方案的案例。</li><li>请分享你个人最具有冒险精神的一次经历，你是如何做出这个决定的？结果如何？你从中学到了什么？</li><li>假设你发现了一个可以提高公司效率的新想法，但这个想法与公司当前的做法相冲突，你会怎么做？</li><li>公司业务战略转型带来工作的各方面变化，你将会采取怎么样的做法和心态去应对变化？</li></ol><h4 id="高效执行"><a href="#高效执行" class="headerlink" title="高效执行"></a>高效执行</h4><ol><li>介绍一下你做过的最棘手的一个项目？是什么背景？你如何解决的？结果如何？</li><li>介绍一下你处理过的突发事件？是什么背景？你如何解决的？结果如何？</li><li>时间紧迫的情况下，你如何保证目标的达成，你做了哪些事情？结果如何？请举例说明。</li><li>如何理解高效执行？结合过往经历详细谈谈。</li><li>请分享一个在项目进行中遇到了困难，你仍然保质保量交付项目的案例。</li></ol><h4 id="沟通与影响"><a href="#沟通与影响" class="headerlink" title="沟通与影响"></a>沟通与影响</h4><ol><li>讲述一次你成功阐述个人观点并说服他人改变立场的经历，当时是什么场景？使用了什么方法？结果如何？</li><li>你遇到过的最难相处的人是谁？谈谈你和他接触的情况，你是如何处理的？结果如何？</li><li>请分享一次你成功处理冲突或危机的经历，你采取的行动和解决的方法时什么？最终结果怎么样？</li><li>举一个成功影响他人思考或行动的案例，你采取的策略是什么，反馈如何？</li><li>请讲一个你与其他部门或团队合作完成的成功项目，并描述你在其中扮演的角色？有什么收获？</li></ol><h4 id="学习能力"><a href="#学习能力" class="headerlink" title="学习能力"></a>学习能力</h4><ol><li>最近学习了什么新知识，新技术？是否应用到工作中？如何应用的？结果如何？</li><li>请描述一次你在工作中需要掌握新技能的经历，你具体是如何做到的？</li><li>请讲出一件你通过学习尽快胜任新的工作任务的案例？当时的任务是什么？你是如何解决的？结果如何？</li><li>目前你的技能和知识水平已经跟不上工作岗位要求了，你会采取哪些措施来填补自己的知识和技能缺口？</li><li>请讲述一次你通过学习新技术、新知识，帮助团队攻克难关的经历？</li></ol><h4 id="扎实"><a href="#扎实" class="headerlink" title="扎实"></a>扎实</h4><ol><li>请说说你当前岗位的工作职责和工作成果？考核指标是什么？完成率怎么样？</li><li>请分享拟在当前岗位工作期间最引以为豪的项目或产出？当时目标是什么？用了什么关键策略？</li><li>请分享一个失败的案例，当时的任务是什么？你是怎么做的？你的反思是什么？</li><li>当你的上级要求你完成一个看似不切实际的任务是，你会怎么做？</li></ol><h4 id="自驱"><a href="#自驱" class="headerlink" title="自驱"></a>自驱</h4><ol><li>最近一年你给自己设定的工作目标是什么样的？（区分是自己设定的，还是他人设定的，追问设定的标准是否够高）</li><li>请分享最近一次工作成果超预期的经历。</li><li>有时候领导安排的任务可能会高于我们的能力范围，请举例说明你是如何处理的？结果如何？</li><li>请分享一个你通过持续付出更大努力，取得了更卓越的成绩的案例。</li></ol><h4 id="创新"><a href="#创新" class="headerlink" title="创新"></a>创新</h4><ol><li>请讲述一个通过持续创新满足客户长期需求的案例。</li><li>你认为你所在的部门哪些制度和流程需要优化，为此你做了哪些努力和实际行动。</li><li>请分享一个在工作中用创新的方法完成任务的案例，当时是什么场景？用了什么方法？结果如何？</li><li>请讲述一个创新失败的例子？当时具体是什么情况？你做了哪些工作？你如何看待最终的结果？现在来看，你会怎么做？</li></ol><h4 id="自省"><a href="#自省" class="headerlink" title="自省"></a>自省</h4><ol><li>你觉得现在做哪一件事情可以提高你的工作效率？为什么？</li><li>你的职业生涯中最错误的决策是什么？为什么是这个？现在有什么感悟？</li><li>在同岗位的同事中，你觉得你的核心优势是什么？</li><li>你和你的领导有过最严重的分歧是什么？你现在怎么看这些分歧？</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm发包</title>
      <link href="/blog/2019/12/20/FE-npm%E5%8F%91%E5%8C%85/"/>
      <url>/blog/2019/12/20/FE-npm%E5%8F%91%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>本文记录了如何发布npm包到  http://registry.npmjs.org 的过程，完整的 npm 命令可以参考 <a href="https://docs.npmjs.com/cli-documentation/cli">npm CLI commands</a> 。</p><span id="more"></span><ol><li>创建待发包工程</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init [--force|-f|--yes|-y|--scope]</span><br></pre></td></tr></table></figure><p>npm init 创建了一个 package.json 描述 project 信息。<br>name 描述了待发布的 package 名。<br>version 描述了待发布的版本号。<br>dependencies 描述了该 project 所需要的依赖包，在发布前保证所有依赖在 npmjs.org 均可找到。  </p><ol start="2"><li>排除无需发布的文件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch .npmignore</span><br></pre></td></tr></table></figure><p>.npmignore 文件的写法和 .gitignore 文件的写法一样，可以将无需发布的文件路径添加到该文件中。  </p><ol start="3"><li>添加用户</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm adduser [--registry=http://registry.npmjs.com] [--scope=@orgname]</span><br></pre></td></tr></table></figure><p>该命令用来注册一个账户。它会提示你填写用户名密码和邮箱，然后（通过将你的验证信息存储在 .npmrc 文件中）自动登录，在 npmjs.org 发包需要验证邮箱。<br>你可以用 <code>npm logout</code> 命令登出，也可以用 <code>npm login</code> 命令再次登入。可以用 <code>npm who am i</code> 命令查看当前登录用户名。  </p><ol start="4"><li>预发包</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm pack</span><br></pre></td></tr></table></figure><p>该命令会根据当前配置将 project 打包为 <code>.tgz</code> 文件，可以使用 <code>npm install</code> + <code>.taz</code> 文件的路径测试是否打包正确。   </p><ol start="5"><li>发包</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure><p>默认发布的是公共包，如果包名带有 npm-scope ，那么默认发的是私有包，私有包在 npmjs 上发布需要收费，如果不想发私有包可以使用 <code>npm publish --access public</code> 发布公共包。<br>每次发布需要保证版本号有变更，如果包名和版本号已经存在那么会发布失败。  </p><ol start="6"><li>取消发包</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm unpublish</span><br></pre></td></tr></table></figure><p>可以使用以上命令取消发包，但是如果是不再支持某个包的话应该是用 <code>npm deprecate</code> 来表示不再支持。  </p>]]></content>
      
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫Scrapy</title>
      <link href="/blog/2019/08/21/HACK-Python%E7%88%AC%E8%99%ABScrapy/"/>
      <url>/blog/2019/08/21/HACK-Python%E7%88%AC%E8%99%ABScrapy/</url>
      
        <content type="html"><![CDATA[<h2 id="Scrapy简介"><a href="#Scrapy简介" class="headerlink" title="Scrapy简介"></a>Scrapy简介</h2><p><a href="https://scrapy.org/">Scrapy</a> 是一个开源的Python网络爬虫框架。源码在github上开源，<a href="https://github.com/scrapy/scrapy">地址</a>。Scrapy简单易学而且非常好用，支持配置、代理分布式爬取、容易扩展而且官方也很活跃。截止目前（2019年8月21日）最新版本为 v1.7.3 。  </p><span id="more"></span><h2 id="Scrapy-安装"><a href="#Scrapy-安装" class="headerlink" title="Scrapy 安装"></a>Scrapy 安装</h2><p>你需要先安装Python，Scrapy需要 Python 2.7 或者 Python 3.5+ ，通常MacOS会自带Python，其它系统需要自己安装，Python安装不再赘述。  </p><p>Scrapy由纯Python语言实现，但是需要依赖一些Python包，包括  </p><ul><li><a href="lxml.de">lxml</a>：一种高效的XML和HTML解析器，</li><li><a href="https://pypi.python.org/pypi/parsel">parsel</a>：一个HTML / XML数据提取库，基于上面的lxml，</li><li><a href="https://pypi.org/project/w3lib/">w3lib</a>：一种处理URL和网页编码多功能辅助</li><li><a href="https://twistedmatrix.com/trac/">twisted</a>：一个异步网络框架</li><li><a href="https://cryptography.io">cryptography</a> and <a href="https://pypi.org/project/pyOpenSSL/">pyOpenSSL</a>：处理各种网络级安全需求</li></ul><p>由于包依赖版本问题，建议首先安装 <a href="https://virtualenv.pypa.io">virtualenv</a> ，这是一个独立Python运行环境包。</p><ol><li>全局安装 virtualenv</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pip install virtualenv</span><br></pre></td></tr></table></figure><ol start="2"><li>创建独立Python运行环境</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ virtualenv ENV</span><br></pre></td></tr></table></figure><ol start="3"><li>安装Scrapy</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install scrapy</span><br></pre></td></tr></table></figure><p><strong> 在不同的平台上的安装步骤不尽相同，某些平台需要安装平台依赖包，具体请 <a href="https://docs.scrapy.org/en/latest/intro/install.html#intro-install-platform-notes">查看</a> </strong> </p><h2 id="Scrapy项目创建"><a href="#Scrapy项目创建" class="headerlink" title="Scrapy项目创建"></a>Scrapy项目创建</h2><ol><li>创建项目&amp;生成爬虫</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ scrapy startproject [PROJECT_NAME]</span><br><span class="line">$ cd [PROJECT_NAME]</span><br><span class="line">$ scrapy genspider [SPIDER_NAME] [START_SITE_NAME]</span><br></pre></td></tr></table></figure><p>[PROJECT_NAME] 是待创建的爬虫项目名<br>[SPIDER_NAME] 是爬虫名<br>[SITE_NAME] 是待爬取的初始站点地址</p><p>例如我们创建了一个名为 tutorial 的项目，并添加爬虫 top  </p><p>项目目录如下  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tutorial/</span><br><span class="line">|___scrapy.cfg            # 配置文件</span><br><span class="line">|___tutorial/             # 项目的 Python 模块，代码存在这里</span><br><span class="line">    |___ __init__.py</span><br><span class="line">    |___items.py          # 项目 items 定义文件</span><br><span class="line">    |___middlewares.py    # 项目 middlewares 文件</span><br><span class="line">    |___pipelines.py      # 项目 pipelines 文件</span><br><span class="line">    |___settings.py       # 项目 settings 文件</span><br><span class="line">    |___spiders/          # 爬虫文件目录</span><br><span class="line">        |___ __init__.py</span><br><span class="line">        |___top.py        # 爬虫文件</span><br></pre></td></tr></table></figure><p>打开 top.py 可以看到 Scrapy 爬虫文件结构  </p><ul><li><strong>name</strong> 爬虫名  </li><li><strong>allowed_domains</strong> 是允许爬取的域名  </li><li><strong>start_urls</strong> 开始爬取的链接  </li><li><strong>start_requests()</strong> 开始爬取的链接方法，需要返回 Requests 对象的遍历器或者 Reqeusts 数组  </li><li><strong>parse()</strong> 爬取后的处理方法  </li></ul><h2 id="settings-修改"><a href="#settings-修改" class="headerlink" title="settings 修改"></a>settings 修改</h2><p>可以在 settings.py 文件中看到常用设置: </p><ul><li><strong>USER_AGENT</strong> request的 <code>user-agent</code> header 中的 user-agent 参数  </li><li><strong>ROBOTSTXT_OBEY</strong> 是否遵守robots.txt协议，默认 <code>True</code>  </li><li><strong>CONCURRENT_REQUESTS</strong> 最大并发请求数量  </li><li><strong>DEFAULT_REQUEST_HEADERS</strong> 覆盖默认请求header 参数</li><li><strong>SPIDER_MIDDLEWARES</strong> 爬虫中间件  </li><li><strong>DOWNLOADER_MIDDLEWARES</strong> 下载中间件  </li><li><strong>ITEM_PIPELINES</strong> 设置pipeline调用顺序  </li></ul><h2 id="使用-shell-命令分析待爬取网站"><a href="#使用-shell-命令分析待爬取网站" class="headerlink" title="使用 shell 命令分析待爬取网站"></a>使用 shell 命令分析待爬取网站</h2><p>shell命令是Scrapy提供的交互式页面分析工具，类似于一个debug工具，你可以先使用shell分析待爬取的页面然后再执行爬虫。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy shell [SITE_NAME]</span><br></pre></td></tr></table></figure><p>shell命令将会采用settings里的配置来请求地址 [SITE_NAME] ，以下列出一些常用分析命令  </p><ul><li><strong>scrapy</strong> scrapy模块，包括scrapy.Request, scrapy.Selector等  </li><li><strong>crawler</strong> scrapy.crawler.Crawler object  </li><li><strong>response</strong> 返回的响应object</li><li><strong>request</strong> 请求的object</li><li><strong>settings</strong> 请求的设置</li><li><strong>view(response)</strong> 在浏览器中查看获取到页面  </li><li><strong>fetch(url[, redicrect=True])</strong> 重新获取url内容并更新当前object</li><li><strong>fetch(req)</strong> 获取一个 scrapy.Request 并更新当前object</li></ul><p><code>view(response)</code> 可以在浏览器中查看页面结构。<br>如果返回的结构和我们期待的有所不同，可以通过 <code>request.replace()</code> 进行修改，例如修改请求方法 <code>request.replace(method=&#39;POST&#39;)</code><br><code>fetch(req)</code> 常用在对request或settings进行了修改然后重新请求。<br><code>response</code> 是返回的响应体，这通常是我们需要分析的东西，如果分析的是html，首先最好先执行 <code>view(response)</code> 在浏览器中查看页面结构，找到我们需要获取的 文本/链接 位置。<br>然后使用 xpath选择器 或者 css选择器 定位我们需要获取的 文本/链接 位置。<br>例如采用 css选择器 且我们需要获取页面中的所有链接，则可以执行<br> <code>response.css(&#39;a::attr(href).getall()&#39;)</code><br>如果获取title文本则可以执行<br> <code>response.css(&#39;title::text&#39;).get(default=&#39;&#39;)</code><br><code>fetch(url)</code> 常用来获取下一个待分析的链接<br>这样就构成了一个完整闭环  </p><p>另外我们也可以通过<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from pprint import pprint</span><br><span class="line">pprint(response.headers)</span><br></pre></td></tr></table></figure><br>来打印相应object  </p><h2 id="Scrapy-Items"><a href="#Scrapy-Items" class="headerlink" title="Scrapy Items"></a>Scrapy Items</h2><p>通常我们需要爬取的都是结构化的数据，在 Scrapy 中被称为 Item，在 items.py 中我们需要定义需要爬取的字段，类似 Python dict</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = scrapy.Field()</span><br></pre></td></tr></table></figure><h2 id="Scrapy-Item-Pipeline"><a href="#Scrapy-Item-Pipeline" class="headerlink" title="Scrapy Item Pipeline"></a>Scrapy Item Pipeline</h2><p>Scrapy支持pipeline来对爬取到的数据进行类似于管道一样的一系列操作。<br>管道类一般用来进行以下几类操作：  </p><ul><li>清洗 HTML 数据</li><li>验证爬取到的数据（检查items包括特定的field）</li><li>检查重复数据</li><li>将爬取到的数据存储于数据库中</li></ul><p>包括以下几分方法</p><p><code>process_item(self, item, spider)</code></p><p>处理item，需要返回处理后的 data dict</p><p><code>open_spider(self, spider)</code></p><p>spider开始时触发的钩子</p><p><code>close_spider(self, spider)</code></p><p>spider结束时触发的钩子</p><p><code>from_crawler(cls, crawler)</code></p><p>类方法，可以通过 crawler.settings 获取 settings.py 里的配置信息</p><h2 id="运行爬虫"><a href="#运行爬虫" class="headerlink" title="运行爬虫"></a>运行爬虫</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scrapy crawl [SPIDER_NAME] [-o [FILE_NAME]]</span><br></pre></td></tr></table></figure><p>可以添加 <code>-o</code> 参数来输出为不同的文件例如 xml, csv, json 文件<br>爬取后的文件默认放到项目根目录下  </p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> scrapy </tag>
            
            <tag> crawler </tag>
            
            <tag> spider </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript常用校验规则</title>
      <link href="/blog/2019/08/14/JS-js%E5%B8%B8%E7%94%A8%E6%A0%A1%E9%AA%8C%E8%A7%84%E5%88%99/"/>
      <url>/blog/2019/08/14/JS-js%E5%B8%B8%E7%94%A8%E6%A0%A1%E9%AA%8C%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>以下列举些常用 javascript 校验规则  </p><span id="more"></span><h2 id="用户名"><a href="#用户名" class="headerlink" title="用户名"></a>用户名</h2><p>用户名的初衷一般是用户在应用中的唯一标志以及默认昵称，采用用户名不会明显地暴露用户在真实世界的个人隐私，同时因为用户名代表了用户在此应用中的唯一身份，应该易于记忆，而且能够体现出用户对自己身份的认同和特殊性（个性化）。<br>用户名允许的字符（包括种类和数量）太多会带来很多问题，也不利于管理，允许的字符太少不利于表达出用户的个性化  </p><p>百度账号以前允许的字符就很宽泛，允许单个汉字，甚至允许emoji字符，这充分给了用户表达自己个性的自由，但在不同的设备/应用上可能会有不同的表现，同时有些地方需要对用户名模糊处理（比如隐藏中间几个字符），百度账号难以处理。<br>目前百度的用户名规则为  </p><ul><li>不超过7个汉字或14个英文</li><li>仅支持中英文、数字和下划线</li><li>不能为纯数字</li></ul><p>腾讯的QQ号是随机数字，十分利于管理，但是因为是随机生成并分发给用户的，对于用户而言没有逻辑上的联想记忆，容易被用户忘记。<br>淘宝用户名被称为会员名，微信用户名被称为微信号，这两者账号是处理的比较好的，一般都是允许大小写字母，汉字，数字和_-#@等比较温和的特殊字符。比较不同的是淘宝以前注册时直接填写的是用户名，没有昵称概念，最近才提示要用户设置昵称。而微信注册时填写的就是昵称，用户名是随机生成的类似于 <code>wxid_oz2xxxxxxxxxxx</code> 的字符串，用户自己可以修改一次，改成易于记忆的用户名。  </p><p>当然现在很多账号弱化了用户名的概念，直接使用 <strong>电话号码/邮箱地址</strong> 作为用户名，例如美团(美团注册甚至不用https)，我个人觉得这是及其不合理的。  </p><ul><li>首先用户名也具有默认昵称的作用，会在应用的某些位置进行展示，甚至会被其它用户看到，采用电话号码/邮箱地址会暴露用户的个人隐私。</li><li>其次，电话号码并不能用来标志用户的唯一身份。我们都知道用户可能会经常变换电话号码，有些电话号码本身具有价值，用户甚至将电话号码作为财产的一部分进行赠予，但应用的账号并不一定需要同时转移所有权，而且如果用户的电话号码长时间未使用是有可能被电信运营商再次放入号池并售卖给其它个人的。这时如果电话号码新的用户登陆了原用户的账号就造成了严重的隐私泄漏事件。</li><li>最后，电话号码/邮箱地址是需要验证的，验证的操作其实需要用户主动去触发，但是在注册时，我们只能称之为游客，一个游客不应该有验证电话的权限（这正是短信轰炸的根源之一），发短信虽然成本很低，但不是没有成本，可能会有恶意游客利用这个功能。</li><li>最最后，如果一个游客没有邮箱没有电话就不能注册为你的用户了吗？虽然大部分情况下，绑定电话/邮箱的用户会是优质用户（说明用户愿意告知你他的部分隐私来提升你的应用账号安全性），但强制用户绑定手机号码/邮箱地址这显然不合理。  </li></ul><h2 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h2><p>不同的网站通常有自己的密码规则<br>例如百度的密码规则如下：  </p><ul><li>长度为8-14个字符</li><li>支持数字大小写字母和标点符号</li><li>不允许有空格</li><li>必须有数字、大写字母、小写字母、标点符号中至少两种</li></ul><p>实测</p><ul><li>汉字也是可以的，而且不受字符种类至少两种的限制  </li><li>对标点符号的容忍十分宽限，单引号双引号斜线反斜线都可以</li></ul><h2 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h2><p>邮箱通常是 字母数字小数点下划线@域名</p><h2 id="电话号码"><a href="#电话号码" class="headerlink" title="电话号码"></a>电话号码</h2><p>分为移动电话和固定电话<br>移动电话类似固定前三位数字选择，总共11位数字<br>中国需要加上区号 +86 其它国家地区有不同区号</p><h2 id="url地址"><a href="#url地址" class="headerlink" title="url地址"></a>url地址</h2><p>通常指http协议地址，以 http:// 或 https:// 开头，后跟域名，端口号（可选），路径，问号，url参数，hash</p><h2 id="居民身份证"><a href="#居民身份证" class="headerlink" title="居民身份证"></a>居民身份证</h2><p>通常为18位数字，前六位代表地区，中间八位代表生日，后四位代表编号，最后一位可以为X</p><h2 id="IPv4地址"><a href="#IPv4地址" class="headerlink" title="IPv4地址"></a>IPv4地址</h2><p>四个 0-255 之间的数字，以 . 连接</p><h2 id="国内常用账号注册地址"><a href="#国内常用账号注册地址" class="headerlink" title="国内常用账号注册地址"></a>国内常用账号注册地址</h2><p><a href="https://passport.baidu.com/v2/?reg">百度</a><br><a href="https://reg.taobao.com/member/reg/  fill_mobile.htm">淘宝</a><br><a href="https://ssl.zc.qq.com/v3/index-chs.html">QQ</a><br><a href="https://reg.jd.com/p/regPage">京东</a><br><a href="http://passport.meituan.com/account/unitivesignup">美团</a><br><a href="https://cn.account.xiaomi.com/pass/register">小米</a><br><a href="https://login.dangdang.com/Register.aspx">当当</a><br><a href="https://id1.cloud.huawei.com/CAS/portal/userRegister/regbyphone.html">华为</a><br><a href="https://weibo.com/signup/signup.php">新浪微博</a></p><h2 id="常用的校验库"><a href="#常用的校验库" class="headerlink" title="常用的校验库"></a>常用的校验库</h2><p>可参考：</p><p>https://github.com/any86/any-rule</p><p>https://github.com/validatorjs/validator.js</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> regexp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node server常用npm库</title>
      <link href="/blog/2019/08/12/FE-node-server%E5%B8%B8%E7%94%A8npm%E5%BA%93/"/>
      <url>/blog/2019/08/12/FE-node-server%E5%B8%B8%E7%94%A8npm%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>以下列举一些 node server 常用npm库：  </p><ul><li><a href="https://github.com/expressjs/express">express</a>: nodejs server web框架</li><li><a href="https://github.com/koajs/koa">koa</a>: nodejs server web框架 采用es6 async调用方式</li><li><a href="https://github.com/Automattic/mongoose">mongoose</a>: MongoDB 对象建模库  </li><li><a href="https://github.com/jdesboeufs/connect-mongo">connect-mongo</a>: MongoDB 会话存储库(连接池)，支持Express  </li><li><a href="https://github.com/tj/co">co</a>: 基于es6的generator及yield用同步的形式编写异步代码  </li><li><a href="https://github.com/motdotla/dotenv">dotenv</a>: 从.env文件自动加载环境变量  </li><li><a href="https://github.com/remy/nodemon">nodemon</a>: node守护进程  </li><li><a href="https://github.com/Unitech/pm2">pm2</a>: nodejs应用生产环境进程管理库  </li><li><a href="https://github.com/tjunnone/npm-check-updates">npm-check-updates</a>: 检查package是否有新版本  </li><li><a href="https://github.com/dylang/npm-check">npm-check</a>: 检查package是否有过时版本  </li><li><a href="https://github.com/jaredhanson/passport">passport</a>: 身份认证库  </li><li><a href="https://github.com/jaredhanson/passport-local">passport-local</a>: 身份认证本地认证策略  </li><li><a href="https://github.com/helmetjs/helmet">helmet</a>: 通过修改header来减少安全问题的库  </li><li><a href="https://github.com/winstonjs/winston">winston</a>: 生产环境日志记录  </li><li><a href="https://github.com/nock/nock">nock</a>: HTTP 服务器请求模拟库  </li><li><a href="https://github.com/expressjs/body-parser">body-parser</a>: body解析 <strong>express中间件</strong>  </li><li><a href="https://github.com/expressjs/cookie-parser">cookie-parser</a>: cookie解析 <strong>express中间件</strong>  </li><li><a href="https://github.com/expressjs/compression">compression</a>: gzip压缩  <strong>express中间件</strong>  </li><li><a href="https://github.com/expressjs/session">express-session</a>: session控制 <strong>express中间件</strong>  </li><li><a href="https://github.com/expressjs/csurf">csurf</a>: 避免csrf安全问题 <strong>express中间件</strong></li><li><a href="https://github.com/expressjs/cors">cors</a>: 跨域 <strong>express中间件</strong>  </li><li><a href="https://github.com/expressjs/morgan">morgan</a>: 请求日志记录 <strong>express中间件</strong>  </li><li><a href="https://github.com/expressjs/multer">multer</a>: 文件上传 <strong>express中间件</strong>  </li><li><a href="https://github.com/expressjs/method-override">method-override</a>: 协议头复写 <strong>express中间件</strong>  </li><li><a href="https://github.com/nodemailer/nodemailer">nodemailer</a>: 支持通过 Node.js 发送邮件</li><li><a href="https://github.com/kelektiv/node-cron">node-cron</a>: Node.js 定时任务库</li><li><a href="https://github.com/indexzero/nconf">nconf</a>: 支持文件、环境变量、命令行参数和原子对象合并的分层 Node.js 配置</li><li><a href="https://github.com/kentcdodds/cross-env">cross-env</a>: 跨平台环境变量设置</li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB 小抄</title>
      <link href="/blog/2019/08/05/MongoDB-cheatsheet/"/>
      <url>/blog/2019/08/05/MongoDB-cheatsheet/</url>
      
        <content type="html"><![CDATA[<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p><a href="https://www.mongodb.com/">MongoDB</a> 是一个基于分布式文件存储的数据库，截止当前日期（2019-08-05） 最新版本是 MongoDB 4.0。MongoDB由 C++ 语言编写，旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。<br>MongoDB 将数据存储为一个文档，数据结构由键值对(key=&gt;value)组成。 MongoDB 文档类型似于 JSON 对象。字段值可以包含其他文档，数组及文档数组等。<br>你可以在 MongoDB 官网 <a href="https://www.mongodb.com/download-center/community">下载安装包</a>。<br>MongoDB可视化工具有 <a href="https://robomongo.org/">Robomongo</a> 等。<br>MongoDB的文档写的很好可惜没有中文版的，英语不错的同学可以直接访问 <a href="https://docs.mongodb.com/">MongoDB文档官网</a>  </p><!-- more --><h2 id="MongoDB-命令"><a href="#MongoDB-命令" class="headerlink" title="MongoDB 命令"></a>MongoDB 命令</h2><p>Windows系统下的命令如下，其他系统类似：</p><ol><li>运行Mongo服务器</li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">mongodb</span>\<span class="title">bin</span>\<span class="title">mongod</span> --<span class="title">dbpath</span> <span class="title">c</span>:\<span class="title">data</span>\<span class="title">db</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>启动命令行界面连接MongoDB(打开MongoDB Shell)</li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">mongodb</span>\<span class="title">bin</span>\<span class="title">mongo.exe</span> --<span class="title">port</span> 28015</span></span><br></pre></td></tr></table></figure><p>默认连接27017端口，可以通过 <code>--port</code> 指定端口<br>可以通过 <code>--host &lt;host&gt;:&lt;port&gt;</code> 指定连接远程实例  </p><ol start="3"><li>安装MongoDB服务</li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">mongodb</span>\<span class="title">bin</span>\<span class="title">mongod.exe</span> --<span class="title">config</span> &quot;<span class="title">C</span>:\<span class="title">mongodb</span>\<span class="title">mongod.cfg</span>&quot; --<span class="title">install</span></span></span><br></pre></td></tr></table></figure><ol start="4"><li>启用MongoDB服务</li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">net</span> <span class="built_in">start</span> MongoDB</span><br></pre></td></tr></table></figure><ol start="5"><li>关闭MongoDB服务</li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">net</span> stop MongoDB</span><br></pre></td></tr></table></figure><ol start="6"><li>移除MongoDB服务</li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">mongodb</span>\<span class="title">bin</span>\<span class="title">mongod.exe</span> --<span class="title">remove</span></span></span><br></pre></td></tr></table></figure><h2 id="MongoDB-概念解析"><a href="#MongoDB-概念解析" class="headerlink" title="MongoDB 概念解析"></a>MongoDB 概念解析</h2><table><thead><tr><th>SQL概念</th><th>MongoDB概念</th><th>解释</th></tr></thead><tbody><tr><td>database</td><td>database</td><td>数据库</td></tr><tr><td>table</td><td>collection</td><td>表/集合</td></tr><tr><td>row</td><td>document</td><td>行/文档</td></tr><tr><td>column</td><td>field</td><td>列or字段/域</td></tr><tr><td>index</td><td>index</td><td>索引</td></tr><tr><td>primary key</td><td>primary key</td><td>主键，MongoDB自动将 _id 域设置为主键</td></tr></tbody></table><h3 id="Database"><a href="#Database" class="headerlink" title="Database"></a>Database</h3><p>一个mongodb中可以创建多个数据库。<br>MongoDB的默认数据库为”db”，该数据库存储在data目录中。<br>MongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中。<br>数据库名可以是满足以下条件的任意UTF-8字符串。  </p><ul><li>不能是空字符串（””)。</li><li>不得含有’ ‘（空格)、.、$、/、\和\0 (空字符)。</li><li>应全部小写。</li><li>最多64字节。</li></ul><p>有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。  </p><table><thead><tr><th>数据库名</th><th>作用</th></tr></thead><tbody><tr><td>admin</td><td>从权限的角度来看，这是”root”数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。</td></tr><tr><td>local</td><td>这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合</td></tr><tr><td>config</td><td>当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。</td></tr></tbody></table><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p>集合就是 MongoDB 文档组。<br>集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。  </p><p>合法的集合名需要满足以下条件。  </p><ul><li>集合名不能是空字符串””。</li><li>集合名不能含有\0字符（空字符)，这个字符表示集合名的结尾。</li><li>集合名不能以”system.”开头，这是为系统集合保留的前缀。</li><li>用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的集合，否则千万不要在名字里出现$。</li></ul><h3 id="Document"><a href="#Document" class="headerlink" title="Document"></a>Document</h3><p>文档是一组键值(key-value)对(即 BSON )。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。  </p><p>需要注意的是：</p><ul><li>文档中的键/值对是有序的。</li><li>文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。</li><li>MongoDB区分类型和大小写。</li><li>MongoDB的文档不能有重复的键。</li><li>文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。</li></ul><p>文档键命名规范：</p><ul><li>键不能含有\0 (空字符)。这个字符用来表示键的结尾。<br>.和$有特别的意义，只有在特定环境下才能使用。</li><li>以下划线”_”开头的键是保留的(不是严格要求的)。</li></ul><h3 id="BSON-Types"><a href="#BSON-Types" class="headerlink" title="BSON Types"></a>BSON Types</h3><p>BSON是一种在MongoDB中使用的用来存储文档和进行远程存储过程调用二进制序序列化格式。</p><table><thead><tr><th>类型</th><th>数字</th><th>别名</th><th>备注</th></tr></thead><tbody><tr><td>Double</td><td>1</td><td>“double”</td><td>双精度浮点值。用于存储浮点值。</td></tr><tr><td>String</td><td>2</td><td>“string”</td><td>字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。</td></tr><tr><td>Object</td><td>3</td><td>“object”</td><td>用于内嵌文档。</td></tr><tr><td>Array</td><td>4</td><td>“array”</td><td>用于将数组或列表或多个值存储为一个键。</td></tr><tr><td>Binary data</td><td>5</td><td>“binData”</td><td>二进制数据。用于存储二进制数据。</td></tr><tr><td>Undefined</td><td>6</td><td>“undefined”</td><td>废除</td></tr><tr><td>ObjectId</td><td>7</td><td>“objectId”</td><td>对象 ID。用于创建文档的 ID。</td></tr><tr><td>Boolean</td><td>8</td><td>“bool”</td><td>布尔值。用于存储布尔值（真/假）。</td></tr><tr><td>Date</td><td>9</td><td>“date”</td><td>日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息</td></tr><tr><td>Null</td><td>10</td><td>“null”</td><td>用于创建空值。</td></tr><tr><td>Regular Expression</td><td>11</td><td>“regex”</td><td>正则表达式类型。用于存储正则表达式。</td></tr><tr><td>DBPointer</td><td>12</td><td>“dbPointer”</td><td>废除</td></tr><tr><td>JavaScript</td><td>13</td><td>“javascript”</td><td>代码类型。用于在文档中存储 JavaScript 代码。</td></tr><tr><td>Symbol</td><td>14</td><td>“symbol”</td><td>废除</td></tr><tr><td>JavaScript (with scope)</td><td>15</td><td>“javascriptWithScope”</td><td>-</td></tr><tr><td>32-bit integer</td><td>16</td><td>“int”</td><td>23位整型数值。用于存储数值</td></tr><tr><td>Timestamp</td><td>17</td><td>“timestamp”</td><td>时间戳。记录文档修改或添加的具体时间。</td></tr><tr><td>64-bit integer</td><td>18</td><td>“long”</td><td>64位整型数值。用于存储数值</td></tr><tr><td>Decimal128</td><td>19</td><td>“decimal”</td><td>3.4版本新加</td></tr><tr><td>Min key</td><td>-1</td><td>“minKey”</td><td>-</td></tr><tr><td>Max key</td><td>127</td><td>“maxKey”</td><td>-</td></tr></tbody></table><h4 id="ObjectId"><a href="#ObjectId" class="headerlink" title="ObjectId"></a>ObjectId</h4><p>ObjectId 类似唯一主键，可以很快的去生成和排序，包含 12 bytes:</p><ul><li>前 4 个字节表示文档创建时间 unix 时间戳</li><li>中间 5 个字节是随机数</li><li>最后 3 个字节是以随机数开始的计数器</li></ul><p>MongoDB 中存储的文档必须有一个 _id 键。这个键的值可以是任何类型的，默认是个 ObjectId 对象</p><p>由于 ObjectId 中保存了创建的时间戳，所以你可以通过 <code>ObjectId().getTimestamp()</code> 函数来获取创建时间:  </p><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>BSON 字符串只能是 UTF-8 编码。<br>内部 sort() 方法使用了 C++ 的 strcmp API，所以部分排序可能并不正确。  </p><h4 id="Timestamp"><a href="#Timestamp" class="headerlink" title="Timestamp"></a>Timestamp</h4><p>Timestamp是用在MongoDB内部的时间戳类型。  </p><ul><li>前 32 位是一个 time_t 值（与Unix新纪元相差的秒数）</li><li>后 32 位是在某秒中操作的一个递增的序数</li></ul><h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><p>BSON Date 是一个64位整型，表示当前距离 Unix新纪元（1970年1月1日）的毫秒数。日期类型是有符号的, 负数表示 1970 年之前的日期。  </p><h2 id="MongoDB-连接"><a href="#MongoDB-连接" class="headerlink" title="MongoDB 连接"></a>MongoDB 连接</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongodb://[username:password@]host1[:port1][,...hostN[:portN]][/[database][?options]]</span><br></pre></td></tr></table></figure><ul><li><p><strong>mongodb://</strong> mongodb协议头。</p></li><li><p><strong>username:password@</strong> 可选项，如果设置，在连接数据库服务器之后，驱动都会尝试登录这个数据库。</p></li><li><p><strong>hostX</strong> 必须的指定至少一个host, host1 是这个URI唯一要填写的。它指定了要连接服务器的地址。如果要连接复数集，请指定多个主机地址。</p></li><li><p><strong>portX</strong> 可选的指定端口，如果不填，默认为27017。</p></li><li><p><strong>/database</strong> 如果指定username:password@，连接并验证登录指定数据库。若不指定，默认打开 test 数据库。</p></li><li><p><strong>?options</strong> 是连接选项。如果不使用/database，则前面需要加上/。所有连接选项都是键值对name=value，键值对之间通过&amp;或;（分号）隔开。</p></li></ul><h2 id="MongoDB-shell-方法"><a href="#MongoDB-shell-方法" class="headerlink" title="MongoDB shell 方法"></a>MongoDB shell 方法</h2><p>参见<a href="https://docs.mongodb.com/manual/reference/method/index.html">mongo Shell Methods</a>，以下列举一些常用的方法：  </p><h3 id="数据库-Database-相关"><a href="#数据库-Database-相关" class="headerlink" title="数据库(Database)相关"></a>数据库(Database)相关</h3><h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use DATABASE_NAME</span><br></pre></td></tr></table></figure><h4 id="查看所有数据库"><a href="#查看所有数据库" class="headerlink" title="查看所有数据库"></a>查看所有数据库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show dbs</span><br></pre></td></tr></table></figure><h4 id="查看当前数据库名"><a href="#查看当前数据库名" class="headerlink" title="查看当前数据库名"></a>查看当前数据库名</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db</span><br></pre></td></tr></table></figure><h4 id="删除当前数据库"><a href="#删除当前数据库" class="headerlink" title="删除当前数据库"></a>删除当前数据库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.dropDatabase()</span><br></pre></td></tr></table></figure><h4 id="查看当前数据库状态"><a href="#查看当前数据库状态" class="headerlink" title="查看当前数据库状态"></a>查看当前数据库状态</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.stats()</span><br></pre></td></tr></table></figure><h3 id="集合-Collection-相关"><a href="#集合-Collection-相关" class="headerlink" title="集合(Collection)相关"></a>集合(Collection)相关</h3><h4 id="创建集合-视图"><a href="#创建集合-视图" class="headerlink" title="创建集合/视图"></a>创建集合/视图</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.createCollection(&lt;name&gt;, &lt;options&gt;)</span><br></pre></td></tr></table></figure><ul><li><strong>name</strong>: 要创建的集合名称</li><li><strong>options</strong>: 可选参数，指定有关内存大小及索引的选项</li></ul><p>options 可以是如下参数：  </p><table><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>capped</td><td>布尔</td><td>（可选）如果为 true，则创建固定集合。固定集合是指有着固定大小的集合，当达到最大值时，它会自动覆盖最早的文档。<strong>当该值为 true 时，必须指定 size 参数。</strong></td></tr><tr><td>autoIndexId</td><td>布尔</td><td>（可选）如为 true，自动在 _id 字段创建索引。默认为 false。</td></tr><tr><td>size</td><td>数值</td><td>（可选）为固定集合指定一个最大值（以字节计）。<strong>如果 capped 为 true，也需要指定该字段。</strong></td></tr><tr><td>max</td><td>数值</td><td>（可选）指定固定集合中包含文档的最大数量。</td></tr></tbody></table><h4 id="查看当前Database下所有集合"><a href="#查看当前Database下所有集合" class="headerlink" title="查看当前Database下所有集合"></a>查看当前Database下所有集合</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show collections</span><br><span class="line">show tables</span><br></pre></td></tr></table></figure><h4 id="删除集合"><a href="#删除集合" class="headerlink" title="删除集合"></a>删除集合</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.drop()</span><br></pre></td></tr></table></figure><h3 id="文档-Document-相关"><a href="#文档-Document-相关" class="headerlink" title="文档(Document)相关"></a>文档(Document)相关</h3><h4 id="插入文档"><a href="#插入文档" class="headerlink" title="插入文档"></a>插入文档</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.insert(&lt;document&gt;)</span><br><span class="line">db.COLLECTION_NAME.insertOne(&lt;document&gt;)</span><br><span class="line">db.COLLECTION_NAME.insertMany(&lt;document&gt;)</span><br></pre></td></tr></table></figure><p>如果 COLLECTION_NAME 该集合不在该数据库中， MongoDB 会自动创建该集合并插入文档.  </p><ul><li><strong>document</strong>: 待插入的文档</li></ul><h4 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.update(</span><br><span class="line">   &lt;filter&gt;,</span><br><span class="line">   &lt;update&gt;,</span><br><span class="line">   &lt;options&gt;</span><br><span class="line">)</span><br><span class="line">db.COLLECTION_NAME.updateOne(...)</span><br><span class="line">db.COLLECTION_NAME.updateMany(...)</span><br></pre></td></tr></table></figure><ul><li><strong>filter</strong> : update的查询条件。</li><li><strong>update</strong> : update的对象和一些更新的操作符（如$,$inc…）等。</li><li><strong>options</strong> : 可选参数，指定更新文档的选项</li></ul><p>options可以是如下参数：  </p><table><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>upsert</td><td>boolean</td><td>可选，这个参数的意思是，如果不存在update的记录，是否插入objNew，true为插入，默认是false，不插入</td></tr><tr><td>multi</td><td>boolean</td><td>可选，mongodb 默认是false，只更新找到的第一条记录，如果这个参数为true，就把按条件查出来多条记录全部更新</td></tr><tr><td>writeConcern</td><td>document</td><td>可选，写级别</td></tr><tr><td>collation</td><td>document</td><td>可选，数据的校验</td></tr><tr><td>arrayFilters</td><td>[&lt;filterdocument1\>,…]</td><td>可选，文档过滤器的数组</td></tr></tbody></table><h4 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.remove(&lt;query&gt;, &lt;options&gt;)</span><br></pre></td></tr></table></figure><ul><li><strong>query</strong> : 删除的查询条件。</li></ul><p>options可以是如下参数：  </p><table><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>justOne</td><td>boolean</td><td>可选，true的话只删除第一个找到的文档。默认 false，删除所有符合query的文档</td></tr><tr><td>writeConcern</td><td>document</td><td>可选，写级别</td></tr><tr><td>collation</td><td>document</td><td>可选，数据的校验</td></tr></tbody></table><h4 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.find(&lt;query&gt;, &lt;projection&gt;)</span><br><span class="line">db.COLLECTION_NAME.findOne(...)</span><br></pre></td></tr></table></figure><ul><li><strong>query</strong> : 查询的条件。</li><li><strong>projection</strong> : 可选，表明文档中需要返回的符合query过滤器的域，忽略此参数时返回所有的域</li></ul><h3 id="索引-Index-相关"><a href="#索引-Index-相关" class="headerlink" title="索引(Index)相关"></a>索引(Index)相关</h3><p>MongoDB 索引使用 B-tree 数据结构。MongoDB 会在集合创建时建立唯一索引 <code>_id</code> 且不能删除。MongoDB可以创建复合索引。</p><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.createIndex( &lt;keys&gt;, &lt;options&gt; )</span><br></pre></td></tr></table></figure><ul><li><strong>keys</strong> 健值对文档，指定索引的字段和排序方式</li><li><strong>options</strong> 可选参数，指定有关索引的其它选项</li></ul><p>options可以是如下参数：  </p><table><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>background</td><td>boolean</td><td>可选，指定是否在后台创建索引，默认false</td></tr><tr><td>unique</td><td>boolean</td><td>可选，指定是否是唯一索引，默认false</td></tr><tr><td>name</td><td>string</td><td>可选，指定索引名。不提供的话，MongoDB会将索引名和排序方式连接来生成索引名</td></tr><tr><td>partialFilterExpression</td><td>document</td><td>可选，若提供则仅对符合过滤表达式的文档建立索引</td></tr><tr><td>sparse</td><td>boolean</td><td>可选，若提供则仅针对提供的field进行索引，这样的话索引占用空间会更小，但对非指定的field进行排序会有影响，默认false</td></tr><tr><td>expireAfterSeconds</td><td>integer</td><td>可选，提供一个秒为单位的数字来控制索引的存在时间</td></tr><tr><td>storageEngine</td><td>document</td><td>可选</td></tr><tr><td>collation</td><td>document</td><td>可选，表明索引的排序规则</td></tr></tbody></table><h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.dropIndex(&lt;index name&gt;)</span><br><span class="line">db.COLLECTION_NAME.dropIndexes() // 删除所有索引</span><br></pre></td></tr></table></figure><h4 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.getIndexes()</span><br></pre></td></tr></table></figure><h4 id="强制使用指定索引"><a href="#强制使用指定索引" class="headerlink" title="强制使用指定索引"></a>强制使用指定索引</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.find(&lt;query&gt;).hint(&lt;string or document&gt;)</span><br><span class="line">db.COLLECTION_NAME.find( &#123; $query: &#123;&#125;, $hint: &lt;string or document&gt; &#125; )</span><br></pre></td></tr></table></figure><h3 id="其它常用"><a href="#其它常用" class="headerlink" title="其它常用"></a>其它常用</h3><h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.aggregate(pipeline, options)</span><br></pre></td></tr></table></figure><p>用于通过管道计算集合/视图数据的聚合结果。  </p><ul><li><strong>pipeline</strong> 可以取 聚合管道步骤 的操作符</li><li><strong>options</strong> 可选参数，指定有关聚合的其它选项</li></ul><h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.find(&lt;query&gt;).pretty()</span><br></pre></td></tr></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.find(&lt;query&gt;).sort(&#123;&lt;field&gt;: &lt;positive integer&gt;&#125;)</span><br></pre></td></tr></table></figure><p>将结果根据field进行排序，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而 -1 是用于降序排列。  </p><h4 id="限制返回条数"><a href="#限制返回条数" class="headerlink" title="限制返回条数"></a>限制返回条数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.find(&lt;query&gt;).limit(&lt;positive integer&gt;)</span><br></pre></td></tr></table></figure><p>限制返回n条数据</p><h4 id="跳过固定条数数据"><a href="#跳过固定条数数据" class="headerlink" title="跳过固定条数数据"></a>跳过固定条数数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.find(&lt;query&gt;).skip(&lt;positive integer&gt;)</span><br></pre></td></tr></table></figure><p>跳过固定n条数数据</p><h4 id="查看执行计划"><a href="#查看执行计划" class="headerlink" title="查看执行计划"></a>查看执行计划</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.find(&lt;query&gt;).explain()</span><br><span class="line">db.COLLECTION_NAME.find( &#123; $query: &#123;&#125;, $explain: 1 &#125; )</span><br><span class="line">db.COLLECTION_NAME.explain().find(&lt;query&gt;)</span><br></pre></td></tr></table></figure><h3 id="MongoDB-操作符"><a href="#MongoDB-操作符" class="headerlink" title="MongoDB 操作符"></a>MongoDB 操作符</h3><p>MongoDB 操作符分为</p><ul><li>查询与预测操作符</li><li>更新操作符</li><li>聚合管道步骤</li><li>聚合管道操作符</li><li>查询修饰符</li></ul><p>以下列举常用的一些操作符</p><table><thead><tr><th>名称</th><th>类型</th><th>描述</th><th>语法</th></tr></thead><tbody><tr><td><code>$eq</code></td><td>比较</td><td>equal 值相等</td><td><code>&#123; &lt;field&gt;: &#123; $eq: &lt;value&gt; &#125; &#125;</code></td></tr><tr><td><code>$gt</code></td><td>比较</td><td>greater than 值大于</td><td><code>&#123; &lt;field&gt;: &#123;$gt: &lt;value&gt;&#125; &#125;</code></td></tr><tr><td><code>$gte</code></td><td>比较</td><td>greater than equal 值大于等于</td><td><code>&#123; &lt;field&gt;: &#123;$gte: &lt;value&gt;&#125; &#125;</code></td></tr><tr><td><code>$in</code></td><td>比较</td><td>值存在于</td><td><code>&#123; &lt;field&gt;: &#123; $in: [&lt;value1&gt;, &lt;value2&gt;, ... &lt;valueN&gt; ] &#125; &#125;</code></td></tr><tr><td><code>$lt</code></td><td>比较</td><td>less than 值小于</td><td><code>&#123; &lt;field&gt;: &#123;$lt: &lt;value&gt;&#125; &#125;</code></td></tr><tr><td><code>$lte</code></td><td>比较</td><td>less than equal 值小于等于</td><td><code>&#123; &lt;field&gt;: &#123; $lte: &lt;value&gt;&#125; &#125;</code></td></tr><tr><td><code>$ne</code></td><td>比较</td><td>not equal 值不等于</td><td><code>&#123; &lt;field&gt;: &#123;$ne: &lt;value&gt;&#125; &#125;</code></td></tr><tr><td><code>$nin</code></td><td>比较</td><td>not in 值不存在于</td><td><code>&#123; &lt;field&gt;: &#123; $nin: [ &lt;value1&gt;, &lt;value2&gt; ... &lt;valueN&gt; ]&#125; &#125;</code></td></tr><tr><td><code>$and</code></td><td>逻辑</td><td>与，跟表达式数组，表达式之间是与关系</td><td><code>&#123; $and: [ &#123; &lt;expression1&gt; &#125;, &#123; &lt;expression2&gt; &#125; , ... , &#123; &lt;expressionN&gt; &#125; ] &#125;</code></td></tr><tr><td><code>$not</code></td><td>逻辑</td><td>非，跟操作符表达式</td><td><code>&#123; &lt;field&gt;: &#123; $not: &#123; &lt;operator-expression&gt; &#125; &#125; &#125;</code></td></tr><tr><td><code>$nor</code></td><td>逻辑</td><td>异或，跟表达式数组，表达式之间是异或关系</td><td>{ <code>$nor: [ &#123; &lt;expression1&gt; &#125;, &#123; &lt;expression2&gt; &#125;, ...  &#123; &lt;expressionN&gt; &#125; ] &#125;</code></td></tr><tr><td><code>$or</code></td><td>逻辑</td><td>或，跟表达式数组，表达式之间是或关系</td><td><code>&#123; $or: [ &#123; &lt;expression1&gt; &#125;, &#123; &lt;expression2&gt; &#125;, ... , &#123; &lt;expressionN&gt; &#125; ] &#125;</code></td></tr><tr><td><code>$exists</code></td><td>元素</td><td>表示field是否存在</td><td><code>&#123; &lt;field&gt;: &#123; $exists: &lt;boolean&gt; &#125; &#125;</code></td></tr><tr><td><code>$type</code></td><td>元素</td><td>表示field需要符合列出的BSON类型，<code>&lt;BSON type&gt;</code>可以是 <a href="#BSON-Types">BSON Types</a> 的别名或者数字</td><td><code>&#123; &lt;field&gt;: &#123; $type: &lt;BSON type&gt; &#125; &#125;</code> <br> <code>&#123; &lt;field&gt;: &#123; $type: [ &lt;BSON type1&gt; , &lt;BSON type2&gt;, ... ] &#125; &#125;</code></td></tr><tr><td><code>$where</code></td><td>评估</td><td><code>$where</code> 查询操作符只对最顶层的document生效，会执行javascript但不走索引，所以尽量先使用其它操作符对数据进行过滤</td><td><code>&#123;$where: function() &#123;&lt;code&gt; return true;&#125;&#125;</code></td></tr><tr><td><code>$all</code></td><td>数组</td><td>field应当是数组，过滤出包含所有给定数组中值的field</td><td><code>&#123; &lt;field&gt;: &#123; $all: [ &lt;value1&gt; , &lt;value2&gt; ... ] &#125; &#125;</code></td></tr><tr><td><code>$elemMath</code></td><td>数组</td><td>field应当是数组，过滤出至少有一个元素符合所有给定表达式的field</td><td><code>&#123; &lt;field&gt;: &#123; $elemMatch: &#123; &lt;query1&gt;, &lt;query2&gt;, ... &#125; &#125; &#125;</code></td></tr><tr><td><code>$size</code></td><td>数组</td><td>field应当是数组，过滤出所有元素数量符合size的field</td><td><code>&#123; &lt;field&gt;: &#123; $size: &lt;positive integer&gt; &#125; &#125;</code></td></tr><tr><td><code>$comment</code></td><td>评论</td><td>为查询添加注释</td><td><code>&#123; &lt;query&gt;, $comment: &lt;comment&gt; &#125;</code></td></tr><tr><td><code>$sort</code></td><td>聚合</td><td>排序，根据给定的field和排序规则对结果进行排序，<code>&lt;sort order&gt;</code>有两种取值，1代表asc，-1代表desc</td><td><code>&#123; $sort: &#123; &lt;field1&gt;: &lt;sort order&gt;, &lt;field2&gt;: &lt;sort order&gt; ... &#125; &#125;</code></td></tr><tr><td><code>$limit</code></td><td>聚合</td><td>限制取前n个数据</td><td><code>&#123; $limit: &lt;positive integer&gt; &#125;</code></td></tr><tr><td><code>$skip</code></td><td>聚合</td><td>跳过n个数据</td><td><code>&#123; $skip: &lt;positive integer&gt; &#125;</code></td></tr><tr><td><code>$group</code></td><td>聚合</td><td>分组，通过特定表达式与输出将文档分成不同的group</td><td><code>&#123; $group: &#123; _id: &lt;expression&gt;, &lt;field1&gt;: &#123; &lt;accumulator1&gt; : &lt;expression1&gt; &#125;, ... &#125; &#125;</code></td></tr></tbody></table><h2 id="事务与原子性"><a href="#事务与原子性" class="headerlink" title="事务与原子性"></a>事务与原子性</h2><p>MongoDB在 4.0版本之后支持了多文档事务，并且计划在4.2版本支持分布式事务。  </p><p>在MongoDB中，对单文件的操作是原子性的。4.0之后通过复制集合的方式支持了多文档事务。多文档事务支持跨多操作、集合、数据库以及文档，但是大部分情况下相比于单文档写会导致巨大的性能消耗。官方仍旧推荐嵌入式的文档模型而不是多文档事务。而且多文档事务限制较多，具体限制可以查看 <a href="https://docs.mongodb.com/manual/core/transactions/">事务文档</a> 。  </p><p>只有存储引擎 WiredTiger 支持 多文档事务，内存数据引擎或 MMAPv1 存储引擎不支持。  </p><p>事务例子如下：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start a session.</span></span><br><span class="line">session = db.<span class="title function_">getMongo</span>().<span class="title function_">startSession</span>( &#123; <span class="attr">readPreference</span>: &#123; <span class="attr">mode</span>: <span class="string">&quot;primary&quot;</span> &#125; &#125; );</span><br><span class="line"></span><br><span class="line">employeesCollection = session.<span class="title function_">getDatabase</span>(<span class="string">&quot;hr&quot;</span>).<span class="property">employees</span>;</span><br><span class="line">eventsCollection = session.<span class="title function_">getDatabase</span>(<span class="string">&quot;reporting&quot;</span>).<span class="property">events</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start a transaction</span></span><br><span class="line">session.<span class="title function_">startTransaction</span>( &#123; <span class="attr">readConcern</span>: &#123; <span class="attr">level</span>: <span class="string">&quot;snapshot&quot;</span> &#125;, <span class="attr">writeConcern</span>: &#123; <span class="attr">w</span>: <span class="string">&quot;majority&quot;</span> &#125; &#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Operations inside the transaction</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   employeesCollection.<span class="title function_">updateOne</span>( &#123; <span class="attr">employee</span>: <span class="number">3</span> &#125;, &#123; <span class="attr">$set</span>: &#123; <span class="attr">status</span>: <span class="string">&quot;Inactive&quot;</span> &#125; &#125; );</span><br><span class="line">   eventsCollection.<span class="title function_">insertOne</span>( &#123; <span class="attr">employee</span>: <span class="number">3</span>, <span class="attr">status</span>: &#123; <span class="attr">new</span>: <span class="string">&quot;Inactive&quot;</span>, <span class="attr">old</span>: <span class="string">&quot;Active&quot;</span> &#125; &#125; );</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">   <span class="comment">// Abort transaction on error</span></span><br><span class="line">   session.<span class="title function_">abortTransaction</span>();</span><br><span class="line">   <span class="keyword">throw</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Commit the transaction using write concern set at transaction start</span></span><br><span class="line">session.<span class="title function_">commitTransaction</span>();</span><br><span class="line"></span><br><span class="line">session.<span class="title function_">endSession</span>();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
            <tag> database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小技巧</title>
      <link href="/blog/2019/06/19/TIPS-%E5%BC%80%E5%8F%91%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/blog/2019/06/19/TIPS-%E5%BC%80%E5%8F%91%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>本篇主要记录一些小技巧或者开发过程中遇到的小问题和解决方案。这些问题实在太小了而且大部分可能和代码没有关系，不好每次都单独列一篇文章，所以放到一起了。</p><span id="more"></span><h2 id="在eclipse中设置字体"><a href="#在eclipse中设置字体" class="headerlink" title="在eclipse中设置字体"></a>在eclipse中设置字体</h2><p>在eclipse中设置 Windows-&gt;Preferences-&gt;General-&gt;Appearance-&gt;Color and Fonts-&gt;Basic-&gt;Text Font-&gt;Edit-&gt;脚本(R) 选择 <code>中欧字符</code> 后中文字体的显示能够更好看些。</p><h2 id="处理-nginx-php-遇到后端返回413错误"><a href="#处理-nginx-php-遇到后端返回413错误" class="headerlink" title="处理 nginx + php 遇到后端返回413错误"></a>处理 nginx + php 遇到后端返回413错误</h2><p>php 默认上传文件大小限制为 2M，如果超出 2M 你需要修改 php 配置文件 php.ini 里面的参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">post_max_size = 128M ## （表单提交的最大限制，此项不是限制上传单个文件的大小，而是针对整个表单提交的数据进行限制）</span><br><span class="line">upload_max_filesize = 128M ## （上传的单个文件的最大限制）</span><br></pre></td></tr></table></figure><p>需要保证 post_max_size &gt;= upload_max_filesize ，也就是前者不小于后者。修改之后一定要重启 php-fpm (service php-fpm restart)。</p><p>除了修改 php 配置，你也需要修改nginx配置文件 nginx.conf<br>打开 nginx 配置文件 nginx.conf，找到 http{} 段，在其中添加一行配置：<br>client_max_body_size 128m; 其中 128m 可以根据需要上传文件大小自行设定。<br>修改之后一定要重新载入 nginx （service nginx reload）。</p><h2 id="导入-导出-csv文件到mysql"><a href="#导入-导出-csv文件到mysql" class="headerlink" title="导入/导出 csv文件到mysql"></a>导入/导出 csv文件到mysql</h2><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>需要表存在且字段与csv文件中的相同</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA <span class="keyword">LOCAL</span> INFILE <span class="string">&#x27;$&#123;csv文件路径&#125;&#x27;</span></span><br><span class="line"><span class="keyword">INTO</span> <span class="keyword">TABLE</span> $&#123;数据库表名&#125;</span><br><span class="line"><span class="type">CHARACTER</span> <span class="keyword">SET</span>  utf8</span><br><span class="line">FIELDS</span><br><span class="line">    TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;,&#x27;</span></span><br><span class="line">    ENCLOSED <span class="keyword">BY</span> <span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">LINES</span><br><span class="line">    TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">IGNORE <span class="number">1</span> <span class="keyword">ROWS</span>;</span><br></pre></td></tr></table></figure><h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLES $&#123;数据库表名&#125; read;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> $&#123;数据库表名&#125; <span class="keyword">INTO</span> OUTFILE <span class="string">&#x27;$&#123;csv文件路径&#125;&#x27;</span> </span><br><span class="line">FIELDS</span><br><span class="line">    TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;,&#x27;</span></span><br><span class="line">    OPTIONALLY ENCLOSED <span class="keyword">BY</span> <span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">LINES</span><br><span class="line">    TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure><h2 id="导出csv文件到mysql报错"><a href="#导出csv文件到mysql报错" class="headerlink" title="导出csv文件到mysql报错"></a>导出csv文件到mysql报错</h2><h3 id="Error-1148"><a href="#Error-1148" class="headerlink" title="Error 1148"></a>Error 1148</h3><p>如果在执行语句时报错 <code>Error 1148 MySQL The used command is not allowed with this MySQL version</code> 可能是因为MySQL的安全策略阻止读取本地文件，可以通过以下方法解决：</p><ol><li>Use –local-infile=1 argument on the mysql commandline:</li></ol><p>When you start MySQL on the terminal, include –local-infile=1 argument, Something like this:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="comment">--local-infile=1 -uroot -p</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span>LOAD DATA <span class="keyword">LOCAL</span> INFILE <span class="string">&#x27;/tmp/foo.txt&#x27;</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> foo</span><br><span class="line">COLUMNS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\t&#x27;</span>;</span><br></pre></td></tr></table></figure><p>Then the command is permitted:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Query OK, <span class="number">3</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">Records: <span class="number">3</span>  Deleted: <span class="number">0</span>  Skipped: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure><ol><li>Or send the parameter into the mysql daemon:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --local-infile=1</span><br></pre></td></tr></table></figure><ol><li>Or set it in the my.cnf file (This is a security risk):</li></ol><p>Find your mysql my.cnf file and edit it as root.</p><p>Add the local-infile line under the mysqld and mysql designators:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">local-infile</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">local-infile</span><br></pre></td></tr></table></figure><p>Save the file, restart mysql. Try it again.</p><ol><li>The main reason why we are using the LOCAL keyword is explained in the MySQL manual. On the other hand, you do not need the FILE privilege to load local files. So if you in fact do have file access to the server then try to skip using the word “LOCAL” in SQL query, and instead copy the file to the server and the directory mysql/data/[tablename].</li></ol><h3 id="Error-1290"><a href="#Error-1290" class="headerlink" title="Error 1290"></a>Error 1290</h3><p>如果在执行语句时报错 <code>[Error Code] 1290 - The MySQL server is running with the --secure-file-priv option</code> 说明参数secure-file-priv 可能有问题</p><p>执行以下语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> &quot;secure_file_priv&quot;;</span><br></pre></td></tr></table></figure><p>可以看到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">secure_file_prive=null   -- 限制mysqld 不允许导入导出</span><br><span class="line">secure_file_priv=/tmp/   -- 限制mysqld的导入导出只能发生在/tmp/目录下</span><br><span class="line">secure_file_priv=&#x27;&#x27;     -- 不对mysqld 的导入/导出做限制</span><br></pre></td></tr></table></figure><p>可以在 my.ini（windows） 或 /etc/my.cnf(linux) 文件中的[mysqld]节点添加secure_file_priv=’’，然后重启mysql服务</p><h2 id="启动mysql报错error-11"><a href="#启动mysql报错error-11" class="headerlink" title="启动mysql报错error: 11"></a>启动mysql报错error: 11</h2><p>如果在启动mysql时遇到了 <code>[ERROR] InnoDB: Unable to lock ./ibdata1, error: 11</code><br>说明 ibdata1 文件被其他的进程占用 或者 磁盘空间目录不足，有以下解决方案：</p><ol><li>查看磁盘空间情况</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure><ol><li>查看系统 mysql 相关进程</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -eaf | grep mysql</span><br><span class="line">kill -9 78806</span><br></pre></td></tr></table></figure><p>如果语句执行正常但是返回 <code>0 row(s) affected</code> ，查看一下csv中的字段是否是否与表中的字段一致，区分大小写；查看一下csv文件的分隔符的设置是否正确。</p><h2 id="处理-mongoose-中-bson-MODULE-NOT-FOUND-相关报错"><a href="#处理-mongoose-中-bson-MODULE-NOT-FOUND-相关报错" class="headerlink" title="处理 mongoose 中 bson MODULE_NOT_FOUND 相关报错"></a>处理 mongoose 中 bson MODULE_NOT_FOUND 相关报错</h2><p>node.js 在使用 mongoose时报错 <code>[Error: Cannot find module &#39;../build/Release/bson&#39;] code: &#39;MODULE_NOT_FOUND&#39;</code></p><p>参见 https://github.com/Automattic/mongoose/issues/3436</p><p>应该是mongoose版本问题，理论上升级到最新版本可以解决，也可以按照以下步骤解决</p><ol><li>更改 bson 引用<br>找到 module mongodb ..node_modules\mongodb\node_modules\bson\ext\index.js<br>改变bson引用的路径</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bson = <span class="built_in">require</span>(<span class="string">&#x27;../build/Release/bson&#x27;</span>);</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bson = <span class="built_in">require</span>(<span class="string">&#x27;../browser_build/bson&#x27;</span>);</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bson = require(&#x27;bson&#x27;);</span><br></pre></td></tr></table></figure><ol start="2"><li>更改mongoose版本<br>将原有的mongoose升级为 <code>&quot;mongoose &quot;: &quot;~3.8.23&quot;</code></li></ol><h2 id="Python-报错-‘ascii’-codec-can’t-encode-characters-in-position-0-8：ordinal-not-in-range-128"><a href="#Python-报错-‘ascii’-codec-can’t-encode-characters-in-position-0-8：ordinal-not-in-range-128" class="headerlink" title="Python 报错 ‘ascii’ codec can’t encode characters in position 0-8：ordinal not in range(128)"></a>Python 报错 ‘ascii’ codec can’t encode characters in position 0-8：ordinal not in range(128)</h2><ol><li>第一步，别忘了给文件顶部加上</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure><ol start="2"><li>重新载入SYS模块并设置uft-8</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="使用nvm的前置脚本"><a href="#使用nvm的前置脚本" class="headerlink" title="使用nvm的前置脚本"></a>使用nvm的前置脚本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export NVM_DIR=&quot;$HOME/.nvm&quot;</span><br><span class="line">[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot;  # This loads nvm</span><br></pre></td></tr></table></figure><h2 id="快速启用httpserver"><a href="#快速启用httpserver" class="headerlink" title="快速启用httpserver"></a>快速启用httpserver</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m SimpleHTTPServer 8080</span><br></pre></td></tr></table></figure><h2 id="启动-mongodb-数据库服务"><a href="#启动-mongodb-数据库服务" class="headerlink" title="启动 mongodb 数据库服务"></a>启动 mongodb 数据库服务</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --dbpath=/users/</span><br></pre></td></tr></table></figure><h2 id="启动-redis-数据库"><a href="#启动-redis-数据库" class="headerlink" title="启动 redis 数据库"></a>启动 redis 数据库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure><h2 id="显示为大写字符，在选中复制后发现原文为包含大小写的字符"><a href="#显示为大写字符，在选中复制后发现原文为包含大小写的字符" class="headerlink" title="显示为大写字符，在选中复制后发现原文为包含大小写的字符"></a>显示为大写字符，在选中复制后发现原文为包含大小写的字符</h2><p>如下所示：</p><div><style>@font-face {font-family:Bebas Neue;font-style: normal;font-weight: 400;font-display: swap;src: url(https://fonts.gstatic.com/s/bebasneue/v14/JTUSjIg69CK48gW7PXoo9Wdhyzbi.woff2) format(woff2);unicode-range: U+0100-02AF, U+0304, U+0308, U+0329, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face {font-family:Bebas Neue;font-style: normal;font-weight: 400;font-display: swap;src: url(https://fonts.gstatic.com/s/bebasneue/v14/JTUSjIg69CK48gW7PXoo9Wlhyw.woff2) format(woff2);unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}</style><div style="font-family: 'Bebas Neue', 'IBM Plex Mono', monospace;">Nullish Coalescing</div></div><p>原因是采用了 Bebas Nene 这款字体，这款字体对小写字符也显示成大写的样式。</p><h2 id="字符tooltip"><a href="#字符tooltip" class="headerlink" title="字符tooltip"></a>字符tooltip</h2><p><span title="显示的内容" style="background: lightyellow" >鼠标hover会显示tooltip</span></p><p>只需要设置下DOM元素的 <code>title</code> 属性</p><h2 id="node内部模块"><a href="#node内部模块" class="headerlink" title="node内部模块"></a>node内部模块</h2><p>从 Node.js 12.2.0 版本开始，支持使用 <code>const fs = require(&#39;node:fs&#39;);</code> 的写法。这种写法被称为 “内部模块”（Internal Modules）。</p><p>内部模块的目的是为了解决在 Node.js 中使用内置模块时可能出现的命名冲突问题。在旧的写法 <code>const fs = require(&#39;fs&#39;);</code> 中，如果你在项目中有一个名为 fs.js 的文件，那么 <code>require(&#39;fs&#39;)</code> 将会加载你的 fs.js 文件而不是 Node.js 的内置 fs 模块。</p><p>通过使用 <code>require(&#39;node:fs&#39;)</code>，你可以明确地指定要加载的是 Node.js 的内置 fs 模块，避免了命名冲突的问题。</p><p>需要注意的是，内部模块的写法只适用于 Node.js，不适用于浏览器端的 JavaScript。在浏览器端，仍然需要使用 <code>require(&#39;fs&#39;)</code> 的写法来加载模块。</p><h2 id="process-env-npm-lifecycle-event"><a href="#process-env-npm-lifecycle-event" class="headerlink" title="process.env.npm_lifecycle_event"></a>process.env.npm_lifecycle_event</h2><p>在 package.json 的 script 中书写了一个命令 “custom-command” 在 env.js 中通过”require(‘child_process’).execSync(‘npx another-command’)“ 执行了另外的命令。Nodejs 14 中 process.env.npm_lifecycle_event 会返回 custom-command 但在 Nodejs 16 中 process.env.npm_lifecycle_event 会返回 npx。</p><p>在 Node.js 14 中，process.env.npm_lifecycle_event 返回 “custom-command”，因为它只关注 npm 生命周期事件的名称。但在 Node.js 16 中，process.env.npm_lifecycle_event 返回 “npx”，因为它将整个命令行作为一个事件处理。</p><p>这个更改是为了提供更准确的事件处理信息，以便开发者能够更好地理解正在执行的命令。通过返回整个命令行，开发者可以知道是通过 npx 工具执行了哪个命令。</p><p>如果需要在 Node.js 16 中获取 “custom-command”，可以不调用 npx 直接执行 another-command 或者可以通过在 env.js 中传递参数的方式来实现。在 package.json 的 script 中，可以使用 – 来传递参数，然后在 env.js 中通过 process.argv 来获取这些参数。</p><figure class="highlight json"><figcaption><span>package.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;custom-command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node env.js --custom-command&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>env.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> args = process.<span class="property">argv</span>.<span class="title function_">slice</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> customCommand = args[<span class="number">0</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(customCommand); <span class="comment">// 输出 &quot;custom-command&quot;</span></span><br></pre></td></tr></table></figure><h2 id="error-0308010C-digital-envelope-routines-unsupported"><a href="#error-0308010C-digital-envelope-routines-unsupported" class="headerlink" title="error:0308010C:digital envelope routines::unsupported"></a>error:0308010C:digital envelope routines::unsupported</h2><p>运行 &gt;17 的 Nodejs 脚本时报错“error:0308010C:digital envelope routines::unsupported”，<br>因为高版本的 Nodejs crypto 模块 使用了 OpenSSL3.0，OpenSSL3.0 对允许的算法和密钥大小进行了限制，使用不允许的算法是会抛出 “error:0308010C:digital envelope routines::unsupported” 的错误，报错如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ERROR <span class="keyword">in</span> ./src/epmp-apps/epm_p/taskCenter/main/index.js</span><br><span class="line">Module build failed (from ./node_modules/thread-loader/dist/cjs.js):</span><br><span class="line">Thread Loader (Worker 2)</span><br><span class="line">error:0308010C:digital envelope routines::unsupported</span><br><span class="line">    at PoolWorker.fromErrorObj (D:\workspace\EPM_Front\node_modules\thread-loader\dist\WorkerPool.js:346:12)</span><br><span class="line">    at D:\workspace\EPM_Front\node_modules\thread-loader\dist\WorkerPool.js:219:29</span><br><span class="line">    at new Hash (node:internal/crypto/hash:69:19)</span><br><span class="line">    at Object.createHash (node:crypto:133:10)</span><br><span class="line">    at filename (D:\workspace\EPM_Front\node_modules\.store\babel-loader@8.2.2\node_modules\babel-loader\lib\cache.js:94:23)</span><br><span class="line">    at D:\workspace\EPM_Front\node_modules\.store\babel-loader@8.2.2\node_modules\babel-loader\lib\cache.js:120:39</span><br><span class="line">    at Generator.next (&lt;anonymous&gt;)</span><br><span class="line">    at asyncGeneratorStep (D:\workspace\EPM_Front\node_modules\.store\babel-loader@8.2.2\node_modules\babel-loader\lib\cache.js:3:103)</span><br><span class="line">    at _next (D:\workspace\EPM_Front\node_modules\.store\babel-loader@8.2.2\node_modules\babel-loader\lib\cache.js:5:194)</span><br><span class="line">    at D:\workspace\EPM_Front\node_modules\.store\babel-loader@8.2.2\node_modules\babel-loader\lib\cache.js:5:364</span><br><span class="line">    at new Promise (&lt;anonymous&gt;)</span><br><span class="line">    at D:\workspace\EPM_Front\node_modules\.store\babel-loader@8.2.2\node_modules\babel-loader\lib\cache.js:5:97</span><br></pre></td></tr></table></figure><p>可以直接在nodejs中运行相应的脚本查看对应报错：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">require</span>(<span class="string">&#x27;cryto&#x27;</span>).<span class="title function_">createHash</span>(<span class="string">&#x27;md4&#x27;</span>);</span><br><span class="line"><span class="title class_">Uncaught</span> <span class="title class_">Error</span>: <span class="attr">error</span>:0308010<span class="attr">C</span>:digital envelope <span class="attr">routines</span>::unsupported</span><br><span class="line">    at <span class="keyword">new</span> <span class="title class_">Hash</span> (<span class="attr">node</span>:internal/crypto/<span class="attr">hash</span>:<span class="number">69</span>:<span class="number">19</span>)</span><br><span class="line">    at <span class="title class_">Object</span>.<span class="property">createHash</span> (<span class="attr">node</span>:<span class="attr">crypto</span>:<span class="number">133</span>:<span class="number">10</span>) &#123;</span><br><span class="line">  <span class="attr">opensslErrorStack</span>: [ <span class="string">&#x27;error:03000086:digital envelope routines::initialization error&#x27;</span> ],</span><br><span class="line">  <span class="attr">library</span>: <span class="string">&#x27;digital envelope routines&#x27;</span>,</span><br><span class="line">  <span class="attr">reason</span>: <span class="string">&#x27;unsupported&#x27;</span>,</span><br><span class="line">  <span class="attr">code</span>: <span class="string">&#x27;ERR_OSSL_EVP_UNSUPPORTED&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OpenSSL 是一个强大的开源安全套接字层密码库，它提供了功能丰富的安全工具包用来处理对称与非对称加密算法、数字证书编解码等。Nodejs 的 crypto 模块就是用了 OpenSSL 的能力进行加解密的。Nodejs 从 17版本开始用了 OpenSSL3.0，OpenSSL 3.0 中提供了5个 Provider（表示算法实现的容器），其中：</p><ul><li>default: 默认，提供了所有标准的内置算法，如果没明确指定则将使用默认算法容器；</li><li>legacy: 遗留，意不常用或者被反对使用的算法，正常情况下不可用，除非现实的指定使用 legacy 容器;</li></ul><p>许多流行的库使用到了 <code>crypto.createHash(&quot;md4&quot;)</code> 来创建哈希串，所以在高版本 Nodejs 中执行会报错。</p><p>已知的库包括：<br><a href="mailto:babel-loader@8.2.4">babel-loader@8.2.4</a> 解决了该问题 Use md5 hashing for OpenSSL 3 by @pathmapper in #924<br><a href="mailto:webpack@4.47.0">webpack@4.47.0</a> 解决了该问题 [Security] - Add support for md4 in Node &gt;=18. by @iclanton in #17628<br><a href="mailto:webpack@5.61.0">webpack@5.61.0</a> 解决了该问题 use a wasm md4 implementation for node 17 support<br>@<a href="mailto:vue/cli-service@5.0.1">vue/cli-service@5.0.1</a> 支持了 <a href="mailto:webpack@5.61.0">webpack@5.61.0</a><br><a href="mailto:react-scripts@5.0.0">react-scripts@5.0.0</a> 支持了 <a href="mailto:webpack@5.61.0">webpack@5.61.0</a></p><p>如果遇到该问题我们可以：</p><ol><li>升级项目中所有依赖的库到解决该问题的版本</li><li>提供 legacy 容器环境，即执行脚本之前先执行 <code>cross-env NODE_OPTIONS=--openssl-legacy-provider</code>（安装 cross-env 以支持跨环境脚本）设置环境变量或者在系统环境变量中添加变量名为 <code>NODE_OPTIONS</code> 值为 <code>--openssl-legacy-provider</code> 的环境变量</li><li>降级 Nodejs 版本，降级到 Nodejs 16，在脚本中进行Nodejs版本检查，不符合要求时进行升级</li></ol><h2 id="在弹窗中使用-beautiful-react-dnd-时拖拽元素的位置时有不正确的偏移"><a href="#在弹窗中使用-beautiful-react-dnd-时拖拽元素的位置时有不正确的偏移" class="headerlink" title="在弹窗中使用 beautiful-react-dnd 时拖拽元素的位置时有不正确的偏移"></a>在弹窗中使用 beautiful-react-dnd 时拖拽元素的位置时有不正确的偏移</h2><p>原因是父元素弹窗使用了 transform 进行定位，而 beautiful-react-dnd 在定位元素时使用了 <code>position: fixed</code>，参见 MDN 对 fixed 属性的解释：</p><blockquote><blockquote><blockquote><p>元素会被移出正常文档流，并不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed 属性会创建新的层叠上下文。当元素祖先的 <code>transform</code>、<code>perspective</code>、<code>filter</code> 或 <code>backdrop-filter</code> 属性非 none 时，容器由视口改为该祖先。</p></blockquote></blockquote></blockquote><p>所以拖拽元素的 top,left 等属性的定位从浏览器改为了弹窗元素，但 beautiful-react-dnd 仍旧是以浏览器计算的，所以会出现问题，解决方案参见 https://github.com/atlassian/react-beautiful-dnd/issues/485#issuecomment-754398585 将拖动元素的 left 和 top 属性强制改为 auto。但是如果拖动的元素在可滚动的元素内时，一旦发生了滚动，此时位置又会出现错乱。解决办法为使用 <code>React.createPortal()</code> 将拖拽元素脱离文档流进行渲染。参见 https://github.com/atlassian/react-beautiful-dnd/blob/master/stories/src/portal/portal-app.jsx</p><h2 id="执行-npm-publish-时未发布到期待的源"><a href="#执行-npm-publish-时未发布到期待的源" class="headerlink" title="执行 npm publish 时未发布到期待的源"></a>执行 npm publish 时未发布到期待的源</h2><p>执行 <code>npm config set registry https://registry.npmjs.com/</code> 也不行，<br>在发布的目录新建 <code>.npmrc</code> 添加 <code>registry=https://registry.npmjs.com/</code> 然后执行 <code>npm publish</code> 也不行，<br>执行 <code>npm publish --registry=https://registry.npmjs.com/</code> 也不行。</p><p>最终执行 <code>npm config ls</code> 发现端倪，原来在 npm 用户配置中设置了针对于某个 scope 的 registry，而这个配置项的生效优先级更高，删除该项配置后即可正确发布到期待的源。</p><p>执行 <code>npm config ls</code> 的结果如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> D:\workspace\SEM\epm<span class="literal">-extend-core</span>&gt; npm config <span class="built_in">ls</span></span><br><span class="line">; <span class="string">&quot;global&quot;</span> config from D:\software\nodejs\etc\npmrc</span><br><span class="line"></span><br><span class="line">strict<span class="literal">-peer-dependencies</span> = false</span><br><span class="line"></span><br><span class="line">; <span class="string">&quot;user&quot;</span> config from C:\Users\Administrator\.npmrc</span><br><span class="line"></span><br><span class="line">@epmkit:registry = <span class="string">&quot;https://repo.yyrd.com/artifactory/api/npm/ynpm-all/&quot;</span></span><br><span class="line">//registry.npmjs.com/:_authToken = (protected)</span><br><span class="line">//registry.npmjs.org/:_authToken = (protected)</span><br><span class="line"></span><br><span class="line">; <span class="string">&quot;project&quot;</span> config from D:\workspace\SEM\epm<span class="literal">-extend-core</span>\.npmrc</span><br><span class="line"></span><br><span class="line">registry = <span class="string">&quot;https://registry.npmjs.org/&quot;</span></span><br><span class="line"></span><br><span class="line">; node bin location = D:\software\nodejs\node.exe</span><br><span class="line">; node version = v16.<span class="number">19.0</span></span><br><span class="line">; npm local prefix = D:\workspace\SEM\epm<span class="literal">-extend-core</span></span><br><span class="line">; npm version = <span class="number">8.19</span>.<span class="number">3</span></span><br><span class="line">; cwd = D:\workspace\SEM\epm<span class="literal">-extend-core</span></span><br><span class="line">; HOME = C:\Users\Administrator</span><br><span class="line">; Run `npm config <span class="built_in">ls</span> <span class="literal">-l</span>` to show all defaults.</span><br></pre></td></tr></table></figure><p>也可以仅执行 <code>npm config get userconfig</code> 或者 <code>npm config get globalconfig</code> 获取配置文件的位置</p><h2 id="globalThis-is-not-defined"><a href="#globalThis-is-not-defined" class="headerlink" title="globalThis is not defined"></a>globalThis is not defined</h2><p>globalThis 是 ES2020 引入的特性，globalThis 提供了一个标准的方式来获取不同环境下的全局 this 对象。例如在 Web 中，可以通过 window、self 或者 frames 取到全局对象，在 Web Workers 中，使用 self 。在 Node.js 中，使用 global。在某些环境中会报错 “globalThis is not defined” 通常是环境中没有 globalThis 变量。</p><ol><li>在严格模式中</li><li>在模块环境下</li><li>环境不支持 通常是兼容性问题，例如在 Chrome &lt; 71 的浏览器中并未支持 globalThis</li></ol><h2 id="unable-to-write-symref-for-HEAD-Permission-denied"><a href="#unable-to-write-symref-for-HEAD-Permission-denied" class="headerlink" title="unable to write symref for HEAD: Permission denied"></a>unable to write symref for HEAD: Permission denied</h2><p>在切换分支时报如此错误，通常是执行 git 命令的用户没有相应的权限</p><ol><li>以管理员权限执行 git 命令或打开执行 git 命令的软件（例如SourceTree）</li><li>打开文件夹属性-安全，赋予用户相应的权限</li></ol>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis支持的数据类型</title>
      <link href="/blog/2019/05/06/Redis-%E6%94%AF%E6%8C%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/blog/2019/05/06/Redis-%E6%94%AF%E6%8C%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>以下列举 <a href="https://redis.io/topics/data-types-intro">redis支持的数据类型</a> （截止2019-05-06 redis最新为5.0.4版本）  </p><span id="more"></span><h2 id="二进制安全的字符串（Binary-safe-strings）"><a href="#二进制安全的字符串（Binary-safe-strings）" class="headerlink" title="二进制安全的字符串（Binary-safe strings）"></a>二进制安全的字符串（Binary-safe strings）</h2><p>如字面意思。</p><h2 id="列表（Lists）"><a href="#列表（Lists）" class="headerlink" title="列表（Lists）"></a>列表（Lists）</h2><p>按照插入顺序排序的字符串元素的集合。基本上就是是链表（linked lists）。</p><h2 id="集合（Sets）"><a href="#集合（Sets）" class="headerlink" title="集合（Sets）"></a>集合（Sets）</h2><p>不重复且无序的的字符串元素集合。</p><h2 id="有序集合（Sorted-sets）"><a href="#有序集合（Sorted-sets）" class="headerlink" title="有序集合（Sorted sets）"></a>有序集合（Sorted sets）</h2><p>和集合（Sets）类似但是每个字符串元素都和一个浮动的被称为评分（score）的数字值相关联。 元素值总是根据评分的值来排序,所以不像集合（Sets）那样，有序集合可以检索到一系列的数据。（例如你可以请求：给我前十个或者最后十个元素）。</p><h2 id="散列（Hashes）"><a href="#散列（Hashes）" class="headerlink" title="散列（Hashes）"></a>散列（Hashes）</h2><p>由字段(field)和与之关联的值(value)组成的映射。字段(field)与值(value)都是字符串。与Ruby或Python的hashes相似。</p><h2 id="位数组（Bit-arrays）（bitmaps）"><a href="#位数组（Bit-arrays）（bitmaps）" class="headerlink" title="位数组（Bit arrays）（bitmaps）"></a>位数组（Bit arrays）（bitmaps）</h2><p>可以使用特殊命令行来像一个由位（bit）组成的数组(array)一样的控制字符串值：你可以设置并且清除个别的位(bit)，计算所有设置成1的位(bits)，找到第一个设置或未设置的位(bit)，诸如此类。</p><h2 id="超对数日志（HyperLogLogs）"><a href="#超对数日志（HyperLogLogs）" class="headerlink" title="超对数日志（HyperLogLogs）"></a>超对数日志（HyperLogLogs）</h2><p>这是一个用来估算集合（set）基数(cardinality)的数据结构。</p><h2 id="流（Streams）"><a href="#流（Streams）" class="headerlink" title="流（Streams）"></a>流（Streams）</h2><p>只追加提供抽象日志数据类型的类似映射项的集合。</p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读Vue源码所能想到的面试问题</title>
      <link href="/blog/2019/02/12/Vue-%E8%AF%BBVue%E6%BA%90%E7%A0%81%E6%89%80%E8%83%BD%E6%83%B3%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
      <url>/blog/2019/02/12/Vue-%E8%AF%BBVue%E6%BA%90%E7%A0%81%E6%89%80%E8%83%BD%E6%83%B3%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="指令v-if-v-show有什么不同？"><a href="#指令v-if-v-show有什么不同？" class="headerlink" title="指令v-if v-show有什么不同？"></a>指令v-if v-show有什么不同？</h2><p>v-if 和 v-show都是Vue中的指令而且都可以用来控制模板的渲染。  </p><p>v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。  </p><p>v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。  </p><p>相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS( <code>display:none</code>) 进行切换。  </p><p>一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。  </p><span id="more"></span><h2 id="写出-normalizeProps-方法"><a href="#写出-normalizeProps-方法" class="headerlink" title="写出 normalizeProps 方法"></a>写出 normalizeProps 方法</h2><p>在 Vue 中，我们在使用 props 的时候有两种写法，一种是使用字符串数组  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ChildComponent</span> = &#123;</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;some-data1&#x27;</span>， <span class="string">&#x27;someData2&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一种是使用对象语法  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ChildComponent</span> = &#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    some-<span class="attr">data1</span>: <span class="title class_">Number</span>,</span><br><span class="line">    <span class="attr">someData2</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">      <span class="attr">default</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请写出规范化props的方法 <code>normalizeProps (options, vm)</code>，将两种形式规范成同一种形式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ChildComponent</span> = &#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">someData1</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">Number</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">someData2</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">      <span class="attr">default</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">camelize</span> (str) &#123;</span><br><span class="line">  <span class="keyword">return</span> str.<span class="title function_">replace</span>(<span class="regexp">/-(\w)/g</span>, <span class="function">(<span class="params">_, c</span>) =&gt;</span> c ? c.<span class="title function_">toUpperCase</span>() : <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isPlainObject</span> (obj) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj) === <span class="string">&#x27;[object Object]&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toRawType</span> (value) &#123;</span><br><span class="line">  <span class="keyword">return</span>  <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(value).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">normalizeProps</span> (options, vm) &#123;</span><br><span class="line">  <span class="keyword">const</span> props = options.<span class="property">props</span></span><br><span class="line">  <span class="keyword">if</span> (!props) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">  <span class="keyword">let</span> i, val, name</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(props)) &#123;</span><br><span class="line">    i = props.<span class="property">length</span></span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      val = props[i]</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        name = <span class="title function_">camelize</span>(val)</span><br><span class="line">        res[name] = &#123; <span class="attr">type</span>: <span class="literal">null</span> &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(<span class="string">&#x27;props must be strings when using array syntax.&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isPlainObject</span>(props)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">      val = props[key]</span><br><span class="line">      name = <span class="title function_">camelize</span>(key)</span><br><span class="line">      res[name] = <span class="title function_">isPlainObject</span>(val)</span><br><span class="line">        ? val</span><br><span class="line">        : &#123; <span class="attr">type</span>: val &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">    <span class="title function_">warn</span>(</span><br><span class="line">      <span class="string">`Invalid value for option &quot;props&quot;: expected an Array or an Object, `</span> +</span><br><span class="line">      <span class="string">`but got <span class="subst">$&#123;toRawType(props)&#125;</span>.`</span>,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  options.<span class="property">props</span> = res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么-data-需要写成一个函数？"><a href="#为什么-data-需要写成一个函数？" class="headerlink" title="为什么 data 需要写成一个函数？"></a>为什么 data 需要写成一个函数？</h2><p>通过函数返回数据对象，保证了每个组件实例都有一个唯一的数据副本，避免了组件间数据互相影响。  </p><h2 id="为什么我们能够使用-props-初始化-data-中的数据"><a href="#为什么我们能够使用-props-初始化-data-中的数据" class="headerlink" title="为什么我们能够使用 props 初始化 data 中的数据"></a>为什么我们能够使用 props 初始化 data 中的数据</h2><p>因为 data 选项是在初始化的时候才求值的，而 props 的初始化先于 data 选项的初始化。  </p><h2 id="生命周期钩子是否可以写成数组形式？如果可以那么将以什么顺序执行？如果不可以为什么不可以？"><a href="#生命周期钩子是否可以写成数组形式？如果可以那么将以什么顺序执行？如果不可以为什么不可以？" class="headerlink" title="生命周期钩子是否可以写成数组形式？如果可以那么将以什么顺序执行？如果不可以为什么不可以？"></a>生命周期钩子是否可以写成数组形式？如果可以那么将以什么顺序执行？如果不可以为什么不可以？</h2><p>可以，因为在合并生命周期钩子函数 <code>mergeHook</code> 中判断了子组件钩子函数为数组的情况。钩子函数将按顺序执行。  </p><h2 id="vm-options-parent和-vm-parent-有什么不同？"><a href="#vm-options-parent和-vm-parent-有什么不同？" class="headerlink" title="vm.$options.parent和 vm.$parent 有什么不同？"></a>vm.$options.parent和 vm.$parent 有什么不同？</h2><p>vm.$options.parent 指的是当前实例 components 下注册的子组件的父实例<br>vm.$parent指的是当前实例的非抽象父实例  </p><h2 id="vue源码中大量用到了-Object-create-null-，Object-create-null-和-new-Object-及对象直接量-有什么不同？"><a href="#vue源码中大量用到了-Object-create-null-，Object-create-null-和-new-Object-及对象直接量-有什么不同？" class="headerlink" title="vue源码中大量用到了 Object.create(null)，Object.create(null) 和 new Object() 及对象直接量{}有什么不同？"></a>vue源码中大量用到了 Object.create(null)，Object.create(null) 和 new Object() 及对象直接量{}有什么不同？</h2><p> <code>Object.create()</code> 方法的内部实现简单来说是这样的：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">o</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> t = <span class="keyword">typeof</span> o;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="string">&quot;object&quot;</span> &amp;&amp; t != <span class="string">&quot;function&quot;</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="title class_">TypeError</span>();</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">    f.<span class="property"><span class="keyword">prototype</span></span> = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来 <code>Object.create(null)</code> 创建的新对象的原型对象就是null，也就是说它没有任何原型方法；<br>而直接使用{}创建新对象，其实是等同于new Object()，它是继承了Object的，是有原型方法的。  </p><h2 id="Vue-是通过什么方法来实现数据响应系统的？"><a href="#Vue-是通过什么方法来实现数据响应系统的？" class="headerlink" title="Vue 是通过什么方法来实现数据响应系统的？"></a>Vue 是通过什么方法来实现数据响应系统的？</h2><p>Vue 数据响应系统的原理的核心是通过 Object.defineProperty 函数将数据对象的属性转换为访问器(getter/setter)属性，从而使得我们能够拦截到属性的读取和设置。  </p><h2 id="哪些数据变化情况无法被-Vue-的响应式系统观测到，应该如何处理？"><a href="#哪些数据变化情况无法被-Vue-的响应式系统观测到，应该如何处理？" class="headerlink" title="哪些数据变化情况无法被 Vue 的响应式系统观测到，应该如何处理？"></a>哪些数据变化情况无法被 Vue 的响应式系统观测到，应该如何处理？</h2><ol><li>Vue 不能检测到以下变动的对象<ol><li>当你添加或删除对象的属性时，例如：</li></ol></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">items</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>. <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// `vm.a` 现在是响应式的</span></span><br><span class="line"></span><br><span class="line">vm.<span class="property">b</span> = <span class="number">2</span></span><br><span class="line"><span class="comment">// `vm.b` 不是响应式的</span></span><br></pre></td></tr></table></figure><ol start="2"><li>Vue 不能检测到以下变动的数组<ol><li>当你利用索引直接设置一个项时，例如：<code>vm.items[indexOfItem] = newValue</code></li><li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li></ol></li></ol><p>可以使用全局方法 <code>Vue.set(target, key, value)</code> 方法向嵌套对象添加响应式属性/直接设置一个数组的值，或者使用实例方法 <code>vm.$set(target, key, value)</code>。  </p><p>可以使用全局方法 <code>Vue.delete(target, key)</code> 方法向嵌套对象删除响应式属性/删除数组元素，或者使用实例方法 <code>vm.$delete(target, key)</code>。  </p><p>修改数组的长度可以通过 <code>vm.items.splice(newLength)</code> 实现。  </p><p>注意 <code>Vue.set(target, key, value)</code> 或  <code>Vue.delete(target, key)</code> 并不能为根数据对象添加/删除属性也不能为 Vue 实例添加/删除属性。  </p><h2 id="vue不同组件之间如何通信"><a href="#vue不同组件之间如何通信" class="headerlink" title="vue不同组件之间如何通信?"></a>vue不同组件之间如何通信?</h2><p>可以通过使用一个空的Vue实例作为中间事件栈，然后使用 <code>$emit</code> <code>$on</code> 传递数据。  </p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git小抄</title>
      <link href="/blog/2019/02/01/FE-Git%E5%B0%8F%E6%8A%84/"/>
      <url>/blog/2019/02/01/FE-Git%E5%B0%8F%E6%8A%84/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-Git"><a href="#什么是-Git" class="headerlink" title="什么是 Git"></a>什么是 Git</h2><p><a href="https://github.com/git/git">Git</a> 是一个免费的开源分布式版本控制系统。它被设计用来高效的控制各种各样的工程项目。<br>Git最初在2005年由 <a href="https://github.com/torvalds">Linus</a> 花费了两周时间用C语言开发而成，并被用来管理 <a href="https://github.com/torvalds/linux">Linux kernel</a> 的源码。<br>Git很容易学习，所占用空间极小而且效率很高。它比同类型的版本控制工具比如Subversion(SVN)，CVS， ClearCase要更加功能强大。  </p><span id="more"></span><h3 id="什么是版本控制"><a href="#什么是版本控制" class="headerlink" title="什么是版本控制"></a>什么是版本控制</h3><p>简单来说就是项目的历史，项目的代码从无到有，从少到多是有个过程的。在写代码的过程中我们免不了会遇到想知道项目发展过程中的许多事情，比如  </p><ol><li><p>谁提交了多少次代码，提交了多少行代码，谁对这个项目的贡献最大  </p></li><li><p>某行代码是何时由谁合并到项目中的，为什么他要这样写  </p></li><li><p>想要回滚当前项目到过去的某个时间段  </p></li><li><p>两个不同的人都修改了代码，如何能够快速的将两个人的代码diff并合并到项目中去  </p></li><li><p>想要维护两套代码分别开发不同的功能  </p></li><li><p>在每次提交代码时想要做一些验证，比如保证代码格式  </p></li></ol><p>版本控制系统就是来控制这些事情的工具。Git也可以做到这些。  </p><h3 id="Git-的特色"><a href="#Git-的特色" class="headerlink" title="Git 的特色"></a>Git 的特色</h3><p>Git与其它的版本控制系统有什么不同呢？最大的不同（除了开源）在于Git采用了分布式的版本控制。<br>在Git之前，版本控制系统都是集中式的，集中式版本控制系统的特色是最基本的版本库是存放在中央服务器的，在开发功能的时候，所有开发者都需要从中央服务器获取代码的最新版本，然后在本地加入自己的功能，最后再将代码合并到中央服务器中，合并的过程中，如果有别人在你之前合入了代码而你的代码和他的有冲突，你就要先处理这些冲突，然后合并入中央服务器。  </p><p><img src="/blog/static/imgs/git/集中式版本控制系统.jpeg" alt="集中式版本控制系统">  </p><p>集中式版本控制系统是可以工作的，但在某些方面也有自己的不足，比如如果中央服务器出现了问题，所有人都必须等待中央服务器可用。由于地理因素，某些开发者可能互相之间需要同步代码，而不希望和中央服务器同步（比如由于和中央服务器之间的带宽较小）。再比如开发者想要并行开发多个功能，但不想每次都需要同服务器同步获取最新代码。<br>分布式版本控制系统很好的解决了以上问题。在分布式版本控制系统中，每个版本库都是独立的。换句话说，每个版本库都可以作为“中央服务器”。这样，在开发的时候，任何两个开发者之间都可以互相推送自己的修改，而且由于记录的都是修改的操作，所以在自己本地创建“新版本库”（实际上通常是分支）来开发新功能的代价很小。  </p><p><img src="/blog/static/imgs/git/分布式版本控制系统.jpeg" alt="分布式版本控制系统">  </p><p>当然，实际上，采用分布式版本控制系统的项目通常也有一个版本库充当“中央服务器”的角色，而这个版本库标记这产品的正式的代码变更，每个开发者从“中央服务器”同步最新的代码相当于获取大家都认可的项目最新的代码。</p><h2 id="如何安装-Git"><a href="#如何安装-Git" class="headerlink" title="如何安装 Git"></a>如何安装 Git</h2><p>下面列举了在Linux/MacOS/Windows中安装Git的方法：  </p><h3 id="在Linux上安装Git"><a href="#在Linux上安装Git" class="headerlink" title="在Linux上安装Git"></a>在Linux上安装Git</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install git</span><br></pre></td></tr></table></figure><h3 id="在Mac-OS-X上安装Git"><a href="#在Mac-OS-X上安装Git" class="headerlink" title="在Mac OS X上安装Git"></a>在Mac OS X上安装Git</h3><p>安装homebrew，然后通过homebrew安装Git，具体方法请参考 <a href="http://brew.sh/">homebrew</a> 的文档。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install</span><br></pre></td></tr></table></figure><h3 id="在Windows上安装Git"><a href="#在Windows上安装Git" class="headerlink" title="在Windows上安装Git"></a>在Windows上安装Git</h3><p>从Git官网直接 <a href="https://git-scm.com/downloads">下载安装程序</a> ，然后双击安装即可。  </p><h2 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h2><p>首先我们来了解下Git中的各个区域的含义  </p><table><thead><tr><th>区域</th><th>解释</th></tr></thead><tbody><tr><td>stash 存档库</td><td>当你去修改别的东西的时候，隐藏（临时保存）当前的修改</td></tr><tr><td>workspace 工作区</td><td>本地检出</td></tr><tr><td>index 暂存区（索引）</td><td>索引（暂存区）保存了一份工作(树)的快照，作为下次提交的内容</td></tr><tr><td>local repository 本地版本库</td><td>.git 文件夹保存版本库需要的全部信息(Git 版本库的骨架)，一般包括分支 <strong>master</strong>, <strong>feature-x</strong>, <strong>bugfix-y</strong></td></tr><tr><td>upstream repository 上游版本库</td><td>在网络（局域或因特网）上共享给其他开发者的版本库，一般叫”origin”. 一般包括分支<strong>master</strong>, <strong>shared-feature-x</strong>, <strong>release-y</strong></td></tr></tbody></table><p>一个Git命令由 <code>git</code>开始，然后加上命令名，例如 <code>config</code>，然后加上参数，例如<code>--global user.name &quot;your name&quot;</code>，中间由空格连接。一个Git命令通常在一个区域或者两个区域之间进行了某些操作。  </p><p>Git提供了很多的命令，可以自由的实现版本控制的几乎所有的要求，然而在日常工作中，最常用的几乎只有那么几个，你只需要打印出来贴在办公桌上即可，这里提供了一个 <a href="/static/docs/github-git-cheat-sheet.pdf" target="_blank" ref="noopener noreferrer">Git 命令小抄</a> 。  </p><p>如果你不想手打Git命令，也有很好的界面化工具 <a href="https://www.sourcetreeapp.com/">Sourcetree</a> 支持。  </p><p>如果想要更全面的了解Git，可以查看 <a href="https://git-scm.com/book/zh/v2">《Pro Git》</a> ，这本书由 Scott Chacon &amp; Ben Straub 编写，由Apress发布，遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/">Creative Commons Attribution Non Commercial Share Alike 3.0 license</a>。  </p><p>下面列出一些常用的Git命令：  </p><h3 id="git-stash-save-lt-msg"><a href="#git-stash-save-lt-msg" class="headerlink" title="git stash save [&lt;msg>]"></a>git stash save [&lt;msg>]</h3><p>所属区域： 从 <code>工作区</code> 到 <code>存档区</code><br>保存当前修改到新的存档库，并且执行<code>git reset ‑‑hard</code>来回滚。 msg是可选的用来描述存档。想快速建立存档，可以省略掉<code>save</code>和<code>msg</code>。</p><h3 id="git-stash-apply-lt-stash"><a href="#git-stash-apply-lt-stash" class="headerlink" title="git stash apply [&lt;stash>]"></a>git stash apply [&lt;stash>]</h3><p>所属区域： 从 <code>存档区</code> 到 <code>工作区</code><br>从某个存档中将改变应用到工作区，默认是最近的存档。</p><h3 id="git-stash-pop"><a href="#git-stash-pop" class="headerlink" title="git stash pop"></a>git stash pop</h3><p>所属区域： 从 <code>存档区</code> 到 <code>工作区</code><br>应用最后一个（或指定的）存档中的改动，然后从存档库丢弃它。</p><h3 id="git-stash-list"><a href="#git-stash-list" class="headerlink" title="git stash list"></a>git stash list</h3><p>所属区域： <code>存档区</code><br>显示当前你有的所有存档。  </p><h3 id="git-stash-show-lt-stash"><a href="#git-stash-show-lt-stash" class="headerlink" title="git stash show [&lt;stash>]"></a>git stash show [&lt;stash>]</h3><p>所属区域： <code>存档区</code><br>显示存档中记录的改动，对比存档生成时的原来状态；不指定stash则显示最后一个。</p><h3 id="git-stash-drop-lt-stash"><a href="#git-stash-drop-lt-stash" class="headerlink" title="git stash drop [&lt;stash>]"></a>git stash drop [&lt;stash>]</h3><p>所属区域： <code>存档区</code><br>从存储区中删除单个存档；不指定stash则删除最后一个。  </p><h3 id="git-stash-clear"><a href="#git-stash-clear" class="headerlink" title="git stash clear"></a>git stash clear</h3><p>所属区域： <code>存档区</code><br>清空存档库。注意相关存档会被清理，此操作<strong>不能被恢复</strong>。  </p><h3 id="git-stash-branch-lt-branshname-lt-stash"><a href="#git-stash-branch-lt-branshname-lt-stash" class="headerlink" title="git stash branch &lt;branshname> [&lt;stash>]"></a>git stash branch &lt;branshname> [&lt;stash>]</h3><p>所属区域： 从 <code>存档区</code> 到 <code>本地版本库</code><br>新建并检出一个新分支branchname, 分支开始于存档建立时的源提交，应用存档的变化作为新的工作区和暂存区。如果成功并且stash是以 stash@{revision}方式给出的，则从存档库删除它。未给出则使用最后一个存档。这在当前分支运行 stash save 导致冲突时很好用，因为存档应用于它生成时的提交一定不会有冲突发生。  </p><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><p>所属区域： 在 <code>工作区</code> 与 <code>暂存区</code> 之间<br>显示状态变化，包括  </p><ol><li>暂存区与当前的 HEAD 提交之间(即将提交的)的状态变化</li><li>工作区与暂存区(下次不会提交)的状态变化</li><li>未曾被git追踪(没有历史记录)的状态变化</li></ol><h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><p>所属区域： 在 <code>工作区</code> 与 <code>暂存区</code> 之间<br>显示未添加到暂存区的不同。  </p><h3 id="git-diff-1"><a href="#git-diff-1" class="headerlink" title="git diff "></a>git diff <commit or branch\></h3><p>所属区域： 在 <code>工作区</code> 与 <code>本地版本库</code> 之间<br>查看工作区与某一提交之间的不同。你也可以使用 HEAD 来对比上一提交，或是用分支名来和分支比较。  </p><h3 id="git-add-lt-file-or-dir…"><a href="#git-add-lt-file-or-dir…" class="headerlink" title="git add &lt;file.. or dir…>"></a>git add &lt;file.. or dir…></h3><p>所属区域： 从 <code>工作区</code> 到 <code>暂存区</code><br>添加当前的新内容或是修改的文件到暂存区，作为下次提交的(部分)内容。用 <code>add --interactive</code> 来交互式操作。  </p><h3 id="git-add-u"><a href="#git-add-u" class="headerlink" title="git add -u"></a>git add -u</h3><p>所属区域： 从 <code>工作区</code> 到 <code>暂存区</code><br>添加当前修改(<strong>不包括新文件</strong>)到暂存区, 这与 <code>git commit -a</code> 准备提交内容的方式一致。  </p><h3 id="git-rm-lt-file-s-…"><a href="#git-rm-lt-file-s-…" class="headerlink" title="git rm &lt;file(s)…>"></a>git rm &lt;file(s)…></h3><p>所属区域： 从 <code>工作区</code> 到 <code>暂存区</code><br>从工作区和暂存区删除某个文件。  </p><h3 id="git-mv-lt-file-s-…"><a href="#git-mv-lt-file-s-…" class="headerlink" title="git mv &lt;file(s)…>"></a>git mv &lt;file(s)…></h3><p>所属区域： 从 <code>工作区</code> 到 <code>暂存区</code><br>从工作区和暂存区移动文件。  </p><h3 id="git-commit-a-m-‘msg’"><a href="#git-commit-a-m-‘msg’" class="headerlink" title="git commit -a [-m ‘msg’]"></a>git commit -a [-m ‘msg’]</h3><p>所属区域： 从 <code>工作区</code> 到 <code>本地版本库</code><br>提交上次提交之后的所有修改，  </p><ol><li>未追踪的除外(即：所有暂存区有记录的文件)；</li><li>从暂存区删除已在工作区删除的文件</li></ol><h3 id="git-checkout-lt-file-s-…-or-dir…"><a href="#git-checkout-lt-file-s-…-or-dir…" class="headerlink" title="git checkout &lt;file(s)… or dir…>"></a>git checkout &lt;file(s)… or dir…></h3><p>所属区域： 从 <code>暂存区</code> 到 <code>工作区</code><br>更新工作区文件或文件夹，<strong>不会</strong>切换分支。  </p><h3 id="git-reset-hard"><a href="#git-reset-hard" class="headerlink" title="git reset - -hard"></a>git reset - -hard</h3><p>所属区域： 从 <code>本地版本库</code> 到 <code>工作区</code><br>恢复工作区和暂存区到上次提交的状态，<br>警告： 所有工作区修改都会被丢弃。使用这条命令来解决合并错误，如果你想从头开始的话传入 ORIG_HEAD 来撤销该次提交以来的所有改动。  </p><h3 id="git-reset-soft-origin-master"><a href="#git-reset-soft-origin-master" class="headerlink" title="git reset  - -soft origin/master"></a>git reset  - -soft origin/master</h3><p>所属区域： 从 <code>上游版本库</code> 到 <code>工作区</code><br>恢复工作区和暂存区到上次提交的状态，当前所有工作区的修改都会保留成未提交的文件。  </p><h3 id="git-checkout-b"><a href="#git-checkout-b" class="headerlink" title="git checkout -b "></a>git checkout -b <name of new branch\></h3><p>所属区域： 从 <code>本地版本库</code> 到 <code>工作区</code><br>切换分支，更改工作区和暂存区为branch分支的内容，之后HEAD指向branch分支。  </p><h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge "></a>git merge <commit or branch\></h3><p>所属区域： 从 <code>本地版本库</code> 到 <code>工作区</code><br>从branch name分支合并到当前分支，使用‑‑no-commit可以保持在(已经合并)但未提交状态。  </p><h3 id="git-rebase-lt-upstream"><a href="#git-rebase-lt-upstream" class="headerlink" title="git rebase &lt;upstream>"></a>git rebase &lt;upstream></h3><p>所属区域： 从 <code>本地版本库</code> 到 <code>工作区</code><br>变基：回滚从【当前提交和upstream分支分开处】开始直到当前提交的所有提交，将这些提交一一应用到upstream分支，结果作为upstream的新提交。</p><h3 id="git-cherry-pick-lt-commit"><a href="#git-cherry-pick-lt-commit" class="headerlink" title="git cherry-pick &lt;commit>"></a>git cherry-pick &lt;commit></h3><p>所属区域： 从 <code>本地版本库</code> 到 <code>工作区</code><br>把某个提交移动到当前分支来。  </p><h3 id="git-revert-lt-commit"><a href="#git-revert-lt-commit" class="headerlink" title="git revert &lt;commit>"></a>git revert &lt;commit></h3><p>所属区域： 从 <code>本地版本库</code> 到 <code>工作区</code><br>回滚commit指定的提交，这需要当前工作区是干净的，即相比于 HEAD 提交没有修改。  </p><h3 id="git-clone-lt-repository"><a href="#git-clone-lt-repository" class="headerlink" title="git clone &lt;repository>"></a>git clone &lt;repository></h3><p>所属区域： 从 <code>上游版本库</code> 到 <code>工作区</code><br>下载repository指定的版本库，并在工作区迁出master分支的HEAD版本。  </p><h3 id="git-pull-lt-remote-lt-refspec"><a href="#git-pull-lt-remote-lt-refspec" class="headerlink" title="git pull &lt;remote> &lt;refspec>"></a>git pull &lt;remote> &lt;refspec></h3><p>所属区域： 从 <code>上游版本库</code> 到 <code>工作区</code><br>从远程版本库取得修改到当前分支。 一般来说, git pull 相当于 git fetch 然后做 git merge FETCH_HEAD。  </p><h3 id="git-reset-hard-lt-remote-lt-branch"><a href="#git-reset-hard-lt-remote-lt-branch" class="headerlink" title="git reset - -hard &lt;remote>|&lt;branch>"></a>git reset - -hard &lt;remote>|&lt;branch></h3><p>所属区域： 从 <code>上游版本库</code> 到 <code>工作区</code><br>重置本地版本库，让它与远程版本一致；用 reset ‑‑hard origin/master 来丢弃所有的本地改动；用这个来处理失败的合并，直接从远程开始。  </p><h3 id="git-clean"><a href="#git-clean" class="headerlink" title="git clean"></a>git clean</h3><p>所属区域： 从 <code>工作区</code> 到 <code>工作区</code><br>从当前文件夹开始递归清理不受版本管理的内容。  </p><h3 id="git-reset-HEAD-lt-file-s-…"><a href="#git-reset-HEAD-lt-file-s-…" class="headerlink" title="git reset HEAD &lt;file(s)…>"></a>git reset HEAD &lt;file(s)…></h3><p>所属区域： 从 <code>暂存区</code> 到 <code>暂存区</code><br>从下次提交中移除指定文件。重置暂存区记录但是不处理工作区(即: 文件改动被保留但不会被提交)，同时报告没有被更新的文件。  </p><h3 id="git-reset-soft-HEAD"><a href="#git-reset-soft-HEAD" class="headerlink" title="git reset - -soft HEAD^"></a>git reset - -soft HEAD^</h3><p>所属区域： 从 <code>本地版本库</code> 到 <code>暂存区</code><br>恢复上一次提交，保留暂存区的改动。  </p><h3 id="git-diff-cached-lt-commit"><a href="#git-diff-cached-lt-commit" class="headerlink" title="git diff - -cached [&lt;commit>]"></a>git diff - -cached [&lt;commit>]</h3><p>所属区域： 在 <code>暂存区</code> 与 <code>本地版本库</code> 之间<br>查看已经暂存的内容和上次提交的区别，也可指定某一提交。  </p><h3 id="git-commit-m-‘msg’"><a href="#git-commit-m-‘msg’" class="headerlink" title="git commit [-m ‘msg’]"></a>git commit [-m ‘msg’]</h3><p>所属区域： 从 <code>暂存区</code> 到 <code>本地版本库</code><br>暂存区中的当前内容连同提交信息储存为新提交。  </p><h3 id="git-commit-amend"><a href="#git-commit-amend" class="headerlink" title="git commit - -amend"></a>git commit - -amend</h3><p>所属区域： 从 <code>暂存区</code> 到 <code>本地版本库</code><br>用当前暂存区的内容修改最近一次的提交，也可以拿来修改提交信息。  </p><h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><p>所属区域： <code>本地版本库</code><br>显示最近的提交，新的在上边。  </p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>‑‑decorate</td><td>显示分支和tag名字到对应的提交</td></tr><tr><td>‑‑stat</td><td>显示状态 (文件修改, 添加, 删除)</td></tr><tr><td>‑‑author=author</td><td>只显示某个作者</td></tr><tr><td>‑‑after=”MMM DD YYYY”</td><td>如(“Jun 20 2008”) 只显示某个日期之后的提交</td></tr><tr><td>‑‑before=”MMM DD YYYY”</td><td>只显示某个日期之前的提交</td></tr><tr><td>‑‑merge</td><td>只与当前合并冲突有关的提交</td></tr></tbody></table><h3 id="git-diff-lt-commit-lt-commit"><a href="#git-diff-lt-commit-lt-commit" class="headerlink" title="git diff &lt;commit> &lt;commit>"></a>git diff &lt;commit> &lt;commit></h3><p>所属区域： <code>本地版本库</code><br>显示两个提交之间的不同。  </p><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><p>所属区域： <code>本地版本库</code><br>显示所有（本地）存在的分支。参数 -r 显示远程追踪分支，参数 -a 显示全部。  </p><h3 id="git-branch-d-lt-branch"><a href="#git-branch-d-lt-branch" class="headerlink" title="git branch -d &lt;branch>"></a>git branch -d &lt;branch></h3><p>所属区域： <code>本地版本库</code><br>删除某个分支，使用—D来强制删除。  </p><h3 id="git-branch-track-lt-new-lt-remote-branch"><a href="#git-branch-track-lt-new-lt-remote-branch" class="headerlink" title="git branch - -track &lt;new> &lt;remote/branch>"></a>git branch - -track &lt;new> &lt;remote/branch></h3><p>所属区域： 从 <code>上游版本库</code> 到 <code>本地版本库</code><br>添加一个本地分支来跟踪某个远程分支。  </p><h3 id="git-fetch-lt-remote-lt-refspec"><a href="#git-fetch-lt-remote-lt-refspec" class="headerlink" title="git fetch &lt;remote> &lt;refspec>"></a>git fetch &lt;remote> &lt;refspec></h3><p>所属区域： 从 <code>上游版本库</code> 到 <code>本地版本库</code><br>从远端版本库下载对象和引用(即版本信息)。  </p><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p>所属区域： 从 <code>本地版本库</code> 到 <code>上游版本库</code><br>从本地提交推送分支改变到远程，分支为所有推送过的分支。  </p><h3 id="git-push-lt-remote-lt-branch"><a href="#git-push-lt-remote-lt-branch" class="headerlink" title="git push &lt;remote> &lt;branch>"></a>git push &lt;remote> &lt;branch></h3><p>所属区域： 从 <code>本地版本库</code> 到 <code>上游版本库</code><br>向远端版本库推送新的(已存在的)分支。  </p><h3 id="git-push-lt-remote-lt-branch-lt-branch"><a href="#git-push-lt-remote-lt-branch-lt-branch" class="headerlink" title="git push &lt;remote> &lt;branch>:&lt;branch>"></a>git push &lt;remote> &lt;branch>:&lt;branch></h3><p>所属区域： 从 <code>本地版本库</code> 到 <code>上游版本库</code><br>向远端版本库推送分支，但是从不同的（本地）分支名。  </p><h3 id="git-branch-r"><a href="#git-branch-r" class="headerlink" title="git branch -r"></a>git branch -r</h3><p>所属区域： <code>上游版本库</code><br>显示远程端分支。  </p><h3 id="git-push-lt-remote-lt-branch-1"><a href="#git-push-lt-remote-lt-branch-1" class="headerlink" title="git push &lt;remote>:&lt;branch>"></a>git push &lt;remote>:&lt;branch></h3><p>所属区域： <code>上游版本库</code><br>删除一个远程分支，通过向远程分支推送空内容。  </p><h3 id="git-config-lt-options"><a href="#git-config-lt-options" class="headerlink" title="git config [&lt;options>]"></a>git config [&lt;options>]</h3><p>Git 配置相关信息</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>- -global</td><td>使用全局配置文件</td></tr><tr><td>- -system</td><td>使用系统配置文件</td></tr><tr><td>- -local</td><td>使用版本库配置文件</td></tr><tr><td>-f, - -file &lt;file></td><td>使用给定路径的配置文件</td></tr><tr><td>- -get</td><td>获取Git配置的值</td></tr><tr><td>-l, - -list</td><td>列出所有的配置</td></tr></tbody></table><p>可以通过 <code>git config alias.&lt;command alias&gt; &lt;command&gt;</code> 设置别名  </p><h2 id="其它注意事项"><a href="#其它注意事项" class="headerlink" title="其它注意事项"></a>其它注意事项</h2><p>平常我会使用 SourceTree 来省却自己手打git命令的烦恼，但有时在提交到 Github 的时候，会在 Github 的 commit history 里看到如下一句  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mangon authored and Xiang committed 16 minutes ago</span><br></pre></td></tr></table></figure><p>其实在SourceTree 的提交历史中也能看到类似如下信息  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fix: fix desc error</span><br><span class="line">提交：</span><br><span class="line">1bcf9d0d3c9df73e52b38a71402d4b3943698287 [1bcf9d0]</span><br><span class="line">父级：</span><br><span class="line">371e1e0379</span><br><span class="line">作者：</span><br><span class="line">Mangon &lt;*************@***.com&gt;</span><br><span class="line">日期：</span><br><span class="line">2019年2月14日 GMT+8 下午1:57:33</span><br><span class="line">提交者：</span><br><span class="line">Xiang &lt;**********@*****.com&gt;</span><br><span class="line">提交日期：</span><br><span class="line">2019年2月14日 GMT+8 下午2:06:47</span><br><span class="line">标签：</span><br><span class="line">HEAD -&gt; develop origin/develop</span><br></pre></td></tr></table></figure><p>显然是作者与提交者不一致导致的。经查阅，Git中一个commit有作者和提交者的差别。作者（author）指的是实际作出修改的人，提交者(committer)指的是最后将此工作成果提交到仓库的人。所以，当你为某个项目发布补丁，然后某个核心成员将你的补丁并入项目时，你就是作者，而那个核心成员就是提交者。  </p><p>在SourceTree中，可以在提交时 commit message 输入框左上方改变自己的 Author 属性，在当前项目窗口的右上角设置里选择高级，然后修改用户信息“全名”及“电子邮件地址”来改变 committer 属性。  </p><p>将两者改为一致的自己想要用的Github账户名就可以保证在Github提交历史中显示正确的名字。  </p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tool </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>head中的meta</title>
      <link href="/blog/2019/01/21/HTML-head%E4%B8%AD%E7%9A%84meta/"/>
      <url>/blog/2019/01/21/HTML-head%E4%B8%AD%E7%9A%84meta/</url>
      
        <content type="html"><![CDATA[<p>meta指的是html元素中存在与head中的meta元素<br>它长这样  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="meta的含义"><a href="#meta的含义" class="headerlink" title="meta的含义"></a>meta的含义</h2><p>HTML <meta> 元素表示那些不能由其它HTML元相关元素 (&lt;base>, &lt;link>, &lt;script>, &lt;style> 或 &lt;title>) 之一表示的任何元数据信息.  </p><h2 id="meta的属性"><a href="#meta的属性" class="headerlink" title="meta的属性"></a>meta的属性</h2><h3 id="charset"><a href="#charset" class="headerlink" title="charset"></a>charset</h3><p>此特性声明当前文档所使用的字符编码，但该声明可以被任何一个元素(通常是html)的 lang 特性的值覆盖。此特性的值必须是一个符合由IANA所定义的字符编码首选MIME 名称（preferred MIME name ）之一。</p><p>有几点需要注意：</p><ol><li>推荐使用 UTF-8；  </li><li><meta> 元素必须包含在 <head> 元素中并且在HTML代码的前1024个字节内，因为某些浏览器在选择编码之前只查看前面这些字节。  </li><li>meta charset元素并不能决定字符集，网页采用何种字符是由 <a href="https://html.spec.whatwg.org/multipage/parsing.html#encoding-sniffing-algorithm">网页字符算法</a> 决定的  </li><li>强烈建议使用该属性定义字符编码. 如果未定义，某些跨脚本技术可能危害网页， 例如 <a href="http://code.google.com/p/doctype-mirror/wiki/ArticleUtf7">UTF-7 降级XSS攻击</a>  </li></ol><h3 id="http-equiv"><a href="#http-equiv" class="headerlink" title="http-equiv"></a>http-equiv</h3><p>这个枚举属性定义了能改变服务器和用户引擎行为的编译行为。值使用 content 来定义，如下：  </p><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>content-security-policy</td><td>它允许页面作者定义当前页的内容策略。 内容策略主要指定允许的服务器源和脚本端点，这有助于防止跨站点脚本攻击。</td></tr><tr><td>default-style</td><td>这个属性指定了在页面上使用的首选样式表. content属性必须包含 <code>&lt;link&gt;</code> 元素的标题, href属性链接到CSS样式表或包含CSS样式表的 <code>&lt;style&gt;</code> 元素的标题.</td></tr><tr><td>refresh</td><td>这个属性规定了重新载入页面或跳转到指定链接的时间间隔（正整数）</td></tr></tbody></table><h3 id="name-amp-content"><a href="#name-amp-content" class="headerlink" title="name &amp; content"></a>name &amp; content</h3><p>全局属性 name 在 <meta> 元素中具有特殊的语义；<br>另外， 在同一个 <meta> 标签中，name、http-equiv 或者 charset 三者中任何一个属性存在时，itemprop 属性不能被使用。  </p><p>定义文档级元数据的名称 与 内容  </p><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>application-name</td><td>定义正运行在该网页上的网络应用名称</td></tr><tr><td>author</td><td>这个文档的作者名称</td></tr><tr><td>description</td><td>其中包含页面内容的简短和精确的描述。 一些浏览器，如Firefox和Opera，将其用作书签页面的默认描述</td></tr><tr><td>generator</td><td>包含生成页面的软件的标识符</td></tr><tr><td>keywords</td><td>包含与逗号分隔的页面内容相关的单词（关键词）</td></tr><tr><td>referrer</td><td>控制所有从该文档发出的 HTTP 请求中HTTP Referer 首部的内容</td></tr></tbody></table><p>name 为 referrer 时 content 的可选值</p><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>no-referrer</td><td>不要发送 HTTP Referer 首部</td></tr><tr><td>origin</td><td>发送当前文档的 origin。</td></tr><tr><td>no-referrer-when-downgrade</td><td>当目的地是先验安全的(https-&gt;https)则发送 origin 作为 referrer ，但是当目的地是较不安全的 (https-&gt;http)时则不发送 referrer 。这个是默认的行为。</td></tr><tr><td>origin-when-crossorigin</td><td>在同源请求下，发送完整的URL (不含查询参数) ，其他情况下则仅发送当前文档的 origin。</td></tr><tr><td>unsafe-URL</td><td>在同源请求下，发送完整的URL (不含查询参数)。</td></tr></tbody></table><p>有些name虽然没有被正式承认，但是也被广泛使用，<a href="https://wiki.whatwg.org/wiki/MetaExtensions">这个网站</a> 列举了所有存在的meta值。以下列举一些常用的。</p><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>creator</td><td>文档的创建者</td></tr><tr><td>publisher</td><td>文档的发布者</td></tr><tr><td>robots</td><td>定义了合理的被允许的爬虫行为，注意只有搜索引擎爬虫会遵循此规则所以并不能阻止个人的爬虫程序，而且爬虫能读取到该属性说明已经在读取此网页了，所以最好使用robots.txt来阻止搜索引擎爬虫</td></tr><tr><td>viewport</td><td>视口，提供有关视口初始大小的提示，仅供移动设备使用，虽然目前标准化程度不高，还处于草案(work in progress)的进度，但由于事实上的几个浏览器的支配地位，大多数移动浏览器都尊重这一声明，更多有关viewport的解释参见<a href="https://drafts.csswg.org/css-device-adapt/#viewport-meta">文档</a></td></tr></tbody></table><p>有关viewport的相关内容，参见 <a href="/2019/01/21/浅谈viewport/">浅谈viewport</a></p>]]></content>
      
      
      <categories>
          
          <category> html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>viewport</title>
      <link href="/blog/2019/01/21/HTML-viewport/"/>
      <url>/blog/2019/01/21/HTML-viewport/</url>
      
        <content type="html"><![CDATA[<h2 id="viewport来源"><a href="#viewport来源" class="headerlink" title="viewport来源"></a>viewport来源</h2><p>通常为了使得网页能够成为响应式的，我们需要在head内声名有关viewport的meta。<br>它长这样  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1,user-scalable=no&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>viewport的设计是由于pc互联网向移动互联网的过渡。在过去，多数文档被设计用来在pc上进行阅读，而pc的设备通常比较宽，同样的网页不进行任何改变放到移动端的话，内容就会变得无法辨认。</p><span id="more"></span><p>例如，新浪网在移动端的显示：<br><img src="/blog/static/imgs/viewport/web_page.png" alt="新浪网桌面版在移动端的显示"></p><p>为了避免这个问题，浏览器通常使用一个固定的初始区域宽度来模拟桌面浏览器窗口大小（通常980px-1024px)。而移动端的宽度是小于这个值的，于是内容便看起来像自动放大了一般，同样的，移动端当前的屏幕也只会显示文档的一部分。<br><img src="/blog/static/imgs/viewport/layout_viewport.png" alt="布局视口"><br><img src="/blog/static/imgs/viewport/visual_viewport.png" alt="视觉视口"></p><p><code>document.documentElement.clientWidth/Height</code> 返回的即是当前布局视口的尺寸<br><code>window.innerWidth/Height</code> 返回的即是当前视觉视口的尺寸  </p><p>由上述描述所知，其实视觉视口的大小和文档缩放程度是逆相关的：放得越大，视觉视口越小  </p><p>浏览器对viewport也有默认布局视口宽度  </p><table><thead><tr><th>iPhone</th><th>iPad</th><th>Android Samsung</th><th>Chrome</th><th>Opera</th><th>BlackBerry</th><th>IE</th></tr></thead><tbody><tr><td>980</td><td>980</td><td>980</td><td>980</td><td>980</td><td>1024</td><td>1024</td></tr></tbody></table><p>即使如此，对于一个用户而言，还是不甚理想，在狭窄的屏幕上更适合一个狭窄的网站而不是需要用户来缩放的桌面网站。于是Safari引入了meta标签viewport以及理想视口的概念，其它浏览器厂商也纷纷跟进。  </p><p>只有当网站是为移动端准备的时候才应该使用理想视口。<br>只有主动地往页面里添加meta视口标签时理想视口才会生效。<br>如果没有meta视口标签声明，那么布局视口将会维持它的默认宽度，理想视口只有当显式地使用它的时候才会产生影响。<br>理想视口只和设备有关，由浏览器定义，因此同一设备上的不同浏览器拥有不同的理想视口。<br>以下代码告之浏览器，布局视口的宽度应该与理想视口的宽度一致：  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;device&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>screen.width/height</code> 返回的是理想视口的尺寸  </p><h2 id="viewport取值"><a href="#viewport取值" class="headerlink" title="viewport取值"></a>viewport取值</h2><table><thead><tr><th>值</th><th>可能值</th><th>描述</th></tr></thead><tbody><tr><td>width</td><td>一个正整数或者字符串 device-width</td><td>以pixels（像素）为单位， 定义viewport（视口）的宽度。</td></tr><tr><td>height</td><td>一个正整数或者字符串 device-height</td><td>以pixels（像素）为单位， 定义viewport（视口）的高度。</td></tr><tr><td>initial-scale</td><td>一个0.0 到10.0之间的正数</td><td>定义设备宽度（纵向模式下的设备宽度或横向模式下的设备高度）与视口大小之间的缩放比率。</td></tr><tr><td>maximum-scale</td><td>一个0.0 到10.0之间的正数</td><td>定义缩放的最大值；它必须大于或等于minimum-scale的值，不然会导致不确定的行为发生。</td></tr><tr><td>minimum-scale</td><td>一个0.0 到10.0之间的正数</td><td>定义缩放的最小值；它必须小于或等于maximum-scale的值，不然会导致不确定的行为发生。</td></tr><tr><td>user-scalable</td><td>一个布尔值（yes 或者no）</td><td>如果设置为 no，用户将不能放大或缩小网页。默认值为 yes。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ionic4+vue搭建跨平台移动应用框架</title>
      <link href="/blog/2019/01/09/TIPS-Ionic4-vue%E6%90%AD%E5%BB%BA%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/"/>
      <url>/blog/2019/01/09/TIPS-Ionic4-vue%E6%90%AD%E5%BB%BA%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>ionic是一款混合移动应用开发框架，可以用来构建跨平台（Android &amp; iOS）的移动应用程序，而且还可以基于Sass和AngularJS进行构建，是目前跨平台移动应用开发的一个翘楚。这个框架的目的是从web的角度开发手机应用，基于PhoneGap的编译平台，可以实现编译成各个平台的应用程序。<br>Vue.js是一个MVVM驱动的 web 界面的渐进式框架，学习简单并且十分灵活。ionic3之前一般默认和Angular“绑定”在了一起，从ionic4开始，Ionic Team宣布将会逐渐采用<a href="https://github.com/ionic-team/stencil">Stencil</a>来实现标准Web Components，使用ionic将不再必须使用Angular，可以使用React，Vue，Jquery或者什么框架都不使用。  </p><span id="more"></span><h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>Vue提供了CLI工具来方便的创建Vue应用，首先我们需要  </p><ol><li>安装Vue CLI：  </li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g vue-cli</span><br></pre></td></tr></table></figure><ol start="2"><li>创建vue项目</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init webpack ionic-vue</span><br></pre></td></tr></table></figure><p>随后一路enter</p><ol start="3"><li>打开项目</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ionic-vue</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><h2 id="引入Ionic"><a href="#引入Ionic" class="headerlink" title="引入Ionic"></a>引入Ionic</h2><ol><li>在 index.html 引入 Ionic</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;format-detection&quot;</span> <span class="attr">content</span>=<span class="string">&quot;telephone=no&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;msapplication-tap-highlight&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/@ionic/core@0.0.2-20/dist/ionic.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在 src/main.js 中添加ignoredElements</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">ignoredElements</span> = [</span><br><span class="line">    <span class="string">&#x27;ion-app&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;ion-header&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;ion-navbar&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;ion-title&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;ion-content&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;ion-button&#x27;</span>,</span><br><span class="line">    ··· ···</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h2 id="开发应用"><a href="#开发应用" class="headerlink" title="开发应用"></a>开发应用</h2><ol><li>创建两个新页面</li></ol><p>我们希望演示如何在两个页面之间跳转</p><p>例如 src/pages/HelloWorld.vue<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ion-app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ion-header</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ion-navbar</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ion-title</span>&gt;</span>Ionic<span class="tag">&lt;/<span class="name">ion-title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ion-navbar</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ion-header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ion-content</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ion-button</span> @<span class="attr">click</span>=<span class="string">&quot;goToDetail&quot;</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">ion-button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ion-content</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ion-app</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">name</span>: <span class="string">&#x27;HelloWorld&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">  data () &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">msg</span>: <span class="string">&#x27;Welcome to Your Vue.js App&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    goToDetail () &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(<span class="string">&#x27;detail&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>src/pages/Detail.vue<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ion-app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ion-header</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ion-navbar</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ion-title</span>&gt;</span>Ionic<span class="tag">&lt;/<span class="name">ion-title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ion-navbar</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ion-header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ion-content</span> <span class="attr">padding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span>&gt;</span>Go home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ion-content</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ion-app</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">name</span>: <span class="string">&#x27;Detail&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">  data () &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">msg</span>: <span class="string">&#x27;Welcome to Your Ionic App&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><ol start="2"><li>添加路由</li></ol><p>router/index.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Router</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">HelloWorld</span> <span class="keyword">from</span> <span class="string">&#x27;@/pages/HelloWorld&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Detail</span> <span class="keyword">from</span> <span class="string">&#x27;@/pages/Detail&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Router</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Router</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">HelloWorld</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/detail&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">Detail</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><ol start="3"><li>添加全局过渡动画效果</li></ol><p>src/App.vue<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">&quot;slide-fade&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">name</span>: <span class="string">&#x27;app&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-id">#app</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">font-family</span>: <span class="string">&#x27;Avenir&#x27;</span>, Helvetica, Arial, sans-serif;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  -webkit-<span class="attribute">font-smoothing</span>: antialiased;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  -moz-osx-<span class="attribute">font-smoothing</span>: grayscale;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">text-align</span>: center;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">color</span>: <span class="number">#2c3e50</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">margin-top</span>: <span class="number">60px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.slide-fade-enter-active</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">transition</span>: all .<span class="number">3s</span> ease;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.slide-fade-leave-active</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">transition</span>: all .<span class="number">8s</span> <span class="built_in">cubic-bezier</span>(<span class="number">1.0</span>, <span class="number">0.5</span>, <span class="number">0.8</span>, <span class="number">1.0</span>);</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.slide-fade-enter</span>, <span class="selector-class">.slide-fade-leave-to</span></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="comment">/* .slide-fade-leave-active below version 2.1.8 */</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">10px</span>);</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><h2 id="打包成应用"><a href="#打包成应用" class="headerlink" title="打包成应用"></a>打包成应用</h2><ol><li>添加cordova 到项目</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cordova</span><br></pre></td></tr></table></figure><ol start="2"><li>创建cordova项目</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cordova create my-project-name</span><br></pre></td></tr></table></figure><ol start="3"><li>创建/移动vue项目</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init webpack my-app</span><br></pre></td></tr></table></figure><p>将my-app里的内容剪切到my-project-name下，同名覆盖</p><ol start="4"><li>修改打包路径<br>修改config/index.js文件下的build属性，将dist改为www，绝对路径改为相对路径</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">build</span>: &#123;</span><br><span class="line">  <span class="attr">index</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../www/index.html&#x27;</span>),</span><br><span class="line"></span><br><span class="line">  <span class="attr">assetsRoot</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../www&#x27;</span>),</span><br><span class="line">  <span class="attr">assetsSubDirectory</span>: <span class="string">&#x27;static&#x27;</span>,</span><br><span class="line">  <span class="attr">assetsPublicPath</span>: <span class="string">&#x27;./&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">productionSourceMap</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">devtool</span>: <span class="string">&#x27;#source-map&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">productionGzip</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">productionGzipExtensions</span>: [<span class="string">&#x27;js&#x27;</span>, <span class="string">&#x27;css&#x27;</span>],</span><br><span class="line"></span><br><span class="line">  <span class="attr">bundleAnalyzerReport</span>: process.<span class="property">env</span>.<span class="property">npm_config_report</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.vue项目中添加cordova.js</p><p>在index.html body中添加cordova.js<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;cordova.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><br>同时在 head 中添加 移动端meta信息</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#x27;self&#x27; data: gap: https://ssl.gstatic.com &#x27;unsafe-eval&#x27;; style-src &#x27;self&#x27; &#x27;unsafe-inline&#x27;; media-src *; img-src &#x27;self&#x27; data: content:;&quot;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;format-detection&quot;</span> <span class="attr">content</span>=<span class="string">&quot;telephone=no,email=no&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;msapplication-tap-highlight&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="6"><li>运行项目</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><ol start="7"><li>编译成 iOS &amp; Android 项目</li></ol><p>安装 cordova iOS &amp; Android 平台</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cordova platform add ios android --save</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cordova run ios --device</span><br><span class="line">cordova run android --device</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在线绘图小工具</title>
      <link href="/blog/2019/01/04/TIPS-%E5%9C%A8%E7%BA%BF%E7%BB%98%E5%9B%BE%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
      <url>/blog/2019/01/04/TIPS-%E5%9C%A8%E7%BA%BF%E7%BB%98%E5%9B%BE%E5%B0%8F%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<section><br>    <div class="paint-area"><br>        <p>移动端无法使用</p><br>        <canvas></canvas><br>    </div><br>    <script type="text/javascript" src="/blog/static/js/painter.js"></script><br></section>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链接a标签的用法</title>
      <link href="/blog/2019/01/03/HTML-a-%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/blog/2019/01/03/HTML-a-%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><p>&lt;a> 标签定义超链接，用于从一张页面链接到另一张页面。</p><p>在所有浏览器中，链接的默认外观是：  </p><ul><li style="text-decoration: underline; color:blue;">未被访问的链接带有下划线而且是蓝色的</li><li style="text-decoration: underline; color:red;">活动链接带有下划线而且是红色的</li><li style="text-decoration: underline; color:purple;">已被访问的链接带有下划线而且是紫色的</li></ul><p>链接默认样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;<span class="attribute">color</span>: blue;<span class="attribute">text-decoration</span>: underline;&#125;    <span class="comment">/* 未访问的链接 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">color</span>: blue;<span class="attribute">text-decoration</span>: underline;&#125;    <span class="comment">/* 鼠标移动到链接上 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;<span class="attribute">color</span>: red;<span class="attribute">text-decoration</span>: underline;&#125;     <span class="comment">/* 鼠标按下但还未收起时的链接 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;<span class="attribute">color</span>: purple;<span class="attribute">text-decoration</span>: underline;&#125;    <span class="comment">/* 已访问的链接 */</span></span><br></pre></td></tr></table></figure><p>&lt;a>不能自闭合，必须有开始标识与结束标识。  </p><span id="more"></span><h2 id="href"><a href="#href" class="headerlink" title="href"></a>href</h2><p>&lt;a> 元素最重要的属性是 href 属性，它指示链接的目标。  </p><p>如果没有href属性，&lt;a> 标签会表现的像是一个行内元素&lt;span>标签，甚至没有默认的样式。如果href属性没有值或者值为空字符串则点击 &lt;a> 标签会刷新当前页面。  </p><p>href 属性的值可以是任何URL或URL片段。如果用户选择了 &lt;a> 标签中的内容，那么浏览器会尝试检索并显示 href 属性指定的 URL 所表示的文档，或者执行 JavaScript 表达式、方法和函数的列表。  </p><p>href的值可以有很多种：  </p><ul><li>绝对 URL - 指向另一个站点（<code>href=&quot;http://www.example.com/index.html&quot;</code>）</li><li>相对 URL - 指向站点内的某个文件（<code>href=&quot;index.html&quot;</code>）</li><li>锚 URL - 指向页面中的锚（<code>href=&quot;#top&quot;</code>）</li><li>javascript代码 - 执行javascript代码(<code>href=&quot;javascript:alert(&#39;a is clicked&#39;);&quot;</code>)</li><li>本地文件地址 - 在浏览器中打开本地文件(<code>href=&quot;file:///Users/work/Desktop/test.txt&quot;</code>)</li><li>邮件地址 - 发送邮件(<code>href=&quot;mailto://somebody@example.com&quot;</code>)</li><li>电话号码 - 打电话(<code>href=&quot;tel:+86-10010&quot;</code>)</li></ul><p>⚠️注意事项</p><ul><li><p>除了相对URL和锚点，其它的表现都和在地址栏中输入相应href类似。<br>亦和<code>window.location.href=?</code>差不多，值得注意的是，在console执行 <code>window.location.href=&quot;file:///Users/work/Desktop/test.txt&quot;</code> 时会报错 <code>Not allowed to load local resource:file:///Users/work/Desktop/test.txt</code> 而执行 <code>window.location.href=&quot;tel:+86-10010&quot;</code> 则根本没反应</p></li><li><p>如果不是采用hash方式进行页面内导航的话，可以使用 <code>href=&quot;#top&quot;</code> 或者 <code>href=&quot;#&quot;</code> 链接返回到页面顶部 <span class="tag">HTML5<span/></p></li></ul><h2 id="target"><a href="#target" class="headerlink" title="target"></a>target</h2><p>&lt;a> 标签的 target 属性规定在何处打开链接文档。  </p><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>_blank</td><td>浏览器总在一个新打开、未命名的窗口中载入目标文档。</td></tr><tr><td>_self</td><td>默认值，它使得目标文档载入并显示在相同的frame或者window中作为源文档。</td></tr><tr><td>_parent</td><td>这个目标使得文档载入父窗口或者包含来超链接引用的框架的框架集。如果这个引用是在窗口或者在顶级框架中，那么它与目标 _self 等效。</td></tr><tr><td>_top</td><td>这个目标使得文档载入包含这个超链接的窗口，用 _top 目标将会清除所有被包含的框架并将文档载入整个浏览器窗口。</td></tr><tr><td>&lt;framename></td><td>在指定的frame中打开被链接文档。</td></tr></tbody></table><h2 id="rel"><a href="#rel" class="headerlink" title="rel"></a>rel</h2><p>&lt;a> 标签的 rel 属性用于指定当前文档与被链接文档的关系。与 &lt;link> 标签的 rel 属性类似，事实上许多值两者通用。<br>搜索引擎可以利用该属性获得更多有关链接的信息，在跳转的时候某些值也有特殊的用处。  </p><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>alternate</td><td>文档的可选版本（例如打印页、翻译页或镜像）</td></tr><tr><td>author</td><td>作者链接</td></tr><tr><td>bookmark</td><td>表明这个超链接是当前页面的一个永久链接（可被加入书签的）</td></tr><tr><td>external</td><td>表明指向外部链接</td></tr><tr><td>licence</td><td>描述版权信息</td></tr><tr><td>next</td><td>集合中的下一个文档</td></tr><tr><td>nofollow</td><td>Google 使用 “nofollow”用于指定 Google 搜索引擎不要跟踪链接</td></tr><tr><td>noopener</td><td>防止新打开的页面通过window.opener访问父级页面</td></tr><tr><td>noreferrer</td><td>防止新打开页面时在http请求的header添加referrer字段</td></tr><tr><td>prev</td><td>集合中的前一个文档</td></tr><tr><td>help</td><td>指向帮助文档</td></tr><tr><td>tag</td><td>描述当前页面标识的页面</td></tr></tbody></table><p>⚠️注意事项</p><ul><li>使用target时，考虑添加 <code>rel=&quot;external noopener noreferrer&quot;</code> 以防止针对 window.opener API 的恶意行为。</li></ul><h2 id="download-HTML5"><a href="#download-HTML5" class="headerlink" title="download HTML5"></a>download <span class="self-tag">HTML5<span/></h2><p>&lt;a> 标签的 download 属性指示浏览器下载URL而不是导航到它，因此将提示用户将链接（href）指向地址保存为本地文件。如果属性有一个值，那么它将在Save提示符中作为预填充的文件名使用（如果用户需要，仍然可以更改文件名）。此属性对允许的值没有限制，但是/和\会被转换为下划线。大多数文件系统限制了文件名中的标点符号，故此，浏览器将相应地调整建议的文件名。  </p><p>⚠️注意事项</p><ul><li>此属性仅适用于同源 URLs。</li><li>尽管HTTP URL需要位于同一源中，但是可以使用 <code>blob: URLs</code> 和 <code>data: URLs</code> ，以方便用户下载 JavaScript 方式生成的内容（例如使用在线绘图的Web应用创建的照片）。</li><li>如果HTTP头的Content-Disposition赋予了一个不同于此属性的文件名，HTTP头属性Content-Disposition优先于此属性。</li><li>如果HTTP头属性Content-Disposition被设置为inline(即Content-Disposition=’inline’)，那么Firefox优先考虑HTTP头Content-Disposition属性，就像文件名的情况，而Chrome优先考虑download属性。</li></ul><h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><p>该属性指定在一个 MIME type 链接目标的形式的媒体类型。其仅提供建议，并没有内置的功能。  </p><h2 id="废弃属性"><a href="#废弃属性" class="headerlink" title="废弃属性"></a>废弃属性</h2><p>以下属性在HTML5中已废弃，不推荐使用  </p><ul><li>charset</li><li>coords</li><li>name</li><li>rev</li><li>shape</li></ul>]]></content>
      
      
      <categories>
          
          <category> html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程范式</title>
      <link href="/blog/2018/12/14/CS-%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"/>
      <url>/blog/2018/12/14/CS-%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>函数式编程（Functional programming）或称函数程序设计，又称泛函编程，是一种编程范型，它将电脑运算视为数学上的函数计算，并且避免使用程序状态以及易变对象。函数编程语言最重要的基础是λ演算（lambda calculus）。而且λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。</p><p>函数式编程优点：  </p><ol><li>没有并发编程的问题，是多线程安全的</li><li>函数式编程的表达方式更加符合人类日常生活中的语法，代码可读性更强，实现同样的功能函数式编程所需要的代码比面向对象编程要少很多，代码更加简洁明晰</li></ol><p>函数式编程缺点：  </p><ol><li>所有的变量在程序运行期间都是一直存在的，资源利用率低</li><li>大型项目中工程化不足，使得代码易读性降低</li></ol><span id="more"></span><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>面向对象程序设计（Object-oriented programming，OOP）是种具有对象概念的程序编程范型，同时也是一种程序开发的方法。它可能包含数据、属性、代码与方法。对象则指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关连的数据。在面向对象程序编程里，计算机程序会被设计成彼此相关的对象。</p><p>面向对象编程优点：  </p><ol><li>灵活，可维护，易拓展，在大型项目设计中广为应用</li><li>由于继承、封装、多态的特性，自然设计出高内聚、低耦合的系统结构，使得系统更灵活、更容易扩展，而且成本较低。</li><li>23种设计模式广泛应用</li></ol><p>面向对象编程缺点：  </p><ol><li>在多线程并发编程中，多个线程同时操作数据的时候可能会导致数据修改的不确定性。</li><li>为了写可重用的代码而产生了很多无用的代码，导致代码膨胀</li><li>为了面向对象而面向对象，使得代码易读性降低</li><li>代码的运行效率比起面向过程要低很多</li></ol><h2 id="命令式编程"><a href="#命令式编程" class="headerlink" title="命令式编程"></a>命令式编程</h2><p>命令式编程（Imperative programming），也叫指令式编程，是一种描述计算机所需作出的行为的编程典范。几乎所有计算机的硬件工作都是命令式的；几乎所有计算机的硬件都是设计来运行机器码，使用命令式的风格来写的。较高阶的命令式编程语言使用变量和更复杂的语句，但仍依从相同的典范。因为命令式编程的基础观念，不但概念上比较熟悉，而且较容易具体表现于硬件，所以大部分的硬件编程语言都是命令式的。</p><h2 id="声明式编程"><a href="#声明式编程" class="headerlink" title="声明式编程"></a>声明式编程</h2><p>声明式编程（Declarative programming，DP）是一种编程范式，与命令式编程相对立。它描述目标的性质，让计算机明白目标，而非流程。声明式编程不用告诉计算机问题领域，从而避免随之而来的副作用。它通过函数、推理规则或者重写规则，来描述变量间关系，通过编译器采用固定算法，使得这些关系产生结果。</p><p>声明式编程是一个大的概念，其下包含一些有名的子编程范式。包括 <em>约束式编程</em>、<em>领域专属语言</em>、<em>函数式编程</em>、<em>逻辑式编程</em>。</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> design </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>头像的显示</title>
      <link href="/blog/2018/12/10/CSS-%E5%A4%B4%E5%83%8F%E7%9A%84%E6%98%BE%E7%A4%BA/"/>
      <url>/blog/2018/12/10/CSS-%E5%A4%B4%E5%83%8F%E7%9A%84%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<p>在项目中遇到了上传头像图片的需求，包括两个部分，一个是头像的上传。另一个是上传后头像图片的显示。</p><h2 id="头像的上传"><a href="#头像的上传" class="headerlink" title="头像的上传"></a>头像的上传</h2><p>头像的上传和普通的图片上传几乎没有不同，但通常需要对上传的图片进行限制，例如限制图片格式为png/jpg，图片大小的限制，图片像素的限制等。</p><span id="more"></span><h3 id="图片格式的限制"><a href="#图片格式的限制" class="headerlink" title="图片格式的限制"></a>图片格式的限制</h3><p>限制为图片格式[‘jpg’, ‘jpeg’, ‘png’, ‘bmp’]，如果头像允许显示动态图，也可以允许gif，不过考虑到大小，一般不允许。最好给予用户提示文案，限定一种最友好的图片格式，例如png。</p><h3 id="图片大小的限制"><a href="#图片大小的限制" class="headerlink" title="图片大小的限制"></a>图片大小的限制</h3><p>头像一般不允许过大的图片，因为引用的页面可能比较多，所以一般限制在百k的级别。例如120k。</p><h3 id="图片像素的限制"><a href="#图片像素的限制" class="headerlink" title="图片像素的限制"></a>图片像素的限制</h3><p>头像一般为正方形，所以最好有文案提示用户上传正方形的图片，而且给予限定范围，例如“尺寸需小于256px*256px且大于120px*120px”，同时给出最佳的头像显示像素，采用此种像素，在应用中大部分情况下既不压缩也不拉伸。由于大部分情况下用户不会上传完全正方形的图片，所以在一定的宽高比例内，也应该允许上传。</p><h3 id="提示语"><a href="#提示语" class="headerlink" title="提示语"></a>提示语</h3><p>包括：  </p><pre><code>1. 默认提示语2. 默认上传失败提示语3. 上传成功提示语4. 图片格式不正确5. 图片大小超过限制6. 图片宽高比例不正确</code></pre><h3 id="上传进度"><a href="#上传进度" class="headerlink" title="上传进度"></a>上传进度</h3><p>有时也需要显示上传进度，不过一般而言图片文件不会很大，如果单单只是图片的上传，也可以使用loading图。</p><h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><p>最简单的上传头像图片的逻辑代码如下：  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;upload-example&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">&quot;file&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">placeholder</span>=<span class="string">&quot;选择图片&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">onchange</span>=<span class="string">&quot;onChange&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">onChange</span>(<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> file = e.<span class="property">target</span>.<span class="property">files</span>[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">check</span>(file); <span class="comment">// 检查待上传文件是否符合要求</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span></span><br><span class="line"><span class="language-javascript">    formData.<span class="title function_">append</span>(<span class="string">&#x27;file&#x27;</span>, file, file.<span class="property">name</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">upload</span>(formData);</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">upload</span>(<span class="params">formData</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    axios.<span class="title function_">request</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">url</span>: uploadUrl,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">data</span>: formData,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">headers</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;multipart/form-data&#x27;</span></span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;).<span class="title function_">then</span>(</span></span><br><span class="line"><span class="language-javascript">            ...</span></span><br><span class="line"><span class="language-javascript">        )</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">check</span>(<span class="params">file</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// file.type in [typeLimit]</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// file.size &lt; sizeLimit</span></span></span><br><span class="line"><span class="language-javascript">    ...</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="头像的显示"><a href="#头像的显示" class="headerlink" title="头像的显示"></a>头像的显示</h2><p>头像的显示也有两种方案，一种是显示为img，另一种是显示为div，然后通过将背景设置为头像图片来显示。两种都需要设置 <code>border-radiu: 50%;</code> 。下面演示下两种显示方案。我们假设头像的区域范围为120px*120px。用户上传了几种头像，一种是实际图片大小为400px*400px，另一种为800px*400px，还有一种为120px*60px。</p><h3 id="用img标签显示"><a href="#用img标签显示" class="headerlink" title="用img标签显示"></a>用img标签显示</h3><p>设置图片的宽和高，通常长度相同，然后设置 <code>border-radiu: 50%;</code> 即可，这样如果用户上传的图片不是正方形的话，在相应的方向上会有拉伸或压缩的效果，如下图二，因为宽度大于高度，且大于120px所以产生了在宽度上压缩的效果。下图三因为高度小于宽度，且小于120px，所以在高度上产生了拉伸的效果。可以使用 <code>object-fit: cover</code> 属性来使图片更合适。</p><p>效果图：  </p><div><style type="text/css">.markdown-body img.avator-example-1 {height: 120px;width: 120px;border-radius: 50%;box-shadow:none;} img.avator-example-1.object-fit {object-fit: cover;}</style></div><div><img class="avator-example-1" src="/blog/static/imgs/avator/400_400.jpg"></img><img class="avator-example-1" src="/blog/static/imgs/avator/800_400.jpg"></img><img class="avator-example-1" src="/blog/static/imgs/avator/120_60.jpg"></img><img class="avator-example-1 object-fit" src="/blog/static/imgs/avator/800_400.jpg"></div><p>代码：  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">img</span><span class="selector-class">.avator-example-1</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">120px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">120px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">img</span><span class="selector-class">.avator-example-1</span><span class="selector-class">.object-fit</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">object-fit</span>: cover;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;avator-example-1&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/blog/static/imgs/avator/400_400.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">img</span>&gt;</span><span class="comment">&lt;!-- 图一 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;avator-example-1&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/blog/static/imgs/avator/800_400.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">img</span>&gt;</span><span class="comment">&lt;!-- 图二 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;avator-example-1&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/blog/static/imgs/avator/120_60.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">img</span>&gt;</span><span class="comment">&lt;!-- 图三 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;avator-example-1 object-fit&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/blog/static/imgs/avator/120_60.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">img</span>&gt;</span><span class="comment">&lt;!-- 图四 --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="用div标签的background-image来显示"><a href="#用div标签的background-image来显示" class="headerlink" title="用div标签的background-image来显示"></a>用div标签的background-image来显示</h3><p>设置区域的 <code>background-image</code> 为用户上传的图片然后设置 <code>background-size</code> 属性即可，例如设置 <code>background-size: 120px 120px;</code> 则会在相应的方向上压缩或拉伸，如下图三。如果设置 <code>background-size: auto 120px;</code> 则图片的高度会占满空间，宽度会取120px，如下图二。这和设置成 <code>background-size: cover;</code> 的效果是相同的，如下图四，五。注意，因为此处举例的图片为宽度大于高度，所以设置 <code>background-size: auto 120px;</code> 会呈现圆形，如果高度大于宽度，则应当设置 <code>backgounrd-size: 120px auto;</code> 。</p><p>效果图：  </p><div><style type="text/css">div.avator-example-2,div.avator-example-3,div.avator-example-4,div.avator-example-5,div.avator-example-6 {height: 120px;width: 120px;margin: 10px 25px;border-radius: 50%;background-color: #fff;background-size: 120px 120px;background-repeat: no-repeat;background-image: url(/blog/static/imgs/avator/800_400.jpg);}div.avator-example-2 {background-image: url(/blog/static/imgs/avator/400_400.jpg);}div.avator-example-3 {background-size: auto 120px;}div.avator-example-5,div.avator-example-6 {background-size: cover;}div.avator-example-6 {background-image:url(/blog/static/imgs/avator/120_60.jpg);}</style></div><div style="display:flex; flex-wrap: wrap;"><div class="avator-example-2"></div><div class="avator-example-3"></div><div class="avator-example-4"></div><div class="avator-example-5"></div><div class="avator-example-6"></div></div><p>代码：  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span><span class="selector-class">.avator-example-2</span>,</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span><span class="selector-class">.avator-example-3</span>,</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span><span class="selector-class">.avator-example-4</span>,</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span><span class="selector-class">.avator-example-5</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">120px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">120px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-size</span>: <span class="number">120px</span> <span class="number">120px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-repeat</span>: no-repeat;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">/blog/static/imgs/avator/800_400.jpg</span>);</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span><span class="selector-class">.avator-example-2</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">/blog/static/imgs/avator/400_400.jpg</span>);</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span><span class="selector-class">.avator-example-3</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-size</span>: auto <span class="number">120px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span><span class="selector-class">.avator-example-5</span>,</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span><span class="selector-class">.avator-example-6</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-size</span>: cover;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span><span class="selector-class">.avator-example-6</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">/blog/static/imgs/avator/120_60.jpg</span>);</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;avator-example-2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="comment">&lt;!-- 图一 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;avator-example-3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="comment">&lt;!-- 图二 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;avator-example-4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="comment">&lt;!-- 图三 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;avator-example-5&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="comment">&lt;!-- 图四 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;avator-example-6&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="comment">&lt;!-- 图五 --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="object-fit"><a href="#object-fit" class="headerlink" title="object-fit"></a>object-fit</h3><p><code>object-fit</code> 属性用来控制 img、video 元素在容器中的显示方式，尤其是元素的宽高和容器不一致时。</p><ul><li><code>cover</code> 将会正比例的调整图片的大小以适应容器的宽高比，使得图片被裁剪。</li><li><code>contain</code>会成比例的调整图片的大小以使得图片可以完整的展示，但是容器中不展示图片的部分将会展示为 <code>background-color</code> 的颜色。</li><li>默认值为 <code>fill</code>,图片的宽高和容器不一致时图片会被压缩或拉伸。</li><li><code>none</code> 将不会处理图片，图片会被平铺在容器中，既不压缩也不拉伸。</li></ul><h3 id="backgound-size"><a href="#backgound-size" class="headerlink" title="backgound-size"></a>backgound-size</h3><p><code>backgound-size</code> 属性用来指定背景图片（<code>background-image</code>）的大小，以像素、百分比来显示，或者通过 <code>cover</code>、<code>contain</code> 属性对图片进行拉伸或压缩。</p><ul><li>值为像素值时，可以设定背景图片的高度和宽度。第一个值设置宽度，第二个值设置高度。如果只给出一个值，第二个会被设置为 <code>auto</code>。</li><li>值为百分比时，将计算相对于背景定位区域的百分比。<code>100% 100%</code> 表示将背景图片的宽高设置为与容器一致，如果背景图片的宽高比与容器不一致，则会在特定方向上出现压缩或拉伸的效果。</li><li>值为 <code>cover</code> 时，会保持图片的宽高比并将图片缩放成完全覆盖背景定位区域的大小。</li><li>值为 <code>contain</code> 时，会保持图片的宽高比并将图片缩放到背景区域能够完全包含图片的大小。</li><li>默认值为 <code>auto</code> ，既不压缩也不拉伸。</li></ul>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flex布局</title>
      <link href="/blog/2018/12/06/CSS-Flex%E5%B8%83%E5%B1%80/"/>
      <url>/blog/2018/12/06/CSS-Flex%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h2><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性，设为 Flex 布局以后，子元素的 float、clear 和 vertical-align 属性无效。  </p><p>任何一个容器都可以指定为flex布局</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: -webkit-flex;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flex布局由父子元素共同组成，父元素被称为flex container，子元素被称为flex item。</p><div><style type="text/css">img {box-shadow:none !important;</style><img src="/blog/static/imgs/flex.png" alt="flex"></div><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。  </p><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。  </p><span id="more"></span><h2 id="flex-container-属性"><a href="#flex-container-属性" class="headerlink" title="flex container 属性"></a>flex container 属性</h2><p>flex container包含以下属性  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">flex</span>-container &#123; // <span class="attribute">flex</span>容器</span><br><span class="line">    <span class="attribute">display</span>: flex; // 设置容器为弹性布局</span><br><span class="line">    <span class="attribute">flex-direction</span>: <span class="built_in">row</span>(default) | row-reverse | column | column-reverse; // 主轴方向</span><br><span class="line">    <span class="attribute">flex-wrap</span>: <span class="built_in">nowrap</span>(default) | wrap | wrap-reverse; //换行</span><br><span class="line">    <span class="attribute">flex-flow</span>: &lt;flex-direction&gt;||&lt;flex-wrap&gt;; //以上两属性的缩写形式</span><br><span class="line">    <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around; //主轴对齐方式</span><br><span class="line">    <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch; // 交叉轴对齐方式</span><br><span class="line">    <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch; // 轴有多个时（<span class="attribute">flex-wrap</span>:wrap），多根轴线的对齐方式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="flex-item-属性"><a href="#flex-item-属性" class="headerlink" title="flex item 属性"></a>flex item 属性</h2><p>flex item 包含以下属性  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">flex</span>-item &#123; // <span class="attribute">flex</span> item</span><br><span class="line">    <span class="attribute">order</span>: &lt;integer&gt;(default <span class="number">0</span>); //顺序</span><br><span class="line">    <span class="attribute">flex-grow</span>:&lt;number&gt;(default <span class="number">0</span>); //项目放大比例 默认存在剩余空间也不放大</span><br><span class="line">    <span class="attribute">flex-shrink</span>: &lt;number&gt;(default <span class="number">1</span>); //项目缩小比例 默认空间不足时，当前项目缩小</span><br><span class="line">    <span class="attribute">flex-basis</span>: &lt;length&gt;|<span class="built_in">auto</span>(default auto); // 在分配多余空间之前，项目占据主轴的空间</span><br><span class="line">    <span class="attribute">flex</span>:&lt;flex-grow&gt; || &lt;flex-shrink&gt; || &lt;flex-basis&gt;; //<span class="attribute">flex-grow</span> <span class="attribute">flex-shrink</span> <span class="attribute">flex-basis</span> 缩写</span><br><span class="line">    <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;//该项目交叉轴对齐方式， 覆盖container的<span class="attribute">align-items</span>属性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac下Eclipse快捷键</title>
      <link href="/blog/2018/11/30/TIPS-Mac-%E4%B8%8BEclipse%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/blog/2018/11/30/TIPS-Mac-%E4%B8%8BEclipse%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="快捷操作"><a href="#快捷操作" class="headerlink" title="快捷操作"></a>快捷操作</h2><table><thead><tr><th>操作</th><th>快捷键</th></tr></thead><tbody><tr><td>全选</td><td>command A</td></tr><tr><td>复制</td><td>command C</td></tr><tr><td>粘贴</td><td>command V</td></tr><tr><td>查找</td><td>command F</td></tr><tr><td>回退</td><td>command Z</td></tr><tr><td>剪切</td><td>command X</td></tr><tr><td>退出</td><td>command Q</td></tr><tr><td>删除当前行</td><td>command D</td></tr><tr><td>放大字体</td><td>command +</td></tr><tr><td>缩小字体</td><td>command -</td></tr><tr><td>注释/反注释</td><td>command /</td></tr><tr><td>打开preference</td><td>command ,</td></tr><tr><td>代码补全提示</td><td>option /</td></tr><tr><td>最大化/还原</td><td>control M</td></tr><tr><td>格式化代码</td><td>command shift F</td></tr><tr><td>自动导入包</td><td>command shift O</td></tr></tbody></table><h2 id="便利设置"><a href="#便利设置" class="headerlink" title="便利设置"></a>便利设置</h2><p>Preference -&gt; General -&gt; Editors -&gt; Text Editors</p><p><input type="checkbox" checked></input> Show line numbers<br><input type="checkbox" checked></input> Show white space charactors</p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
            <tag> eclipse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS postion属性</title>
      <link href="/blog/2018/11/29/CSS-position%E5%B1%9E%E6%80%A7/"/>
      <url>/blog/2018/11/29/CSS-position%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="position四个属性"><a href="#position四个属性" class="headerlink" title="position四个属性"></a>position四个属性</h2><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>absolute</td><td>生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。<br/>此元素的位置可通过 “top”、”right”、”bottom” 以及 “left” 属性来规定。</td></tr><tr><td>relative</td><td>生成相对定位的元素，相对于其正常位置进行定位。</td></tr><tr><td>fixed</td><td>生成绝对定位的元素，相对于浏览器窗口进行定位。<br/>元素的位置通过 “top”、”right”、”bottom” 以及 “left” 属性进行规定。</td></tr><tr><td>sticky</td><td>粘性布局，元素先按照普通文档流定位，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位，而后，元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 “top”、”right”、”bottom” 以及 “left” 之一</td></tr><tr><td>static</td><td>默认值。static 元素会忽略任何 “top”、”right”、”bottom”、”left” 和 “z-index” 声明</td></tr><tr><td>inherit</td><td>规定应该从父元素继承 position 属性的值。position 属性默认是不继承的</td></tr><tr><td>initial</td><td>设置该属性为浏览器默认值，对 positon 属性来说就是 static</td></tr><tr><td>unset</td><td>将属性的值复位，如果该属性是默认继承属性，该值等同于 inherit ，如果该属性是非继承属性，该值等同于 initial 。对 positon 属性来说就是 static</td></tr></tbody></table><span id="more"></span><h2 id="sticky布局如何polifill"><a href="#sticky布局如何polifill" class="headerlink" title="sticky布局如何polifill"></a>sticky布局如何polifill</h2><p>假如需要设置滑动时区块若超出视口则固定于浏览器上。按照常规做法，监听页面 onscroll 事件，判断 scrollTop 是否大于区块距离视口顶部距离，超过了则设定该区块 <code>position: fixed;</code>，反之去掉。onscroll 事件触发比较频繁，需要添加截流。  </p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>下载csv文件</title>
      <link href="/blog/2018/11/26/JS-%E4%B8%8B%E8%BD%BDcsv%E6%96%87%E4%BB%B6/"/>
      <url>/blog/2018/11/26/JS-%E4%B8%8B%E8%BD%BDcsv%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>在B端项目中，经常遇到报表类的需求。即一个表单，然后查询出多种数据，最后导出为excel文件。<br>这里就需要遇到文件下载类的开发。通常，有以下几种方式：  </p><span id="more"></span><h2 id="打开一个文件地址"><a href="#打开一个文件地址" class="headerlink" title="打开一个文件地址"></a>打开一个文件地址</h2><p>前端传递表单参数，后端生成文件，然后返回静态文件地址，然后前端可以在空白页面打开这个地址，文件就会被下载。  </p><h2 id="下载文件流"><a href="#下载文件流" class="headerlink" title="下载文件流"></a>下载文件流</h2><p>前端传递表单参数，后端生成文件，然后返回文件流，最后前端将文件流保存。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前后端采用不同的编码格式会使文件名乱码，暂未解决，work around:可以前端直接定义文件名而不从content-disposition获取</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line">axios.<span class="title function_">request</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: url,</span><br><span class="line">    <span class="attr">params</span>: params,</span><br><span class="line">    <span class="attr">responseType</span>: <span class="string">&#x27;blob&#x27;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> filename = res.<span class="property">headers</span>[<span class="string">&#x27;content-disposition&#x27;</span>];</span><br><span class="line">    <span class="keyword">let</span> filetype = res.<span class="property">headers</span>[<span class="string">&#x27;content-type&#x27;</span>];</span><br><span class="line">    <span class="keyword">const</span> blob = <span class="keyword">new</span> <span class="title class_">Blob</span>([res.<span class="property">data</span>], &#123;<span class="attr">type</span>: filetype&#125;);</span><br><span class="line">    <span class="comment">// IE hack; see http://msdn.microsoft.com/en-us/library/ie/hh779016.aspx</span></span><br><span class="line">    <span class="keyword">const</span> result = filename.<span class="title function_">split</span>(<span class="string">&#x27;;filename=&#x27;</span>)[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (result &amp;&amp; result.<span class="title function_">endsWith</span>(<span class="string">&#x27;.csv&#x27;</span>)) &#123;</span><br><span class="line">        filename = result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        filename = <span class="string">`<span class="subst">$&#123;result || filename&#125;</span>.csv`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">navigator</span>.<span class="property">msSaveOrOpenBlob</span>) &#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="property">navigator</span>.<span class="title function_">msSaveBlob</span>(blob, filename);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> a = <span class="variable language_">window</span>.<span class="property">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        a.<span class="property">href</span> = <span class="variable language_">window</span>.<span class="property">URL</span>.<span class="title function_">createObjectURL</span>(blob, &#123;<span class="attr">type</span>: <span class="string">&#x27;text/plain&#x27;</span>&#125;);</span><br><span class="line">        a.<span class="property">download</span> = filename;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(a);</span><br><span class="line">        <span class="comment">// IE: &quot;Access is denied&quot;; see: https://connect.microsoft.com/IE/feedback/details/797361/ie-10-treats-blob-url-as-cross-origin-and-denies-access</span></span><br><span class="line">        a.<span class="title function_">click</span>();</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// error handle</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="传递数据，由前端生成文件"><a href="#传递数据，由前端生成文件" class="headerlink" title="传递数据，由前端生成文件"></a>传递数据，由前端生成文件</h2><p>前端post传递表单参数，后端返回数据（data）,前端根据返回的数据生成excel文件。<br>这里需要用到 <a href="https://github.com/SheetJS/js-xlsx">js-xlsx</a><br> <a href="https://github.com/SheetJS/js-xlsx">js-xlsx</a> 是一个方便操作xlsx文件的js工具库, node环境及客户端环境都可以用。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="variable constant_">XLSX</span> <span class="keyword">from</span> <span class="string">&#x27;xlsx&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line">axios.<span class="title function_">post</span>(url, params).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = res.<span class="property">data</span>.<span class="property">list</span>; <span class="comment">// result should be array of arrays</span></span><br><span class="line">    <span class="keyword">const</span> ws = <span class="variable constant_">XLSX</span>.<span class="property">utils</span>.<span class="title function_">aoa_to_sheet</span>(result);</span><br><span class="line">    <span class="keyword">const</span> wb = <span class="variable constant_">XLSX</span>.<span class="property">utils</span>.<span class="title function_">book_new</span>();</span><br><span class="line">    <span class="variable constant_">XLSX</span>.<span class="property">utils</span>.<span class="title function_">book_append_sheet</span>(wb, ws, <span class="string">&quot;tabname&quot;</span>);</span><br><span class="line">    <span class="variable constant_">XLSX</span>.<span class="title function_">writeFile</span>(wb, <span class="string">&#x27;filename.xlsx&#x27;</span>);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// error handle</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP状态码</title>
      <link href="/blog/2018/11/02/HTTP-%E7%8A%B6%E6%80%81%E7%A0%81/"/>
      <url>/blog/2018/11/02/HTTP-%E7%8A%B6%E6%80%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<div><style type="text/css">th {white-space: nowrap;}</style></div><p>HTTP状态码（HTTP Status Code）是用以表示网页服务器HTTP响应状态的3位数字代码。它由 RFC 2616 规范定义的，并得到RFC 2518、RFC 2817、RFC 2295、RFC 2774、RFC 4918等规范扩展。  </p><p>常见状态码以<font color='red'>红色</font>显示。</p><span id="more"></span><h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><p>这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。  </p><table><thead><tr><th>状态码</th><th>含义</th><th>解释</th></tr></thead><tbody><tr><td>100</td><td>Continue</td><td>客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应</td></tr><tr><td>101</td><td>Switching Protocols</td><td>服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议</td></tr><tr><td>102</td><td>Processing</td><td>由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行</td></tr></tbody></table><h2 id="成功"><a href="#成功" class="headerlink" title="成功"></a>成功</h2><p>这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。  </p><table><thead><tr><th>状态码</th><th>含义</th><th>解释</th></tr></thead><tbody><tr><td><font color='red'>200</font></td><td><font color='red'>OK</font></td><td>请求已成功，请求所希望的响应头或数据体将随此响应返回。出现此状态码是表示正常状态</td></tr><tr><td>201</td><td>Created</td><td>请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’</td></tr><tr><td>202</td><td>Accepted</td><td>服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了<br>返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成</td></tr><tr><td>203</td><td>Non-Authoritative Information</td><td>服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的</td></tr><tr><td>204</td><td>No Content</td><td>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。<br>如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。<br>由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</td></tr><tr><td>205</td><td>Reset Content</td><td>服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。<br>与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。</td></tr><tr><td>206</td><td>Partial Content</td><td>服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。</td></tr><tr><td>207</td><td>Multi-Status</td><td>由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</td></tr></tbody></table><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。<br>当且仅当后续的请求所使用的方法是 GET 或者 HEAD 时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A-&gt;A，或者A-&gt;B-&gt;C-&gt;A），因为这会导致服务器和客户端大量不必要的资源消耗。按照 HTTP/1.0 版规范的建议，浏览器不应自动访问超过5次的重定向。</p><table><thead><tr><th>状态码</th><th>含义</th><th>解释</th></tr></thead><tbody><tr><td>300</td><td>Multiple Choices</td><td>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。<br>除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。<br>如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。</td></tr><tr><td><font color='red'>301</font></td><td><font color='red'>Moved Permanently</font></td><td>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。<br>新的永久性的URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。<br>如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</td></tr><tr><td><font color='red'>302</font></td><td><font color='red'>Move temporarily</font></td><td>请求的资源临时从不同的 URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。</td></tr><tr><td>303</td><td>See Other</td><td>对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。</td></tr><tr><td><font color='red'>304</font></td><td><font color='red'>Not Modified</font></td><td>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。</td></tr><tr><td>305</td><td>Use Proxy</td><td>被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。</td></tr><tr><td>306</td><td>Switch Proxy</td><td>在最新版的规范中，306状态码已经不再被使用</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>请求的资源临时从不同的URI 响应请求。<br>新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。<br>如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</td></tr></tbody></table><h2 id="请求错误"><a href="#请求错误" class="headerlink" title="请求错误"></a>请求错误</h2><p>这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个 HEAD 请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。<br>如果错误发生时客户端正在传送数据，那么使用TCP的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前，客户端已经收到了包含错误信息的数据包。如果客户端在收到错误信息后继续向服务器发送数据，服务器的TCP栈将向客户端发送一个重置数据包，以清除该客户端所有还未识别的输入缓冲，以免这些数据被服务器上的应用程序读取并干扰后者。  </p><table><thead><tr><th>状态码</th><th>含义</th><th>解释</th></tr></thead><tbody><tr><td>400</td><td>Bad Request</td><td>1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。<br>2、请求参数有误。</td></tr><tr><td><font color='red'>401</font></td><td><font color='red'>Unauthorized</font></td><td>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。</td></tr><tr><td>402</td><td>Payment Required</td><td>该状态码是为了将来可能的需求而预留的。</td></tr><tr><td><font color='red'>403</font></td><td><font color='red'>Forbidden</font></td><td>服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。</td></tr><tr><td><font color='red'>404</font></td><td><font color='red'>Not Found</font></td><td>请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。出现这个错误的最有可能的原因是服务器端没有这个页面。</td></tr><tr><td>405</td><td>Method Not Allowed</td><td>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。<br>鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</td></tr><tr><td>406</td><td>Not Acceptable</td><td>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。<br>除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</td></tr><tr><td>407</td><td>Proxy Authentication Required</td><td>与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。</td></tr><tr><td>408</td><td>Request Timeout</td><td>请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</td></tr><tr><td>409</td><td>Conflict</td><td>由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。</td></tr><tr><td>410</td><td>Gone</td><td>被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。</td></tr><tr><td>411</td><td>Length Required</td><td>服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。</td></tr><tr><td>412</td><td>Precondition Failed</td><td>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</td></tr><tr><td>413</td><td>Request Entity Too Large</td><td>服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。<br>如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。</td></tr><tr><td>414</td><td>Request-URI Too Long</td><td>请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：<br>本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。<br>重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。<br>客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。</td></tr><tr><td>415</td><td>Unsupported Media Type</td><td>对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。</td></tr><tr><td>416</td><td>Requested Range Not Satisfiable</td><td>如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。<br>假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。</td></tr><tr><td>417</td><td>Expectation Failed</td><td>在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。</td></tr><tr><td>421</td><td>too many connections</td><td>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td></tr><tr><td>422</td><td>Unprocessable Entity</td><td>请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）</td></tr><tr><td>423</td><td>Locked</td><td>当前资源被锁定。（RFC 4918 WebDAV）</td></tr><tr><td>424</td><td>Failed Dependency</td><td>由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）</td></tr><tr><td>425</td><td>Unordered Collection</td><td>在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。</td></tr><tr><td>426</td><td>Upgrade Required</td><td>客户端应当切换到TLS/1.0。（RFC 2817）</td></tr><tr><td>449</td><td>Retry With</td><td>由微软扩展，代表请求应当在执行完适当的操作后进行重试。</td></tr><tr><td>451</td><td>Unavailable For Legal Reasons</td><td>该请求因法律原因不可用。（RFC 7725）</td></tr></tbody></table><h2 id="服务器错误"><a href="#服务器错误" class="headerlink" title="服务器错误"></a>服务器错误</h2><p>这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD 请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。<br>这些状态码适用于任何响应方法。  </p><table><thead><tr><th>状态码</th><th>含义</th><th>解释</th></tr></thead><tbody><tr><td><font color='red'>500</font></td><td><font color='red'>Internal Server Error</font></td><td>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</td></tr><tr><td><font color='red'>502</font></td><td><font color='red'>Bad Gateway</font></td><td>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</td></tr><tr><td><font color='red'>503</font></td><td><font color='red'>Service Unavailable</font></td><td>由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。</td></tr><tr><td>504</td><td>Gateway Timeout</td><td>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。</td></tr><tr><td>505</td><td>HTTP Version Not Supported</td><td>服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</td></tr><tr><td>506</td><td>Variant Also Negotiates</td><td>由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</td></tr><tr><td>507</td><td>Insufficient Storage</td><td>服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)</td></tr><tr><td>509</td><td>Bandwidth Limit Exceeded</td><td>服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。</td></tr><tr><td>510</td><td>Not Extended</td><td>获取资源所需要的策略并没有被满足。（RFC 2774）</td></tr><tr><td>600</td><td>Unparseable Response Headers</td><td>源站没有返回响应头部，只返回实体内容</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> status </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue2组件间通信</title>
      <link href="/blog/2018/10/12/Vue-%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
      <url>/blog/2018/10/12/Vue-%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<p>本篇主要讲述Vue2中组件间通信。目前 <a href="https://github.com/vuejs/vue">Vue</a> 最新版本为<a href="https://www.npmjs.com/package/vue"><img src="https://img.shields.io/npm/v/vue.svg" alt="Version" style="width:auto !important;margin:auto;margin-left: 5px;"></a>。</p><span id="more"></span><h2 id="props与自定义事件"><a href="#props与自定义事件" class="headerlink" title="props与自定义事件"></a>props与自定义事件</h2><p>这是Vue推荐使用的通信方法</p><h3 id="Vue中通过props属性可以实现父组件向子组件的参数传递。"><a href="#Vue中通过props属性可以实现父组件向子组件的参数传递。" class="headerlink" title="Vue中通过props属性可以实现父组件向子组件的参数传递。"></a>Vue中通过props属性可以实现父组件向子组件的参数传递。</h3><p>所有的 prop 都使得其父子之间形成了一个 <em>单向下行绑定</em> ：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。</p><p>在子组件中定义props属性<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;blog-post&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 在 JavaScript 中是 camelCase 的</span></span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;postTitle&#x27;</span>],</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>在父组件中传入对应的props属性<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在 HTML 中是 kebab-case 的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">post-title</span>=<span class="string">&quot;hello!&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure></p><blockquote><p>在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变这个对象或数组本身将会影响到父组件的状态。  </p></blockquote><h3 id="Vue中通过自定义事件可以实现子组件向父组件的参数传递。"><a href="#Vue中通过自定义事件可以实现子组件向父组件的参数传递。" class="headerlink" title="Vue中通过自定义事件可以实现子组件向父组件的参数传递。"></a>Vue中通过自定义事件可以实现子组件向父组件的参数传递。</h3><p>在子组件中触发事件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.$emit(<span class="string">&#x27;myEvent&#x27;</span>, data)</span><br></pre></td></tr></table></figure></p><p>在父组件中接受事件并进行处理<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-on:my-event</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="provide与inject"><a href="#provide与inject" class="headerlink" title="provide与inject"></a>provide与inject</h2><p>2.2.0+ 新增  </p><p>这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代组件注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。祖先组件中通过provide来提供变量，然后在子孙后代组件中通过inject来注入变量。不论子孙后代有多深，只要调用了inject那么就可以注入provide中的数据。而不是局限于只能从当前父组件的prop属性来获取数据，只要在祖先组件的生命周期内，子孙后代组件都可以调用。  </p><blockquote><p>provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。</p></blockquote><blockquote><p>provide 和 inject 主要为高阶插件/组件库提供用例。并不推荐直接用于应用程序代码中。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;child&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">inject</span>: [<span class="string">&#x27;somedata&#x27;</span>], <span class="comment">//得到父组件传递过来的数据</span></span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">mymessage</span>: <span class="variable language_">this</span>.<span class="property">somedata</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div&gt;</span></span><br><span class="line"><span class="string">            &lt;input type=&quot;tet&quot; v-model=&quot;mymessage&quot;&gt; </span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;parent&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">provide</span>:&#123;</span><br><span class="line">        <span class="attr">somedata</span>: <span class="string">&#x27;test&#x27;</span> <span class="comment">//提供给子组件的数据</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div&gt;</span></span><br><span class="line"><span class="string">            &lt;p&gt;this is parent compoent!&lt;/p&gt;</span></span><br><span class="line"><span class="string">            &lt;child&gt;&lt;/child&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="props与-sync"><a href="#props与-sync" class="headerlink" title="props与.sync"></a>props与.sync</h2><p>2.3.0+ 新增</p><p>.sync 是一个自定义事件修饰符，可以实现对props的“双向绑定”<br>实际上sync只是props&amp;自定义事件的一个语法糖  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text-document</span> <span class="attr">v-bind:title.sync</span>=<span class="string">&quot;doc.title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">text-document</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实际上是以下写法的一个缩写  </p><p>父组件<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text-document</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:title</span>=<span class="string">&quot;doc.title&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:update:title</span>=<span class="string">&quot;doc.title = $event&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">text-document</span>&gt;</span></span><br></pre></td></tr></table></figure><br>子组件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.$emit(<span class="string">&#x27;update:title&#x27;</span>, newTitle)</span><br></pre></td></tr></table></figure></p><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><p>一个组件上的 <code>v-model</code> 默认会利用名为 value 的 prop 和名为 input 的事件<br>所以可以在父组件中使用  <code>v-model=&quot;message&quot;</code> 然后在子组件中通过 <code>$emit(&#39;input&#39;, newMessage)</code> 来改变父组件上v-model绑定的值message。<br>但是像单选框、复选框等类型的输入控件可能会将 <code>value</code> 特性用于不同的目的。  </p><h2 id="parent与-children-refs"><a href="#parent与-children-refs" class="headerlink" title="$parent与$children/$refs"></a>$parent与$children/$refs</h2><p>不推荐使用  </p><p>在子组件中可以直接通过 <code>this.$parent.$data</code> 来访问和修改父组件的值，<br>在父组件中也可以通过 <code>this.$children[0].$data</code> 来访问和修改子组件的值<br>也可以在引用子组件时通过添加ref来使得父组件中可以通过 <code>this.$refs.child.$data</code> 来访问和修改子组件的值  </p><h2 id="attr与-listener"><a href="#attr与-listener" class="headerlink" title="$attr与$listener"></a>$attr与$listener</h2><p>2.4.0+新增  </p><p>$attr与$listener实现了一种跨父子的参数传递方法  </p><p>$attr包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=”$attrs” 传入内部组件。  </p><p>$listener包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=”$listeners” 传入内部组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;C&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div&gt;</span></span><br><span class="line"><span class="string">            &lt;input type=&quot;text&quot;</span></span><br><span class="line"><span class="string">                v-model=&quot;$attrs.messagec&quot;</span></span><br><span class="line"><span class="string">                @input=&quot;passCData($attrs.messagec)&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;`</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="title function_">passCData</span>(<span class="params">val</span>)&#123;</span><br><span class="line">            <span class="comment">//触发父组件A中的事件</span></span><br><span class="line">            <span class="variable language_">this</span>.$emit(<span class="string">&#x27;getCData&#x27;</span>, val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;B&#x27;</span>, &#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">mymessage</span>: <span class="variable language_">this</span>.<span class="property">message</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div&gt;</span></span><br><span class="line"><span class="string">            &lt;input type=&quot;text&quot; v-model=&quot;mymessage&quot; @input=&quot;passData(mymessage)&quot;&gt; </span></span><br><span class="line"><span class="string">            &lt;!-- C组件中能直接触发getCData的原因在于 B组件调用C组件时 使用 v-on 绑定了$listeners 属性 --&gt;</span></span><br><span class="line"><span class="string">            &lt;!-- 通过v-bind 绑定$attrs属性，C组件可以直接获取到A组件中传递下来的props（除了B组件中props声明的） --&gt;</span></span><br><span class="line"><span class="string">            &lt;C v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot;&gt;&lt;/C&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">    <span class="attr">props</span>:[<span class="string">&#x27;message&#x27;</span>], <span class="comment">//得到父组件传递过来的数据</span></span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="title function_">passData</span>(<span class="params">val</span>)&#123;</span><br><span class="line">            <span class="comment">//触发父组件中的事件</span></span><br><span class="line">            <span class="variable language_">this</span>.$emit(<span class="string">&#x27;getChildData&#x27;</span>,val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;A&#x27;</span>, &#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">message</span>:<span class="string">&#x27;hello b&#x27;</span>, <span class="comment">//传递给子组件的数据</span></span><br><span class="line">            <span class="attr">messagec</span>:<span class="string">&#x27;hello c&#x27;</span> <span class="comment">//传递给c组件的数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div&gt;</span></span><br><span class="line"><span class="string">            &lt;p&gt;this is parent compoent!&lt;/p&gt;</span></span><br><span class="line"><span class="string">            &lt;B :message=&quot;message&quot; @getChildData=&quot;getChildData&quot;</span></span><br><span class="line"><span class="string">                v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot; &gt;&lt;/B&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="comment">//执行子组件触发的事件</span></span><br><span class="line">        <span class="title function_">getChildData</span>(<span class="params">val</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;这是来自B组件的数据&#x27;</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//执行C组件触发的事件</span></span><br><span class="line">        <span class="title function_">getCData</span>(<span class="params">val</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这是来自C组件的数据：&quot;</span> + val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Event-Bus-中央事件总栈-emit-on"><a href="#Event-Bus-中央事件总栈-emit-on" class="headerlink" title="Event Bus 中央事件总栈 $emit $on"></a>Event Bus 中央事件总栈 $emit $on</h2><p>为了实现非父子间的通信，我们可以通过通过使用一个空的Vue实例作为中央事件总栈来处理所有的事件，通过Vue自带的$emit $on来进行组件间通信。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bus = <span class="keyword">new</span> <span class="title class_">Vue</span>()</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bus</span> = bus</span><br></pre></td></tr></table></figure><p>甚至可以用app.js中的Vue实例来处理  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* app.js*/</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  router,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;App/&gt;&#x27;</span>,</span><br><span class="line">  <span class="attr">components</span>: &#123; <span class="title class_">App</span> &#125;,</span><br><span class="line">  beforeCreate () &#123;</span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bus</span> = <span class="variable language_">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样在组件中我们就可以通过以下方式处理  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">bus</span>.$emit(<span class="string">&#x27;some-event&#x27;</span>, data)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">bus</span>.$on(<span class="string">&#x27;some-event&#x27;</span>, <span class="function">()=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><p><a href="https://github.com/vuejs/vuex">vuex</a></p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>清除网站中的无效链接</title>
      <link href="/blog/2018/09/28/TIPS-%E6%B8%85%E9%99%A4%E7%BD%91%E7%AB%99%E4%B8%AD%E7%9A%84%E6%97%A0%E6%95%88%E9%93%BE%E6%8E%A5/"/>
      <url>/blog/2018/09/28/TIPS-%E6%B8%85%E9%99%A4%E7%BD%91%E7%AB%99%E4%B8%AD%E7%9A%84%E6%97%A0%E6%95%88%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p>网站上有大量的无效链接（返回404或域名不存在）会使网站的总体质量下降，所以清除网站中的无效链接也是提升网站质量，优化用户体验的一种方法。  </p><p>通常而言，链接有链接向外部的也有在网站内部跳转的链接，链接向外部的网站尽量希望链接到一些稳定的网站，有些地址是很容易被移除的，比如链接到文章或评论的，链接到个人网站的，链接到下载页的。时常注意一些大的域名变动，比如有些产品可能已经下线或更换地址，如果自己的网站中有引用，也需要同步的改变。链接到内部的网站时可以做一次引用记录，当记录的链接修改时同步修改所有的地方。  </p><span id="more"></span><p>同时介绍一个可以查看页面内链接情况的 Chrome extension  </p><p><a href="https://github.com/ocodia/Check-My-Links">Check-My-Links</a>  </p><div class="check-my-links"><style>.check-my-links img {width:auto;}</style><img src="/blog/static/imgs/check_my_links.png" alt="Check-My-Links"></div><ul><li>Valid links: 通过的链接</li><li>Valid redirecting links: 通过的链接</li><li>Warnings: 警告</li><li>invalid links: 503/404 或其它无效链接</li></ul><p>Check-My-Links 会将当前页面中所有的http/https链接的background改为与上面四种情况对应的颜色。值得注意的是，有时候一些可用的链接可能由于某种原因而被标注为 Invalid links ，所以在 Invalid links 里的链接最好被重新手工测试一下。Warnings 的链接会被在console中显示出来，什么样的链接会被标为warning是可配置的，一般链接的href为空或“#”或者没有href或者表示为hashtag形式却无法在落地页找到时可以标注为warning。可用的链接可以被cache起来，这样就不用相同的链接也发多次请求验证其正确性。如果不想要验证链接的正确性，比如一些退出账户（log out）的链接，可以在链接上加上属性 <code>rel=&quot;nofollow&quot;</code> 来让Check-My-Links跳过对他的验证。具体配置可以在 Check-My-Links 的 <a href="chrome-extension://ojkcdipcgfaekbeaelaapakgnjflfglf/options.html">配置页</a> 查看。有一个问题是当请求返回状态是302，然后跳转到一个下载时，此链接会一直在Queue中，这算是一个bug吧。</p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Charles小抄</title>
      <link href="/blog/2018/09/27/FE-Charles%E5%B0%8F%E6%8A%84/"/>
      <url>/blog/2018/09/27/FE-Charles%E5%B0%8F%E6%8A%84/</url>
      
        <content type="html"><![CDATA[<p>在前端开发过程中我们常常要用到代理工具来处理一些诸如改变请求参数，代理请求地址，以及抓包的问题。目前最流行的代理工具有两种 <a href="https://www.telerik.com/fiddler">Fiddler</a> &amp; <a href="https://www.charlesproxy.com/">Charles</a>。Fiddler是免费的，一直以来只提供了Windows版本，2016年10月之后也提供了Mac OSX版本，不过需要安装跨平台方案Mono。Charles是付费的，20$/license，不过Charles是java swing编写的，网上可以找到很多破解的方案，这里不再赘述。Charles的好处在于功能齐全，界面简单，提供了几乎所有可以用到的代理功能，在MacOS下十分好用，2018年3月之后甚至提供了IOS的版本。下面主要来讲一下Charles的使用。</p><span id="more"></span><h2 id="Charles是什么"><a href="#Charles是什么" class="headerlink" title="Charles是什么"></a>Charles是什么</h2><p>Charles是一个提供了HTTP代理/HTTP监控/反向代理的工具，通过这个工具，开发者可以查看本机与网络之间的所有HTTP以及SSL/HTTPS通信，包括请求与返回以及HTTP头部信息（包含cookie和缓存信息）。</p><div><style type="text/css">img {box-shadow:none !important;</style><img src="/blog/static/imgs/charles-macosx.png" alt="charles-macosx"></div><h2 id="Charles主要功能"><a href="#Charles主要功能" class="headerlink" title="Charles主要功能"></a>Charles主要功能</h2><p>Charles主要功能如下：  </p><ol><li>记录了本机与网络之间的所有通信流量</li><li>展示了所有的请求，返回数据，cookie和头部信息的内容</li><li>支持SSL和HTTPS</li><li>模拟慢网速环境</li><li>下载静态资源</li><li>请求高度可配置</li></ol><h2 id="Charles-安装"><a href="#Charles-安装" class="headerlink" title="Charles 安装"></a>Charles 安装</h2><p>点击<a href="https://www.charlesproxy.com/download/">这里</a>可以跳转到下载页面。<br>截止北京时间2018年9月27日16:09 最新的版本为4.2.7  </p><p>Charles提供了以下版本</p><ul><li><p>Windows</p><blockquote><p>Windows 64 bit (msi, 64.7 MB)<br>Windows 32 bit (msi, 63.9 MB)</p></blockquote></li><li><p>macOS</p><blockquote><p>macOS (dmg, 58 MB) (兼容 macOS 10.7 - 10.13)</p></blockquote></li><li><p>Linux</p><blockquote><p>Linux 64 bit (tar.gz, 56.1 MB)<br>Linux 32 bit (tar.gz, 55.6 MB)</p></blockquote></li></ul><p>Firefox浏览器下还提供了一个add-on来支持Charles.</p><h2 id="Charles配置"><a href="#Charles配置" class="headerlink" title="Charles配置"></a>Charles配置</h2><p>在Windows及 MacOS系统中，只要赋予权限Charles会自动将自己配置为代理服务器，不过还有一些比较通用的设置，以MacOS为例  </p><ul><li>打开 Charles &gt; Preference &gt; Startup ，关掉Start throttling，Check for updates。  </li><li>点击 Proxy &gt; Mac OS X Proxy 启用系统代理。  </li></ul><p>在IOS中需要自己在wifi配置中手动设置。配置步骤如下：  </p><ol><li>打开 设置 &gt; Wifi ，找到自己连接的网络然后打开</li><li>滑动到 HTTP代理设置，选择 手动 ，输入运行Charles server的IP与端口号（通常是8888）。</li></ol><h2 id="Charles-用法"><a href="#Charles-用法" class="headerlink" title="Charles 用法"></a>Charles 用法</h2><p>以Charles 3.9.1为例，Charles的常用功能如下：  </p><h3 id="查看请求内容（抓包）"><a href="#查看请求内容（抓包）" class="headerlink" title="查看请求内容（抓包）"></a>查看请求内容（抓包）</h3><p>首先点击 File &gt; New 或者 菜单栏的New Session创建一个session，然后点击 Proxy &gt; Start Recording 开始记录请求。 在浏览器中发送请求，就可以在Charles中查看请求的相关信息。Charles支持以结构化（Structure）或者序列（Sequence）的方式展示请求，结构化展示会把同地址端口的请求汇总，序列化则会按照请求顺序展示请求。<br>可以在Proxy &gt; Recording Setting设置记录的相关信息  </p><p>支持：</p><ol><li>限制请求数量与大小</li><li>仅记录固定地址列表</li><li>记录时排除某些地址</li></ol><p>记录的信息是存储在内存中的，所以如果不需要记录的请求最好能够过滤掉，记录的数据过多时Charles也会提醒并关闭记录。记录的数据可以通过 File &gt; Export 导出，也可以通过 File &gt; Save as 保存为Charles可识别的.chls文件。</p><h3 id="代理请求"><a href="#代理请求" class="headerlink" title="代理请求"></a>代理请求</h3><p>打开 Tools &gt; Map Remote/Map Local &gt; Enable Map Remote/Enable Map Local ，点击 Add 可以添加新的代理映射<br>代理的作用是将请求的地址转向一个新的网络地址/本地地址，有些情况下可以用到  </p><ol><li>在生产环境测试时发现了问题，可以将请求的资源映射到本地资源，然后通过修改本地的代码预览修改后的效果。</li><li>可以配置生产环境，测试环境，开发环境的地址，通过在 Map remote 中切换环境地址来切换环境而不用修改访问的地址。</li><li>某些已发布的客户端请求的地址时固定的，可以通过 Map remote 来修改请求的地址。</li></ol><h3 id="查看HTTPS"><a href="#查看HTTPS" class="headerlink" title="查看HTTPS"></a>查看HTTPS</h3><p>通常情况下HTTPS请求是加密并无法被查看的，但是通过替换正常证书为Charles颁发的证书可以做到查看HTTPS请求。<br>打开 Proxy &gt; Proxy Settings &gt; SSL &gt; Enable SSL proxying ，点击Add添加地址，通常端口号为443(HTTPS的端口号)。<br>然后打开网址，以Chrome为例，需要点击 高级 &gt; 允许 来访问地址，这时就可以在Charles中查看HTTPS请求内容。<br>通过将Charles证书添加到“受信任的证书”可以避免浏览器的不信任阻塞。<br>如何将Charles证书添加到“受信任的证书”的方法根据操作系统及浏览器的不同而不同。<br>Windows/IE</p><blockquote><p>Help &gt; SSL Proxying &gt; Install Charles Root Certificate &gt; Install Certificate</p></blockquote><p>MacOS</p><blockquote><p>Help &gt; SSL Proxying &gt; Install Charles Root Certificate 打开钥匙串，搜索 Charles Proxy，双击打开，然后将 信任 &gt; 使用此证书时 下拉框选择为“始终信任”<br>根据官网文档，如上步骤操作就行了，实际上因为Charles certficate 采用的SHA1加密算法，仍旧会被Chrome提示不安全，Safari不再提示不安全</p></blockquote><h3 id="截流"><a href="#截流" class="headerlink" title="截流"></a>截流</h3><p>打开 Proxy &gt; Throttle Settings &gt; Enable Throttling ，可以模仿弱网环境下的请求。  </p><p>支持：  </p><ol><li>对指定host截流</li><li>限制上传下载带宽，利用率，往返延迟，最大传输单元（MTU）</li></ol><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>Charles还提供了其它的一些功能：  </p><ol><li>请求内容的结构化展示</li><li>请求的断点与内容修改/重写</li><li>反向代理，将请求向本机的资源转发到远端的 web server 上</li><li>TCP/UDP 端口转发</li><li>IP访问控制</li><li>外部 HTTP/HTTPS/SOCKS 代理服务器连接</li><li>Charles web化管理</li><li>SSL连接</li><li>no cache连接，包括特定地址的 no cache 连接</li><li>block cookie连接，包括特定地址的 block cookie 连接</li><li>DNS欺骗</li><li>发布Gist</li></ol>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> proxy </tag>
            
            <tag> charles </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>列表拖拽排序sortablejs</title>
      <link href="/blog/2018/09/26/JS-%E5%88%97%E8%A1%A8%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8Fsortablejs/"/>
      <url>/blog/2018/09/26/JS-%E5%88%97%E8%A1%A8%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8Fsortablejs/</url>
      
        <content type="html"><![CDATA[<h2 id="简单的拖拽交换"><a href="#简单的拖拽交换" class="headerlink" title="简单的拖拽交换"></a>简单的拖拽交换</h2><p>实现列表拖拽排序，最简单的方法就是将想要拖拽的元素设置为dragable=“true”，然后利用drag事件处理元素位置变换。  </p><p>拖拽的时候主要有以下几个事件  </p><ul><li>ondragstart 事件：当拖拽元素开始被拖拽的时候触发的事件，此事件作用在被拖曳元素上  </li><li>ondragenter 事件：当拖曳元素进入目标元素的时候触发的事件，此事件作用在目标元素上  </li><li>ondragover 事件：拖拽元素在目标元素上移动的时候触发的事件，此事件作用在目标元素上  </li><li>ondrop 事件：被拖拽的元素在目标元素上同时鼠标放开触发的事件，此事件作用在目标元素上  </li><li>ondragend 事件：当拖拽完成后触发的事件，此事件作用在被拖曳元素上  </li></ul><span id="more"></span><p>实现一个最简单的拖拽交换顺序，可以通过以下步骤来实现</p><ol><li>ondragstart 记录初始拖拽元素，需要注意的是在Firefox浏览器中必须调用 <code>dataTransfer.setData()</code> 设置拖拽的值否则无法拖拽</li><li>ondragover e.preventDefault() 阻止ondragover可能导致ondrop无法触发</li><li>ondrop 记录目标元素，并交换初始元素与目标元素</li></ol><h2 id="Sortable用法"><a href="#Sortable用法" class="headerlink" title="Sortable用法"></a>Sortable用法</h2><p>实现更顺滑的拖拽排序可以通过<a href="https://github.com/RubaXa/Sortable">Sortable</a> 来实现。<br>Sortable采用的是MIT协议，不依赖任何其它的库，使用原生html5 DnD来实现，并且只有1500行。<br>查看<a href="http://rubaxa.github.io/Sortable/">Demo</a>  </p><p>用法：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Sortable</span>.<span class="title function_">create</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;foo&#x27;</span>), &#123;</span><br><span class="line">    <span class="attr">group</span>: <span class="string">&quot;name&quot;</span>,  <span class="comment">// 列表名，在多列表中互相交换时为Object,形如&#123;name:&quot;...&quot;,pull:true,put:false，revertClone:false&#125;多列表需要设置相同的name，pull和put表示拖拽入和出的各种情况</span></span><br><span class="line">    <span class="attr">sort</span>: <span class="literal">true</span>,  <span class="comment">// 是否在列表中排序</span></span><br><span class="line">    <span class="attr">delay</span>: <span class="number">0</span>, <span class="comment">// 毫秒值，定义何时排序开始</span></span><br><span class="line">    <span class="attr">touchStartThreshold</span>: <span class="number">0</span>, <span class="comment">// px, how many pixels the point should move before cancelling a delayed drag event</span></span><br><span class="line">    <span class="attr">disabled</span>: <span class="literal">false</span>, <span class="comment">// 设定为true则禁止排序</span></span><br><span class="line">    <span class="attr">store</span>: <span class="literal">null</span>,  <span class="comment">// @see Store</span></span><br><span class="line">    <span class="attr">animation</span>: <span class="number">150</span>,  <span class="comment">// 毫秒值，移动的动画时间，设置为0则没有动画效果</span></span><br><span class="line">    <span class="comment">// 以下都是一些元素选择器命名</span></span><br><span class="line">    <span class="attr">handle</span>: <span class="string">&quot;.my-handle&quot;</span>,  <span class="comment">// Drag handle selector within list items</span></span><br><span class="line">    <span class="attr">filter</span>: <span class="string">&quot;.ignore-elements&quot;</span>,  <span class="comment">// Selectors that do not lead to dragging (String or Function)</span></span><br><span class="line">    <span class="attr">preventOnFilter</span>: <span class="literal">true</span>, <span class="comment">// Call `event.preventDefault()` when triggered `filter`</span></span><br><span class="line">    <span class="attr">draggable</span>: <span class="string">&quot;.item&quot;</span>,  <span class="comment">// Specifies which items inside the element should be draggable</span></span><br><span class="line">    <span class="attr">ghostClass</span>: <span class="string">&quot;sortable-ghost&quot;</span>,  <span class="comment">// Class name for the drop placeholder</span></span><br><span class="line">    <span class="attr">chosenClass</span>: <span class="string">&quot;sortable-chosen&quot;</span>,  <span class="comment">// Class name for the chosen item</span></span><br><span class="line">    <span class="attr">dragClass</span>: <span class="string">&quot;sortable-drag&quot;</span>,  <span class="comment">// Class name for the dragging item</span></span><br><span class="line">    <span class="attr">dataIdAttr</span>: <span class="string">&#x27;data-id&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">forceFallback</span>: <span class="literal">false</span>,  <span class="comment">// 是否忽略HTML5 原生dnd行为</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">fallbackClass</span>: <span class="string">&quot;sortable-fallback&quot;</span>,  <span class="comment">// Class name for the cloned DOM Element when using forceFallback</span></span><br><span class="line">    <span class="attr">fallbackOnBody</span>: <span class="literal">false</span>,  <span class="comment">// Appends the cloned DOM Element into the Document&#x27;s Body</span></span><br><span class="line">    <span class="attr">fallbackTolerance</span>: <span class="number">0</span>, <span class="comment">// Specify in pixels how far the mouse should move before it&#x27;s considered as a drag.</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">scroll</span>: <span class="literal">true</span>, <span class="comment">// or HTMLElement</span></span><br><span class="line">    <span class="attr">scrollFn</span>: <span class="keyword">function</span>(<span class="params">offsetX, offsetY, originalEvent, touchEvt, hoverTargetEl</span>) &#123; ... &#125;, <span class="comment">// if you have custom scrollbar scrollFn may be used for autoscrolling</span></span><br><span class="line">    <span class="attr">scrollSensitivity</span>: <span class="number">30</span>, <span class="comment">// px, how near the mouse must be to an edge to start scrolling.</span></span><br><span class="line">    <span class="attr">scrollSpeed</span>: <span class="number">10</span>, <span class="comment">// px</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">setData</span>: <span class="keyword">function</span> (<span class="params"><span class="comment">/** DataTransfer */</span>dataTransfer, <span class="comment">/** HTMLElement*/</span>dragEl</span>) &#123;</span><br><span class="line">        dataTransfer.<span class="title function_">setData</span>(<span class="string">&#x27;Text&#x27;</span>, dragEl.<span class="property">textContent</span>); <span class="comment">// `dataTransfer` object of HTML5 DragEvent</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onChoose</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;  <span class="comment">// 元素被选择时触发该事件</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onChoose.foo:&#x27;</span>, [evt.<span class="property">item</span>]);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onStart</span>:<span class="keyword">function</span>(<span class="params">evt</span>)&#123;  <span class="comment">//开始拖拽触发该事件</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onStart.foo:&#x27;</span>, [evt.<span class="property">item</span>]);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onEnd</span>: <span class="keyword">function</span>(<span class="params">evt</span>)&#123; <span class="comment">//拖拽完毕之后触发该事件</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onEnd.foo:&#x27;</span>, [evt.<span class="property">item</span>, evt.<span class="property">from</span>, evt.<span class="property">to</span>, evt.<span class="property">oldIndex</span>, evt.<span class="property">newIndex</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">onAdd</span>: <span class="keyword">function</span> (<span class="params">evt</span>)&#123;   <span class="comment">//从另外一个列表拖找到当前列表时触发该事件</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onAdd.foo:&#x27;</span>, [evt.<span class="property">item</span>]);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onUpdate</span>: <span class="keyword">function</span> (<span class="params">evt</span>)&#123;  <span class="comment">//在列表内更新位置时触发该事件</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onUpdate.foo:&#x27;</span>, [evt.<span class="property">item</span>]);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onSort</span>:<span class="keyword">function</span>(<span class="params">evt</span>)&#123;  <span class="comment">//发生排序时触发该事件</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onSort.foo:&#x27;</span>, [evt.<span class="property">item</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">onRemove</span>: <span class="keyword">function</span> (<span class="params">evt</span>)&#123;  <span class="comment">//从当前列表删除时触发该事件（被拖拽到另一个列表）</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onRemove.foo:&#x27;</span>, [evt.<span class="property">item</span>]);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onFilter</span>: <span class="keyword">function</span> (<span class="params">evt</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onFilter.foo:&#x27;</span>, [evt.<span class="property">item</span>]);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onMove</span>: <span class="keyword">function</span> (<span class="params">evt, originalEvent</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onMove.foo:&#x27;</span>, [evt.<span class="property">dragged</span>,evt.<span class="property">draggedRect</span>, evt.<span class="property">related</span>, evt.<span class="property">relatedRect</span>, originalEvent.<span class="property">clientY</span>]);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onClone</span>: <span class="keyword">function</span> (<span class="params">evt</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onClone.foo:&#x27;</span>, [evt.<span class="property">item</span>, evt.<span class="property">clone</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Sortable在React中的用法示例"><a href="#Sortable在React中的用法示例" class="headerlink" title="Sortable在React中的用法示例"></a>Sortable在React中的用法示例</h2><p>React中的示例：<br><figure class="highlight javascript"><figcaption><span>react</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Sortable</span>.<span class="title function_">create</span>(<span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;ul-container&#x27;</span>)[<span class="number">0</span>], &#123;</span><br><span class="line">    <span class="attr">animation</span>: <span class="number">150</span>,</span><br><span class="line">    <span class="attr">onSort</span>: <span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> newOrderItem = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">orderItem</span>;</span><br><span class="line">        <span class="keyword">let</span> dragedItem = newOrderItem.<span class="title function_">splice</span>(evt.<span class="property">oldIndex</span>, <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">        newOrderItem.<span class="title function_">splice</span>(evt.<span class="property">newIndex</span>, <span class="number">0</span>, dragedItem);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">orderItem</span>: newOrderItem &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>通常，还需要将拖拽的item的样式设置为不可见<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">cursor</span>: move;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sortable-ghost</span> &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="其它版本的Sortable"><a href="#其它版本的Sortable" class="headerlink" title="其它版本的Sortable"></a>其它版本的Sortable</h2><p>Sortable由于只采用了原生的HTML5来实现拖拽，所以可以被轻松地移植到几乎所有的框架中，例如<a href="https://github.com/SortableJS/Vue.Draggable">Vue版本的Sortable</a>，<a href="https://github.com/SortableJS/angular-sortablejs">Angular2版本的Sortable</a>.</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>失效链接替换方案</title>
      <link href="/blog/2018/09/25/TIPS-%E5%A4%B1%E6%95%88%E9%93%BE%E6%8E%A5%E6%9B%BF%E6%8D%A2%E6%96%B9%E6%A1%88/"/>
      <url>/blog/2018/09/25/TIPS-%E5%A4%B1%E6%95%88%E9%93%BE%E6%8E%A5%E6%9B%BF%E6%8D%A2%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>有些时候，尤其在文档型的网站中，页面链接经常变化调整。通常的做法即搜索网站中的所有相应页面进行url替换，但是即使这样做了，还是有一定风险，用户可能已经收藏了链接，在用户点击收藏链接跳转的时候，会发现页面不存在。这时，我们可以通过设置404页面来引导用户跳转到其它的可能符合用户期望的页面（比如主页）。同样的，如果其它网站引用了该失效链接，同时不希望此网站的引用失效（或者没有修改此网站的权限），就只能在落地页网站做一下兼容，在跳转的时候重新定向一下，具体代码如下：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">!<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> path = location.<span class="property">pathname</span> + location.<span class="property">hash</span>;</span><br><span class="line">    <span class="keyword">var</span> urlMap = &#123;</span><br><span class="line">        <span class="string">&#x27;xxx&#x27;</span>: <span class="string">&#x27;xxxx&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;xxx/media#live-player&#x27;</span>: <span class="string">&#x27;xxx/media_live-player/&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    urlMap[path] &amp;&amp; location.<span class="title function_">replace</span>(urlMap[path]);</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><p>这是一种治标不治本的改动，最好的改动还是移除失效的链接。  </p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 长度单位</title>
      <link href="/blog/2018/09/18/CSS-%E9%95%BF%E5%BA%A6%E5%8D%95%E4%BD%8D/"/>
      <url>/blog/2018/09/18/CSS-%E9%95%BF%E5%BA%A6%E5%8D%95%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<p>本篇主要列举并比较下CSS中常用到的几个长度单位。包含px、em、rem、vh、vw、rpx、in、cm、mm、ex、pt、pc。</p><span id="more"></span><h2 id="px"><a href="#px" class="headerlink" title="px"></a>px</h2><p>px(Pixel)像素。相对长度单位。1px等于计算机屏幕上的一个点像素的宽度。px是相对于显示器屏幕分辨率而言的。  </p><h2 id="em"><a href="#em" class="headerlink" title="em"></a>em</h2><p>em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前行内文本的字体尺寸未被人为设置，则相当于浏览器的默认字体尺寸。  </p><p>em特点  </p><ol><li>em的值并不是固定的</li><li>em会继承父级元素的字体大小</li></ol><p>注意：任意浏览器的默认字体高都是16px。所有未经调整的浏览器都符合: 1em = 16px。那么12px = 0.75em，10px = 0.625em。<br>如果使用em作为当前项目的单位，为了简化font-size的换算，需要在CSS中的body选择器中声明font-size=62.5%，这就使em值变为 16px * 62.5% = 10px，这样12px = 1.2em，10px=1em，也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。  </p><h2 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h2><p>rem(Font size of the root element)是CSS3新增的一个相对单位，指相对于根元素（即html元素）的字体大小的单位。  </p><p>rem特点  </p><ol><li>可以做到只修改根元素就成比例地调整所有字体大小</li><li>避免px em混用导致的字体复数计算</li></ol><p>如果使用rem作为当前项目的单位，可以设置<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>那么<code>10px</code>就可以表示为<code>.1rem</code></p><h2 id="vh-vw"><a href="#vh-vw" class="headerlink" title="vh/vw"></a>vh/vw</h2><p>vh(Viewport height)相对于视口的高度。视口被均分为100单位的vh，通过vh可以在不知道视口高度的情况下设置一个相对视口的高度。同理，vw指相对于视口的宽度。</p><p>用法<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.banner</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100vw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="rpx"><a href="#rpx" class="headerlink" title="rpx"></a>rpx</h2><p>rpx(Relative pixcel) 相对像素。只有在小程序中采用的长度计算值。以屏幕宽度恒为750rpx来计算。以iPhone6来讲，屏幕宽度为375px，所以在iPhone6中，375px = 750rpx，也就是1rpx = 0.5px。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>多是一些绝对长度单位<br>1in = 2.54cm = 25.4 mm = 101.6q = 72pt = 6pc = 96px</p><table><thead><tr><th>单位</th><th>含义</th></tr></thead><tbody><tr><td>in</td><td>英寸</td></tr><tr><td>pt</td><td>磅 (1pt =  1/72 in)</td></tr><tr><td>cm</td><td>厘米</td></tr><tr><td>mm</td><td>毫米</td></tr><tr><td>q</td><td>1/4毫米 (1q = 1/4mm)</td></tr><tr><td>pc</td><td>派卡（Picas）(1pc = 12px)</td></tr><tr><td>ex</td><td>相对长度单位 ex 代表了字符 x 的高度(通常是字体尺寸的一半)</td></tr><tr><td>ch</td><td>相对长度单位 ch 代表了字符 0 的宽度</td></tr></tbody></table><h2 id="一些坑"><a href="#一些坑" class="headerlink" title="一些坑"></a>一些坑</h2><p>PC chrome有12px最小字号限制，若使用10px会造成pc调试困难带来不必要的麻烦，所以可以设置字号为12px，然后通过 <code>transform: scale(.8)</code> 来达到同样的效果。  </p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDoS攻击</title>
      <link href="/blog/2018/09/17/HACK-DDOS%E6%94%BB%E5%87%BB/"/>
      <url>/blog/2018/09/17/HACK-DDOS%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<p>分布式拒绝服务(DDoS:Distributed Denial of Service)攻击指借助于客户/服务器技术，将多个计算机联合起来作为攻击平台，对一个或多个目标发动 DoS 攻击，从而成倍地提高拒绝服务攻击威力的一种攻击方式。</p><span id="more"></span><h2 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h2><p>DDoS 攻击通过大量的请求占用网络资源，以达到瘫痪网络的目的。 这种攻击方式大致可分为以下几种：</p><ul><li>通过使网络过载来干扰甚至阻断正常的网络通讯</li><li>通过向服务器提交大量请求，使服务器超负荷</li><li>阻断某一用户访问服务器</li><li>阻断某服务与特定系统或个人的通讯</li></ul><p>下面列举一些常见的 DDos/Dos 攻击方式：  </p><h3 id="SYN-flood"><a href="#SYN-flood" class="headerlink" title="SYN flood"></a>SYN flood</h3><p>该攻击以多个随机的源主机地址向意图主机发送 SYN 包，而在收到意图主机的 SYN ACK 后并不回应，这么，意图主机就为这些源主机树立了很多的衔接行列，而且因为没有收到 ACK 一直维护着这些行列，形成了资源的很多耗费而不能向正常请求供给服务。</p><h3 id="ACK-flood"><a href="#ACK-flood" class="headerlink" title="ACK flood"></a>ACK flood</h3><p>ACK Flood 攻击是在 TCP 连接建立之后，所有的数据传输 TCP 报文都是带有 ACK 标志位的，主机在接收到一个带有 ACK 标志位的数据包的时候，需要检查该数据包所表示的连接四元组是否存在，如果存在则检查该数据包所表示的状态是否合法，然后再向应用层传递该数据包。如果在检查中发现该数据包不合法，例如该数据包所指向的目的端口在本机并未开放，则主机操作系统协议栈会回应 RST 包告诉对方此端口不存在。</p><h3 id="UDP-flood"><a href="#UDP-flood" class="headerlink" title="UDP flood"></a>UDP flood</h3><p>如今在 Internet 上 UDP （用户数据包协议）的应用比较广泛，很多提供 WWW 和 Mail 等服务设备通常是使用 Unix 的服务器，它们默认打开一些被黑客恶意利用的 UDP 服务。如 echo 服务会显示接收到的每一个数据包，而原本作为测试功能的 chargen 服务会在收到每一个数据包时随机反馈一些字符。UDP flood 攻击就是利用这两个简单的 TCP/IP 服务的漏洞进行恶意攻击，通过伪造与某一主机的 Chargen 服务之间的一次的 UDP 连接，回复地址指向开着 Echo 服务的一台主机，通过将 Chargen 和 Echo 服务互指，来回传送毫无用处且占满带宽的垃圾数据，在两台主机之间生成足够多的无用数据流，这一拒绝服务攻击飞快地导致网络可用带宽耗尽。</p><h3 id="Ping-of-Death"><a href="#Ping-of-Death" class="headerlink" title="Ping of Death"></a>Ping of Death</h3><p>ICMP(Internet Control Message Protocol，Internet 控制信息协议)在 Internet 上用于错误处理和传递控制信息。最普通的 ping 程序就是这个功能。而在 TCP/IP 的 RFC 文档中对包的最大尺寸都有严格限制规定，许多操作系统的 TCP/IP 协议栈都规定 ICMP 包大小为64KB，且在对包的标题头进行读取之后，要根据该标题头里包含的信息来为有效载荷生成缓冲区。”Ping of Death” 就是故意产生畸形的测试 Ping（Packet Internet Groper）包，声称自己的尺寸超过 ICMP 上限，也就是加载的尺寸超过64KB上限，使未采取保护措施的网络系统出现内存分配错误，导致 TCP/IP 协议栈崩溃，最终接收方宕机。</p><h3 id="Teardrop"><a href="#Teardrop" class="headerlink" title="Teardrop"></a>Teardrop</h3><p>Teardrop 攻击利用在 TCP/IP 协议栈实现中信任 IP 碎片中的包的标题头所包含的信息来实现自己的攻击。IP 分段含有指示该分段所包含的是原包的哪一段的信息，某些 TCP/IP 协议栈（例如 NT 在 servicepack4 以前）在收到含有重叠偏移的伪造分段时将崩溃。</p><h3 id="Smurf"><a href="#Smurf" class="headerlink" title="Smurf"></a>Smurf</h3><p>该攻击向一个子网的广播地址发一个带有特定请求(如 ICMP 回应请求)的包，并且将源地址伪装成想要攻击的主机地址。子网上所有主机都回应广播包请求而向被攻击主机发包，使该主机受到攻击。</p><h3 id="IP-Spoofing"><a href="#IP-Spoofing" class="headerlink" title="IP Spoofing"></a>IP Spoofing</h3><p>IP 欺骗攻击是一种黑客通过向服务端发送虚假的包以欺骗服务器的做法。具体说，就是将包中的源 IP 地址设置为不存在或不合法的值。服务器一旦接受到该包便会返回接受请求包，但实际上这个包永远返回不到来源处的计算机。这种做法使服务器必需开启自己的监听端口不断等待，也就浪费了系统各方面的资源。</p><h3 id="Land-Attack"><a href="#Land-Attack" class="headerlink" title="Land Attack"></a>Land Attack</h3><p>在 Land 攻击中，黑客利用一个特别打造的 SYN 包–它的原地址和目标地址都被设置成某一个服务器地址进行攻击。此举将导致接受服务器向它自己的地址发送 SYN-ACK 消息，结果这个地址又发回 ACK 消息并创建一个空连接，每一个这样的连接都将保留直到超时，在 Land 攻击下，许多 UNIX 将崩溃， NT 变得极其缓慢（大约持续五分钟）。</p><h3 id="ICMP-flood"><a href="#ICMP-flood" class="headerlink" title="ICMP flood"></a>ICMP flood</h3><p>ICMP flood是通过向未良好设置的路由器发送广播信息占用系统资源的做法。</p><h3 id="Application-level-flood"><a href="#Application-level-flood" class="headerlink" title="Application level flood"></a>Application level flood</h3><p>与前面叙说的攻击方式不同，Application level flood 主要是针对应用软件层的，也就是高于OSI的。它同样是以大量消耗系统资源为目的，通过向 IIS 这样的网络服务程序提出无节制的资源申请来迫害正常的网络服务。</p><h2 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h2><p>可参考措施如下：  </p><ol><li>采用高性能的网络设备<br>首先要保证网络设备不能成为瓶颈，因此选择路由器、交换机、硬件防火墙等设备的时候要尽量选用知名度高、 口碑好的产品。 再就是假如和网络提供商有特殊关系或协议的话就更好了，当大量攻击发生的时候请他们在网络接点处做一下流量限制来对抗某些种类的 DDoS 攻击是非常有效的。</li><li>尽量避免 NAT 的使用<br>无论是路由器还是硬件防护墙设备要尽量避免采用网络地址转换 NAT 的使用， 因为采用此技术会较大降低网络通信能力，其实原因很简单，因为 NAT 需要对地址来回转换，转换过程中需要对网络包的校验和进行计算，因此浪费了很多 CPU 的时间，但有些时候必须使用 NAT，那就没有好办法了。</li><li>充足的网络带宽保证<br>网络带宽直接决定了能抗受攻击的能力， 假若仅仅有 10M 带宽的话， 无论采取什么措施都很难对抗当今的 SYNFlood 攻击， 至少要选择 100M 的共享带宽，最好的当然是挂在1000M 的主干上了。但需要注意的是，主机上的网卡是 1000M 的并不意味着它的网络带宽就是千兆的， 若把它接在 100M 的交换机上， 它的实际带宽不会超过 100M， 再就是接在 100M 的带宽上也不等于就有了百兆的带宽， 因为网络服务商很可能会在交换机上限制实际带宽为10M，这点一定要搞清楚。</li><li>升级主机服务器硬件<br>在有网络带宽保证的前提下，请尽量提升硬件配置，要有效对抗每秒 10 万个 SYN 攻击包，服务器的配置至少应该为：P4 2.4G/DDR512M/SCSI-HD，起关键作用的主要是 CPU 和内存， 内存一定要选择 DDR 的高速内存， 硬盘要尽量选择 SCSI 的，别只贪 IDE 价格不贵量还足的便宜，否则会付出高昂的性能代价，再就是网卡一定要选用 3COM 或 Intel 等名牌的，若是 Realtek 的还是用在自己的 PC 上吧。</li><li>把网站做成静态页面<br>大量事实证明，把网站尽可能做成静态页面，不仅能大大提高抗攻击能力，而且还给黑客入侵带来不少麻烦，至少到现在为止关于 HTML 的溢出还没出现，新浪、搜狐、网易等门户网站主要都是静态页面， 若你非的需要动态脚本调用， 那就把它弄到另外一台单独主机去，免的遭受攻击时连累主服务器。当然， 适当放一些不做数据库调用脚本还是可以的， 此外，最好在需要调用数据库的脚本中拒绝使用代理的访问， 因为经验表明使用代理访问你网站的80%属于恶意行为。</li></ol>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> security </tag>
            
            <tag> DDoS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo也能构建SPA</title>
      <link href="/blog/2018/09/15/Hexo-%E4%B9%9F%E8%83%BD%E6%9E%84%E5%BB%BASPA/"/>
      <url>/blog/2018/09/15/Hexo-%E4%B9%9F%E8%83%BD%E6%9E%84%E5%BB%BASPA/</url>
      
        <content type="html"><![CDATA[<h2 id="SPA"><a href="#SPA" class="headerlink" title="SPA"></a>SPA</h2><p>单页Web应用（single page web application，SPA），就是只有一张Web页面的应用，是加载单个HTML页面并在用户与应用程序交互时动态更新该页面的Web应用程序。<br>单页面应用的好处是不必使得用户在加载新页面时感觉到闪烁刷新的效果，有更好的用户体验。当然，单页面应用也有其问题，例如首屏渲染问题以及SEO问题，但如果构建的是类似于应用型的web页面的话，SPA的好处是远远大于其弊端的。  </p><span id="more"></span><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p><a href="https://github.com/hexojs/hexo">Hexo</a> 是一个静态页面生成框架，一般用来其来搭建博客或者文档型的网站。  </p><h2 id="Hexo-gt-SPA"><a href="#Hexo-gt-SPA" class="headerlink" title="Hexo =&gt; SPA"></a>Hexo =&gt; SPA</h2><p>如何在Hexo的基础上转换为SPA呢？基本的思路就是，监管所有的点击跳转链接，阻止默认行为采用ajax调用的方式获取文档然后替换当前页面。为了使替换时的影响较小，当前文档中数据没有变化的元素就不用替换了，只替换变化的部分。例如，一个采用Hexo的文档型的网站，一般而言包括三个部分header，nav，以及article，header及nav部分是不用变的，只需要替换article部分即可。需要注意的事，在替换后需要注意article内部的事件，需要重新绑定一遍，同时也需要处理nav部分的一些事件，比如focus的变化及样式上的变化，以及其它的一些变化，比如页面title的变化。这样当用户点击左侧nav时，只有article内部内容的替换，看起来就像一个应用一样。但这样修改还有两个问题，一是当用户点击后退时，浏览器不能很好的处理，我们希望记录每一次用户的点击跳转，当用户点击后退时能够回到上一次点击时的页面，另外一个问题是地址栏的没有变化，我们希望每一次用户点击跳转时地址栏也显示相应页面的URL。这时就需要用到History API了.  </p><p>History 对象包含用户（在浏览器窗口中）访问过的 URL。<br>History 对象是 window 对象的一部分，可通过 window.history 属性对其进行访问。  </p><p>属性<br>History.length 只读<br>History.scrollRestoration<br>允许Web应用程序在历史导航上显式地设置默认滚动恢复行为。此属性可以是自动的（auto）或者手动的（manual）。<br>History.state 只读<br>返回一个表示历史堆栈顶部的状态的值。这是一种可以不必等待 popstate 事件而查看状态而的方式。  </p><p>方法<br>History.back()<br>前往上一页, 用户可点击浏览器左上角的返回按钮模拟此方法. 等价于 history.go(-1).<br>History.forward()<br>在浏览器历史记录里前往下一页，用户可点击浏览器左上角的前进按钮模拟此方法. 等价于 history.go(1).<br>History.go()<br>通过当前页面的相对位置从浏览器历史记录( 会话记录 )加载页面。<br>History.pushState()<br>按指定的名称和URL（如果提供该参数）将数据push进会话历史栈，数据被DOM进行不透明处理；你可以指定任何可以被序列化的javascript对象。<br>History.replaceState()<br>按指定的数据，名称和URL(如果提供该参数)，更新历史栈上最新的入口。这个数据被DOM 进行了不透明处理。  </p><p>这里我们需要用到History.pushState()<br>这个方法接收三个参数，第一个state，记录页面状态，第二个title，并不是页面title，感觉没有什么用，第三个是页面URL。在页面变化时执行History.pushState()把将要跳转的页面记录到history中，地址栏中的地址就会同时改变。同时，需要在window.onpopstate中监听后退事件，在后退时也通过ajax方法获取article内容。如果想要减少请求，还可以将ajax获取到的文档缓存下来，当用户点击新URL时再去获取，如果用户点击的是一个已经访问过的URL时，从本地获取。  </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>让我们总结一下，我们需要改变的是如下几个部分(代码中引入了jQuery)：  </p><ol><li>阻止点击链接的默认行为  </li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.<span class="title function_">preventDefault</span>();</span><br></pre></td></tr></table></figure><ol start="2"><li>ajax获取文档内容  </li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// href 跳转url</span></span><br><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: href,</span><br><span class="line">    <span class="attr">dataType</span>: <span class="string">&#x27;html&#x27;</span>,</span><br><span class="line">    <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">res</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> article = $(res).<span class="title function_">find</span>(<span class="string">&#x27;#article&#x27;</span>).<span class="title function_">html</span>();</span><br><span class="line">        $(<span class="string">&#x27;#article&#x27;</span>).<span class="title function_">html</span>(article);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = href;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>成功替换文章内容之后需要重新绑定文章内部的事件，同时对一些样式（例如选中的样式）进行改变。<br>ajax失败则直接通过改变url的方式刷新页面。  </p><ol start="3"><li>页面title变化  </li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doc.<span class="property">title</span> = $(res).<span class="title function_">filter</span>(<span class="string">&#x27;title&#x27;</span>).<span class="title function_">html</span>();</span><br></pre></td></tr></table></figure><ol start="4"><li>window.history.pushState() <ol><li>页面url变化</li><li>记录跳转页面信息到历史记录中，当用户点击后退时能够正确响应 </li></ol></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">win.<span class="property">history</span>.<span class="title function_">pushState</span>(href, <span class="string">&#x27;&#x27;</span>, href);</span><br></pre></td></tr></table></figure><ol start="5"><li>window.onpopstate() 处理用户点击后退/前进时的逻辑</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="variable language_">window</span>).<span class="title function_">on</span>(<span class="string">&#x27;popstate&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="property">state</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> href = e.<span class="property">state</span> ? e.<span class="property">state</span> : win.<span class="property">location</span>.<span class="property">href</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">getArticle</span>(href, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如上代码中，getArticle封装了获取文章的action，加入callback是考虑到获取文章内容之后如果url中包含锚点，页面应该滑动到锚点所在处。  </p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SPA </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 折行</title>
      <link href="/blog/2018/09/12/CSS-%E6%8A%98%E8%A1%8C/"/>
      <url>/blog/2018/09/12/CSS-%E6%8A%98%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>本篇主要介绍与折行有关的三个样式 <code>white-space</code> ， <code>word-wrap</code> ， <code>word-break</code> 。  </p><span id="more"></span><h2 id="css-white-space-属性"><a href="#css-white-space-属性" class="headerlink" title="css white-space 属性"></a>css white-space 属性</h2><p>white-space 属性设置如何处理元素内的空白。  </p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>normal</td><td>默认。空白会被浏览器忽略。</td></tr><tr><td>pre</td><td>空白会被浏览器保留。其行为方式类似 HTML 中的 &lt;pre> 标签。</td></tr><tr><td>nowrap</td><td>文本不会换行，文本会在在同一行上继续，直到遇到 &lt;br> 标签为止。</td></tr><tr><td>pre-wrap</td><td>保留空白符序列，但是正常地进行换行。</td></tr><tr><td>pre-line</td><td>合并空白符序列，但是保留换行符。</td></tr><tr><td>inherit</td><td>规定应该从父元素继承 white-space 属性的值。</td></tr></tbody></table><h2 id="CSS3-word-wrap-属性"><a href="#CSS3-word-wrap-属性" class="headerlink" title="CSS3 word-wrap 属性"></a>CSS3 word-wrap 属性</h2><p>word-wrap 属性允许长单词或 URL 地址换行到下一行。  </p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>normal</td><td>只在允许的断字点换行（浏览器保持默认处理）。</td></tr><tr><td>break-word</td><td>在长单词或 URL 地址内部进行换行。</td></tr></tbody></table><h2 id="CSS3-word-break-属性"><a href="#CSS3-word-break-属性" class="headerlink" title="CSS3 word-break 属性"></a>CSS3 word-break 属性</h2><p>word-break 属性规定自动换行的处理方法。  </p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>normal</td><td>使用浏览器默认的换行规则。</td></tr><tr><td>break-all</td><td>允许在单词内换行。</td></tr><tr><td>keep-all</td><td>只能在半角空格或连字符处换行。</td></tr></tbody></table><h2 id="常用设置"><a href="#常用设置" class="headerlink" title="常用设置"></a>常用设置</h2><p>不折行，可以左右滑动：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">white-space</span>: nowrap;</span><br><span class="line"><span class="attribute">overflow-x</span>: scroll;</span><br></pre></td></tr></table></figure></p><p>每行长度固定，到长度即折行：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">white-space</span>: normal;</span><br><span class="line"><span class="attribute">word-wrap</span>: break-word;</span><br><span class="line"><span class="attribute">word-break</span>: break-all;</span><br></pre></td></tr></table></figure></p><p>每行长度固定，到长度即折行，但标点字符不在首位：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">white-space</span>: normal;</span><br><span class="line"><span class="attribute">word-wrap</span>: break-word;</span><br><span class="line"><span class="attribute">word-break</span>: normal;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>querySelectorAll一个小坑</title>
      <link href="/blog/2018/09/12/TIPS-querySelectorAll%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9D%91/"/>
      <url>/blog/2018/09/12/TIPS-querySelectorAll%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p>首先查看一下querySelectorAll的文档：  </p><h2 id="querySelectorAll"><a href="#querySelectorAll" class="headerlink" title="querySelectorAll"></a>querySelectorAll</h2><p>返回与指定的选择器组匹配的文档中的元素列表 (使用深度优先的先序遍历文档的节点)。返回的对象是 <code>NodeList</code> 。  </p><p>用法：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elementList = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(selectors);</span><br></pre></td></tr></table></figure><ul><li>elementList 是一个静态的 NodeList 类型的对象.</li><li>selectors 是一个由逗号连接的包含一个或多个CSS选择器的字符串.</li><li>如果 selectors参数中包含 <code>CSS伪元素</code>,则返回一个空的elementList.</li><li>如果指定的选择器不合法,则抛出一个<code>SYNTAX_ERR</code> 异常.</li></ul><span id="more"></span><h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><p>如下一个element  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;123&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>document.getElementById(‘123’)可以正常获取到该元素<br>document.querySelectorAll(‘#123’)则报错  </p><p>我们看下Zepto中选择器的实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `$.zepto.qsa` is Zepto&#x27;s css selector implementation which</span></span><br><span class="line"><span class="comment">// uses `document.querySelectorAll` and optimizes for some special cases, like `#id`.</span></span><br><span class="line"><span class="comment">// This method can be overridden in plugins.</span></span><br><span class="line">zepto.<span class="property">qsa</span> = <span class="keyword">function</span>(<span class="params">element, selector</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> found,</span><br><span class="line">      maybeID = selector[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span>,</span><br><span class="line">      maybeClass = !maybeID &amp;&amp; selector[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>,</span><br><span class="line">      nameOnly = maybeID || maybeClass ? selector.<span class="title function_">slice</span>(<span class="number">1</span>) : selector, <span class="comment">// Ensure that a 1 char tag name still gets checked</span></span><br><span class="line">      isSimple = <span class="regexp">/^[\w-]*$/</span>.<span class="title function_">test</span>(nameOnly)</span><br><span class="line">  <span class="keyword">return</span> (element.<span class="property">getElementById</span> &amp;&amp; isSimple &amp;&amp; maybeID) ? <span class="comment">// Safari DocumentFragment doesn&#x27;t have getElementById</span></span><br><span class="line">    ( (found = element.<span class="title function_">getElementById</span>(nameOnly)) ? [found] : [] ) :</span><br><span class="line">    (element.<span class="property">nodeType</span> !== <span class="number">1</span> &amp;&amp; element.<span class="property">nodeType</span> !== <span class="number">9</span> &amp;&amp; element.<span class="property">nodeType</span> !== <span class="number">11</span>) ? [] :</span><br><span class="line">    slice.<span class="title function_">call</span>(</span><br><span class="line">      isSimple &amp;&amp; !maybeID &amp;&amp; element.<span class="property">getElementsByClassName</span> ? <span class="comment">// DocumentFragment doesn&#x27;t have getElementsByClassName/TagName</span></span><br><span class="line">        maybeClass ? element.<span class="title function_">getElementsByClassName</span>(nameOnly) : <span class="comment">// If it&#x27;s simple, it could be a class</span></span><br><span class="line">        element.<span class="title function_">getElementsByTagName</span>(selector) : <span class="comment">// Or a tag</span></span><br><span class="line">        element.<span class="title function_">querySelectorAll</span>(selector) <span class="comment">// Or it&#x27;s not simple, and we need to query all</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同样的，zepto中的选择器用的就是querySelectorAll，但是对于简单情况，又可能使用getElementById/getElementsByClassName/getElementsByTagName，<br>所以对于上面的元素，$(‘#123’)可以获取到元素， $(‘#123 .test’)却会报错，$(‘#123’).find(‘.sddd’)可以正常获取到。<br>对于如下这种元素使用$(‘#1.2.3-标题’)也会报错<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;1.2.3-标题&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><br>报错信息：  </p><blockquote><p><em>VM238:1 Uncaught DOMException: Failed to execute ‘querySelectorAll’ on ‘Document’: ‘#123’ is not a valid selector</em>.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 截断</title>
      <link href="/blog/2018/09/11/CSS-%E6%88%AA%E6%96%AD/"/>
      <url>/blog/2018/09/11/CSS-%E6%88%AA%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<p>有时，我们需要对某段文字进行截断处理，多余的字符显示…  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;words&quot;</span>&gt;</span>For a long time it seemed to me that life was about to begin , real life. But, there was always some obsacle in the way, something to be gotten through first, some unfinnished business, time still to be served or a debt to be paid. Then life would begin.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="单行"><a href="#单行" class="headerlink" title="单行"></a>单行</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.words</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;  <span class="comment">/*超过部分不显示*/</span></span><br><span class="line">    <span class="attribute">text-overflow</span>: ellipsis;  <span class="comment">/*超过部分用点点表示*/</span></span><br><span class="line">    <span class="attribute">white-space</span>: nowrap; <span class="comment">/*不换行*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><div class="words1">For a long time it seemed to me that life was about to begin , real life. But, there was always some obsacle in the way, something to be gotten through first, some unfinnished business, time still to be served or a debt to be paid. Then life would begin.</div></p><style type="text/css">.words1 {    width: 400px;    overflow: hidden;    text-overflow: ellipsis;    white-space: nowrap;}</style><h2 id="多行"><a href="#多行" class="headerlink" title="多行"></a>多行</h2><h3 id="webkit-代码"><a href="#webkit-代码" class="headerlink" title="-webkit 代码"></a>-webkit 代码</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webkit</span></span><br><span class="line"><span class="selector-class">.words</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">overflow </span>: hidden;</span><br><span class="line">    <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">    <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">    -webkit-line-clamp: 2; <span class="comment">/*规定超过两行的部分截断*/</span></span><br><span class="line">    -webkit-box-orient: vertical;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="webkit-效果"><a href="#webkit-效果" class="headerlink" title="-webkit 效果"></a>-webkit 效果</h3><p><div class="words2">For a long time it seemed to me that life was about to begin , real life. But, there was always some obsacle in the way, something to be gotten through first, some unfinnished business, time still to be served or a debt to be paid. Then life would begin.</div></p><style type="text/css">.words2 {    width: 400px;    overflow : hidden;    text-overflow: ellipsis;    display: -webkit-box;    -webkit-line-clamp: 2;    -webkit-box-orient: vertical;}</style><h3 id="兼容代码"><a href="#兼容代码" class="headerlink" title="兼容代码"></a>兼容代码</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 兼容其它内核 <span class="attribute">padding</span>需要根据实际情况计算</span><br><span class="line"><span class="selector-class">.words</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.4em</span>;</span><br><span class="line">    <span class="comment">/* 高度=2倍的行高 */</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">2.8em</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.words</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;...&quot;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">35px</span> <span class="number">1px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="兼容代码效果"><a href="#兼容代码效果" class="headerlink" title="兼容代码效果"></a>兼容代码效果</h3><p><div class="words3">For a long time it seemed to me that life was about to begin , real life. But, there was always some obsacle in the way, something to be gotten through first, some unfinnished business, time still to be served or a debt to be paid. Then life would begin.</div></p><style type="text/css">.words3 {    width: 400px;    position: relative;    line-height: 1.4em;    height: 2.8em;    overflow: hidden;}.words3::after {    content: "...";    position: absolute;    bottom: 0;    right: 0;    padding: 0 35px 1px 0;}</style><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>也有一些通过js实现的截断插件，例如 <a href="https://github.com/FrDH/jQuery.dotdotdot">jQuery.dotdotdot</a>，<a href="https://github.com/josephschmitt/Clamp.js">Clamp.js</a></p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSRF攻击</title>
      <link href="/blog/2018/09/10/HACK-CSRF%E6%94%BB%E5%87%BB/"/>
      <url>/blog/2018/09/10/HACK-CSRF%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<p>CSRF（Cross-site request forgery）跨站请求伪造，也被称为 One Click Attack 或者 Session Riding ，通常缩写为 CSRF 或者 XSRF ，是一种通过伪造用户请求破坏网站的攻击方式。  </p><span id="more"></span><h2 id="CSRF攻击原理"><a href="#CSRF攻击原理" class="headerlink" title="CSRF攻击原理"></a>CSRF攻击原理</h2><p>当你访问 xxx.com 黑客页面的时候，页面上放了一个按钮或者一个表单，URL/action 为 <code>http://you.com/delete-myself</code> ，这样引导或迫使甚至伪造用户触发按钮或表单。在浏览器发出 GET 或 POST 请求的时候，它会带上 you.com 的 cookie，如果网站 you.com 没有做 CSRF 防御措施，那么这次请求在 you.com 看来会是完全合法的，这样就会对 you.com 的数据产生破坏。</p><h2 id="CSRF防范"><a href="#CSRF防范" class="headerlink" title="CSRF防范"></a>CSRF防范</h2><p>对于用户：<br>通过在浏览其它站点前登出站点或者在浏览器会话结束后清理浏览器的 Cookie。</p><p>对于网站拥有者：  </p><h3 id="验证-HTTP-Referer-字段"><a href="#验证-HTTP-Referer-字段" class="headerlink" title="验证 HTTP Referer 字段"></a>验证 HTTP Referer 字段</h3><p>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 <code>http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory</code> ，用户必须先登录 bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。  </p><p>这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。  </p><p>然而，这种方法并非万无一失。Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击。  </p><p>即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。  </p><h3 id="在请求地址中添加-token-并验证"><a href="#在请求地址中添加-token-并验证" class="headerlink" title="在请求地址中添加 token 并验证"></a>在请求地址中添加 token 并验证</h3><p>CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 Cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 Cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 Cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。  </p><p>这种方法要比检查 Referer 要安全一些，token 可以在用户登录后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 <code>http://url?csrftoken=tokenvalue</code> 。 而对于 POST 请求来说，要在 form 的最后加上 <code>&lt;input type=”hidden” name=”csrftoken” value=”tokenvalue”/&gt;</code>，这样就把 token 以参数的形式加入请求了。但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。  </p><p>该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。  </p><h3 id="在-HTTP-头中自定义属性并验证"><a href="#在-HTTP-头中自定义属性并验证" class="headerlink" title="在 HTTP 头中自定义属性并验证"></a>在 HTTP 头中自定义属性并验证</h3><p>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。  </p><p>然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进、后退、刷新、收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。  </p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> security </tag>
            
            <tag> CSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS攻击</title>
      <link href="/blog/2018/09/09/HACK-XSS%E6%94%BB%E5%87%BB/"/>
      <url>/blog/2018/09/09/HACK-XSS%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<p>XSS, 即为（Cross Site Scripting）, 中文名为跨站脚本, 是发生在目标用户的浏览器层面上的攻击方式，当渲染DOM树的过程成发生了不在预期内执行的JS代码时，就发生了XSS攻击。  </p><span id="more"></span><h2 id="XSS攻击方式"><a href="#XSS攻击方式" class="headerlink" title="XSS攻击方式"></a>XSS攻击方式</h2><h3 id="反射型-XSS"><a href="#反射型-XSS" class="headerlink" title="反射型 XSS"></a>反射型 XSS</h3><p>反射型XSS，也叫非持久型XSS，是指发生请求时，XSS代码出现在请求URL中，作为参数提交到服务器，服务器解析并响应。响应结果中包含XSS代码，最后浏览器解析并执行。  </p><p>从概念上可以看出，反射型XSS代码是首先出现在URL中的，然后需要服务端解析，最后需要浏览器解析之后XSS代码才能够攻击。  </p><p>例如：<br>使用express起一个web服务器，然后设置一下请求接口。通过ajax的GET请求将参数发往服务器，服务器解析成json后响应。将返回的数据解析后显示到页面上。（没有对返回的数据进行解码和过滤等操作。）  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;txt&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txt&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;80&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#test&#x27;</span>)</span><br><span class="line">test.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> url = <span class="string">`/test?test=<span class="subst">$&#123;txt.value&#125;</span>`</span>   <span class="comment">// 1. 发送一个GET请求</span></span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">  xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || xhr.<span class="property">status</span> === <span class="number">304</span>) &#123;</span><br><span class="line">        <span class="comment">// 3. 客户端解析JSON，并执行</span></span><br><span class="line">        <span class="keyword">var</span> str = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(xhr.<span class="property">responseText</span>).<span class="property">test</span></span><br><span class="line">        <span class="keyword">var</span> node = <span class="string">`<span class="subst">$&#123;str&#125;</span>`</span></span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">insertAdjacentHTML</span>(<span class="string">&#x27;beforeend&#x27;</span>, node)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;error&#x27;</span>, xhr.<span class="property">responseText</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, url, <span class="literal">true</span>)</span><br><span class="line">  xhr.<span class="title function_">send</span>(<span class="literal">null</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务器代码</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> router = express.<span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/test&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line"> <span class="comment">// 2. 服务端解析成JSON后响应</span></span><br><span class="line">  res.<span class="title function_">json</span>(&#123;</span><br><span class="line">    <span class="attr">test</span>: req.<span class="property">query</span>.<span class="property">test</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>现在我们通过给textarea添加一段有攻击目的的img标签，<br><code>&lt;img src=&quot;null&quot; onerror=&#39;alert(document.cookie)&#39; /&gt;</code></p><p>现在，我们点击&lt;测试&gt;按钮，一个XSS攻击就发生了。  </p><p>实际上，我们只是模拟攻击，通过alert获取到了个人的cookie信息。但是如果是黑客的话，他们会注入一段第三方的js代码，然后将获取到的cookie信息存到他们的服务器上。这样的话黑客们就有机会拿到我们的身份认证做一些违法的事情了。  </p><h3 id="存储型-XSS"><a href="#存储型-XSS" class="headerlink" title="存储型 XSS"></a>存储型 XSS</h3><p>存储型XSS，也叫持久型XSS，主要是将XSS代码发送到服务器并存储在服务器中（不管是数据库、内存还是文件系统等），在用户下次请求页面的时候服务器返回XSS代码并在浏览器中运行。<br>最典型的就是留言板XSS。用户提交了一条包含XSS代码的留言到数据库。当目标用户查询留言时，那些留言的内容会从服务器解析之后加载出来。浏览器发现有XSS代码，就当做正常的HTML和JS解析执行。XSS攻击就发生了。  </p><h3 id="DOM-XSS"><a href="#DOM-XSS" class="headerlink" title="DOM XSS"></a>DOM XSS</h3><p>DOM XSS代码不需要服务器端的解析响应的直接参与，通常是通过浏览器端解析用户输入的内容并直接在页面执行导致的。</p><p>例如：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;var x = &#x27;&quot;</span> + location.<span class="property">hash</span> + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"><span class="comment">// url为</span></span><br><span class="line"><span class="string">`https://www.examle.com/index.html#&#x27;;alert(document.cookie);`</span></span><br></pre></td></tr></table></figure><p>以下 API 均需要注意：  </p><p>动态改变 DOM 的 API:  </p><ul><li>innerHTML/outerHTML</li><li>appendChild/replaceChild/insertBefore</li><li>setAttribute</li><li>document.write/document.writeln</li></ul><p>动态代码执行：  </p><ul><li>document.execCommand</li><li>eval</li><li>setTimeout/setInterval</li><li>new Function()</li></ul><p>用户输入来源：  </p><ul><li>location.href</li><li>location.hash</li><li>document.URL</li><li>document.cookie</li><li>localStorage</li><li>sessionStorage</li><li>indexedDB</li><li>window.opener</li></ul><h2 id="XSS危害"><a href="#XSS危害" class="headerlink" title="XSS危害"></a>XSS危害</h2><ol><li>通过 document.cookie 盗取 cookie</li><li>使用 JS 或 CSS 破坏页面正常的结构、样式与功能，篡改页面</li><li>流量劫持（通过 window.location.href 跳转到其他页面）</li><li>Dos攻击：利用合理的客户端请求来占用过多的服务器资源，从而使合法用户无法得到服务器响应</li><li>利用iframe、frame、XMLHttpRequest等方式，以（被攻击）用户的身份执行一些提交行为，或执行一些一般的如发微博、加好友、发私信等操作</li><li>利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动</li></ol><h2 id="XSS防御"><a href="#XSS防御" class="headerlink" title="XSS防御"></a>XSS防御</h2><p>从以上的XSS攻击样例可以看出，我们不能原样地将用户输入的数据直接存到服务器，需要对数据进行一些处理。以上的代码出现的一些问题如下</p><ul><li>没有过滤危险的DOM节点。如具有执行脚本能力的script, 具有显示广告和色情图片的img, 具有改变样式的link, style, 具有内嵌页面的iframe, frame等元素节点。</li><li>没有过滤危险的属性节点。如事件, style, src, href等</li><li>没有对 cookie 设置 httpOnly 。</li></ul><p>解决方法如下:  </p><h3 id="对cookie的保护"><a href="#对cookie的保护" class="headerlink" title="对cookie的保护"></a>对cookie的保护</h3><p>对重要的 cookie 设置 httpOnly , 防止客户端通过 document.cookie 读取 cookie 。</p><h3 id="对用户输入数据的处理"><a href="#对用户输入数据的处理" class="headerlink" title="对用户输入数据的处理"></a>对用户输入数据的处理</h3><ul><li>编码：不能对用户输入的内容都保持原样，对用户输入的数据进行字符实体编码。</li><li>解码：原样显示内容的时候解码。</li><li>过滤：把输入的一些不合法的字符过滤掉，从而保证安全性。如移除用户上传的DOM属性，如 onerror ，移除用户上传的 style、iframe、script 节点等。</li></ul><h3 id="设置-CSP"><a href="#设置-CSP" class="headerlink" title="设置 CSP"></a>设置 CSP</h3><p>CSP （Content-Security-Policy）内容安全策略，是一个额外的安全层，通过指定有效域——即浏览器认可的可执行脚本的有效来源——使服务器管理者有能力减少或消除XSS攻击所依赖的载体。</p><h3 id="设置-X-XSS-Protection"><a href="#设置-X-XSS-Protection" class="headerlink" title="设置 X-XSS-Protection"></a>设置 X-XSS-Protection</h3><p>HTTP X-XSS-Protection 响应头是 Internet Explorer，Chrome 和 Safari 的一个特性，当检测到跨站脚本攻击（XSS）时，浏览器将停止加载页面。</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> security </tag>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>页面禁止选中复制</title>
      <link href="/blog/2018/09/07/HTML-%E9%A1%B5%E9%9D%A2%E7%A6%81%E6%AD%A2%E9%80%89%E4%B8%AD%E5%A4%8D%E5%88%B6/"/>
      <url>/blog/2018/09/07/HTML-%E9%A1%B5%E9%9D%A2%E7%A6%81%E6%AD%A2%E9%80%89%E4%B8%AD%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>有时，为了防止用户随意的获取页面内的内容，我们需要禁止用户选中和拷贝，下面介绍两种禁止的方法。  </p><span id="more"></span><h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><p>可以在需要禁止的元素内监听选中和拷贝的事件，当用户如此操作时予以禁止。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 禁止右键菜单</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">oncontextmenu</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;;</span><br><span class="line"><span class="comment">// 禁止文字选择</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">onselectstart</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;;</span><br><span class="line"><span class="comment">// 禁止复制</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">oncopy</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;;</span><br><span class="line"><span class="comment">// 禁止剪切</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">oncut</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;;</span><br><span class="line"><span class="comment">// 禁止粘贴</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">onpaste</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;;</span><br><span class="line"><span class="comment">// 禁止打印</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">onbeforeprint</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;;</span><br></pre></td></tr></table></figure><h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><p>在支持use-select属性的浏览器中，设置user-select: none来禁止选中行为。<br>Opera12.5中支持私有的标签属性 unselectable=”on”来实现相同的行为  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* &#123; </span><br><span class="line">    -webkit-user-select: none;</span><br><span class="line">       -moz-user-select: none;</span><br><span class="line">        -ms-user-select: none;</span><br><span class="line">            user-select: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何破解"><a href="#如何破解" class="headerlink" title="如何破解"></a>如何破解</h2><p>如上所述，如果想要可以选中复制，可以在开发者工具F12中勾选<code>禁止Javascript</code> 并将想要复制的内容的<code>element.style</code><br>改为<code>user-select:none</code>即可。当然，其实什么样的内容都可以在开发者工具的Element中复制得到。</p>]]></content>
      
      
      <categories>
          
          <category> html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React父子组件数据传递</title>
      <link href="/blog/2018/09/06/React-React%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/"/>
      <url>/blog/2018/09/06/React-React%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/</url>
      
        <content type="html"><![CDATA[<p>本篇主要讲述 <a href="https://github.com/facebook/react">React</a> 中的 props state 以及 父子组件之间的数据传递。  </p><span id="more"></span><h2 id="props-amp-state"><a href="#props-amp-state" class="headerlink" title="props &amp; state"></a>props &amp; state</h2><p>对于一个组件来说，props 属性是只读的，像一个透明包裹一样，子组件可以看到包裹里的东西，却不能直接改变 props 的值。props 来自他的父组件。而 state 属性则好像是自己的背包一样，可以随意通过 setState 修改，而且是永远跟随着自己的，不用担心丢失。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ChildComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(props);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">            <span class="attr">item</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">sendToFather</span>(<span class="params">data</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">setData</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;this.sendToFather(&#123;item1: value2&#125;)&#125;&#125;&gt;&#123;this.props.item&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.item&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FatherComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(props);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">            <span class="attr">item</span>: <span class="string">&#x27;value1&#x27;</span>,</span><br><span class="line">            <span class="attr">item1</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">setDateMethod</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">setData</span>=<span class="string">&#123;(this.setDateMethod).bind(this))&#125;</span> <span class="attr">item</span>=<span class="string">&#123;this.state.item&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">ChildComponent</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h2><p>父组件需要向自组件传递数据的时候，比如需要传递一个名字为 item ，值为 value1 的数据，<br>只需要引用子组件的时候为其添加一个名字为 item 的属性，然后将值赋予它，那么在子组件中就可以通过 props.item 获取到传递进来的值。  </p><p>子组件要把数据返回给父组件，比如需要传递一个名字为 item1 ，值为 value2 的数据，<br>就需要父组件传递一个函数 setData 给子组件，子组件通过传入参数 <code>&#123; item1: value2 &#125;</code> 调用函数 setData 将数据返回给父组件的函数，父组件的函数 setDateMethod 接受实参来改变父组件中的 state 等值。  </p><p>简单来说：</p><ul><li>父组件将需要传递的数据，更改 state 的方法（setData方法）或组件本身通过 props 传递给子组件</li><li>子组件通过调用 props 传来的回调函数（setData方法）向父组件传递数据或更改状态</li></ul><h2 id="全局传递数据"><a href="#全局传递数据" class="headerlink" title="全局传递数据"></a>全局传递数据</h2><h3 id="EventEmitter"><a href="#EventEmitter" class="headerlink" title="EventEmitter"></a>EventEmitter</h3><p>因为数据只能在父子之间传递，当父子关系嵌套很深的时候，不同组件之间传递数据十分不便。这时可以使用 <code>EventEmitter</code> 事件传递来实现组件之间的数据传递。使用事件模型，组件之间无论是父子关系还是非父子关系都可以直接沟通，从而解决了组件间层层回调传递的问题，但是频繁地使用事件实现组件间沟通会使整个程序的数据流向越来越乱，因此，组件间的沟通还是要尽量遵循单向数据流机制。  </p><p>一个简单的发布订阅 Eventbus</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Eventbus</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span> () &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">fns</span> = []</span><br><span class="line">    &#125;</span><br><span class="line">    emit (type, ...args) &#123;</span><br><span class="line">        <span class="keyword">const</span> fns = <span class="variable language_">this</span>.<span class="property">fns</span>[type]</span><br><span class="line">        <span class="keyword">if</span> (fns) fns.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args))</span><br><span class="line">    &#125;</span><br><span class="line">    on (type, fn) &#123;</span><br><span class="line">        <span class="keyword">const</span> fns = <span class="variable language_">this</span>.<span class="property">fns</span>[type]</span><br><span class="line">        fns ? fns.<span class="title function_">push</span>(fn) : (<span class="variable language_">this</span>.<span class="property">fns</span>[type] = [fn])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>全局传递数据可以通过 <a href="https://zh-hans.reactjs.org/docs/context.html">Context</a> 来实现<br>Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据，比如UI主题，地区偏好。</p><h4 id="什么是-Context"><a href="#什么是-Context" class="headerlink" title="什么是 Context"></a>什么是 Context</h4><ul><li>Context 提供了一种无需为每层组件手动添加 props，能在组件树间进行数据传递的方法</li><li>Context 设计目的是共享或缓存组件树的全局数据，如用户认证，地区偏好，主题和语言</li><li>Context 应用场景是不同层级组件访问同样数据，副作用是降低组件的复用性</li><li>Context API<ul><li><code>React.createContext</code> 创建 Context 对象，订阅该对象的组件从组件树中离自身最近的匹配的 Provider 中读取当前的 context 值</li><li><code>Context.Provider</code> 接收 value 属性，当其发生变化时，内部所有消费组件都会重新渲染，忽略 shouldComponentUpdate 函数</li><li><code>Class.contextType</code> 订阅单一 context，在任何生命周期中，使用 <code>this.context</code> 访问</li><li><code>Context.Consumer</code><ul><li>在函数式组件中订阅 context 的变更</li><li>需要一个函数作为子元素。函数接收当前 context 值，并返回一个 React 节点<ul><li>context 值由最近的 Provider 提供</li><li>没有 Provider 时等同于 <code>createContext()</code> 的 defaultValue</li></ul></li></ul></li><li><code>Context.displayName</code> 指定组件在 DevToools 中显示的名称</li></ul></li></ul><h4 id="Context-的适用场景"><a href="#Context-的适用场景" class="headerlink" title="Context 的适用场景"></a>Context 的适用场景</h4><ul><li>适合在组件之间共享如地区偏好，主题等数据，避免逐层传递 props</li><li>存在 context 的 value 更新，内部所有消费组件都重新渲染问题</li><li>过度使用组件的状态与上下文相关，复用度降低</li></ul><h3 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h3><h4 id="什么是-Ref-转发"><a href="#什么是-Ref-转发" class="headerlink" title="什么是 Ref 转发"></a>什么是 Ref 转发</h4><ul><li>Ref 转发可以将 ref 传递到子组件<ul><li>由 React.forwardRef 实现</li><li>向 ref 传入回调函数，函数第一参数是 React 组件实例或 HTML DOM 元素</li></ul></li><li>Ref 转发适合应用场景<ul><li>转发表单组件的 ref 到 DOM 节点，便于访问 DOM 节点，来管理焦点、选中或动画</li><li>在高阶组件内，转发外层组件的 ref 到 被包裹的组件</li></ul></li><li>Ref 转发更改了组件默认的 ref 指向，对组件使用者不可见，不建议使用<ul><li>不兼容之前同时使用组件和 ref 的应用</li><li>对组件使用者，ref 结果可能不符合直观预期</li></ul></li><li><p>由 React.forwardRef 实现 Ref 转发，可以使用函数决定 ref 转发组件显示的内容</p><ul><li><p>设置传入 React.forwardRef 函数名称，例如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newComponent = <span class="title class_">React</span>.<span class="title function_">forwardRef</span>(<span class="keyword">function</span> <span class="title function_">myName</span>(<span class="params">props, ref</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">innerComponent</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">forwardedRef</span>=<span class="string">&#123;ref&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// DevTools DisplayName: ForwardRef(myName)</span></span><br></pre></td></tr></table></figure><blockquote><p>设置函数的 displayName 来包含被包裹组件的名称</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myName</span>(<span class="params">props, ref</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">innerComponent</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">forwardedRef</span>=<span class="string">&#123;ref&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">myName.displayName</span> = <span class="string">&#x27;myDisplayName&#x27;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">const</span> <span class="attr">newComponent</span> = <span class="string">React.forwardRef(myName)</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">// <span class="attr">DevTools</span> <span class="attr">DisplayName:</span> <span class="attr">ForwardRef</span>(<span class="attr">myDisplayName</span>)</span></span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="refs-适用场景"><a href="#refs-适用场景" class="headerlink" title="refs 适用场景"></a>refs 适用场景</h4><ul><li>适合在典型数据流之外强制修改子组件的场景，例如<ul><li>管理焦点，文本选择或媒体播放</li><li>触发强制动画</li><li>集成第三方 DOM 库</li></ul></li><li>DOM refs 打破组件封装，ref 转发更改开发者预期<ul><li>应避免过度使用，用声明式实现和状态提升代替</li><li>一定要使用时，建议添加注释和说明</li></ul></li><li>被修改的子组件可以是 React 组件实例或 DOM 元素</li><li>包含向子组件添加 ref、回调 refs 和 ref 转发三种方式</li></ul><h3 id="使用状态管理库"><a href="#使用状态管理库" class="headerlink" title="使用状态管理库"></a>使用状态管理库</h3><p>状态管理库例如 Redux、Mobx 通过自己的 API 实现了对数据状态的管理。</p><h2 id="为什么-React-是单向数据流"><a href="#为什么-React-是单向数据流" class="headerlink" title="为什么 React 是单向数据流"></a>为什么 React 是单向数据流</h2><p>在 React 中，父组件可以把它的 state 作为 props 向下传递它的子组件中，子组件通过 props 接收父组件的数据，不关心数据来源于父组件的 state 或 props。 状态 state 总是所属于特定的组件，而能够使用 state 的组件只限定于当前组件或者他的孩子组件。React 中这种自上而下的数据传递被称为单向数据流。</p><p>单向数据流的好处在于，数据只限定于特定的流向，在寻找数据流向和查找问题时，链路更加清晰明了。但是在某些情况下，相比于双向绑定，单向数据流需要通过通过传入回调来实现，不够简洁。</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改光标的样式</title>
      <link href="/blog/2018/09/05/CSS-%E4%BF%AE%E6%94%B9%E5%85%89%E6%A0%87%E7%9A%84%E6%A0%B7%E5%BC%8F/"/>
      <url>/blog/2018/09/05/CSS-%E4%BF%AE%E6%94%B9%E5%85%89%E6%A0%87%E7%9A%84%E6%A0%B7%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>某些情况下我们需要修改默认的光标样式，比如当我们为一个元素添加了点击事件之后，这个元素就会表现的像一个按钮。为了更好的用户体验，我们可以将光标样式由默认的箭头样式改为指针样式。这样，当用户划过此元素时，就会意识到这是一个可点击的元素。</p><span id="more"></span><p>可以通过修改cursor属性来改变元素的光标样式。</p><h2 id="css-cursor-属性"><a href="#css-cursor-属性" class="headerlink" title="css cursor 属性"></a>css cursor 属性</h2><p>cursor 属性规定要显示的光标的类型（形状）。  </p><p>该属性定义了鼠标指针放在一个元素边界范围内时所用的光标形状。  </p><h2 id="可能的值"><a href="#可能的值" class="headerlink" title="可能的值"></a>可能的值</h2><table><thead><tr><th>值</th><th>描述</th><th>样式</th></tr></thead><tbody><tr><td>url</td><td>需使用的自定义光标的 URL。<br><font color="red">注意：</font>请在此列表的末端始终定义一种普通的光标，以防没有由 URL 定义的可用光标。</td><td><div style="cursor:url('/blog/static/imgs/create-repo.png');height:25px"></div></td></tr><tr><td>default</td><td>默认光标（通常是一个箭头）</td><td><div style="cursor:default;height:25px"></div></td></tr><tr><td>auto</td><td>默认。浏览器设置的光标。</td><td><div style="cursor:auto;height:25px"></div></td></tr><tr><td>crosshair</td><td>光标呈现为十字线。</td><td><div style="cursor:crosshair;height:25px"></div></td></tr><tr><td>pointer</td><td>光标呈现为指示链接的指针（一只手）</td><td><div style="cursor:pointer;height:25px"></div></td></tr><tr><td>move</td><td>此光标指示某对象可被移动。</td><td><div style="cursor:move;height:25px"></div></td></tr><tr><td>e-resize</td><td>此光标指示矩形框的边缘可被向右（东）移动。</td><td><div style="cursor:e-resize;height:25px"></div></td></tr><tr><td>ne-resize</td><td>此光标指示矩形框的边缘可被向上及向右移动（北/东）。</td><td><div style="cursor:ne-resize;height:25px"></div></td></tr><tr><td>nw-resize</td><td>此光标指示矩形框的边缘可被向上及向左移动（北/西）。</td><td><div style="cursor:nw-resize;height:25px"></div></td></tr><tr><td>n-resize</td><td>此光标指示矩形框的边缘可被向上（北）移动。</td><td><div style="cursor:n-resize;height:25px"></div></td></tr><tr><td>se-resize</td><td>此光标指示矩形框的边缘可被向下及向右移动（南/东）。</td><td><div style="cursor:se-resize;height:25px"></div></td></tr><tr><td>sw-resize</td><td>此光标指示矩形框的边缘可被向下及向左移动（南/西）。</td><td><div style="cursor:sw-resize;height:25px"></div></td></tr><tr><td>s-resize</td><td>此光标指示矩形框的边缘可被向下移动（南）。</td><td><div style="cursor:s-resize;height:25px"></div></td></tr><tr><td>w-resize</td><td>此光标指示矩形框的边缘可被向左移动（西）。</td><td><div style="cursor:w-resize;height:25px"></div></td></tr><tr><td>text</td><td>此光标指示文本。</td><td><div style="cursor:text;height:25px"></div></td></tr><tr><td>wait</td><td>此光标指示程序正忙（通常是一只表或沙漏）。</td><td><div style="cursor:wait;height:25px"></div></td></tr><tr><td>help</td><td>此光标指示可用的帮助（通常是一个问号或一个气球）。</td><td><div style="cursor:help;height:25px"></div></td></tr><tr><td>none</td><td>光标消失</td><td><div style="cursor:none;height:25px"></div></td></tr><tr><td>not-allowed</td><td>不允许操作</td><td><div style="cursor:not-allowed;height:25px"></div></td></tr></tbody></table><div style="cursor:pointer;"></div>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>改变placeholder的颜色</title>
      <link href="/blog/2018/09/05/CSS-%E6%94%B9%E5%8F%98placeholder%E7%9A%84%E9%A2%9C%E8%89%B2/"/>
      <url>/blog/2018/09/05/CSS-%E6%94%B9%E5%8F%98placeholder%E7%9A%84%E9%A2%9C%E8%89%B2/</url>
      
        <content type="html"><![CDATA[<p>我们都知道输入框中改变默认显示的文字是通过改变 input 的 placeholder 来实现的  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;search&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Search...&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>部分浏览器通过改变类似 <code>-webkit-input-placeholder</code> 的属性，使得输入框的 placeholder 也可以有自己的样式。</p><span id="more"></span><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span>::-webkit-input-placeholder,textarea::-webkit-input-placeholder &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-tag">input</span>::-moz-placeholder,</span><br><span class="line">textarea::-moz-placeholder &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-tag">input</span>::-moz-placeholder,</span><br><span class="line">textarea::-moz-placeholder &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-tag">input</span>::-ms-input-placeholder,</span><br><span class="line">textarea::-ms-input-placeholder &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>大部分情况下修改的都是颜色，不过其它属性也是可以的  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span>::-webkit-input-placeholder,textarea::-webkit-input-placeholder &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ccc</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 添加站内搜索功能</title>
      <link href="/blog/2018/09/04/Hexo-%E6%B7%BB%E5%8A%A0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/"/>
      <url>/blog/2018/09/04/Hexo-%E6%B7%BB%E5%8A%A0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>搜索功能的实现最主要是生成一份关键字到站内链接的索引，当用户输入关键字后能够根据索引展示相应的链接。<br>通常，搜索引擎公司（例如Google，百度）会有自己的爬虫，当你将自己的网站地址提交给他们后，他们会用爬虫定期分析你的网站结构，然后生成索引文件并加入自己的索引库中。这样当终端用户输入和你的网站匹配的关键词后，你的网站内的链接就会在结果中显示出来。<br>站内搜索一般就不需要爬虫了，因为，其实最重要的是索引文件，只要你的网站更新的时候同时更新索引文件即可。  </p><span id="more"></span><h2 id="插入Google搜索框"><a href="#插入Google搜索框" class="headerlink" title="插入Google搜索框"></a>插入Google搜索框</h2><p>你可以利用Hexo函数search_form直接插入Google搜索框。  </p><p>search_form<br>插入 Google 搜索框。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%- search_form(options) %&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>class</td><td>表单的 class name</td><td>search-form</td></tr><tr><td>text</td><td>搜索提示文字</td><td>Search</td></tr><tr><td>button</td><td>显示搜索按钮。此参数可为布尔值（boolean）或字符串，<br>当设定是字符串的时候，即为搜索按钮的文字。</td><td>false</td></tr></tbody></table><h2 id="自定义站内搜索"><a href="#自定义站内搜索" class="headerlink" title="自定义站内搜索"></a>自定义站内搜索</h2><p>你也可以利用Hexo插件实现自己的站内搜索的功能。  </p><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>这个插件的本质是生成了一个搜索索引文件。<br>插件： <a href="https://github.com/wzpan/hexo-generator-search">hexo-generator-search</a><br>通过以下命令安装：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><h3 id="修改hexo配置"><a href="#修改hexo配置" class="headerlink" title="修改hexo配置"></a>修改hexo配置</h3><p>在_config.yml中添加站内搜索配置项：  </p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="comment"># 如只想索引文章，可设置为post</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">all</span></span><br></pre></td></tr></table></figure><h3 id="实现搜索框视图"><a href="#实现搜索框视图" class="headerlink" title="实现搜索框视图"></a>实现搜索框视图</h3><p>结构文件<br>search.ejs<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;search-box&quot;</span> <span class="attr">id</span>=<span class="string">&quot;search-box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;search-btn&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;search-input&quot;</span> <span class="attr">name</span>=<span class="string">&quot;q&quot;</span> <span class="attr">results</span>=<span class="string">&quot;0&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;搜索&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">class</span>=<span class="string">&quot;reset-search-btn&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 上面是搜索框，下面是结果域 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span> <span class="attr">id</span>=<span class="string">&quot;search-result&quot;</span> <span class="attr">class</span>=<span class="string">&quot;search-result content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>样式文件<br>search.css<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">// 搜索框</span><br><span class="line"><span class="selector-class">.search-box</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">13px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">36px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">outline</span>: none;</span><br><span class="line">    <span class="attribute">transition</span>: width <span class="number">0.1s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.search-box-focus</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">164px</span>;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">38px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#f0f1f2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.search-box-focus</span> <span class="selector-id">#search-input</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.search-box</span>  <span class="selector-tag">form</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.search-box</span> <span class="selector-class">.search-btn</span>,</span><br><span class="line"><span class="selector-class">.reset-search-btn</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">border</span>: none;</span><br><span class="line">    <span class="attribute">outline</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">30px</span> <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">    <span class="attribute">background-position</span>: center;</span><br><span class="line">    <span class="attribute">background-color</span>: initial;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.search-box</span> <span class="selector-class">.search-btn</span> &#123;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">../images/header_search.png</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.reset-search-btn</span> &#123;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">../images/header_close.png</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.search-box-focus</span> <span class="selector-class">.reset-search-btn</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#search-input</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">    <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">36px</span>);</span><br><span class="line">    <span class="attribute">border</span>: none;</span><br><span class="line">    <span class="attribute">font</span>: inherit;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">outline</span>: none;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">8px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background</span>: transparent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#search-input</span>::-webkit-input-placeholder &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#999</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.search-result</span> <span class="selector-tag">ul</span>, <span class="selector-class">.search-result</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.search-result</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.search-result</span> <span class="selector-tag">li</span> <span class="selector-class">.search-result</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span> : hidden;</span><br><span class="line">    <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">    <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">    -webkit-line-clamp: <span class="number">3</span>;</span><br><span class="line">    -webkit-box-orient: vertical;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.search-result</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.search-result</span> <span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.search-result</span> <span class="selector-tag">em</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#38f</span>;</span><br><span class="line">    -webkit-<span class="attribute">text-emphasis</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.search-result</span> <span class="selector-tag">h1</span> <span class="selector-tag">em</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.search-result</span> <span class="selector-tag">h1</span><span class="selector-class">.empty-title</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#999</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: none;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="实现站内搜索逻辑"><a href="#实现站内搜索逻辑" class="headerlink" title="实现站内搜索逻辑"></a>实现站内搜索逻辑</h3><p>search.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">searchFunc</span>(<span class="params">path, searchId, contentId</span>) &#123;</span><br><span class="line">    $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">        <span class="attr">url</span>: path,</span><br><span class="line">        <span class="attr">dataType</span>: <span class="string">&#x27;xml&#x27;</span>,</span><br><span class="line">        <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">xmlResponse</span>) &#123;</span><br><span class="line">            <span class="comment">// get the contents from search data</span></span><br><span class="line">            <span class="keyword">var</span> datas = $(<span class="string">&#x27;entry&#x27;</span>, xmlResponse).<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    <span class="attr">title</span>: $(<span class="string">&#x27;title&#x27;</span>, <span class="variable language_">this</span>).<span class="title function_">text</span>(),</span><br><span class="line">                    <span class="attr">content</span>: $(<span class="string">&#x27;content&#x27;</span>, <span class="variable language_">this</span>).<span class="title function_">text</span>(),</span><br><span class="line">                    <span class="attr">url</span>: $(<span class="string">&#x27;url&#x27;</span>, <span class="variable language_">this</span>).<span class="title function_">text</span>()</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;).<span class="title function_">get</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> $searchBox = $(<span class="string">&#x27;#&#x27;</span> + searchId);</span><br><span class="line">            <span class="keyword">if</span> (!($searchBox &amp;&amp; $searchBox.<span class="property">length</span> == <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> $resultContent = $(<span class="string">&#x27;#&#x27;</span> + contentId);</span><br><span class="line">            <span class="keyword">if</span> (!($resultContent &amp;&amp; $resultContent.<span class="property">length</span> == <span class="number">1</span> )) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> $input = $searchBox.<span class="title function_">find</span>(<span class="string">&#x27;#search-input&#x27;</span>);</span><br><span class="line">            <span class="keyword">var</span> $searchBtn = $searchBox.<span class="title function_">find</span>(<span class="string">&#x27;.search-btn&#x27;</span>);</span><br><span class="line">            <span class="keyword">var</span> $resetBtn = $searchBox.<span class="title function_">find</span>(<span class="string">&#x27;.reset-search-btn&#x27;</span>);</span><br><span class="line"></span><br><span class="line">            $searchBtn.<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">                $searchBox.<span class="title function_">addClass</span>(<span class="string">&#x27;search-box-focus&#x27;</span>);</span><br><span class="line">                $input[<span class="number">0</span>].<span class="title function_">focus</span>();</span><br><span class="line">            &#125;);</span><br><span class="line">            $resetBtn.<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">                $(<span class="string">&#x27;#content&#x27;</span>).<span class="title function_">css</span>(&#123;</span><br><span class="line">                    <span class="attr">display</span>: <span class="string">&#x27;block&#x27;</span></span><br><span class="line">                &#125;);</span><br><span class="line">                $resultContent.<span class="title function_">css</span>(&#123;</span><br><span class="line">                    <span class="attr">display</span>: <span class="string">&#x27;none&#x27;</span></span><br><span class="line">                &#125;);</span><br><span class="line">                $input[<span class="number">0</span>].<span class="title function_">focus</span>();</span><br><span class="line">            &#125;);</span><br><span class="line">            $input.<span class="title function_">on</span>(<span class="string">&#x27;blur&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                ($(<span class="variable language_">this</span>).<span class="title function_">val</span>() === <span class="string">&#x27;&#x27;</span>) &amp;&amp; $searchBox.<span class="title function_">removeClass</span>(<span class="string">&#x27;search-box-focus&#x27;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line">            $input.<span class="title function_">on</span>(<span class="string">&#x27;compositionstart&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            $input.<span class="title function_">on</span>(<span class="string">&#x27;compositionend&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            $input.<span class="title function_">on</span>(<span class="string">&#x27;keydown&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> e = e || event;</span><br><span class="line">                <span class="keyword">if</span> (e.<span class="property">keyCode</span> === <span class="number">13</span>) &#123;</span><br><span class="line">                    e.<span class="property">returnValue</span> = <span class="literal">false</span>;</span><br><span class="line">                    e.<span class="title function_">preventDefault</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            $input.<span class="title function_">on</span>(<span class="string">&#x27;input&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> $this = <span class="variable language_">this</span>;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">var</span> str = <span class="string">&#x27;&lt;ul class=&quot;search-result-list&quot;&gt;&#x27;</span>;</span><br><span class="line">                    <span class="keyword">var</span> keywords = $this.<span class="property">value</span>.<span class="title function_">trim</span>().<span class="title function_">toLowerCase</span>().<span class="title function_">split</span>(<span class="regexp">/\s+/</span>);</span><br><span class="line">                    $resultContent[<span class="number">0</span>].<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span> ($this.<span class="property">value</span>.<span class="title function_">trim</span>().<span class="property">length</span> &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        $(<span class="string">&#x27;#content&#x27;</span>).<span class="title function_">css</span>(&#123;</span><br><span class="line">                            <span class="attr">display</span>: <span class="string">&#x27;block&#x27;</span></span><br><span class="line">                        &#125;);</span><br><span class="line">                        $resultContent.<span class="title function_">css</span>(&#123;</span><br><span class="line">                            <span class="attr">display</span>: <span class="string">&#x27;none&#x27;</span></span><br><span class="line">                        &#125;);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        $(<span class="string">&#x27;#content&#x27;</span>).<span class="title function_">css</span>(&#123;</span><br><span class="line">                            <span class="attr">display</span>: <span class="string">&#x27;none&#x27;</span></span><br><span class="line">                        &#125;);</span><br><span class="line">                        $resultContent.<span class="title function_">css</span>(&#123;</span><br><span class="line">                            <span class="attr">display</span>: <span class="string">&#x27;block&#x27;</span></span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">var</span> matchCount = <span class="number">0</span>;</span><br><span class="line">                    datas.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">                        <span class="keyword">var</span> isMatch = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (!data.<span class="property">title</span> || data.<span class="property">title</span>.<span class="title function_">trim</span>() === <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">var</span> data_title = data.<span class="property">title</span>.<span class="title function_">trim</span>().<span class="title function_">toLowerCase</span>();</span><br><span class="line">                        <span class="keyword">var</span> data_content = data.<span class="property">content</span>.<span class="title function_">trim</span>().<span class="title function_">replace</span>(<span class="regexp">/&lt;[^&gt;]+&gt;/g</span>, <span class="string">&quot;&quot;</span>).<span class="title function_">toLowerCase</span>();</span><br><span class="line">                        <span class="keyword">var</span> data_url = data.<span class="property">url</span>;</span><br><span class="line">                        <span class="keyword">var</span> index_title = -<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">var</span> index_content = -<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">var</span> first_occur = -<span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// only match artiles with not empty contents</span></span><br><span class="line">                        <span class="keyword">if</span> (data_content !== <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">                            keywords.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">keyword, i</span>) &#123;</span><br><span class="line">                                index_title = data_title.<span class="title function_">indexOf</span>(keyword);</span><br><span class="line">                                index_content = data_content.<span class="title function_">indexOf</span>(keyword);</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (index_title &lt; <span class="number">0</span> &amp;&amp; index_content &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                                    isMatch = <span class="literal">false</span>;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (index_content &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                                        index_content = <span class="number">0</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    <span class="keyword">if</span> (i === <span class="number">0</span>) &#123;</span><br><span class="line">                                        first_occur = index_content;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            isMatch = <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (isMatch) &#123;</span><br><span class="line">                            matchCount++;</span><br><span class="line">                            str += <span class="string">&#x27;&lt;li&gt;&lt;h3&gt;&lt;a target = &quot;_blank&quot; href=&quot;&#x27;</span> + data_url + <span class="string">&#x27;&quot; class=&quot;search-result-title&quot;&gt;&#x27;</span> + data_title + <span class="string">&#x27;&lt;/a&gt;&lt;/h3&gt;&#x27;</span>;</span><br><span class="line">                            <span class="keyword">var</span> content = data.<span class="property">content</span>.<span class="title function_">trim</span>().<span class="title function_">replace</span>(<span class="regexp">/&lt;[^&gt;]+&gt;/g</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">                            <span class="keyword">if</span> (first_occur &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="comment">// cut out 100 characters</span></span><br><span class="line">                                <span class="keyword">var</span> start = first_occur - <span class="number">20</span>;</span><br><span class="line">                                <span class="keyword">var</span> end = first_occur + <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (start &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                                    start = <span class="number">0</span>;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (start === <span class="number">0</span>) &#123;</span><br><span class="line">                                    end = <span class="number">100</span>;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (end &gt; content.<span class="property">length</span>) &#123;</span><br><span class="line">                                    end = content.<span class="property">length</span>;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">var</span> match_content = content.<span class="title function_">substr</span>(start, end);</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// highlight all keywords</span></span><br><span class="line">                                keywords.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">keyword</span>) &#123;</span><br><span class="line">                                    <span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(keyword, <span class="string">&#x27;gi&#x27;</span>);</span><br><span class="line">                                    match_content = match_content.<span class="title function_">replace</span>(reg, <span class="keyword">function</span> (<span class="params">str</span>) &#123;</span><br><span class="line">                                        <span class="keyword">return</span> <span class="string">&#x27;&lt;em class=&quot;search-keyword&quot;&gt;&#x27;</span> + str + <span class="string">&#x27;&lt;/em&gt;&#x27;</span>;</span><br><span class="line">                                    &#125;)</span><br><span class="line">                                &#125;);</span><br><span class="line"></span><br><span class="line">                                str += <span class="string">&#x27;&lt;p class=&quot;search-result&quot;&gt;&#x27;</span> + match_content + <span class="string">&#x27;...&lt;/p&gt;&#x27;</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            str += <span class="string">&#x27;&lt;/li&gt;&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    $input.<span class="title function_">attr</span>(<span class="string">&#x27;results&#x27;</span>, matchCount);</span><br><span class="line">                    str += <span class="string">&#x27;&lt;/ul&gt;&#x27;</span>;</span><br><span class="line">                    <span class="keyword">var</span> title = matchCount ? <span class="string">&#x27;&lt;h1&gt;找到&lt;em&gt;&#x27;</span> + $this.<span class="property">value</span>.<span class="title function_">trim</span>() + <span class="string">&#x27;&lt;/em&gt;相关内容&#x27;</span> + matchCount + <span class="string">&#x27;个&lt;/h1&gt;&#x27;</span> : <span class="string">&#x27;&lt;h1 class=&quot;empty-title&quot;&gt;没有找到&lt;em&gt;&#x27;</span> + $this.<span class="property">value</span>.<span class="title function_">trim</span>() + <span class="string">&#x27;&lt;/em&gt;相关内容&lt;/h1&gt;&#x27;</span>;</span><br><span class="line">                    str = title + str;</span><br><span class="line">                    $(<span class="string">&#x27;#content&#x27;</span>).<span class="title function_">css</span>(&#123;</span><br><span class="line">                        <span class="attr">display</span>: <span class="string">&#x27;none&#x27;</span></span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">                    $resultContent.<span class="title function_">css</span>(&#123;</span><br><span class="line">                        <span class="attr">display</span>: <span class="string">&#x27;block&#x27;</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                    $resultContent[<span class="number">0</span>].<span class="property">innerHTML</span> = str;</span><br><span class="line">                &#125;, <span class="number">0</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="将搜索功能添加如页面"><a href="#将搜索功能添加如页面" class="headerlink" title="将搜索功能添加如页面"></a>将搜索功能添加如页面</h3><p>将如下代码添加到合适的地方,一般为layout.ejs 最下方  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (config.search) &#123; %&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;/js/search.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        var search_path = &quot;&lt;%= config.search.path %&gt;&quot;;</span><br><span class="line">            if (search_path.length == 0) &#123;</span><br><span class="line">            search_path = &quot;search.xml&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        var path = &quot;&lt;%= config.root %&gt;&quot; + search_path;</span><br><span class="line">        searchFunc(path, &#x27;search-box&#x27;, &#x27;search-result&#x27;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS-选择器</title>
      <link href="/blog/2018/09/03/CSS-%E9%80%89%E6%8B%A9%E5%99%A8/"/>
      <url>/blog/2018/09/03/CSS-%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th style="text-align:left">选择器</th><th style="text-align:left">例子</th><th style="text-align:left">例子描述</th><th>css</th></tr></thead><tbody><tr><td style="text-align:left">.class</td><td style="text-align:left">.intro</td><td style="text-align:left">选择 class=”intro” 的所有元素。</td><td>1</td></tr><tr><td style="text-align:left">#id</td><td style="text-align:left">#firstname</td><td style="text-align:left">选择 id=”firstname” 的所有元素。</td><td>1</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">*</td><td style="text-align:left">选择所有元素。</td><td>2</td></tr><tr><td style="text-align:left">element</td><td style="text-align:left">p</td><td style="text-align:left">选择所有 &lt;p> 元素。</td><td>1</td></tr><tr><td style="text-align:left">element,element</td><td style="text-align:left">div,p</td><td style="text-align:left">选择所有 &lt;div> 元素和所有 &lt;p> 元素。</td><td>1</td></tr><tr><td style="text-align:left">element element</td><td style="text-align:left">div p</td><td style="text-align:left">选择 &lt;div> 元素内部的所有 &lt;p> 元素。</td><td>1</td></tr><tr><td style="text-align:left">element>element</td><td style="text-align:left">div>p</td><td style="text-align:left">选择父元素为 &lt;div> 元素的所有 &lt;p> 元素。</td><td>2</td></tr><tr><td style="text-align:left">element+element</td><td style="text-align:left">div+p</td><td style="text-align:left">选择紧接在 &lt;div> 元素之后的所有 &lt;p> 元素。</td><td>2</td></tr><tr><td style="text-align:left">[attribute]</td><td style="text-align:left">[target]</td><td style="text-align:left">选择带有 target 属性所有元素。</td><td>2</td></tr><tr><td style="text-align:left">[attribute=value]</td><td style="text-align:left">[target=_blank]</td><td style="text-align:left">选择 target=”_blank” 的所有元素。</td><td>2</td></tr><tr><td style="text-align:left">[attribute~=value]</td><td style="text-align:left">[title~=flower]</td><td style="text-align:left">选择 title 属性包含单词 “flower” 的所有元素。</td><td>2</td></tr><tr><td style="text-align:left">[attribute&#124;=value]</td><td style="text-align:left">[lang&#124;=en]</td><td style="text-align:left">选择 lang 属性值以 “en” 开头的所有元素。</td><td>2</td></tr><tr><td style="text-align:left">:link</td><td style="text-align:left">a:link</td><td style="text-align:left">选择所有未被访问的链接。</td><td>1</td></tr><tr><td style="text-align:left">:visited</td><td style="text-align:left">a:visited</td><td style="text-align:left">选择所有已被访问的链接。</td><td>1</td></tr><tr><td style="text-align:left">:active</td><td style="text-align:left">a:active</td><td style="text-align:left">选择活动链接。</td><td>1</td></tr><tr><td style="text-align:left">:hover</td><td style="text-align:left">a:hover</td><td style="text-align:left">选择鼠标指针位于其上的链接。</td><td>1</td></tr><tr><td style="text-align:left">:focus</td><td style="text-align:left">input:focus</td><td style="text-align:left">选择获得焦点的 input 元素。</td><td>2</td></tr><tr><td style="text-align:left">:first-letter</td><td style="text-align:left">p:first-letter</td><td style="text-align:left">选择每个 &lt;p> 元素的首字母。</td><td>1</td></tr><tr><td style="text-align:left">:first-line</td><td style="text-align:left">p:first-line</td><td style="text-align:left">选择每个 &lt;p> 元素的首行。</td><td>1</td></tr><tr><td style="text-align:left">:first-child</td><td style="text-align:left">p:first-child</td><td style="text-align:left">选择属于父元素的第一个子元素的每个 &lt;p> 元素。</td><td>2</td></tr><tr><td style="text-align:left">:before</td><td style="text-align:left">p:before</td><td style="text-align:left">在每个 &lt;p> 元素的内容之前插入内容。</td><td>2</td></tr><tr><td style="text-align:left">:after</td><td style="text-align:left">p:after</td><td style="text-align:left">在每个 &lt;p> 元素的内容之后插入内容。</td><td>2</td></tr><tr><td style="text-align:left">:lang(language)</td><td style="text-align:left">p:lang(it)</td><td style="text-align:left">选择带有以 “it” 开头的 lang 属性值的每个 &lt;p> 元素。</td><td>2</td></tr><tr><td style="text-align:left">element1~element2</td><td style="text-align:left">p~ul</td><td style="text-align:left">选择前面有 &lt;p> 元素的每个 &lt;ul> 元素。</td><td>3</td></tr><tr><td style="text-align:left">[attribute^=value]</td><td style="text-align:left">a[src^=”https”]</td><td style="text-align:left">选择其 src 属性值以 “https” 开头的每个 &lt;a> 元素。</td><td>3</td></tr><tr><td style="text-align:left">[attribute$=value]</td><td style="text-align:left">a[src$=”.pdf”]</td><td style="text-align:left">选择其 src 属性以 “.pdf” 结尾的所有 &lt;a> 元素。</td><td>3</td></tr><tr><td style="text-align:left">[attribute*=value]</td><td style="text-align:left">a[src*=”abc”]</td><td style="text-align:left">选择其 src 属性中包含 “abc” 子串的每个 &lt;a> 元素。</td><td>3</td></tr><tr><td style="text-align:left">:first-of-type</td><td style="text-align:left">p:first-of-type</td><td style="text-align:left">选择属于其父元素的首个 &lt;p> 元素的每个 &lt;p> 元素。</td><td>3</td></tr><tr><td style="text-align:left">:last-of-type</td><td style="text-align:left">p:last-of-type</td><td style="text-align:left">选择属于其父元素的最后 &lt;p> 元素的每个 &lt;p> 元素。</td><td>3</td></tr><tr><td style="text-align:left">:only-of-type</td><td style="text-align:left">p:only-of-type</td><td style="text-align:left">选择属于其父元素唯一的 &lt;p> 元素的每个 &lt;p> 元素。</td><td>3</td></tr><tr><td style="text-align:left">:only-child</td><td style="text-align:left">p:only-child</td><td style="text-align:left">选择属于其父元素的唯一子元素的每个 &lt;p> 元素。</td><td>3</td></tr><tr><td style="text-align:left">:nth-child(n)</td><td style="text-align:left">p:nth-child(2)</td><td style="text-align:left">选择属于其父元素的第二个子元素的每个 &lt;p> 元素。</td><td>3</td></tr><tr><td style="text-align:left">:nth-last-child(n)</td><td style="text-align:left">p:nth-last-child(2)</td><td style="text-align:left">同上，从最后一个子元素开始计数。</td><td>3</td></tr><tr><td style="text-align:left">:nth-of-type(n)</td><td style="text-align:left">p:nth-of-type(2)</td><td style="text-align:left">选择属于其父元素第二个 &lt;p> 元素的每个 &lt;p> 元素。</td><td>3</td></tr><tr><td style="text-align:left">:nth-last-of-type(n)</td><td style="text-align:left">p:nth-last-of-type(2)</td><td style="text-align:left">同上，但是从最后一个子元素开始计数。</td><td>3</td></tr><tr><td style="text-align:left">:last-child</td><td style="text-align:left">p:last-child</td><td style="text-align:left">选择属于其父元素最后一个子元素每个 &lt;p> 元素。</td><td>3</td></tr><tr><td style="text-align:left">:root</td><td style="text-align:left">:root</td><td style="text-align:left">选择文档的根元素。</td><td>3</td></tr><tr><td style="text-align:left">:empty</td><td style="text-align:left">p:empty</td><td style="text-align:left">选择没有子元素的每个 &lt;p> 元素（包括文本节点）。</td><td>3</td></tr><tr><td style="text-align:left">:target</td><td style="text-align:left">#news:target</td><td style="text-align:left">选择当前活动的 #news 元素。</td><td>3</td></tr><tr><td style="text-align:left">:enabled</td><td style="text-align:left">input:enabled</td><td style="text-align:left">选择每个启用的 &lt;input> 元素。</td><td>3</td></tr><tr><td style="text-align:left">:disabled</td><td style="text-align:left">input:disabled</td><td style="text-align:left">选择每个禁用的 &lt;input> 元素</td><td>3</td></tr><tr><td style="text-align:left">:checked</td><td style="text-align:left">input:checked</td><td style="text-align:left">选择每个被选中的 &lt;input> 元素。</td><td>3</td></tr><tr><td style="text-align:left">:not(selector)</td><td style="text-align:left">:not(p)</td><td style="text-align:left">选择非 &lt;p> 元素的每个元素。</td><td>3</td></tr><tr><td style="text-align:left">::selection</td><td style="text-align:left">::selection</td><td style="text-align:left">选择被用户选取的元素部分。</td><td>3</td></tr></tbody></table><span id="more"></span><h3 id="CSS选择器都有哪些？内联和-important-哪个优先级高？"><a href="#CSS选择器都有哪些？内联和-important-哪个优先级高？" class="headerlink" title="CSS选择器都有哪些？内联和 important 哪个优先级高？"></a>CSS选择器都有哪些？内联和 <code>important</code> 哪个优先级高？</h3><ol><li>标签选择器(如：body,div,p,ul,li)  </li><li>类选择器(如：class=”head”,class=”head_logo”)  </li><li>ID选择器(如：id=”name”,id=”name_txt”)  </li><li>全局选择器(如：*号)  </li><li>组合选择器(如：.head .head_logo,注意两选择器用空格键分开)  </li><li>后代选择器 (如：#head .nav ul li 从父集到子孙集的选择器)  </li><li>群组选择器 div,span,img {color:Red} 即具有相同样式的标签分组显示  </li><li>继承选择器(如：div p,注意两选择器用空格键分开)  </li><li>伪类选择器(如：就是链接样式,a元素的伪类，4种不同的状态：link、visited、active、hover。)  </li><li>字符串匹配的属性选择符(^ $ *三种，分别对应开始、结尾、包含)  </li><li>子选择器 (如：div&gt;p ,带大于号&gt;)  </li><li>css 相邻兄弟选择器器 (如：h1+p,带加号+)  </li></ol><h3 id="CSS选择器优先级计算规则是什么？"><a href="#CSS选择器优先级计算规则是什么？" class="headerlink" title="CSS选择器优先级计算规则是什么？"></a>CSS选择器优先级计算规则是什么？</h3><p>不同级别  </p><ol><li>在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。  </li><li>作为style属性写在元素内的样式（内联样式）  </li><li>id选择器  </li><li>类选择器 class  </li><li>标签选择器 body div a  </li><li>通配符选择器 *  </li><li>浏览器自定义或继承  </li></ol><p>同一级别  </p><ul><li>同一级别中后写的会覆盖先写的样式</li><li>更精确的匹配会覆盖泛用性大的匹配</li></ul>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery 常用方法</title>
      <link href="/blog/2018/09/03/JS-jQuery-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/blog/2018/09/03/JS-jQuery-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>jQuery 是一个高效、精简并且功能丰富的 JavaScript 工具库。它提供的 API 易于使用且兼容众多浏览器，这让诸如 HTML 文档遍历和操作、事件处理、动画和 Ajax 操作更加简单。  </p><p>jQuery 使用 $ 符号作为 jQuery 的简写。如果你使用其它框架也使用 $ 符号作为简写，有可能导致脚本停止运行。为了防止这种情况，你可以使用jQuery noConflict()方法释放对 $ 标识符的控制并返回对 jQuery 的引用。  </p><span id="more"></span><h2 id="jQuery-核心函数"><a href="#jQuery-核心函数" class="headerlink" title="jQuery 核心函数"></a>jQuery 核心函数</h2><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>jQuery()</td><td>接受一个字符串，其中包含了用于匹配元素集合的 css 选择器。</td></tr><tr><td>jQuery.noConflict()</td><td>运行这个函数将变量 $ 的控制权让渡给第一个实现它的那个库。</td></tr></tbody></table><h2 id="jQuery-选择器"><a href="#jQuery-选择器" class="headerlink" title="jQuery 选择器"></a>jQuery 选择器</h2><p>jQuery 使用 css 选择器来选取 HTML 元素。<br>jQuery 使用 XPath 表达式来选择带有给定属性的元素。<br>jQuery css 选择器可用于改变 HTML 元素的 css 属性。  </p><table><thead><tr><th>选择器</th><th>实例</th><th>选取</th></tr></thead><tbody><tr><td>*</td><td>$(“*”)</td><td>所有元素</td></tr><tr><td>#id</td><td>$(“#lastname”)</td><td>id=”lastname” 的元素</td></tr><tr><td>.class</td><td>$(“.intro”)</td><td>所有 class=”intro” 的元素</td></tr><tr><td>element</td><td>$(“p”)</td><td>所有 &lt;p> 元素</td></tr><tr><td>.class.class</td><td>$(“.intro.demo”)</td><td>所有 class=”intro” 且 class=”demo” 的元素</td></tr><tr><td>:first</td><td>$(“p:first”)</td><td>第一个 &lt;p> 元素</td></tr><tr><td>:last</td><td>$(“p:last”)</td><td>最后一个 &lt;p> 元素</td></tr><tr><td>:even</td><td>$(“tr:even”)</td><td>所有偶数 &lt;tr> 元素</td></tr><tr><td>:odd</td><td>$(“tr:odd”)</td><td>所有奇数 &lt;tr> 元素</td></tr><tr><td>:eq(index)</td><td>$(“ul li:eq(3)”)</td><td>列表中的第四个元素（index 从 0 开始）</td></tr><tr><td>:gt(no)</td><td>$(“ul li:gt(3)”)</td><td>列出 index 大于 3 的元素</td></tr><tr><td>:lt(no)</td><td>$(“ul li:lt(3)”)</td><td>列出 index 小于 3 的元素</td></tr><tr><td>:not(selector)</td><td>$(“input:not(:empty)”)</td><td>所有不为空的 input 元素</td></tr><tr><td>:header</td><td>$(“:header”)</td><td>所有标题元素 &lt;h1> - &lt;h6></td></tr><tr><td>:animated</td><td>$(“:animated”)</td><td>所有动画元素</td></tr><tr><td>:contains(text)</td><td>$(“:contains(‘javascript’)”)</td><td>包含指定字符串的所有元素</td></tr><tr><td>:empty</td><td>$(“:empty”)</td><td>无子（元素）节点的所有元素</td></tr><tr><td>:hidden</td><td>$(“p:hidden”)</td><td>所有隐藏的 &lt;p> 元素</td></tr><tr><td>:visible</td><td>$(“table:visible”)</td><td>所有可见的表格</td></tr><tr><td>s1,s2,s3</td><td>$(“th,td,.intro”)</td><td>所有带有匹配选择的元素</td></tr><tr><td>[attribute]</td><td>$(“[href]”)</td><td>所有带有 href 属性的元素</td></tr><tr><td>[attribute=value]</td><td>$(“[href=’#’]”)</td><td>所有 href 属性的值等于 “#” 的元素</td></tr><tr><td>[attribute!=value]</td><td>$(“[href!=’#’]”)</td><td>所有 href 属性的值不等于 “#” 的元素</td></tr><tr><td>[attribute$=value]</td><td>$(“[href$=’.jpg’]”)</td><td>所有 href 属性的值包含以 “.jpg” 结尾的元素</td></tr><tr><td>:input</td><td>$(“:input”)</td><td>所有 &lt;input> 元素</td></tr><tr><td>:text</td><td>$(“:text”)</td><td>所有 type=”text” 的 &lt;input> 元素</td></tr><tr><td>:password</td><td>$(“:password”)</td><td>所有 type=”password” 的 &lt;input> 元素</td></tr><tr><td>:radio</td><td>$(“:radio”)</td><td>所有 type=”radio” 的 &lt;input> 元素</td></tr><tr><td>:checkbox</td><td>$(“:checkbox”)</td><td>所有 type=”checkbox” 的 &lt;input> 元素</td></tr><tr><td>:submit</td><td>$(“:submit”)</td><td>所有 type=”submit” 的 &lt;input> 元素</td></tr><tr><td>:reset</td><td>$(“:reset”)</td><td>所有 type=”reset” 的 &lt;input> 元素</td></tr><tr><td>:button</td><td>$(“:button”)</td><td>所有 type=”button” 的 &lt;input> 元素</td></tr><tr><td>:image</td><td>$(“:image”)</td><td>所有 type=”image” 的 &lt;input> 元素</td></tr><tr><td>:file</td><td>$(“:file”)</td><td>所有 type=”file” 的 &lt;input> 元素</td></tr><tr><td>:enabled</td><td>$(“:enabled”)</td><td>所有激活的 input 元素</td></tr><tr><td>:disabled</td><td>$(“:disabled”)</td><td>所有禁用的 input 元素</td></tr><tr><td>:selected</td><td>$(“:selected”)</td><td>所有被选取的 input 元素</td></tr><tr><td>:checked</td><td>$(“:checked”)</td><td>所有被选中的 input 元素</td></tr></tbody></table><h2 id="jQuery-事件函数"><a href="#jQuery-事件函数" class="headerlink" title="jQuery 事件函数"></a>jQuery 事件函数</h2><p>事件处理程序指的是当 HTML 中发生某些事件时所调用的方法。术语由事件“触发”（或“激发”）经常会被使用。  </p><p>例如：  </p><p><code>$(&quot;button&quot;).click(function() &#123;..some code... &#125; )</code></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>bind()</td><td>向匹配元素附加一个或更多事件处理器</td></tr><tr><td>blur()</td><td>触发、或将函数绑定到指定元素的 blur 事件</td></tr><tr><td>change()</td><td>触发、或将函数绑定到指定元素的 change 事件</td></tr><tr><td>click()</td><td>触发、或将函数绑定到指定元素的 click 事件</td></tr><tr><td>dblclick()</td><td>触发、或将函数绑定到指定元素的 double click 事件</td></tr><tr><td>delegate()</td><td>向匹配元素的当前或未来的子元素附加一个或多个事件处理器</td></tr><tr><td>die()</td><td>移除所有通过 live() 函数添加的事件处理程序。</td></tr><tr><td>error()</td><td>触发、或将函数绑定到指定元素的 error 事件</td></tr><tr><td>event.isDefaultPrevented()</td><td>返回 event 对象上是否调用了 event.preventDefault()。</td></tr><tr><td>event.pageX</td><td>相对于文档左边缘的鼠标位置。</td></tr><tr><td>event.pageY</td><td>相对于文档上边缘的鼠标位置。</td></tr><tr><td>event.preventDefault()</td><td>阻止事件的默认动作。</td></tr><tr><td>event.result</td><td>包含由被指定事件触发的事件处理器返回的最后一个值。</td></tr><tr><td>event.target</td><td>触发该事件的 DOM 元素。</td></tr><tr><td>event.timeStamp</td><td>该属性返回从 1970 年 1 月 1 日到事件发生时的毫秒数。</td></tr><tr><td>event.type</td><td>描述事件的类型。</td></tr><tr><td>event.which</td><td>指示按了哪个键或按钮。</td></tr><tr><td>focus()</td><td>触发、或将函数绑定到指定元素的 focus 事件</td></tr><tr><td>keydown()</td><td>触发、或将函数绑定到指定元素的 key down 事件</td></tr><tr><td>keypress()</td><td>触发、或将函数绑定到指定元素的 key press 事件</td></tr><tr><td>keyup()</td><td>触发、或将函数绑定到指定元素的 key up 事件</td></tr><tr><td>live()</td><td>为当前或未来的匹配元素添加一个或多个事件处理器</td></tr><tr><td>load()</td><td>触发、或将函数绑定到指定元素的 load 事件</td></tr><tr><td>mousedown()</td><td>触发、或将函数绑定到指定元素的 mouse down 事件</td></tr><tr><td>mouseenter()</td><td>触发、或将函数绑定到指定元素的 mouse enter 事件</td></tr><tr><td>mouseleave()</td><td>触发、或将函数绑定到指定元素的 mouse leave 事件</td></tr><tr><td>mousemove()</td><td>触发、或将函数绑定到指定元素的 mouse move 事件</td></tr><tr><td>mouseout()</td><td>触发、或将函数绑定到指定元素的 mouse out 事件</td></tr><tr><td>mouseover()</td><td>触发、或将函数绑定到指定元素的 mouse over 事件</td></tr><tr><td>mouseup()</td><td>触发、或将函数绑定到指定元素的 mouse up 事件</td></tr><tr><td>one()</td><td>向匹配元素添加事件处理器。每个元素只能触发一次该处理器。</td></tr><tr><td>ready()</td><td>文档就绪事件（当 HTML 文档就绪可用时）</td></tr><tr><td>resize()</td><td>触发、或将函数绑定到指定元素的 resize 事件</td></tr><tr><td>scroll()</td><td>触发、或将函数绑定到指定元素的 scroll 事件</td></tr><tr><td>select()</td><td>触发、或将函数绑定到指定元素的 select 事件</td></tr><tr><td>submit()</td><td>触发、或将函数绑定到指定元素的 submit 事件</td></tr><tr><td>toggle()</td><td>绑定两个或多个事件处理器函数，当发生轮流的 click 事件时执行。</td></tr><tr><td>trigger()</td><td>所有匹配元素的指定事件</td></tr><tr><td>triggerHandler()</td><td>第一个被匹配元素的指定事件</td></tr><tr><td>unbind()</td><td>从匹配元素移除一个被添加的事件处理器</td></tr><tr><td>undelegate()</td><td>从匹配元素移除一个被添加的事件处理器，现在或将来</td></tr><tr><td>unload()</td><td>触发、或将函数绑定到指定元素的 unload 事件</td></tr></tbody></table><h2 id="jQuery-效果函数"><a href="#jQuery-效果函数" class="headerlink" title="jQuery 效果函数"></a>jQuery 效果函数</h2><p>将 CSS 动画效果封装成 Javascript 函数。  </p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>animate()</td><td>对被选元素应用“自定义”的动画</td></tr><tr><td>clearQueue()</td><td>对被选元素移除所有排队的函数（仍未运行的）</td></tr><tr><td>delay()</td><td>对被选元素的所有排队函数（仍未运行）设置延迟</td></tr><tr><td>dequeue()</td><td>运行被选元素的下一个排队函数</td></tr><tr><td>fadeIn()</td><td>逐渐改变被选元素的不透明度，从隐藏到可见</td></tr><tr><td>fadeOut()</td><td>逐渐改变被选元素的不透明度，从可见到隐藏</td></tr><tr><td>fadeTo()</td><td>把被选元素逐渐改变至给定的不透明度</td></tr><tr><td>hide()</td><td>隐藏被选的元素</td></tr><tr><td>queue()</td><td>显示被选元素的排队函数</td></tr><tr><td>show()</td><td>显示被选的元素</td></tr><tr><td>slideDown()</td><td>通过调整高度来滑动显示被选元素</td></tr><tr><td>slideToggle()</td><td>对被选元素进行滑动隐藏和滑动显示的切换</td></tr><tr><td>slideUp()</td><td>通过调整高度来滑动隐藏被选元素</td></tr><tr><td>stop()</td><td>停止在被选元素上运行动画</td></tr><tr><td>toggle()</td><td>对被选元素进行隐藏和显示的切换</td></tr></tbody></table><h2 id="jQuery-遍历函数"><a href="#jQuery-遍历函数" class="headerlink" title="jQuery 遍历函数"></a>jQuery 遍历函数</h2><p>jQuery 遍历，意为“移动”，用于根据其相对于其他元素的关系来“查找”（或选取）HTML 元素。以某项选择开始，并沿着这个选择移动，直到抵达您期望的元素为止。  </p><p>下图展示了一个家族树。通过 jQuery 遍历，您能够从被选（当前的）元素开始，轻松地在家族树中向上移动（祖先），向下移动（子孙），水平移动（同胞）。这种移动被称为对 DOM 进行遍历。  </p><p><img src="/blog/static/imgs/dom_tree.gif" alt="dom_tree_inner"></p><ul><li>&lt;div> 元素是 &lt;ul> 的父元素，同时是其中所有内容的祖先。</li><li>&lt;ul> 元素是 &lt;li> 元素的父元素，同时是 &lt;div> 的子元素</li><li>左边的 &lt;li> 元素是 &lt;span> 的父元素，&lt;ul> 的子元素，同时是 &lt;div> 的后代。</li><li>&lt;span> 元素是 &lt;li> 的子元素，同时是 &lt;ul> 和 &lt;div> 的后代。</li><li>两个 &lt;li> 元素是同胞（拥有相同的父元素）。</li><li>右边的 &lt;li> 元素是 &lt;b> 的父元素，&lt;ul> 的子元素，同时是 &lt;div> 的后代。</li><li>&lt;b> 元素是右边的 &lt;li> 的子元素，同时是 &lt;ul> 和 &lt;div> 的后代。</li></ul><p><font color='red'>提示：</font>祖先是父、祖父、曾祖父等等。后代是子、孙、曾孙等等。同胞拥有相同的父。  </p><p>jQuery 遍历函数包括了用于筛选、查找和串联元素的方法。  </p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>.add()</td><td>将元素添加到匹配元素的集合中。</td></tr><tr><td>.andSelf()</td><td>把堆栈中之前的元素集添加到当前集合中。</td></tr><tr><td>.children()</td><td>获得匹配元素集合中每个元素的所有子元素。</td></tr><tr><td>.closest()</td><td>从元素本身开始，逐级向上级元素匹配，并返回最先匹配的祖先元素。</td></tr><tr><td>.contents()</td><td>获得匹配元素集合中每个元素的子元素，包括文本和注释节点。</td></tr><tr><td>.each()</td><td>对 jQuery 对象进行迭代，为每个匹配元素执行函数。</td></tr><tr><td>.end()</td><td>结束当前链中最近的一次筛选操作，并将匹配元素集合返回到前一次的状态。</td></tr><tr><td>.eq()</td><td>将匹配元素集合缩减为位于指定索引的新元素。</td></tr><tr><td>.filter()</td><td>将匹配元素集合缩减为匹配选择器或匹配函数返回值的新元素。</td></tr><tr><td>.find()</td><td>获得当前匹配元素集合中每个元素的后代，由选择器进行筛选。</td></tr><tr><td>.first()</td><td>将匹配元素集合缩减为集合中的第一个元素。</td></tr><tr><td>.has()</td><td>将匹配元素集合缩减为包含特定元素的后代的集合。</td></tr><tr><td>.is()</td><td>根据选择器检查当前匹配元素集合，如果存在至少一个匹配元素，则返回 true。</td></tr><tr><td>.last()</td><td>将匹配元素集合缩减为集合中的最后一个元素。</td></tr><tr><td>.map()</td><td>把当前匹配集合中的每个元素传递给函数，产生包含返回值的新 jQuery 对象。</td></tr><tr><td>.next()</td><td>获得匹配元素集合中每个元素紧邻的同辈元素。</td></tr><tr><td>.nextAll()</td><td>获得匹配元素集合中每个元素之后的所有同辈元素，由选择器进行筛选（可选）。</td></tr><tr><td>.nextUntil()</td><td>获得每个元素之后所有的同辈元素，直到遇到匹配选择器的元素为止。</td></tr><tr><td>.not()</td><td>从匹配元素集合中删除元素。</td></tr><tr><td>.offsetParent()</td><td>获得用于定位的第一个父元素。</td></tr><tr><td>.parent()</td><td>获得当前匹配元素集合中每个元素的父元素，由选择器筛选（可选）。</td></tr><tr><td>.parents()</td><td>获得当前匹配元素集合中每个元素的祖先元素，由选择器筛选（可选）。</td></tr><tr><td>.parentsUntil()</td><td>获得当前匹配元素集合中每个元素的祖先元素，直到遇到匹配选择器的元素为止。</td></tr><tr><td>.prev()</td><td>获得匹配元素集合中每个元素紧邻的前一个同辈元素，由选择器筛选（可选）。</td></tr><tr><td>.prevAll()</td><td>获得匹配元素集合中每个元素之前的所有同辈元素，由选择器进行筛选（可选）。</td></tr><tr><td>.prevUntil()</td><td>获得每个元素之前所有的同辈元素，直到遇到匹配选择器的元素为止。</td></tr><tr><td>.siblings()</td><td>获得匹配元素集合中所有元素的同辈元素，由选择器筛选（可选）。</td></tr><tr><td>.slice()</td><td>将匹配元素集合缩减为指定范围的子集。</td></tr></tbody></table><h2 id="jQuery-文档操作"><a href="#jQuery-文档操作" class="headerlink" title="jQuery 文档操作"></a>jQuery 文档操作</h2><p>对HTML元素进行操作。  </p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>after()</td><td>在匹配的元素之后插入内容。</td></tr><tr><td>append()</td><td>向匹配元素集合中的每个元素结尾插入由参数指定的内容。</td></tr><tr><td>appendTo()</td><td>向目标结尾插入匹配元素集合中的每个元素。</td></tr><tr><td>attr()</td><td>设置或返回匹配元素的属性和值。</td></tr><tr><td>before()</td><td>在每个匹配的元素之前插入内容。</td></tr><tr><td>clone()</td><td>创建匹配元素集合的副本。</td></tr><tr><td>detach()</td><td>从 DOM 中移除匹配元素集合。</td></tr><tr><td>empty()</td><td>删除匹配的元素集合中所有的子节点。</td></tr><tr><td>html()</td><td>设置或返回匹配的元素集合中的 HTML 内容。</td></tr><tr><td>insertAfter()</td><td>把匹配的元素插入到另一个指定的元素集合的后面。</td></tr><tr><td>insertBefore()</td><td>把匹配的元素插入到另一个指定的元素集合的前面。</td></tr><tr><td>prepend()</td><td>向匹配元素集合中的每个元素开头插入由参数指定的内容。</td></tr><tr><td>prependTo()</td><td>向目标开头插入匹配元素集合中的每个元素。</td></tr><tr><td>remove()</td><td>移除所有匹配的元素。</td></tr><tr><td>replaceAll()</td><td>用匹配的元素替换所有匹配到的元素。</td></tr><tr><td>replaceWith()</td><td>用新内容替换匹配的元素。</td></tr><tr><td>text()</td><td>设置或返回匹配元素的内容。</td></tr><tr><td>unwrap()</td><td>移除并替换指定元素的父元素。</td></tr><tr><td>wrap()</td><td>把匹配的元素用指定的内容或元素包裹起来。</td></tr><tr><td>wrapAll()</td><td>把所有匹配的元素用指定的内容或元素包裹起来。</td></tr><tr><td>wrapinner()</td><td>将每一个匹配的元素的子内容用指定的内容或元素包裹起来。</td></tr></tbody></table><h2 id="jQuery-属性操作"><a href="#jQuery-属性操作" class="headerlink" title="jQuery 属性操作"></a>jQuery 属性操作</h2><p>下面列出的这些方法获得或设置元素的 DOM 属性。  </p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>addClass()</td><td>向匹配的元素添加指定的类名。</td></tr><tr><td>attr()</td><td>设置或返回匹配元素的属性和值。</td></tr><tr><td>hasClass()</td><td>检查匹配的元素是否拥有指定的类。</td></tr><tr><td>html()</td><td>设置或返回匹配的元素集合中的 HTML 内容。</td></tr><tr><td>removeAttr()</td><td>从所有匹配的元素中移除指定的属性。</td></tr><tr><td>removeClass()</td><td>从所有匹配的元素中删除全部或者指定的类。</td></tr><tr><td>toggleClass()</td><td>从匹配的元素中添加或删除一个类。</td></tr><tr><td>val()</td><td>设置或返回匹配元素的值。</td></tr></tbody></table><h2 id="jQuery-css-操作函数"><a href="#jQuery-css-操作函数" class="headerlink" title="jQuery css 操作函数"></a>jQuery css 操作函数</h2><p>下面列出的这些方法设置或返回元素的 css 相关属性。  </p><table><thead><tr><th>css 属性</th><th>描述</th></tr></thead><tbody><tr><td>css()</td><td>设置或返回匹配元素的样式属性。</td></tr><tr><td>height()</td><td>设置或返回匹配元素的高度。</td></tr><tr><td>offset()</td><td>返回第一个匹配元素相对于文档的位置。</td></tr><tr><td>offsetParent()</td><td>返回最近的定位祖先元素。</td></tr><tr><td>position()</td><td>返回第一个匹配元素相对于父元素的位置。</td></tr><tr><td>scrollLeft()</td><td>设置或返回匹配元素相对滚动条左侧的偏移。</td></tr><tr><td>scrollTop()</td><td>设置或返回匹配元素相对滚动条顶部的偏移。</td></tr><tr><td>width()</td><td>设置或返回匹配元素的宽度。</td></tr></tbody></table><h2 id="jQuery-数据操作函数"><a href="#jQuery-数据操作函数" class="headerlink" title="jQuery 数据操作函数"></a>jQuery 数据操作函数</h2><p>这些方法允许我们将指定的 DOM 元素与任意数据相关联。  </p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>.clearQueue()</td><td>从队列中删除所有未运行的项目。</td></tr><tr><td>.data()</td><td>存储与匹配元素相关的任意数据。</td></tr><tr><td>jQuery.data()</td><td>存储与指定元素相关的任意数据。</td></tr><tr><td>.dequeue()</td><td>从队列最前端移除一个队列函数，并执行它。</td></tr><tr><td>jQuery.dequeue()</td><td>从队列最前端移除一个队列函数，并执行它。</td></tr><tr><td>jQuery.hasData()</td><td>存储与匹配元素相关的任意数据。</td></tr><tr><td>.queue()</td><td>显示或操作匹配元素所执行函数的队列。</td></tr><tr><td>jQuery.queue()</td><td>显示或操作匹配元素所执行函数的队列。</td></tr><tr><td>.removeData()</td><td>移除之前存放的数据。</td></tr><tr><td>jQuery.removeData()</td><td>移除之前存放的数据。</td></tr></tbody></table><h2 id="jQuery-AJAX"><a href="#jQuery-AJAX" class="headerlink" title="jQuery AJAX"></a>jQuery AJAX</h2><h3 id="什么是-AJAX？"><a href="#什么是-AJAX？" class="headerlink" title="什么是 AJAX？"></a>什么是 AJAX？</h3><p>AJAX = 异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。  </p><p>简短地说，在不重载整个网页的情况下，AJAX 通过后台加载数据，并在网页上进行显示。  </p><h3 id="jQuery-AJAX方法"><a href="#jQuery-AJAX方法" class="headerlink" title="jQuery AJAX方法"></a>jQuery AJAX方法</h3><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>jQuery.ajax()</td><td>执行异步 HTTP (Ajax) 请求。</td></tr><tr><td>.ajaxComplete()</td><td>当 Ajax 请求完成时注册要调用的处理程序。这是一个 Ajax 事件。</td></tr><tr><td>.ajaxError()</td><td>当 Ajax 请求完成且出现错误时注册要调用的处理程序。这是一个 Ajax 事件。</td></tr><tr><td>.ajaxSend()</td><td>在 Ajax 请求发送之前显示一条消息。</td></tr><tr><td>jQuery.ajaxSetup()</td><td>设置将来的 Ajax 请求的默认值。</td></tr><tr><td>.ajaxStart()</td><td>当首个 Ajax 请求完成开始时注册要调用的处理程序。这是一个 Ajax 事件。</td></tr><tr><td>.ajaxStop()</td><td>当所有 Ajax 请求完成时注册要调用的处理程序。这是一个 Ajax 事件。</td></tr><tr><td>.ajaxSuccess()</td><td>当 Ajax 请求成功完成时显示一条消息。</td></tr><tr><td>jQuery.get()</td><td>使用 HTTP GET 请求从服务器加载数据。</td></tr><tr><td>jQuery.getJSON()</td><td>使用 HTTP GET 请求从服务器加载 JSON 编码数据。</td></tr><tr><td>jQuery.getScript()</td><td>使用 HTTP GET 请求从服务器加载 JavaScript 文件，然后执行该文件。</td></tr><tr><td>.load()</td><td>从服务器加载数据，然后把返回到 HTML 放入匹配元素。</td></tr><tr><td>jQuery.param()</td><td>创建数组或对象的序列化表示，适合在 URL 查询字符串或 Ajax 请求中使用。</td></tr><tr><td>jQuery.post()</td><td>使用 HTTP POST 请求从服务器加载数据。</td></tr><tr><td>.serialize()</td><td>将表单内容序列化为字符串。</td></tr><tr><td>.serializeArray()</td><td>序列化表单元素，返回 JSON 数据结构数据。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Visual Studio Code 常用快捷键</title>
      <link href="/blog/2018/09/02/TIPS-Visual-Studio-Code-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/blog/2018/09/02/TIPS-Visual-Studio-Code-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<p>以下的Ctrl键指的是Windows系统下的Ctrl键，在Mac上对应Command键。  </p><h2 id="主命令框"><a href="#主命令框" class="headerlink" title="主命令框"></a>主命令框</h2><p>F1 或 Ctrl+Shift+P: 打开命令面板。在打开的输入框内，可以输入任何命令，例如：  </p><ol><li>按一下 Backspace 会进入到 Ctrl+P 模式</li><li>在 Ctrl+P 下输入 &gt; 可以进入 Ctrl+Shift+P 模式</li></ol><p>在 Ctrl+P 窗口下还可以:</p><ol><li>直接输入文件名，跳转到文件</li><li>? 列出当前可执行的动作</li><li>! 显示 Errors或 Warnings，也可以 Ctrl+Shift+M</li><li>: 跳转到行数，也可以 Ctrl+G 直接进入</li><li>@ 跳转到 symbol（搜索变量或者函数），也可以 Ctrl+Shift+O 直接进入</li><li>@ 根据分类跳转 symbol，查找属性或函数，也可以 Ctrl+Shift+O 后输入:进入</li><li># 根据名字查找 symbol，也可以 Ctrl+T</li></ol><span id="more"></span><h2 id="编辑器与窗口管理"><a href="#编辑器与窗口管理" class="headerlink" title="编辑器与窗口管理"></a>编辑器与窗口管理</h2><ol><li>打开一个新窗口： Ctrl+Shift+N</li><li>关闭窗口： Ctrl+Shift+W</li><li>同时打开多个编辑器（查看多个文件）</li><li>新建文件 Ctrl+N</li><li>文件之间切换 Ctrl+Tab</li><li>切出一个新的编辑器（最多 3 个） Ctrl+\，也可以按住 Ctrl 鼠标点击 Explorer 里的文件名</li><li>左中右 3 个编辑器的快捷键 Ctrl+1 Ctrl+2 Ctrl+3</li><li>3 个编辑器之间循环切换 Ctrl+</li><li>编辑器换位置， Ctrl+k然后按 Left或 Right</li></ol><h2 id="代码格式调整"><a href="#代码格式调整" class="headerlink" title="代码格式调整"></a>代码格式调整</h2><ol><li>代码行缩进 Ctrl+[ 、 Ctrl+]</li><li>Ctrl+C 、 Ctrl+V 复制或剪切当前行/当前选中内容</li><li>代码格式化： Shift+Alt+F，或 Ctrl+Shift+P 后输入 format code</li><li>上下移动一行： Alt+Up 或 Alt+Down</li><li>向上向下复制一行： Shift+Alt+Up 或 Shift+Alt+Down</li><li>在当前行下边插入一行 Ctrl+Enter</li><li>在当前行上方插入一行 Ctrl+Shift+Enter</li></ol><h2 id="光标相关"><a href="#光标相关" class="headerlink" title="光标相关"></a>光标相关</h2><ol><li>移动到行首： Home</li><li>移动到行尾： End</li><li>移动到文件结尾： Ctrl+End</li><li>移动到文件开头： Ctrl+Home</li><li>移动到定义处： F12</li><li>定义处缩略图：只看一眼而不跳转过去 Alt+F12</li><li>移动到后半个括号： Ctrl+Shift+]</li><li>选择从光标到行尾： Shift+End</li><li>选择从行首到光标处： Shift+Home</li><li>删除光标右侧的所有字： Ctrl+Delete</li><li>扩展/缩小选取范围： Shift+Alt+Left 和 Shift+Alt+Right</li><li>多行编辑(列编辑)：Alt+Shift+鼠标左键，Ctrl+Alt+Down/Up</li><li>同时选中所有匹配： Ctrl+Shift+L</li><li>Ctrl+D 下一个匹配的也被选中 (在 sublime 中是删除当前行，后面自定义快键键中，设置与 Ctrl+Shift+K 互换了)</li><li>回退上一个光标操作： Ctrl+U</li></ol><h2 id="修改代码格式"><a href="#修改代码格式" class="headerlink" title="修改代码格式"></a>修改代码格式</h2><ol><li>找到所有的引用： Shift+F12</li><li>同时修改本文件中所有匹配的： Ctrl+F12</li><li>重命名：比如要修改一个方法名，可以选中后按 F2，输入新的名字，回车，会发现所有的文件都修改了</li><li>跳转到下一个 Error 或 Warning：当有多个错误时可以按 F8 逐个跳转</li><li>查看 diff： 在 explorer 里选择文件右键 Set file to compare，然后需要对比的文件上右键选择 Compare with file_name_you_chose</li></ol><h2 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h2><ol><li>查找 Ctrl+F</li><li>查找替换 Ctrl+H</li><li>整个文件夹中查找 Ctrl+Shift+F</li></ol><h2 id="显示相关"><a href="#显示相关" class="headerlink" title="显示相关"></a>显示相关</h2><ol><li>全屏：F11</li><li>zoomIn/zoomOut：Ctrl +/-</li><li>侧边栏显/隐：Ctrl+B</li><li>显示资源管理器 Ctrl+Shift+E</li><li>显示搜索 Ctrl+Shift+F</li><li>显示 Git Ctrl+Shift+G</li><li>显示 Debug Ctrl+Shift+D</li><li>显示 Output Ctrl+Shift+U</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>自动保存：<br>    File -&gt; AutoSave ，或者 Ctrl+Shift+P，输入 auto<br>修改默认快捷键：  </p><ol><li>打开默认键盘快捷方式设置：File -&gt; Preferences -&gt; Keyboard Shortcuts，或者：Alt+F -&gt; p -&gt; k  </li><li>修改 keybindings.json：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Place your key bindings in this file to overwrite the defaults</span></span><br><span class="line">[</span><br><span class="line">    <span class="comment">// ctrl+space 被切换输入法快捷键占用</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;key&quot;</span>: <span class="string">&quot;ctrl+alt+space&quot;</span>,</span><br><span class="line">        <span class="string">&quot;command&quot;</span>: <span class="string">&quot;editor.action.triggerSuggest&quot;</span>,</span><br><span class="line">        <span class="string">&quot;when&quot;</span>: <span class="string">&quot;editorTextFocus&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ctrl+d 删除一行</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;key&quot;</span>: <span class="string">&quot;ctrl+d&quot;</span>,</span><br><span class="line">        <span class="string">&quot;command&quot;</span>: <span class="string">&quot;editor.action.deleteLines&quot;</span>,</span><br><span class="line">        <span class="string">&quot;when&quot;</span>: <span class="string">&quot;editorTextFocus&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 与删除一行的快捷键互换</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;key&quot;</span>: <span class="string">&quot;ctrl+shift+k&quot;</span>,</span><br><span class="line">        <span class="string">&quot;command&quot;</span>: <span class="string">&quot;editor.action.addSelectionToNextFindMatch&quot;</span>,</span><br><span class="line">        <span class="string">&quot;when&quot;</span>: <span class="string">&quot;editorFocus&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ctrl+shift+/多行注释</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;key&quot;</span>:<span class="string">&quot;ctrl+shift+/&quot;</span>,</span><br><span class="line">        <span class="string">&quot;command&quot;</span>: <span class="string">&quot;editor.action.blockComment&quot;</span>,</span><br><span class="line">        <span class="string">&quot;when&quot;</span>: <span class="string">&quot;editorTextFocus&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 定制与 sublime 相同的大小写转换快捷键，需安装 TextTransform 插件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;key&quot;</span>: <span class="string">&quot;ctrl+k ctrl+u&quot;</span>,</span><br><span class="line">        <span class="string">&quot;command&quot;</span>: <span class="string">&quot;uppercase&quot;</span>,</span><br><span class="line">        <span class="string">&quot;when&quot;</span>: <span class="string">&quot;editorTextFocus&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;key&quot;</span>: <span class="string">&quot;ctrl+k ctrl+l&quot;</span>,</span><br><span class="line">        <span class="string">&quot;command&quot;</span>: <span class="string">&quot;lowercase&quot;</span>,</span><br><span class="line">        <span class="string">&quot;when&quot;</span>: <span class="string">&quot;editorTextFocus&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tool </tag>
            
            <tag> tips </tag>
            
            <tag> VScode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法的javascript实现</title>
      <link href="/blog/2018/09/01/CS-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84javascript%E5%AE%9E%E7%8E%B0/"/>
      <url>/blog/2018/09/01/CS-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84javascript%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="时间空间复杂度"><a href="#时间空间复杂度" class="headerlink" title="时间空间复杂度"></a>时间空间复杂度</h2><p>排序是算法中最经典的问题，以下表格对插入排序、冒泡排序、选择排序、希尔排序、快速排序、归并排序这几种排序进行了比较。  </p><table><thead><tr><th>排序算法</th><th>平均时间复杂度</th><th>最坏时间复杂度</th><th>空间复杂度</th><th>是否稳定</th></tr></thead><tbody><tr><td>插入排序</td><td>O（n2）</td><td>O（n2）</td><td>O（1）</td><td>是</td></tr><tr><td>冒泡排序</td><td>O（n2）</td><td>O（n2）</td><td>O（1）</td><td>是</td></tr><tr><td>选择排序</td><td>O（n2）</td><td>O（n2）</td><td>O（1）</td><td>不是</td></tr><tr><td>希尔排序</td><td>O(nlogn)</td><td>O（n2）</td><td>O（1）</td><td>不是</td></tr><tr><td>快速排序</td><td>O(nlogn)</td><td>O（n2）</td><td>O（logn）</td><td>不是</td></tr><tr><td>归并排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O（n）</td><td>是</td></tr></tbody></table><span id="more"></span><p>下面是具体的javascript实现：  </p><h2 id="插入排序-Insertion-Sort"><a href="#插入排序-Insertion-Sort" class="headerlink" title="插入排序 Insertion Sort"></a>插入排序 Insertion Sort</h2><p>插入排序，一般也被称为直接插入排序。对于少量元素的排序，它是一个有效的算法。它的基本思想是将一个记录插入到已经排好序的有序表中，从而一个形成一个新的、记录数增1的有序表。  </p><p>插入排序还有升级版-二分插入排序（Binary Sort)。即数据在试图找到自己在前面已排序的部分中的位置时，用比较高效的二分查找。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> insertSort = <span class="keyword">function</span> (<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.<span class="property">length</span>, key;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> j = i;</span><br><span class="line">            key = arr[j];</span><br><span class="line">            <span class="keyword">while</span> (--j &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; key) &#123;</span><br><span class="line">                    arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + <span class="number">1</span>] = key;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序 Bubble Sort"></a>冒泡排序 Bubble Sort</h2><p>重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序错误就把他们交换过来。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bubbleSort = <span class="keyword">function</span> (<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">var</span> len = arr.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">var</span> temp = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="选择排序-Selection-Sort"><a href="#选择排序-Selection-Sort" class="headerlink" title="选择排序 Selection Sort"></a>选择排序 Selection Sort</h2><p>第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selectSort = <span class="keyword">function</span> (<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> min;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        min = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="property">length</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[min] &gt; arr[j]) &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i != min) &#123;</span><br><span class="line">            <span class="title function_">swap</span>(arr, i, min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">swap</span>(<span class="params">arr, index1, index2</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> temp = arr[index1];</span><br><span class="line">    arr[index1] = arr[index2];</span><br><span class="line">    arr[index2] = temp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="希尔排序-Shell-Sort"><a href="#希尔排序-Shell-Sort" class="headerlink" title="希尔排序 Shell Sort"></a>希尔排序 Shell Sort</h2><p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shellSort = <span class="keyword">function</span> (<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> gaps = [<span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> g = <span class="number">0</span>; g &lt; gaps.<span class="property">length</span>; ++g) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = gaps[g]; i &lt; arr.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">var</span> temp = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = i; j &gt;= gaps[g] &amp;&amp; arr[j - gaps[g]] &gt; temp; j -= gaps[g])&#123;</span><br><span class="line">                arr[j] = arr[j - gaps[g]];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序 Quick Sort"></a>快速排序 Quick Sort</h2><p>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> quickSort = <span class="keyword">function</span>(<span class="params">arr, left, right</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> i, j, t, pivot;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pivot = arr[left];</span><br><span class="line">    i = left;</span><br><span class="line">    j = right;</span><br><span class="line">    <span class="keyword">while</span> (i != j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[j] &gt;= pivot &amp;&amp; i &lt; j) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (arr[i] &lt;= pivot &amp;&amp; i &lt; j) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            t = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[left] = arr[j];</span><br><span class="line">    arr[j] = pivot;</span><br><span class="line">    <span class="title function_">quickSort</span>(arr, left, i - <span class="number">1</span>);</span><br><span class="line">    <span class="title function_">quickSort</span>(arr, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序 Merge Sort"></a>归并排序 Merge Sort</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mergeSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="property">length</span> &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> step = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> left, right;</span><br><span class="line">    <span class="keyword">while</span> (step &lt; arr.<span class="property">length</span>) &#123;</span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        right = step;</span><br><span class="line">        <span class="keyword">while</span> (right + step &lt;= arr.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="title function_">mergeArrays</span>(arr, left, left + step, right, right + step);</span><br><span class="line">            left = right + step;</span><br><span class="line">            right = left + step;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; arr.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="title function_">mergeArrays</span>(arr, left, left + step, right, arr.<span class="property">length</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        step *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mergeArrays</span>(<span class="params">arr, startLeft, stopLeft, startRight, stopRight</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> rightArr = <span class="keyword">new</span> <span class="title class_">Array</span>(stopRight - startRight + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> leftArr = <span class="keyword">new</span> <span class="title class_">Array</span>(stopLeft - startLeft + <span class="number">1</span>);</span><br><span class="line">    k = startRight;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; (rightArr.<span class="property">length</span> - <span class="number">1</span>); ++i) &#123;</span><br><span class="line">        rightArr[i] = arr[k];</span><br><span class="line">        ++k;</span><br><span class="line">    &#125;</span><br><span class="line">    k = startLeft;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; (leftArr.<span class="property">length</span> - <span class="number">1</span>); ++i) &#123;</span><br><span class="line">        leftArr[i] = arr[k];</span><br><span class="line">        ++k;</span><br><span class="line">    &#125;</span><br><span class="line">    rightArr[rightArr.<span class="property">length</span> - <span class="number">1</span>] = <span class="title class_">Infinity</span>; <span class="comment">// 哨兵值</span></span><br><span class="line">    leftArr[leftArr.<span class="property">length</span> - <span class="number">1</span>] = <span class="title class_">Infinity</span>; <span class="comment">// 哨兵值</span></span><br><span class="line">    <span class="keyword">var</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> k = startLeft; k &lt; stopRight; ++k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftArr[m] &lt;= rightArr[n]) &#123;</span><br><span class="line">            arr[k] = leftArr[m];</span><br><span class="line">            m++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr[k] = rightArr[n];</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="js-中-Array-prototype-sort-的实现"><a href="#js-中-Array-prototype-sort-的实现" class="headerlink" title="js 中 Array.prototype.sort 的实现"></a>js 中 Array.prototype.sort 的实现</h2><p>ECMAScript没有定义使用哪种排序算法，甚至没有规定排序的稳定性，各个浏览器的实现方式也会有所不同。<br>具体到浏览器中，<br>Mozilla/Firefox : 归并排序<br>V8 ：数组长度小于等于 22 的用二分插入排序，其它的用快速排序（<a href="https://github.com/v8/v8/blob/master/test/mjsunit/array-sort.js">array.js test 源码</a>），数组长度大于1000时会 调用 <code>GetThirdIndex</code> 获取更接近中位值的 <code>pivot</code></p><p>见下面注释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Quicksort is used for arrays which length &gt; 22</span><br><span class="line">// Arrays which length &gt; 1000 guarantee GetThirdIndex is executed</span><br></pre></td></tr></table></figure><p>更新于 20210419，v8的排序算法已变更为 tim-sort  </p><p>(array-sort.js源码)[https://github.com/v8/v8/blob/master/third_party/v8/builtins/array-sort.tq]</p><p>Tim Sort采用分治的思想，分组进行二分插入排序，再用归并排序合并。  </p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>debounce &amp; throttle</title>
      <link href="/blog/2018/08/31/JS-%E9%98%B2%E6%8A%96%E4%B8%8E%E6%88%AA%E6%B5%81/"/>
      <url>/blog/2018/08/31/JS-%E9%98%B2%E6%8A%96%E4%B8%8E%E6%88%AA%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="函数节流（throttle）与函数去抖（debounce）"><a href="#函数节流（throttle）与函数去抖（debounce）" class="headerlink" title="函数节流（throttle）与函数去抖（debounce）"></a>函数节流（throttle）与函数去抖（debounce）</h2><p>以下场景往往由于事件频繁被触发，因而频繁执行DOM操作、资源加载等重行为，导致UI停顿甚至浏览器崩溃。  </p><ol><li><p>window对象的resize、scroll事件</p></li><li><p>拖拽时的mousemove事件</p></li><li><p>射击游戏中的mousedown、keydown事件</p></li><li><p>文字输入、自动完成的keyup事件</p></li></ol><p>实际上对于 window 的 resize 事件，实际需求大多为停止改变大小n毫秒后执行后续处理；而其他事件大多的需求是以一定的频率执行后续处理。针对这两种需求就出现了 debounce 和 throttle 两种解决办法。  </p><span id="more"></span><h3 id="什么是debounce"><a href="#什么是debounce" class="headerlink" title="什么是debounce"></a>什么是debounce</h3><p>[dɪ’baʊns] 防止反弹，即如果用手指一直按住一个弹簧，它将不会弹起直到你松手为止。  </p><p>也就是说当调用动作n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间。  </p><p>如果该动作持续的触发，那么该函数只会在最后一次触发之后再延迟delay的时间才会执行一次。  </p><p>接口定义：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> fn &#123;function&#125;  请求关联函数，实际应用需要调用的函数</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> delay &#123;number&#125;    空闲时间，单位毫秒</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &#123;<span class="type">function</span>&#125;    返回客户调用函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title function_">debounce</span>(<span class="params">fn, delay</span>) &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>简单实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> debounce = <span class="keyword">function</span>(<span class="params">fn, delay</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> ctx = <span class="variable language_">this</span>, args = <span class="variable language_">arguments</span>;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(ctx, args)</span><br><span class="line">        &#125;, (delay ? delay : <span class="number">300</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="什么是throttle"><a href="#什么是throttle" class="headerlink" title="什么是throttle"></a>什么是throttle</h3><p>[ˈθrɒtl] 节流阀，即如果将水龙头拧紧直到水是以水滴的形式流出，那你会发现每隔一段时间，就会有一滴水流出。  </p><p>也就是会说预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期。  </p><p>如果该动作持续的触发，那么该函数会在每经过delay时间之后就会执行一次。最终会执行n次, n = 总触发时间/delay。</p><p> 接口定义：<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> fn &#123;function&#125;  请求关联函数，实际应用需要调用的函数</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> delay &#123;number&#125;    延迟时间，单位毫秒</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &#123;<span class="type">function</span>&#125;    返回客户调用函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title function_">throttle</span>(<span class="params">fn, delay</span>) &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>简单实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> throttle = <span class="keyword">function</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> last = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> curr = + <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="keyword">if</span> (curr - last &gt; delay)&#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">      last = curr;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="underscore实现"><a href="#underscore实现" class="headerlink" title="underscore实现"></a>underscore实现</h3><p>debounce  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns a function, that, as long as it continues to be invoked, will not</span></span><br><span class="line"><span class="comment">// be triggered. The function will be called after it stops being called for</span></span><br><span class="line"><span class="comment">// N milliseconds. If `immediate` is passed, trigger the function on the</span></span><br><span class="line"><span class="comment">// leading edge, instead of the trailing.</span></span><br><span class="line">_.<span class="property">debounce</span> = <span class="keyword">function</span>(<span class="params">func, wait, immediate</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> timeout, result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> later = <span class="keyword">function</span>(<span class="params">context, args</span>) &#123;</span><br><span class="line">    timeout = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (args) result = func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> debounced = <span class="title function_">restArguments</span>(<span class="keyword">function</span>(<span class="params">args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">      <span class="keyword">var</span> callNow = !timeout;</span><br><span class="line">      timeout = <span class="built_in">setTimeout</span>(later, wait);</span><br><span class="line">      <span class="keyword">if</span> (callNow) result = func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timeout = _.<span class="title function_">delay</span>(later, wait, <span class="variable language_">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  debounced.<span class="property">cancel</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    timeout = <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> debounced;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>throttle  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns a function, that, when invoked, will only be triggered at most once</span></span><br><span class="line"> <span class="comment">// during a given window of time. Normally, the throttled function will run</span></span><br><span class="line"> <span class="comment">// as much as it can, without ever going more than once per `wait` duration;</span></span><br><span class="line"> <span class="comment">// but if you&#x27;d like to disable the execution on the leading edge, pass</span></span><br><span class="line"> <span class="comment">// `&#123;leading: false&#125;`. To disable execution on the trailing edge, ditto.</span></span><br><span class="line"> _.<span class="property">throttle</span> = <span class="keyword">function</span>(<span class="params">func, wait, options</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> timeout, context, args, result;</span><br><span class="line">   <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span> (!options) options = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> later = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     previous = options.<span class="property">leading</span> === <span class="literal">false</span> ? <span class="number">0</span> : _.<span class="title function_">now</span>();</span><br><span class="line">     timeout = <span class="literal">null</span>;</span><br><span class="line">     result = func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">     <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> throttled = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">var</span> now = _.<span class="title function_">now</span>();</span><br><span class="line">     <span class="keyword">if</span> (!previous &amp;&amp; options.<span class="property">leading</span> === <span class="literal">false</span>) previous = now;</span><br><span class="line">     <span class="keyword">var</span> remaining = wait - (now - previous);</span><br><span class="line">     context = <span class="variable language_">this</span>;</span><br><span class="line">     args = <span class="variable language_">arguments</span>;</span><br><span class="line">     <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">       <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">         <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">         timeout = <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       previous = now;</span><br><span class="line">       result = func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">       <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.<span class="property">trailing</span> !== <span class="literal">false</span>) &#123;</span><br><span class="line">       timeout = <span class="built_in">setTimeout</span>(later, remaining);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   throttled.<span class="property">cancel</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">     previous = <span class="number">0</span>;</span><br><span class="line">     timeout = context = args = <span class="literal">null</span>;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> throttled;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
            <tag> javascript </tag>
            
            <tag> underscore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS calc 函数</title>
      <link href="/blog/2018/08/30/css-calc-%E5%87%BD%E6%95%B0/"/>
      <url>/blog/2018/08/30/css-calc-%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>本篇主要介绍 calc 函数，CSS函数之一，可以在CSS中执行计算操作。  </p><span id="more"></span><p>使用 calc() 函数计算 div 元素的宽度，实现 div 距离左右边界各50px:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#div1</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">100px</span>);</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义与用法"><a href="#定义与用法" class="headerlink" title="定义与用法"></a>定义与用法</h2><p>calc() 函数用于动态计算长度值，CSS3支持。</p><ul><li>需要注意的是，运算符前后都需要保留一个空格，例如：<code>width: calc(100% - 10px)；</code>  </li><li>任何长度值都可以使用calc()函数进行计算；  </li><li>calc()函数支持 “+”, “-“, “*”, “/“ 运算；  </li><li>calc()函数使用标准的数学运算优先级规则；  </li></ul><h2 id="在LESS中"><a href="#在LESS中" class="headerlink" title="在LESS中"></a>在LESS中</h2><p>在LESS中 <code>calc(100% - 40px)</code> 等带单位混合运算会被LESS解析忽略单位，全部按照百分比计算，此例中的计算被LESS编译成 <code>calc(60%)</code>。  </p><p>解决方案：<br>结合LESS使用特点，将计算放到LESS中解决。如上例 <code>calc(100% - 40px)</code>在LESS中可写为 <code>calc(~&quot;100% - 40px&quot;)</code>  </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@height:</span> <span class="number">40px</span>;</span><br><span class="line"><span class="variable">@borderHeight:</span> <span class="number">1px</span>;</span><br><span class="line"><span class="variable">@marginHeight:</span> <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">margin-bottom</span>: <span class="built_in">calc</span>(<span class="string">~&quot;@&#123;height&#125;&quot;</span> );</span><br><span class="line"><span class="attribute">margin-bottom</span>: <span class="built_in">calc</span>(<span class="string">~&quot;@&#123;height&#125; + @&#123;borderHeight&#125; * 3 + @&#123;marginHeight&#125; * 2&quot;</span> );</span><br></pre></td></tr></table></figure><h2 id="在Stylus中"><a href="#在Stylus中" class="headerlink" title="在Stylus中"></a>在Stylus中</h2><p>在Stylus中 calc 也可以使用，在使用变量时，需要用 <code>%s</code> 替代，然后在行尾 <code>%</code> 之后赋值</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">headHeight=<span class="number">50px</span>  <span class="comment">/* stylus语法中定义一个变量 */</span></span><br><span class="line">footerHeight = <span class="number">50px</span></span><br><span class="line"><span class="attribute">height</span> <span class="string">&#x27;calc(100%  - %s - %s)&#x27;</span> % (headHeight footerHeight)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Hexo发布个人博客到Github Pages</title>
      <link href="/blog/2018/08/24/Hexo-%E4%BD%BF%E7%94%A8Hexo%E5%8F%91%E5%B8%83%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%B0GithubPages/"/>
      <url>/blog/2018/08/24/Hexo-%E4%BD%BF%E7%94%A8Hexo%E5%8F%91%E5%B8%83%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%B0GithubPages/</url>
      
        <content type="html"><![CDATA[<p><a href="https://hexo.io/">Hexo</a>是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。Github Pages 是由 Github 提供的一个免费的静态文件部署服务，使用者可以直接将 Github 仓库的静态文件直接发布到 Github 服务器上。本篇讲述如何将 Hexo 博客发布到 Github Pages。</p><span id="more"></span><h2 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h2><p>安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序：</p><p><a href="nodejs.org">Node.js</a><br><a href="git-scm.com">Git</a>  </p><h2 id="安装Hexo-cli"><a href="#安装Hexo-cli" class="headerlink" title="安装Hexo-cli"></a>安装Hexo-cli</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h2 id="在Github中创建仓库"><a href="#在Github中创建仓库" class="headerlink" title="在Github中创建仓库"></a>在Github中创建仓库</h2><p>仓库需要以<code>.github.io</code>结尾<br><img src="/blog/static/imgs/create-repo.png" alt="create-repo"></p><h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ <span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">$ npm install</span><br><span class="line">$ npm install hexo-deployer-git --save</span><br><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><h2 id="配置发布参数"><a href="#配置发布参数" class="headerlink" title="配置发布参数"></a>配置发布参数</h2><p>在 _config.yml 中修改参数</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/username/username.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">&lt;username&gt;</span></span><br><span class="line">  <span class="attr">email:</span> <span class="string">&lt;useremail&gt;</span></span><br></pre></td></tr></table></figure><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><h2 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server -p 5000</span><br></pre></td></tr></table></figure><p>可以在 http://localhost:5000/ 预览效果  </p><h2 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h2><p>访问 https://&lt;username>.github.io 即可</p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> blog </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端简单面试题</title>
      <link href="/blog/2018/07/13/FE-%E5%89%8D%E7%AB%AF%E7%AE%80%E5%8D%95%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/blog/2018/07/13/FE-%E5%89%8D%E7%AB%AF%E7%AE%80%E5%8D%95%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>该文章用来记录一些常见的前端简单面试题，这些题目部分是因为比较细碎，部分是比较偏门（对某个不常用功能的深入知识），部分是因为还没来得及，所以没有单独列出文章来讲述。  </p><span id="more"></span><h1 id="基础-基本概念"><a href="#基础-基本概念" class="headerlink" title="基础(基本概念)"></a>基础(基本概念)</h1><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="display-none-与-visibility-hidden-的区别是什么？还有哪些隐藏元素的方法？"><a href="#display-none-与-visibility-hidden-的区别是什么？还有哪些隐藏元素的方法？" class="headerlink" title="display:none 与 visibility:hidden 的区别是什么？还有哪些隐藏元素的方法？"></a>display:none 与 visibility:hidden 的区别是什么？还有哪些隐藏元素的方法？</h3><p>区别：</p><ol><li><code>display:none;</code> 会让元素完全从渲染树中消失，渲染的时候不占据任何空间；<code>visibility: hidden;</code> 不会让元素从渲染树消失，渲染时元素继续占据空间，只是内容不可见  </li><li><code>display: none;</code> 是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；<code>visibility: hidden;</code> 是继承属性，子孙节点消失由于继承了hidden，通过设置 <code>visibility: visible;</code> 可以让子孙节点显式。  </li><li>修改常规流中元素的 display 通常会造成文档重排。修改 visibility 属性只会造成本元素的重绘。  </li><li>读屏器不会读取 <code>display: none;</code> 元素内容；会读取 <code>visibility: hidden;</code> 元素内容。  </li></ol><p>tips: 还有两种隐藏元素的方法：可以把元素移动到屏幕以外，或设置透明度 <code>opacity:0;</code> 为透明，也可以使用透明度滤镜 <code>filter:opacity(0)</code>  </p><h3 id="link-与-import-都可以引入样式，有什么区别？"><a href="#link-与-import-都可以引入样式，有什么区别？" class="headerlink" title="link 与 @import 都可以引入样式，有什么区别？"></a>link 与 @import 都可以引入样式，有什么区别？</h3><ol><li>link 是 HTML 方式， @import 是 CSS 方式</li><li>link 最大限度支持并行下载，@import 过多嵌套导致串行下载，出现FOUC（Flash Of Unstyled Content）页面闪烁</li><li>link 可以通过 <code>rel=&quot;alternate stylesheet&quot;</code> 指定候选样式</li><li>浏览器对 link 支持早于 @import ，可以使用 @import 对老浏览器隐藏样式</li><li>@import 必须在样式规则之前，可以在 css 文件中引用其他文件</li></ol><h3 id="css-sprite是什么-有什么优缺点？"><a href="#css-sprite是什么-有什么优缺点？" class="headerlink" title="css sprite是什么,有什么优缺点？"></a>css sprite是什么,有什么优缺点？</h3><p>概念：将多个小图片拼接到一个图片中。通过 <code>background-position</code> 和元素尺寸调节需要显示的背景图案。  </p><p>优点：  </p><ol><li>减少HTTP请求数，极大地提高页面加载速度</li><li>增加图片信息重复度，提高压缩比，减少图片大小</li><li>更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现</li></ol><p>缺点：</p><ol><li>图片合并麻烦</li><li>维护麻烦，修改一个图片可能需重新布局整个图片，样式</li></ol><h3 id="为什么要初始化CSS样式"><a href="#为什么要初始化CSS样式" class="headerlink" title="为什么要初始化CSS样式?"></a>为什么要初始化CSS样式?</h3><p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。  </p><h3 id="如何通过a标签批量下载文件？"><a href="#如何通过a标签批量下载文件？" class="headerlink" title="如何通过a标签批量下载文件？"></a>如何通过a标签批量下载文件？</h3><p>&lt;a> 标签的download属性指示浏览器下载而不是导航，参见 <a href="/blog/2019/01/03/HTML-a-的用法/#download-HTML5">a标签的属性download</a> ，然而该属性只适用于同源URLs，我们可以通过将地址转换为 <code>blob:URL</code> 的形式然后下载。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;https://dss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1593106255,4245861836&amp;fm=26&amp;gp=0.jpg&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="property">responseType</span> = <span class="string">&quot;blob&quot;</span>;</span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> == <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> blob = <span class="variable language_">this</span>.<span class="property">response</span>;</span><br><span class="line">        <span class="keyword">const</span> ele = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        ele.<span class="property">download</span> = name;</span><br><span class="line">        ele.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">        ele.<span class="property">href</span> = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(blob);</span><br><span class="line">        ele.<span class="property">onload</span>= <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">            <span class="variable constant_">URL</span>.<span class="title function_">revokeObjectURL</span>(ele.<span class="property">href</span>);</span><br><span class="line">            <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(ele);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(eleLink);</span><br><span class="line">        ele.<span class="title function_">click</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="Object-keys-和-for-…-in-遍历对象属性有什么不同？"><a href="#Object-keys-和-for-…-in-遍历对象属性有什么不同？" class="headerlink" title="Object.keys() 和 for … in 遍历对象属性有什么不同？"></a>Object.keys() 和 for … in 遍历对象属性有什么不同？</h3><p> for-in 循环还会枚举原型链中的属性  </p><h3 id="for-…-in-遍历和-for-…-of-遍历有什么不同？"><a href="#for-…-in-遍历和-for-…-of-遍历有什么不同？" class="headerlink" title="for … in 遍历和 for … of 遍历有什么不同？"></a>for … in 遍历和 for … of 遍历有什么不同？</h3><p><code>for...of</code> 语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。  </p><p><code>for...in</code> 语句以任意顺序遍历一个对象的除 Symbol 以外的可枚举属性（包括原型链中的属性）。  </p><p>for…in 和 for…of 的区别在于：  </p><p>for…in 语句以任意顺序迭代对象的可枚举属性。</p><p>for…of 语句遍历可迭代对象定义要迭代的数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">objCustom</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">arrCustom</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterable = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">iterable.<span class="property">foo</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> iterable) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 打印： 0, 1, 2, &quot;foo&quot;, &quot;arrCustom&quot;, &quot;objCustom&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> iterable) &#123;</span><br><span class="line">  <span class="keyword">if</span> (iterable.<span class="title function_">hasOwnProperty</span>(i)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 打印： 0, 1, 2, &quot;foo&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 打印： 3, 5, 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么使用delete操作符删除对象时需要遍历属性中的属性，依次删除？"><a href="#为什么使用delete操作符删除对象时需要遍历属性中的属性，依次删除？" class="headerlink" title="为什么使用delete操作符删除对象时需要遍历属性中的属性，依次删除？"></a>为什么使用delete操作符删除对象时需要遍历属性中的属性，依次删除？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="attr">p</span>:&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;&#125;;</span><br><span class="line">b=a.<span class="property">p</span>;</span><br><span class="line"><span class="keyword">delete</span> a.<span class="property">p</span>;</span><br></pre></td></tr></table></figure><p> 执行这段代码后b.x的值依然是1。由于已经删除的属性的引用依然存在，因此在JavaScript的某些实现中，可能因为这种不严谨的代码而造成内存泄漏。所以在销毁对象的时候，要遍历属性中的属性，依次删除。  </p><h3 id="解释-null-和-undefined-的区别"><a href="#解释-null-和-undefined-的区别" class="headerlink" title="解释 null 和 undefined 的区别"></a>解释 null 和 undefined 的区别</h3><p>undefined 表示系统级的、出乎意料的或类似错误的值的空缺，null表示程序级的、正常的或在意料之中的值的空缺。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// &#x27;undefined&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="解释-与-的区别"><a href="#解释-与-的区别" class="headerlink" title="解释 == 与 === 的区别"></a>解释 == 与 === 的区别</h3><p>“===”叫做严格相等运算符（恒等运算符），”==”叫做相等运算符。<br>严格相等运算符的运算规则如下，  </p><ul><li>不同类型值<br>  如果两个值的类型不同，直接返回false。</li><li>同一类的原始类型值<br>  同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回true，值不同就返回false。</li><li>同一类的复合类型值<br>  两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个对象。</li><li>undefined和null<br>  undefined 和 null 与自身严格相等。</li></ul><h3 id="创建对象的三个方法是什么？"><a href="#创建对象的三个方法是什么？" class="headerlink" title="创建对象的三个方法是什么？"></a>创建对象的三个方法是什么？</h3><ol><li>对象直接量</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = &#123;&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>通过关键字 <code>new</code> 创建对象</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br></pre></td></tr></table></figure><ol start="3"><li>通过 <code>Object.create()</code> 创建对象</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br></pre></td></tr></table></figure><h3 id="Array-of-和-new-Array-创建的数组有什么不同？"><a href="#Array-of-和-new-Array-创建的数组有什么不同？" class="headerlink" title="Array.of() 和 new Array() 创建的数组有什么不同？"></a>Array.of() 和 new Array() 创建的数组有什么不同？</h3><p><code>Array.of()</code> 和 <code>Array</code> 构造函数之间的区别在于处理整数参数：<code>Array.of(7)</code> 创建一个具有单个元素 7 的数组，而 <code>new Array(7)</code> 创建一个长度为7的空数组（注意：这是指一个有7个空位(empty)的数组，而不是由7个undefined组成的数组）。  </p><h3 id="解释-var-let-const-的区别"><a href="#解释-var-let-const-的区别" class="headerlink" title="解释 var let const 的区别"></a>解释 <code>var</code> <code>let</code> <code>const</code> 的区别</h3><p><code>var</code> :</p><ol><li>默认声明变量形式</li><li>全局作用域/函数作用域</li><li>存在变量提升</li><li>声明的全局对象同时为顶层对象的属性</li><li>可以重复声明，相当于赋值</li></ol><p><code>let</code> :</p><ol><li>块级作用域</li><li>不存在变量提升</li><li>会在当前区域形成暂时性死区</li><li>不允许重复声明</li><li><ul><li>块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了</li></ul></li></ol><p><code>const</code> :</p><ol><li>const声明一个只读的常量。一旦声明，常量的值就不能改变。</li><li>const必须在声明时初始化</li><li>块级作用域</li><li>不存在变量提升</li><li>会在当前区域形成暂时性死区</li><li>不允许重复声明</li><li>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。</li></ol><h3 id="解释-gt-箭头函数的作用"><a href="#解释-gt-箭头函数的作用" class="headerlink" title="解释 ()=&gt;{} 箭头函数的作用"></a>解释 <code>()=&gt;&#123;&#125;</code> 箭头函数的作用</h3><ol><li>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</li><li>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</li><li>不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li><li>不可以使用yield命令，因此箭头函数不能用作 Generator 函数。</li></ol><h3 id="解释-扩展运算符的作用"><a href="#解释-扩展运算符的作用" class="headerlink" title="解释 ... 扩展运算符的作用"></a>解释 <code>...</code> 扩展运算符的作用</h3><p>将一个数组转为用逗号分隔的参数序列。</p><h3 id="解释-字符串模板-的作用"><a href="#解释-字符串模板-的作用" class="headerlink" title="解释 字符串模板 的作用"></a>解释 字符串模板 的作用</h3><p>在需要将变量和字符串进行拼接时使用字符串模板写法更优雅</p><h3 id="简述JS函数柯里化是什么，有什么意义？"><a href="#简述JS函数柯里化是什么，有什么意义？" class="headerlink" title="简述JS函数柯里化是什么，有什么意义？"></a>简述JS函数柯里化是什么，有什么意义？</h3><p>柯里化是函数式编程的一个过程，在这个过程中我们能把一个带有多个参数的函数转换成一系列的嵌套函数。它返回一个新函数，这个新函数期望传入下一个参数。</p><h2 id="others"><a href="#others" class="headerlink" title="others"></a>others</h2><h3 id="解释-offsetLeft-offsetTop-等参数含义"><a href="#解释-offsetLeft-offsetTop-等参数含义" class="headerlink" title="解释 offsetLeft offsetTop 等参数含义"></a>解释 offsetLeft offsetTop 等参数含义</h3><p><code>HTMLElement.offsetLeft</code> 是一个只读属性，返回当前元素左上角相对于  <code>HTMLElement.offsetParent</code> 节点的左边界偏移的像素值。<br><code>HTMLElement.offsetTop</code> 是一个只读属性，它返回当前元素相对于其 <code>HTMLElement.offsetParent</code> 元素的顶部内边距的距离。<br><code>HTMLElement.offsetWidth</code> 是一个只读属性，返回一个元素的布局宽度。<br><code>HTMLElement.offsetHeight</code> 是一个只读属性，它返回该元素的像素高度，高度包含该元素的垂直内边距和边框，且是一个整数。  </p><h3 id="常用正则表达式如何书写？"><a href="#常用正则表达式如何书写？" class="headerlink" title="常用正则表达式如何书写？"></a>常用正则表达式如何书写？</h3><p>（手机号）（邮箱地址）（url地址）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手机号</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isPhoneAvailable</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> myreg = <span class="regexp">/^1[3,4,5,7,8]\d&#123;9&#125;$/</span>;</span><br><span class="line">    <span class="keyword">return</span> myreg.<span class="title function_">test</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 邮箱</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isMailAvailable</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> myreg = <span class="regexp">/^([\w\-\.]+)@([\w\-]+)\.([a-zA-Z]&#123;2,4&#125;)$/</span>;</span><br><span class="line">    <span class="keyword">return</span> myreg.<span class="title function_">test</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// url</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isUrlAvailable</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> myreg = <span class="regexp">/https?:\/\/[\w|\.|-]+(\.cn|\.com)[\w|\?|=|\/]*/</span>;</span><br><span class="line">    <span class="keyword">return</span> myreg.<span class="title function_">test</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么js在html尾部引入，CSS在头部引入比较合适？"><a href="#为什么js在html尾部引入，CSS在头部引入比较合适？" class="headerlink" title="为什么js在html尾部引入，CSS在头部引入比较合适？"></a>为什么js在html尾部引入，CSS在头部引入比较合适？</h3><p>网站加载的整个完整过程</p><ol><li>首先浏览器从服务器接收到html代码，然后开始解析html</li><li>构建DOM树（根据html代码自顶向下进行构建），并且在同时构建渲染树</li><li>遇到js文件加载执行，将阻塞DOM树的构建；遇到CSS文件，将阻塞渲染树的构建<br>（script标签中的defer属性：构建DOM树的过程和js文件的加载异步（并行）进行，但是js文件执行需要在DOM树构建完成之后 script标签中的async属性：构建DOM树、渲染树的过程和js文件的加载和执行异步（并行）进行）</li></ol><p>综上所述，script标签最好放在</body>标签的前面，因为放在所有body中的标签后面就不会出现网页加载时出现空白的情况，可以持续的给用户提供视觉反馈，同时在有些情况下，会降低错误的发生。<br>而CSS标签应该放在<head></head>标签之间，因为如果放在</body>标签的前面，那么当DOM树构建完成了，渲染树才构建，那么当渲染树构建完成，浏览器不得不再重新渲染整个页面，这样造成了资源的浪费。效率也不高。如果放在<head></head>之间，浏览器边构建边渲染，效率要高的多。</p><h3 id="谈谈你对前后端分离的理解？"><a href="#谈谈你对前后端分离的理解？" class="headerlink" title="谈谈你对前后端分离的理解？"></a>谈谈你对前后端分离的理解？</h3><p>https://segmentfault.com/a/1190000009329474?_ea=2038402</p><h1 id="中级（初级编程题及深入基础知识）"><a href="#中级（初级编程题及深入基础知识）" class="headerlink" title="中级（初级编程题及深入基础知识）"></a>中级（初级编程题及深入基础知识）</h1><h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><h3 id="遍历对象属性的方法有哪些？"><a href="#遍历对象属性的方法有哪些？" class="headerlink" title="遍历对象属性的方法有哪些？"></a>遍历对象属性的方法有哪些？</h3><p>（1）for…in</p><p>for…in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p><p>（2）Object.keys(obj)</p><p>Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p><p>（3）Object.getOwnPropertyNames(obj)</p><p>Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p><p>（4）Object.getOwnPropertySymbols(obj)</p><p>Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p><p>（5）Reflect.ownKeys(obj)</p><p>Reflect.ownKeys返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p><p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p><p>首先遍历所有数值键，按照数值升序排列。<br>其次遍历所有字符串键，按照加入时间升序排列。<br>最后遍历所有 Symbol 键，按照加入时间升序排列。</p><h3 id="数组的遍历方法有哪些？"><a href="#数组的遍历方法有哪些？" class="headerlink" title="数组的遍历方法有哪些？"></a>数组的遍历方法有哪些？</h3><p>遍历数组 arr</p><p>第一种: 普通 <code>for</code> 循环<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; arr.<span class="property">length</span>; j++) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>第二种: 优化版 <code>for</code> 循环<br>当数组的长度非常大时，缓存长度会带来略微的性能提升<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> len = arr.<span class="property">length</span>;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>第三种: 利用数组的 <code>forEach</code> 方法<br>forEach() 方法对数组的每个元素执行一次提供的函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>第四种: 利用 <code>for in</code> 来遍历数组的可枚举属性<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(index <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>第五种: 利用数组的 <code>map</code> 方法遍历<br>map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">map</span>((item, index, array) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>第六种: 利用 <code>for of</code> 遍历数组值<br>for…of语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>第七种: 利用数组的 <code>every</code> 方法遍历<br>every() 方法测试数组的所有元素是否都通过了指定函数的测试。<br>当返回false时会由于没有通过测试而中止，所以为了遍历，必须返回true。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">every</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>第八种: 利用数组的 <code>filter</code> 方法遍历<br>filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">filter</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>第九种: 利用数组的 <code>some</code> 方法遍历<br>some() 方法测试是否至少有一个元素通过由提供的函数实现的测试。<br>当返回true时会由于已经找到一个元素通过测试而中止，所以为了遍历，必须返回false。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">some</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>第十种: 利用数组的 <code>reduce</code> 方法遍历<br>reduce() 方法对数组中的每个元素执行一个reducer函数(升序执行)，将其结果汇总为单个返回值。<br>如果没有提供initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供initialValue，从索引0开始。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">result, item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;, initialValue);</span><br></pre></td></tr></table></figure></p><h3 id="书写sass／less-mixin的例子"><a href="#书写sass／less-mixin的例子" class="headerlink" title="书写sass／less mixin的例子"></a>书写sass／less mixin的例子</h3><blockquote><p>Saas</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$link-<span class="attribute">color</span>: blue;</span><br><span class="line">$hover-<span class="attribute">color</span>: red;</span><br><span class="line">$visited-<span class="attribute">color</span>: green;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@mixin</span> link-colors($normal, $<span class="attribute">hover</span>, $visited) &#123;</span><br><span class="line">    <span class="attribute">color</span>: $normal;</span><br><span class="line">    &amp;<span class="selector-pseudo">:hover</span> &#123; <span class="attribute">color</span>: $hover; &#125;</span><br><span class="line">    &amp;<span class="selector-pseudo">:visited</span> &#123; <span class="attribute">color</span>: $visited; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="keyword">@include</span> link-colors($link-color, $hover-color, $visited-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Less</p></blockquote><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@link-color:</span> blue;</span><br><span class="line"><span class="variable">@hover-color:</span> red;</span><br><span class="line"><span class="variable">@visited-color:</span> green;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.link-colors</span> (<span class="variable">@normal</span>:<span class="variable">@link-color</span>; <span class="variable">@hover</span>:<span class="variable">@hover-color</span>; <span class="variable">@visited</span>:<span class="variable">@visited-color</span>) &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">@normal</span>;</span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span> &#123; <span class="attribute">color</span>: <span class="variable">@hover</span>; &#125;</span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:visited</span> &#123; <span class="attribute">color</span>: <span class="variable">@visited</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="selector-class">.link-colors</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123; <span class="attribute">color</span>: blue; &#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123; <span class="attribute">color</span>: red; &#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123; <span class="attribute">color</span>: green; &#125;</span><br></pre></td></tr></table></figure><h3 id="解释Event对象-target-currentTarget-preventDefault-stopPropagation-含义"><a href="#解释Event对象-target-currentTarget-preventDefault-stopPropagation-含义" class="headerlink" title="解释Event对象 target currentTarget preventDefault() stopPropagation()含义"></a>解释Event对象 <code>target</code> <code>currentTarget</code> <code>preventDefault()</code> <code>stopPropagation()</code>含义</h3><p><code>target</code>: 触发事件的对象元素的引用<br><code>currentTarget</code>: 事件属性返回其监听器绑定事件的节点，即当前处理该事件的元素、文档或窗口。<br><code>preventDefault</code>: 该方法将通知 Web 浏览器不要执行与事件关联的默认动作（如果存在这样的动作）。<br><code>stopPropagation</code>： 终止事件在传播过程的捕获、目标处理或起泡阶段进一步传播。调用该方法后，该节点上处理该事件的处理程序将被调用，事件不再被分派到其他节点。  </p><h3 id="实现获取指定范围的随机整数"><a href="#实现获取指定范围的随机整数" class="headerlink" title="实现获取指定范围的随机整数"></a>实现获取指定范围的随机整数</h3><p><code>Math.random()</code>: 获取[0-1)范围的小数<br><code>Math.floor(num)</code>: num取整数<br>取[1-100]范围内一个随机整数值: <code>Math.floor(Math.random() * 100 + 1)</code>  </p><h3 id="解释你熟悉的js常见类库-jquery-js-zepto-js-prototype-js-backbone-js-underscore-js-axios-js-的作用"><a href="#解释你熟悉的js常见类库-jquery-js-zepto-js-prototype-js-backbone-js-underscore-js-axios-js-的作用" class="headerlink" title="解释你熟悉的js常见类库 jquery.js/zepto.js (prototype.js) backbone.js underscore.js axios.js 的作用"></a>解释你熟悉的js常见类库 jquery.js/zepto.js (prototype.js) backbone.js underscore.js axios.js 的作用</h3><p>jQuery:<br>jQuery 是一个高效、精简并且功能丰富的 JavaScript 工具库。它提供的 API 易于使用且兼容众多浏览器，这让诸如 HTML 文档遍历和操作、事件处理、动画和 Ajax 操作更加简单。<br>Zepto:<br>Zepto是一个轻量级的针对现代高级浏览器的JavaScript库， 它与jquery有着类似的api。<br>Underscore:<br>一个JavaScript实用库，提供了一整套函数式编程的实用功能，但是没有扩展任何JavaScript内置对象。它弥补了部分jQuery没有实现的功能,同时又是Backbone.js必不可少的部分。<br>Backbone:<br>Backbone.js为复杂WEB应用程序提供模型(models)、集合(collections)、视图(views)的结构。<br>Axios:<br>Axios 是一个基于 promise 的 HTTP 库,可以用在浏览器和 node.js 中。<br>…</p><h3 id="实现行内元素与块状元素的相互转换"><a href="#实现行内元素与块状元素的相互转换" class="headerlink" title="实现行内元素与块状元素的相互转换"></a>实现行内元素与块状元素的相互转换</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">display</span>: inline/block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解释CSS3动画-过渡效果-transition-transform-animation-keyframe"><a href="#解释CSS3动画-过渡效果-transition-transform-animation-keyframe" class="headerlink" title="解释CSS3动画/过渡效果 transition:transform animation:@keyframe"></a>解释CSS3动画/过渡效果 transition:transform animation:@keyframe</h3><p>transform: 定义转换<br>常用值：<br>translateX(xdeg) 沿X轴旋转x度<br>translateY(ydeg) 沿Y轴旋转y度<br>scale(x, y) 缩放 X轴放大到x倍数，Y轴放大到y倍<br>rotate(ndeg) 旋转 顺时针倾斜n角度<br>skew(x, y) 倾斜 沿X轴旋转x度，沿Y轴旋转y度</p><h3 id="解释模块化编程-及commonJS-AMD-CMD-ES6import"><a href="#解释模块化编程-及commonJS-AMD-CMD-ES6import" class="headerlink" title="解释模块化编程 及commonJS AMD CMD ES6import"></a>解释模块化编程 及commonJS AMD CMD ES6import</h3><p>模块化是指把一个复杂的系统分解到多个模块以方便编码。<br>CommonJS 是一种使用广泛的 JavaScript 模块化规范，核心思想是通过 require 方法来同步地加载依赖的其他模块，通过 module.exports 导出需要暴露的接口。 CommonJS 规范的流行得益于 Node.js 采用了这种方式，后来这种方式被引入到了网页开发中。<br>采用 CommonJS 导入及导出时的代码如下：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入</span></span><br><span class="line"><span class="keyword">const</span> moduleA = <span class="built_in">require</span>(<span class="string">&#x27;./moduleA&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = moduleA.<span class="property">someFunc</span>;</span><br></pre></td></tr></table></figure><p>CommonJS 的优点在于:  </p><ul><li>代码可复用于 Node.js 环境下并运行，例如做同构应用；</li><li>通过 NPM 发布的很多第三方模块都采用了 CommonJS 规范。</li></ul><p>CommonJS 的缺点在于:  </p><ul><li>这样的代码无法直接运行在浏览器环境下，必须通过工具转换成标准的 ES5。</li></ul><p>AMD 也是一种 JavaScript 模块化规范，与 CommonJS 最大的不同在于它采用异步的方式去加载依赖的模块。 AMD 规范主要是为了解决针对浏览器环境的模块化问题，最具代表性的实现是 requirejs。<br>采用 AMD 导入及导出时的代码如下：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 定义一个模块</span></span><br><span class="line">    <span class="title function_">define</span>(<span class="string">&#x27;module&#x27;</span>, [<span class="string">&#x27;dep&#x27;</span>], <span class="keyword">function</span>(<span class="params">dep</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">exports</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 导入和使用</span></span><br><span class="line">    <span class="built_in">require</span>([<span class="string">&#x27;module&#x27;</span>], <span class="keyword">function</span>(<span class="params"><span class="variable language_">module</span></span>) &#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>AMD 的优点在于：  </p><ul><li>可在不转换代码的情况下直接在浏览器中运行；</li><li>可异步加载依赖；</li><li>可并行加载多个依赖；</li><li>代码可运行在浏览器环境和 Node.js 环境下。</li></ul><p>AMD 的缺点在于:  </p><ul><li>JavaScript 运行环境没有原生支持 AMD，需要先导入实现了 AMD 的库后才能正常使用。</li></ul><p>ES6 模块化是欧洲计算机制造联合会 ECMA 提出的 JavaScript 模块化规范，它在语言的层面上实现了模块化。  </p><p>采用 ES6 模块化导入及导出时的代码如下：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入</span></span><br><span class="line"><span class="keyword">import</span> &#123; readFile &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="comment">// 导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ES6模块虽然是终极模块化方案，但它的缺点在于目前无法直接运行在大部分 JavaScript 运行环境下，必须通过工具转换成标准的 ES5 后才能正常运行。  </p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="试解释强缓存和协商缓存的区别"><a href="#试解释强缓存和协商缓存的区别" class="headerlink" title="试解释强缓存和协商缓存的区别"></a>试解释强缓存和协商缓存的区别</h3><p>https://www.jianshu.com/p/9c95db596df5</p><h2 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h2><h1 id="高级（框架，底层，扩展）"><a href="#高级（框架，底层，扩展）" class="headerlink" title="高级（框架，底层，扩展）"></a>高级（框架，底层，扩展）</h1><h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><h3 id="实现-define"><a href="#实现-define" class="headerlink" title="实现 define"></a>实现 define</h3><h3 id="实现-Promise-异步编程"><a href="#实现-Promise-异步编程" class="headerlink" title="实现 Promise 异步编程"></a>实现 Promise 异步编程</h3><p>Promise的解释：<br>http://bruce-xu.github.io/blogs/js/promise<br>两个优秀的Promise的实现：<br>https://github.com/bruce-xu/Promise/blob/master/Promise.js<br>https://blog.csdn.net/yibingxiong1/article/details/68075416</p><h3 id="从输入url到window-onload-结束，这中间发生了什么？（计算机网络）"><a href="#从输入url到window-onload-结束，这中间发生了什么？（计算机网络）" class="headerlink" title="从输入url到window.onload()结束，这中间发生了什么？（计算机网络）"></a>从输入url到window.onload()结束，这中间发生了什么？（计算机网络）</h3><ol><li>预处理</li><li>读取cache(强缓存)</li><li>查询DNS</li><li>建立连接</li><li>发送请求</li><li>等待响应</li><li>接收数据</li><li>读取cache(协商缓存)</li><li>处理渲染</li></ol><h3 id="为什么通常在发送数据埋点请求的时候使用的是-1x1-像素的透明-gif-图片？"><a href="#为什么通常在发送数据埋点请求的时候使用的是-1x1-像素的透明-gif-图片？" class="headerlink" title="为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？"></a>为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？</h3><ol><li>能够完成整个 HTTP 请求+响应（不需要响应内容）</li><li>触发 GET 请求之后不需要获取和处理数据、服务器也不需要发送数据</li><li>跨域友好</li><li>执行过程无阻塞</li><li>相比 XMLHttpRequest 对象发送 GET 请求，性能上更好</li><li>GIF的最低合法体积最小（最小的BMP文件需要74个字节，PNG需要67个字节，而合法的GIF，只需要43个字节）</li></ol><h3 id="前端性能优化从哪几方面入手？有哪些方法？"><a href="#前端性能优化从哪几方面入手？有哪些方法？" class="headerlink" title="前端性能优化从哪几方面入手？有哪些方法？"></a>前端性能优化从哪几方面入手？有哪些方法？</h3><ol><li>性能优化=》减少从用户输入网址到用户看到期望内容的时间</li><li>从用户输入url到 window.onload 发生了什么<ul><li>预处理 本地</li><li>读取cache 本地</li><li>查询DNS 网络</li><li>建立连接 网络</li><li>发送请求 网络</li><li>等待响应 网络</li><li>接收数据 本地</li><li>处理渲染 本地</li></ul></li><li>本地 =》 缩短渲染时间<br>网络 =》 减少请求次数 减小请求体积 加快请求速度</li><li>基本原则<ul><li>建立监控机制 （监控）</li><li>日志分析 （分析）</li><li>针对监控暴露的弱点优化 （优化）</li></ul></li><li>监控节点 window.performance.timing<ul><li>白屏时间 <code>&lt;/head&gt;</code> 结束 domLoading - fetchStart</li><li>首屏时间 首屏加载结束</li><li>用户可操作时间 DOMReady&amp;核心js加载完毕 domContentLoadedEventEnd - fetchStart</li><li>总下载时间 onload/异步渲染完毕 loadEventEnd - fetchStart</li></ul></li><li>常用的性能优化方法</li></ol><ul><li>减少http请求内容</li><li>使用cdn</li><li>添加 expires/ cache-control header</li><li>使用gzip</li><li>将css放到html顶部加载</li><li>将js放到底部加载</li><li>外部引用js &amp; css</li><li>uglify js &amp; css</li><li>避免重定向</li><li>移除重复js</li><li>配置Etags</li><li>缓存ajax数据</li><li>预先加载组件</li><li>减少dom元素个数</li><li>减少iframes</li><li>避免404错误</li><li>减少cookie大小</li><li>对于不需要cookie的组件/请求，使用单独的域名</li><li>减少dom操作</li><li>采用事件委托</li><li>减少 @import 动态导入</li><li>优化图像大小</li><li>使用css图像拼合</li><li>不要缩放图像</li><li>favicon.icon 尽量小&amp;缓存</li><li>组件小于25k</li><li>避免空image src</li><li>采用 渐进式jpeg</li></ul><h3 id="解释-SSR、SEO、SPA"><a href="#解释-SSR、SEO、SPA" class="headerlink" title="解释 SSR、SEO、SPA"></a>解释 SSR、SEO、SPA</h3><p>SSR: Server side render 服务器渲染<br>SEO: Search engine optimize 搜索引擎优化<br>SPA: Single page application 单页面应用</p><h2 id="vue相关"><a href="#vue相关" class="headerlink" title="vue相关"></a>vue相关</h2><h2 id="react相关"><a href="#react相关" class="headerlink" title="react相关"></a>react相关</h2><h2 id="Webpack相关"><a href="#Webpack相关" class="headerlink" title="Webpack相关"></a>Webpack相关</h2><h2 id="node相关"><a href="#node相关" class="headerlink" title="node相关"></a>node相关</h2><p>框架：express koa</p><p>具体请查阅 <a href="https://github.com/ElemeFE/node-interview/tree/master/sections/zh-cn">node-interview</a></p><h2 id="shell相关"><a href="#shell相关" class="headerlink" title="shell相关"></a>shell相关</h2><p>具体请查阅 <a href="https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md">命令行的艺术</a></p><h2 id="git相关"><a href="#git相关" class="headerlink" title="git相关"></a>git相关</h2><p>具体请查阅<a href="https://git-scm.com/book/zh/v2">Pro Git book</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="什么是material-design？"><a href="#什么是material-design？" class="headerlink" title="什么是material design？"></a>什么是material design？</h3><p>具体请查阅<a href="http://www.google.com/design/spec/material-design/introduction.html">material-design</a><br>中文版：<a href="http://wiki.jikexueyuan.com/project/material-design/animation/responsive-interaction.html">material-design</a></p><h2 id="Database-数据库"><a href="#Database-数据库" class="headerlink" title="Database(数据库)"></a>Database(数据库)</h2><h3 id="解释数据库事务的4个基本特征ACID"><a href="#解释数据库事务的4个基本特征ACID" class="headerlink" title="解释数据库事务的4个基本特征ACID"></a>解释数据库事务的4个基本特征ACID</h3><p>Atomic 原子性<br>Consistency 一致性<br>Isolation 隔离性<br>Duration 持久性</p><h3 id="解释数据库隔离级别"><a href="#解释数据库隔离级别" class="headerlink" title="解释数据库隔离级别"></a>解释数据库隔离级别</h3><p>Read uncommitted 未提交读 =&gt; 脏读，不可重复读，幻读<br>Read commited 读写提交 =&gt; 不可重复读，幻读<br>Repeatable read 可重复读 =&gt; 幻读<br>Serializable 串行化</p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端相关语言框架与库</title>
      <link href="/blog/2018/07/13/FE-%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3%E8%AF%AD%E8%A8%80%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%BA%93/"/>
      <url>/blog/2018/07/13/FE-%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3%E8%AF%AD%E8%A8%80%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>收录了一些前端工程师需要了解的语言、框架、工具，进行了简单的解释，并收录了官网、Github地址及一些中文学习网站。</p><h1 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h1><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>超文本标记语言（HyperText Markup Language）是一种简单的、由不同元素组成的标记语言，它定义了网页内容的含义和结构。最新的标准为 HTML5 。<br>官网: https://html.spec.whatwg.org/multipage/<br>Github: https://github.com/whatwg/html</p><span id="more"></span><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>层叠样式表（Cascading Style Sheets）是一种样式表语言，用来描述 HTML 或 XML（包括如 SVG、MathML、XHTML 之类的 XML 分支语言）文档的呈现。最新的标准为 CSS3 。<br>官网: https://www.w3.org/Style/CSS/#specs<br>Github: https://github.com/topics/css</p><h2 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h2><p>JavaScript（又称 ECMAScript）是一种函数优先的、轻量级的、解释型或即时编译型编程语言。当前最被广泛使用的版本为 ES6（也即 ES2015），从2015年（ES2015）开始，每年更新一个版本添加上新的特性。<br>官网:<br>http://www.ecma-international.org/publications/standards/Ecma-262.htm<br>中文学习网站:<br>https://developer.mozilla.org/zh-CN/docs/JavaScript<br>https://wangdoc.com/javascript/index.html<br>http://www.w3school.com.cn/js/<br>http://www.runoob.com/js/js-tutorial.html<br>https://developer.mozilla.org/zh-CN/docs/Web/JavaScript</p><h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><p>TypeScript 是由 Microsoft 开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。<br>官网: http://www.typescriptlang.org<br>Github: https://github.com/Microsoft/TypeScript<br>中文学习网站:<br>https://www.tslang.cn/<br>https://typescript.bootcss.com/</p><h2 id="CoffeeScript"><a href="#CoffeeScript" class="headerlink" title="CoffeeScript"></a>CoffeeScript</h2><p>CoffeeScript 是一门将类 Ruby 语言编译到 JavaScript 的小巧编程语言。<br>官网: http://coffeescript.org<br>Github: https://github.com/jashkenas/coffeescript<br>中文学习网站: http://coffee-script.org/</p><h2 id="PureScript"><a href="#PureScript" class="headerlink" title="PureScript"></a>PureScript</h2><p>PureScript 是一款编译为 JavaScript 的强类型编程语言，使用 Haskell 开发。<br>官网: https://www.purescript.org<br>Github: https://github.com/purescript/purescript</p><h2 id="Elm"><a href="#Elm" class="headerlink" title="Elm"></a>Elm</h2><p>Elm 是一款用来开发 web 应用的函数式编程语言，使用 Haskell 开发。<br>官网: https://elm-lang.org<br>Github: https://github.com/elm</p><h2 id="ReScript"><a href="#ReScript" class="headerlink" title="ReScript"></a>ReScript</h2><p>ReScript 是一款强类型的编程语言，可以编译成高效且可读的 JavaScript 代码，使用 OCaml 开发。<br>官网: https://rescript-lang.org<br>Github: https://github.com/rescript-lang</p><h2 id="Dart"><a href="#Dart" class="headerlink" title="Dart"></a>Dart</h2><p>Dart 是一款快速的、针对客户端优化了的跨平台编程语言。由 Google 开发。</p><p>官网: https://dart.dev<br>Github: https://github.com/dart-lang<br>中文学习网站:<br>https://www.dartcn.com/<br>https://dart.cn/</p><h2 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a>Rust</h2><p>一款高效高可用的编程语言。<br>官网: https://www.rust-lang.org<br>Github: https://github.com/rust-lang/rust</p><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><p>React 是一个声明性的、高效的、灵活的 JavaScript 框架，用于构建用户界面。由 Facebook 开发。</p><p>官网: https://reactjs.org<br>Github: https://github.com/facebook/react<br>中文学习网站:<br>https://www.reactjscn.com/<br>http://www.runoob.com/react/react-tutorial.html</p><h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><p>一款轻量级的状态管理库，只有2kB。<br>官网: https://redux.js.org/<br>Github: https://github.com/reduxjs/redux<br>中文官网: https://cn.redux.js.org/<br>中文学习网站: https://www.redux.org.cn/</p><h4 id="Redux-Toolkit"><a href="#Redux-Toolkit" class="headerlink" title="Redux Toolkit"></a>Redux Toolkit</h4><p>Redux 官方提供的 Redux 开发效率工具集<br>官网: https://redux-toolkit.js.org/<br>Github: https://github.com/reduxjs/redux-toolkit<br>中文官网（翻译不完整）: https://cn.redux-toolkit.js.org/</p><h4 id="React-Redux"><a href="#React-Redux" class="headerlink" title="React Redux"></a>React Redux</h4><p>官方的 React 对 Redux 绑定库<br>官网： https://react-redux.js.org/<br>Github: https://github.com/reduxjs/react-redux<br>中文官网: https://cn.react-redux.js.org/</p><h4 id="redux-saga"><a href="#redux-saga" class="headerlink" title="redux-saga"></a>redux-saga</h4><p>一款直观的 Redux 副作用管理器。<br>官网: https://redux-saga.js.org<br>Github: https://github.com/redux-saga/redux-saga</p><h3 id="MobX"><a href="#MobX" class="headerlink" title="MobX"></a>MobX</h3><p>一款简单的、可伸缩的状态管理库。<br>官网: https://mobx.js.org<br>Github: https://github.com/mobxjs/mobx</p><h3 id="zustand"><a href="#zustand" class="headerlink" title="zustand"></a>zustand</h3><p>一款小巧快速可扩展的状态管理库。<br>官网: https://zustand-demo.pmnd.rs<br>Github: https://github.com/pmndrs/zustand</p><h3 id="react-router"><a href="#react-router" class="headerlink" title="react-router"></a>react-router</h3><p>一款基于 React 的路由管理库。<br>Github: https://github.com/remix-run/react-router</p><h3 id="create-react-app"><a href="#create-react-app" class="headerlink" title="create-react-app"></a>create-react-app</h3><p>React 脚手架工具<br>官网: https://create-react-app.dev<br>Github: https://github.com/facebook/create-react-app</p><h3 id="SWR"><a href="#SWR" class="headerlink" title="SWR"></a>SWR</h3><p>React Hooks 库，专注于数据获取。<br>官网: https://swr.vercel.app/<br>Github: https://github.com/vercel/swr</p><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>Vue.js 是一个渐进式的的 JavaScript 框架，用来构建用户界面。由 Evan You（尤雨溪）开发。<br>常用的 Vue UI 库有 Element UI、Vuetify、iview、Vue Bootstrap、Vue Material、Buefy、Quasar等。<br>常用的Vue 移动 UI库有 vux、mint-ui、vant等。<br>cli <a href="https://github.com/vuejs/vue-cli">vue-cli</a><br>状态管理库 <a href="https://github.com/vuejs/vuex">vuex</a><br>前端路由库 <a href="https://github.com/vuejs/vue-router">vue-router</a><br>小程序开发框架 <a href="https://github.com/Meituan-Dianping/mpvue">mpvue</a>、<a href="https://github.com/dcloudio/uni-app">uni-app</a><br>官网: https://cn.vuejs.org/v2/guide/<br>Github: https://github.com/vuejs/vue<br>官方学习网站: https://cn.vuejs.org/index.html</p><h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h3><p>Vue 的单页面应用路由。<br>Github: https://github.com/vuejs/vue-router</p><h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><p>Vue 的大规模状态管理库。<br>Github: https://github.com/vuejs/vuex</p><h3 id="Pinia"><a href="#Pinia" class="headerlink" title="Pinia"></a>Pinia</h3><p>Pinia 是一款直观、类型安全、存储灵活的 Vue 状态管理库。<br>官网: https://pinia.vuejs.org/<br>Github: https://github.com/vuejs/pinia</p><h3 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a>vue-cli</h3><p>Vue 的项目脚手架工具。<br>Github: https://github.com/vuejs/vue-cli</p><h3 id="vue-loader"><a href="#vue-loader" class="headerlink" title="vue-loader"></a>vue-loader</h3><p>Vue 的单页面组件文件 webpack loader。<br>Github: https://github.com/vuejs/vue-loader</p><h2 id="Angular"><a href="#Angular" class="headerlink" title="Angular"></a>Angular</h2><p>增强 Web 应用程序的HTML框架。由 Google 开发。<br>官网: https://angularjs.org<br>Github: https://github.com/angular/angular.js<br>中文学习网站: https://www.runoob.com/angularjs/angularjs-tutorial.html</p><h2 id="Svelte"><a href="#Svelte" class="headerlink" title="Svelte"></a>Svelte</h2><p>一款编译型 JavaScript 框架。<br>官网: https://svelte.dev<br>Github: https://github.com/sveltejs/svelte</p><h3 id="kit"><a href="#kit" class="headerlink" title="kit"></a>kit</h3><p>Svelte 应用编译工具<br>官网: https://kit.svelte.dev<br>Github: https://github.com/sveltejs/kit</p><h2 id="Cycle-js"><a href="#Cycle-js" class="headerlink" title="Cycle.js"></a>Cycle.js</h2><p>一款函数式的和响应式的 JavaScript 框架。<br>官网: https://cycle.js.org<br>Github: https://github.com/cyclejs/cyclejs</p><h2 id="Alpine-js"><a href="#Alpine-js" class="headerlink" title="Alpine.js"></a>Alpine.js</h2><p>Alpine.js 是一款通过扩展HTML属性实现响应式和声明式的 JavaScript 框架。<br>官网: https://alpinejs.dev<br>Github: https://github.com/alpinejs/alpine</p><h2 id="Polymer"><a href="#Polymer" class="headerlink" title="Polymer"></a>Polymer</h2><p>Polymer 是一款 web 框架，用来构建可重用的 Web 组件（Web Components）。由 Google 发布，目前已处于维护模式，不再开发新的功能。<br>官网: https://polymer-library.polymer-project.org<br>Github: https://github.com/Polymer/polymer</p><h2 id="Lit"><a href="#Lit" class="headerlink" title="Lit"></a>Lit</h2><p>Lit 是一个轻量级的库，用于构建快速、轻量级的 web 组件。由 Google 发布，属于 Polymer 的替代品。<br>官网: https://lit.dev<br>Github: https://github.com/lit/lit</p><h2 id="SolidJS"><a href="#SolidJS" class="headerlink" title="SolidJS"></a>SolidJS</h2><p>SolidJS 是一个用于构建用户界面的声明性、高效和灵活的 JavaScript 框架。<br>官网: https://www.solidjs.com/<br>Github: https://github.com/solidjs/solid</p><h2 id="Stimulus"><a href="#Stimulus" class="headerlink" title="Stimulus"></a>Stimulus</h2><p>Stimulus 是一个轻量级的 Javascript 框架，聚焦于 HTML 元素与 Javascript 对象的绑定上。由 Basecamp 公司开发。<br>官网: https://stimulus.hotwired.dev/<br>Github: https://github.com/hotwired/stimulus</p><h2 id="Stencil"><a href="#Stencil" class="headerlink" title="Stencil"></a>Stencil</h2><p>Stencil 是一个简单的编译器，用于生成 Web 组件和 生成静态站点的渐进式 Web 应用。<br>官网: https://stenciljs.com<br>Github: https://github.com/ionic-team/stencil</p><h2 id="Inferno"><a href="#Inferno" class="headerlink" title="Inferno"></a>Inferno</h2><p>Inferno 是一款类 React、性能优秀的 JavaScript 框架。<br>官网: https://infernojs.org<br>Github: https://github.com/infernojs/inferno</p><h2 id="Preact"><a href="#Preact" class="headerlink" title="Preact"></a>Preact</h2><p>Preact 是一个只有 3kB 大小的 React 替代框架，拥有与 React 相似的 API、组件和虚拟 DOM。<br>官网: https://preactjs.com<br>Github: https://github.com/developit/preact<br>中文学习网站:<br>https://preactjs.com<br>https://preact.bootcss.com</p><h2 id="htmx"><a href="#htmx" class="headerlink" title="htmx"></a>htmx</h2><p>htmx 允许用户在 HTML 中使用 AJAX、CSS 、WebSockets 和服务器推送。通过使用 htmx 框架添加的自定义 HTML 属性，用户可以使用超文本语言直接构建现代用户界面应用。<br>官网: https://htmx.org<br>Github: https://github.com/bigskysoftware/htmx</p><h2 id="turbo"><a href="#turbo" class="headerlink" title="turbo"></a>turbo</h2><p>turbo 是一款无需编写 javascript 的单页应用框架。<br>官网: https://turbo.hotwired.dev<br>Github: https://github.com/hotwired/turbo</p><h2 id="Dojo"><a href="#Dojo" class="headerlink" title="Dojo"></a>Dojo</h2><p>Dojo 是一款基于 Typescript 开发的前端框架。<br>官网: https://dojo.io<br>Github: https://github.com/dojo/framework</p><h2 id="Knockout"><a href="#Knockout" class="headerlink" title="Knockout"></a>Knockout</h2><p>Knockout 是一款 Javascript MVVM 框架，易于创建丰富的用户界面。<br>官网: https://knockoutjs.com/<br>Github: https://github.com/knockout/knockout</p><h2 id="Ember-js"><a href="#Ember-js" class="headerlink" title="Ember.js"></a>Ember.js</h2><p>一款 JavaScript框架。<br>官网: https://emberjs.com<br>Github: https://github.com/emberjs/ember.js</p><h2 id="Mithril"><a href="#Mithril" class="headerlink" title="Mithril"></a>Mithril</h2><p>Mithril 是一个小巧的现代化的 JavaScript 框架，用于构建单页面应用.<br>官网: https://mithril.js.org<br>Github: https://github.com/MithrilJS/mithril.js<br>中文学习网站: https://www.mithriljs.net</p><h2 id="Marko"><a href="#Marko" class="headerlink" title="Marko"></a>Marko</h2><p>Marko 是一款声明式的基于 HTML 的框架。<br>官网: https://markojs.com/<br>Github: https://github.com/marko-js/marko</p><h2 id="Aurelia"><a href="#Aurelia" class="headerlink" title="Aurelia"></a>Aurelia</h2><p>Aurelia是一款用来构建浏览器移动桌面应用的现代前端 Javascript 框架。<br>官网: https://www.auerlia.io<br>Github: https://github.com/aurelia/framework</p><h2 id="Choo"><a href="#Choo" class="headerlink" title="Choo"></a>Choo</h2><p>一款函数式编程框架，只有4kb。<br>官网: https://choo.io<br>Github: https://github.com/choojs/choo</p><h2 id="San"><a href="#San" class="headerlink" title="San"></a>San</h2><p>一款高性能、小体积、高兼容性的 mvvm 框架<br>官网: https://baidu.github.io/san/<br>Github: https://github.com/baidu/san</p><h2 id="Next-js"><a href="#Next-js" class="headerlink" title="Next.js"></a>Next.js</h2><p>基于 React 的服务端渲染 web 应用框架。<br>官网: https://nextjs.org<br>Github: https://github.com/zeit/next.js</p><h2 id="Nuxt-js"><a href="#Nuxt-js" class="headerlink" title="Nuxt.js"></a>Nuxt.js</h2><p>基于 Vue 的服务端渲染 web 应用框架。<br>官网: https://nuxtjs.org<br>Github: https://github.com/nuxt/nuxt.js</p><h2 id="Remix"><a href="#Remix" class="headerlink" title="Remix"></a>Remix</h2><p>全栈 web 应用框架<br>官网: https://remix.run<br>Github: https://github.com/remix-run/remix</p><h2 id="Astro"><a href="#Astro" class="headerlink" title="Astro"></a>Astro</h2><p>采用 Island 架构，适合轻交互重内容的 web 应用框架<br>官网: https://astro.build<br>Github: https://github.com/withastro/astro</p><h2 id="dva"><a href="#dva" class="headerlink" title="dva"></a>dva</h2><p>dva 是一款基于 redux、redux-saga 和 react-router 的轻量级前端框架（受到 Elm 和 Choo 启发）。由 Alibaba 开发。<br>官网: https://dvajs.com<br>Github: https://github.com/dvajs/dva</p><h1 id="编译构建工具"><a href="#编译构建工具" class="headerlink" title="编译构建工具"></a>编译构建工具</h1><h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><p>Webpack 是一款前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则转换并打包成符合生产环境部署的前端资源。<br>官网: https://webpack.js.org<br>Github: https://github.com/webpack/webpack<br>中文学习网站: https://www.webpackjs.com/concepts<br>学习文档:<a href="/blog/2021/01/19/FE-webpack小抄/">webpack小抄</a></p><h2 id="Rollup"><a href="#Rollup" class="headerlink" title="Rollup"></a>Rollup</h2><p>Rollup 是一个 JavaScript 模块打包器，可以将小块代码编译成大块复杂的代码，例如库或应用程序。支持按需打包。<br>官网: https://rollupjs.org<br>Github: https://github.com/rollup/rollup<br>中文学习网站:<br>http://www.rollupjs.com/</p><h2 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h2><p>前端编译构建工具，基于 Rollup 进行打包，基于 esbuild 进行代码编译。<br>官网: https://vitejs.dev/<br>Github: https://github.com/vitejs/vite<br>官方中文网站: https://cn.vitejs.dev/</p><h2 id="Gulp"><a href="#Gulp" class="headerlink" title="Gulp"></a>Gulp</h2><p>JavaScript自动化工作流构建工具，使用流式方法来进行打包。<br>官网: https://gulpjs.com<br>Github: https://github.com/gulpjs/gulp<br>中文学习网站: https://www.gulpjs.com.cn</p><h2 id="Grunt"><a href="#Grunt" class="headerlink" title="Grunt"></a>Grunt</h2><p>JavaScript任务自动化构建工具，通过配置来进行打包。<br>官网: https://gruntjs.com<br>Github: https://github.com/gruntjs/grunt<br>中文学习网站: http://www.gruntjs.net</p><h2 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h2><p>Parcel 是一个 web 应用打包工具, 与其它工具的区别在于开发者的使用体验。它利用多核处理器提供了极快的速度, 并且不需要任何配置。采用模块化的思想进行打包。<br>官网: https://parceljs.org<br>Github: https://github.com/parcel-bundler/parcel<br>中文学习网站:<br>https://www.parceljs.cn/getting_started.html<br>http://www.css88.com/doc/parcel/<br>http://www.parceljs.io</p><h2 id="Turbo"><a href="#Turbo" class="headerlink" title="Turbo"></a>Turbo</h2><p>Turbo 是一个针对 Javascript 和 Typescript 进行了优化的打包和构建工具，使用 Rust 编写。<br>官网: https://turbo.build<br>Github: https://github.com/vercel/turbo</p><h2 id="esbuild"><a href="#esbuild" class="headerlink" title="esbuild"></a>esbuild</h2><p>一款高性能的 Javascript 打包工具，采用 go 编写。<br>官网: https://esbuild.github.io<br>Github: https://github.com/evanw/esbuild</p><h2 id="Snowpack"><a href="#Snowpack" class="headerlink" title="Snowpack"></a>Snowpack</h2><p>Snowpack 是一款快速的前端编译工具，2022.4.20停止维护。<br>官网: https://www.snowpack.dev/<br>Github: https://github.com/FredKSchott/snowpack</p><h2 id="Browerify"><a href="#Browerify" class="headerlink" title="Browerify"></a>Browerify</h2><p>Browerify 可以使得在浏览器端使用 <code>require(&#39;modules&#39;)</code> 引入模块。<br>官网: http://browserify.org/<br>Github: https://github.com/browserify/browserify</p><h2 id="WMR"><a href="#WMR" class="headerlink" title="WMR"></a>WMR</h2><p>WMR 是一款轻量级的开发工具，由 preactjs 团队提供。<br>官网: https://wmr.dev/<br>Github: https://github.com/preactjs/wmr</p><h1 id="工具库"><a href="#工具库" class="headerlink" title="工具库"></a>工具库</h1><h2 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h2><p>jQuery 是一个高效、精简并且功能丰富的 JavaScript 工具库。它提供的 API 易于使用且兼容众多浏览器，这让诸如 HTML 文档遍历和操作、事件处理、动画和 Ajax 操作更加简单。<br>官网: https://jquery.com<br>Github: https://github.com/jquery/jquery<br>中文学习文档: https://www.jquery123.com</p><h2 id="Zepto"><a href="#Zepto" class="headerlink" title="Zepto"></a>Zepto</h2><p>Zepto 是一个轻量级的、针对现代高级浏览器的JavaScript 工具库，它兼容 jQuery 的 API 。<br>官网: http://zeptojs.com<br>Github: https://github.com/madrobby/zepto<br>中文学习文档: https://zeptojs.bootcss.com</p><h2 id="Lodash"><a href="#Lodash" class="headerlink" title="Lodash"></a>Lodash</h2><p>Lodash 是一个一致性、模块化、高性能的 JavaScript 实用工具库。<br>官网: https://lodash.com<br>Github: https://github.com/lodash/lodash<br>https://www.lodashjs.com</p><h2 id="Underscore"><a href="#Underscore" class="headerlink" title="Underscore"></a>Underscore</h2><p>Underscore 是一个JavaScript实用库，提供了一整套函数式编程的实用功能，但是没有扩展任何JavaScript内置对象。<br>官网: http://underscorejs.org<br>Github: https://github.com/jashkenas/underscore<br>http://www.css88.com/doc/underscore/</p><h1 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h1><h2 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h2><p>Bootstrap 是流行的 HTML、CSS 和 JS 框架，用于开发响应式布局、移动设备优先的 WEB 项目。<br>官网: http://getbootstrap.com<br>Github: https://github.com/twbs/bootstrap<br>中文学习网站:<br>http://www.bootcss.com<br>https://v3.bootcss.com</p><h2 id="Semantic-UI"><a href="#Semantic-UI" class="headerlink" title="Semantic UI"></a>Semantic UI</h2><p>一款UI框架，支持 React, Angular, Meteor, and Ember 框架。<br>官网: http://www.semantic-ui.com<br>Github: https://github.com/Semantic-Org/Semantic-UI</p><h2 id="Ant-Design"><a href="#Ant-Design" class="headerlink" title="Ant Design"></a>Ant Design</h2><p>一款企业级的 UI设计 与 React UI 组件库，风格偏向中后台产品，由蚂蚁金服提供。<br>官网: https://ant.design<br>Github: https://github.com/ant-design/ant-design<br>中文学习网站: https://ant.design/index-cn</p><h2 id="Material-UI"><a href="#Material-UI" class="headerlink" title="Material-UI"></a>Material-UI</h2><p>符合 Material Design 的 React 组件库。<br>官网: https://material-ui.com<br>Github: https://github.com/mui-org/material-ui</p><h2 id="Vuetify"><a href="#Vuetify" class="headerlink" title="Vuetify"></a>Vuetify</h2><p>符合 Material Design 的 Vue 组件库。<br>官网: https://vuetifyjs.com<br>Github: https://github.com/vuetifyjs/vuetify<br>中文官网: https://vuetifyjs.com/zh-Hans/</p><h2 id="Element-UI"><a href="#Element-UI" class="headerlink" title="Element-UI"></a>Element-UI</h2><p>基于 Vue2.0 的 UI组件库。<br>官网: https://element.eleme.io<br>Github: https://github.com/ElemeFE/element</p><h2 id="Quasar"><a href="#Quasar" class="headerlink" title="Quasar"></a>Quasar</h2><p>Quasar 是一款基于 Vue.js 的 UI 组件库，支持桌面和移动端。<br>官网: https://quasar.dev/<br>Github: https://github.com/quasarframework/quasar<br>中文学习网站: http://www.quasarchs.com/</p><h2 id="iView"><a href="#iView" class="headerlink" title="iView"></a>iView</h2><p>基于 Vue 的 UI组件库。<br>官网: http://iview.talkingdata.com<br>Github: https://github.com/iview/iview</p><h2 id="Layui"><a href="#Layui" class="headerlink" title="Layui"></a>Layui</h2><p>Layui 是一款采用自身模块规范编写的前端 UI 框架。<br>官网: https://www.layui.com<br>Github: https://github.com/sentsin/layui</p><h1 id="Javascript-内核-amp-运行时"><a href="#Javascript-内核-amp-运行时" class="headerlink" title="Javascript 内核 &amp; 运行时"></a>Javascript 内核 &amp; 运行时</h1><h2 id="ChakraCore"><a href="#ChakraCore" class="headerlink" title="ChakraCore"></a>ChakraCore</h2><p>Micosoft 开发的 Javascript 引擎，被用于 Micosoft Edge 浏览器中。<br>Github: https://github.com/Microsoft/ChakraCore</p><h2 id="JavaScriptCore"><a href="#JavaScriptCore" class="headerlink" title="JavaScriptCore"></a>JavaScriptCore</h2><p>Apple 开发的开源 JavaScript 引擎。Safari 浏览器的内在引擎。<br>Github: https://github.com/WebKit/webkit/tree/master/Source/JavaScriptCore</p><h2 id="SpiderMonkey"><a href="#SpiderMonkey" class="headerlink" title="SpiderMonkey"></a>SpiderMonkey</h2><p>Mozilla 使用C/C++编写的 JavaScript 引擎。它被用于包括 Firefox 在内的多个 Mozilla 产品中。<br>官网: https://developer.mozilla.org/zh-CN/docs/Mozilla/Projects/SpiderMonkey/Releases</p><h2 id="v8"><a href="#v8" class="headerlink" title="v8"></a>v8</h2><p>Google 开发的开源 JavaScript 引擎，以高性能著称。被用于Chrome浏览器。<br>Github: https://github.com/v8/v8</p><h2 id="Rhino"><a href="#Rhino" class="headerlink" title="Rhino"></a>Rhino</h2><p>是一个完全使用 Java 语言编写的开源 JavaScript 实现，由 Mozilla 开发。是J2SE 6上的默认 Java 脚本化引擎。<br>Github: https://github.com/mozilla/rhino</p><h2 id="JerryScript"><a href="#JerryScript" class="headerlink" title="JerryScript"></a>JerryScript</h2><p>JerryScript 是一款轻量级的 JavaScript 引擎，主要用于限制资源的微型设备。由三星开发。<br>Github: https://github.com/jerryscript-project/jerryscript</p><h2 id="kjs"><a href="#kjs" class="headerlink" title="kjs"></a>kjs</h2><p>运行于 KDE 的 JavaScript 引擎。采用了 LGPL-2.1 License。<br>Github: https://github.com/KDE/kjs</p><h2 id="Hermes"><a href="#Hermes" class="headerlink" title="Hermes"></a>Hermes</h2><p>为运行 React Native 进行了优化的 JavaScript 引擎。由 facebook 提供。<br>Github: https://github.com/facebook/hermes</p><h2 id="Chromium"><a href="#Chromium" class="headerlink" title="Chromium"></a>Chromium</h2><p>Chromium 是一款基于 v8 的开源浏览器。<br>官网: https://chromium.googlesource.com/chromium/<br>Github: https://github.com/chromium/chromium</p><h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。<br>官网: https://nodejs.org<br>Github: https://github.com/nodejs/node<br>中文学习网站: http://nodejs.cn<br>书籍:<br>https://github.com/alsotang/node-lessons<br><a href="http://book.douban.com/subject/25768396/">《深入浅出Node.js》</a></p><h3 id="pm2"><a href="#pm2" class="headerlink" title="pm2"></a>pm2</h3><p>基于 Node.js 的一款自带负载均衡的进程管理器<br>官网: https://pm2.keymetrics.io<br>Github: https://github.com/Unitech/pm2</p><h2 id="Deno"><a href="#Deno" class="headerlink" title="Deno"></a>Deno</h2><p>Deno 是一款运行于 Chrome v8 引擎的采用 Rust 编写的 JavaScript/TypeScript 运行环境<br>官网: https://deno.land<br>Github: https://github.com/denoland/deno</p><h2 id="bun"><a href="#bun" class="headerlink" title="bun"></a>bun</h2><p>bun 是一款集成 打包器、编译器、构建工具、包管理器的 JavaScript 运行环境。<br>官网: https://bun.sh/<br>Github: https://github.com/Jarred-Sumner/bun</p><h1 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a>测试框架</h1><h2 id="Puppeteer"><a href="#Puppeteer" class="headerlink" title="Puppeteer"></a>Puppeteer</h2><p>Puppeteer 是一款通过 <a href="https://chromedevtools.github.io/devtools-protocol/">DevTools</a> 协议控制 Chrome 或 Chrominm 的 js 库，它提供了一些高度封装的API，常用来做 UI 自动化测试。<br>Github: https://github.com/puppeteer/puppeteer</p><h2 id="Cypress"><a href="#Cypress" class="headerlink" title="Cypress"></a>Cypress</h2><p>UI 自动化测试框架<br>Github: https://github.com/cypress-io/cypress</p><h2 id="Nightwatch"><a href="#Nightwatch" class="headerlink" title="Nightwatch"></a>Nightwatch</h2><p>自动化端到端测试框架，基于 Node.js 使用 W3C Webdrivers（Selenium）<br>官网: https://nightwatchjs.org<br>Github: https://github.com/nightwatchjs/nightwatch</p><h2 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h2><p>浏览器自动化框架，封装了大量工具和库。<br>官网: https://www.selenium.dev<br>Github: https://github.com/SeleniumHQ/selenium</p><h2 id="Mocha"><a href="#Mocha" class="headerlink" title="Mocha"></a>Mocha</h2><p>一款简单可扩展的js测试框架，可在 Node.js 和 浏览器 环境中测试。<br>官网: https://mochajs.org<br>Github: https://github.com/mochajs/mocha</p><h2 id="Jest"><a href="#Jest" class="headerlink" title="Jest"></a>Jest</h2><p>javascript 测试解决方案，由 facebook 开源。<br>官网: https://jestjs.io<br>Github: https://github.com/facebook/jest</p><h2 id="AVA"><a href="#AVA" class="headerlink" title="AVA"></a>AVA</h2><p>一款 Nodejs 测试运行器<br>Github: https://github.com/avajs/ava</p><h2 id="Tape"><a href="#Tape" class="headerlink" title="Tape"></a>Tape</h2><p><a href="https://npm-stat.com/charts.html?package=tape"></a><br>一款浏览器和 Nodejs 的测试框架<br>Github: https://github.com/substack/tape</p><h1 id="服务器框架"><a href="#服务器框架" class="headerlink" title="服务器框架"></a>服务器框架</h1><h2 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h2><p>Express是一个流行的Node.js web开发框架。<br>官网: http://expressjs.com<br>Github: https://github.com/expressjs/express<br>中文学习网站: http://www.expressjs.com.cn/</p><h2 id="Koa"><a href="#Koa" class="headerlink" title="Koa"></a>Koa</h2><p>使用ES6 async 方法来构建的有表现力的Node.js web开发框架。<br>官网: https://koajs.com<br>Github: https://github.com/koajs/koa<br>中文学习网站: https://koa.bootcss.com</p><h2 id="Fastify"><a href="#Fastify" class="headerlink" title="Fastify"></a>Fastify</h2><p>Fastify是一个Node.js web开发框架，注重于以最少的开销和强大的插件架构提供最佳的开发人员体验<br>Github: https://github.com/fastify/fastify</p><h2 id="Nest"><a href="#Nest" class="headerlink" title="Nest"></a>Nest</h2><p>一款渐进式 Node.js web开发框架，用于构建高效、可扩展的服务器端应用程序，使用 Typescript 开发，支持面向对象编程(OOP)，函数式编程(FP)及函数交互式编程(FRP)，可以基于 Express 或 Fastify 扩展<br>官网: https://nestjs.com<br>Github: https://github.com/nestjs/nest<br>中文学习网站: https://docs.nestjs.cn</p><h2 id="Egg"><a href="#Egg" class="headerlink" title="Egg"></a>Egg</h2><p>基于 Node.js 与 Koa 的企业级web开发框架，由阿里巴巴开发。<br>官网: https://eggjs.org<br>Github: https://github.com/eggjs/egg<br>中文学习网站: https://eggjs.org/zh-cn/</p><h1 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h1><h2 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h2><p>一款快速、可靠、安全的依赖管理工具。<br>官网: https://yarnpkg.com<br>Github: https://github.com/yarnpkg/yarn<br>中文学习网站: https://yarn.bootcss.com</p><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>最流行的 Javascript 包依赖管理工具。<br>官网: https://npm.community<br>Github: https://github.com/npm/cli<br>中文学习网站: https://www.npmjs.com.cn</p><p>有关常用server npm库，可查看 <a href="/blog/2019/08/12/node-server常用npm库/">常用npm库</a></p><h2 id="nvm"><a href="#nvm" class="headerlink" title="nvm"></a>nvm</h2><p>node版本管理器<br>Github: https://github.com/nvm-sh/nvm</p><h1 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h1><h2 id="Standard-Style-Guide"><a href="#Standard-Style-Guide" class="headerlink" title="Standard Style Guide"></a>Standard Style Guide</h2><p>js 样式规范&amp;代码自动对齐规范<br>官网: https://standardjs.com<br>Github: https://github.com/standard/standard</p><h2 id="Airbnb-JavaScript-Style-Guide"><a href="#Airbnb-JavaScript-Style-Guide" class="headerlink" title="Airbnb JavaScript Style Guide"></a>Airbnb JavaScript Style Guide</h2><p>Airbnb js样式规范<br>Github: https://github.com/airbnb/javascript</p><h2 id="Google-Style-Guide"><a href="#Google-Style-Guide" class="headerlink" title="Google Style Guide"></a>Google Style Guide</h2><p>Google js样式规范<br>官网: https://google.github.io/styleguide/jsguide.html<br>Github: https://github.com/google/eslint-config-google</p><h2 id="semver"><a href="#semver" class="headerlink" title="semver"></a>semver</h2><p>语义化版本规范(Nodejs包的版本规范)<br>官网: https://semver.org<br>Github: https://github.com/semver/semver</p><h1 id="编译与格式化工具-库"><a href="#编译与格式化工具-库" class="headerlink" title="编译与格式化工具/库"></a>编译与格式化工具/库</h1><h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><p>将特定Javascript先进语法进行编译的JavaScript 编译器。<br>官网: https://github.com/babel/babel<br>Github: https://github.com/babel/babel<br>中文学习网站:<br>https://babel.bootcss.com</p><h2 id="swc"><a href="#swc" class="headerlink" title="swc"></a>swc</h2><p>一款使用 Rust 开发的 Javascript/Typescript 编译器。<br>官网: https://swc.rs/<br>Github: https://github.com/swc-project/swc</p><h2 id="Prettier"><a href="#Prettier" class="headerlink" title="Prettier"></a>Prettier</h2><p>代码格式化工具<br>官网: https://prettier.io<br>Github: https://github.com/prettier/prettier</p><h2 id="JSlint"><a href="#JSlint" class="headerlink" title="JSlint"></a>JSlint</h2><p>Js 代码格式化工具 由 Douglas Crockford 开发<br>Github: https://github.com/douglascrockford/JSLint</p><h2 id="JSHint"><a href="#JSHint" class="headerlink" title="JSHint"></a>JSHint</h2><p>Js 静态代码分析工具 由 Anton Kovalyov 在 JSLint的基础上开发<br>官网:jshint.com<br>Github: https://github.com/jshint/jshint</p><h2 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h2><p>一个完全插件化的代码识别及格式报告工具，支持jsx。由 Nicholas Zakas 开发<br>官网: https://eslint.org<br>Github: https://github.com/eslint/eslint<br>中文学习网站: http://eslint.cn/</p><h2 id="Esprima"><a href="#Esprima" class="headerlink" title="Esprima"></a>Esprima</h2><p>一款高性能，符合标准的 ECMAscript 解析器, 采用 ECMAscript 编写<br>官网: https://esprima.org<br>Github: https://github.com/jquery/esprima</p><h2 id="Espree"><a href="#Espree" class="headerlink" title="Espree"></a>Espree</h2><p>语言解析工具，可以将js解析为AST（抽象语法树）,由 Esprima 发展而来, 支持ES6, ESLint采用该解析工具<br>Github: https://github.com/eslint/espree</p><h2 id="Acorn"><a href="#Acorn" class="headerlink" title="Acorn"></a>Acorn</h2><p>一款小巧、快速的 Javascript 语言解析器，由 Javascript 编写<br>Github: https://github.com/acornjs/acorn</p><h2 id="Expat"><a href="#Expat" class="headerlink" title="Expat"></a>Expat</h2><p>采用 c99 编写的一款面向流的 XML 解析器。<br>Github: https://github.com/libexpat/libexpat</p><h2 id="Terser"><a href="#Terser" class="headerlink" title="Terser"></a>Terser</h2><p>Github: https://github.com/terser/terser<br>一款支持ES6+的 Javascript 解析器/压缩工具集</p><h2 id="PostCSS"><a href="#PostCSS" class="headerlink" title="PostCSS"></a>PostCSS</h2><p>用 JavaScript 工具和插件转换 css 代码的工具，autoprefixer 是它的插件<br>官网: https://postcss.org<br>Github: https://github.com/postcss/postcss<br>中文学习网站: https://www.postcss.com.cn</p><h2 id="Lightning-CSS"><a href="#Lightning-CSS" class="headerlink" title="Lightning CSS"></a>Lightning CSS</h2><p>一款使用 Rust 编写的 CSS 解析器， 转换器，打包器和压缩器。<br>官网: https://lightningcss.dev/<br>Github: https://github.com/parcel-bundler/lightningcss</p><h2 id="Terser-1"><a href="#Terser-1" class="headerlink" title="Terser"></a>Terser</h2><p>Js压缩混淆工具<br>Github: https://github.com/terser</p><h2 id="Husky"><a href="#Husky" class="headerlink" title="Husky"></a>Husky</h2><p>客户端 Git hook 工具，可以通过命令行执行 git hook，也可以将 git hook 提交到代码库中与成员共享。<br>官网: https://typicode.github.io/husky/<br>Github: https://github.com/typicode/husky</p><h2 id="Font-Awesome"><a href="#Font-Awesome" class="headerlink" title="Font-Awesome"></a>Font-Awesome</h2><p>Font Awesome 字体提供可缩放矢量图标,它可以被定制大小、颜色、阴影以及任何可以用CSS的样式。<br>官网: https://fontawesome.com<br>Github: https://github.com/FortAwesome/Font-Awesome<br>中文学习网站: http://www.fontawesome.com.cn</p><h2 id="LinkChecker"><a href="#LinkChecker" class="headerlink" title="LinkChecker"></a>LinkChecker</h2><p>死链接检查工具<br>Github: http://wummel.github.io/linkchecker/</p><h2 id="blind-watermark"><a href="#blind-watermark" class="headerlink" title="blind_watermark"></a>blind_watermark</h2><p>图片隐形水印添加工具<br>Github: https://github.com/guofei9987/blind_watermark</p><h1 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI/CD"></a>CI/CD</h1><h2 id="Travis"><a href="#Travis" class="headerlink" title="Travis"></a>Travis</h2><p>持续集成服务器解决方案<br>Github: https://github.com/travis-ci/travis-ci<br>官网: https://travis-ci.com</p><h2 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h2><p>持续集成服务器解决方案，使用Java部署<br>Github: https://github.com/jenkinsci/jenkins<br>官网: https://www.jenkins.io</p><h2 id="TeamCity"><a href="#TeamCity" class="headerlink" title="TeamCity"></a>TeamCity</h2><p>JetBrains提供的持续集成服务器解决方案<br>官网: https://www.jetbrains.com/teamcity/</p><h1 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h1><h2 id="Electron"><a href="#Electron" class="headerlink" title="Electron"></a>Electron</h2><p>使用 JavaScript, HTML 和 css 构建跨平台的桌面应用框架。<br>官网: https://electronjs.org<br>Github: https://github.com/electron/electron<br>中文学习网站: https://www.electronjs.cn</p><h2 id="nw-js"><a href="#nw-js" class="headerlink" title="nw.js"></a>nw.js</h2><p>使用 JavaScript, HTML 和 css 构建跨平台的桌面应用框架。<br>官网: https://nwjs.io<br>Github: https://github.com/nwjs/nw.js</p><h2 id="Meteor"><a href="#Meteor" class="headerlink" title="Meteor"></a>Meteor</h2><p>Meteor 是一个用以采用纯 JavaScript 开发 web 和移动应用的完全开源的平台。支持 React、Blaze、Vue和Svelte框架开发。<br>官网: https://www.meteor.com<br>Github: https://github.com/meteor/meteor</p><h2 id="Firebase"><a href="#Firebase" class="headerlink" title="Firebase"></a>Firebase</h2><p>Firebase是一个移动应用程序开发平台，为开发者提供数据分析和数据库 web 服务。由Google驱动。<br>官网: https://firebase.google.com<br>Github: https://github.com/firebase</p><h2 id="Supabase"><a href="#Supabase" class="headerlink" title="Supabase"></a>Supabase</h2><p>Supabase 是一个移动应用程序开发平台，Firebase 的开源替代品。<br>官网: https://supabase.com<br>Github: https://github.com/supabase/supabase</p><h2 id="Cordova"><a href="#Cordova" class="headerlink" title="Cordova"></a>Cordova</h2><p>采用 HTML，CSS&amp;JS 开发跨平台移动应用的开发框架<br>官网: https://cordova.apache.org<br>Github: https://github.com/apache/cordova-android<br>https://github.com/apache/cordova-ios</p><h2 id="Ionic"><a href="#Ionic" class="headerlink" title="Ionic"></a>Ionic</h2><p>Ionic是一款开源的移动应用开发框架。AngularJS移动端解决方案。<br>官网: https://ionicframework.com<br>Github: https://github.com/ionic-team/ionic-framework</p><h2 id="NativeScript"><a href="#NativeScript" class="headerlink" title="NativeScript"></a>NativeScript</h2><p>NativeScript 是一个开源框架，用于使用 JavaScript 构建真正的本地移动应用程序。使用 web 技能，比如 Angular 和 Vue.js 、 FlexBox 和 CSS ，在 iOS 和 Android 上获得本地UI和性能。<br>官网: https://www.nativescript.org<br>Github: https://github.com/NativeScript/NativeScript</p><h2 id="React-Native-RN"><a href="#React-Native-RN" class="headerlink" title="React Native(RN)"></a>React Native(RN)</h2><p>由facebook公司开发，支持使用React来构建原生移动应用的框架<br>官网: https://reactnative.dev<br>Github: https://github.com/facebook/react-native</p><h3 id="Ignite"><a href="#Ignite" class="headerlink" title="Ignite"></a>Ignite</h3><p>Ignite 是一套整合了 MobX 以及一些常见 UI 组件的 React Native 脚手架，提供了命令行 CLI、组件或是容器。<br>Github: https://github.com/infinitered/ignite</p><h3 id="Metro"><a href="#Metro" class="headerlink" title="Metro"></a>Metro</h3><p>React Native 的 Javascript 打包器。由 facebook 提供。<br>官网: https://facebook.github.io/metro<br>Github: https://github.com/facebook/metro</p><h2 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h2><p>由 Google 采用 Dart 语言开发，用于创建高性能、跨平台的移动应用。<br>官网: https://flutter.io<br>Github: https://github.com/flutter/flutter</p><h2 id="Weex"><a href="#Weex" class="headerlink" title="Weex"></a>Weex</h2><p>由 Alibaba 开发，用来创建移动端跨平台应用的框架。<br>官网: https://weex.apache.org<br>Github: https://github.com/apache/incubator-weex</p><h2 id="Tauri"><a href="#Tauri" class="headerlink" title="Tauri"></a>Tauri</h2><p>Tauri 是一款采用 Rust 开发的桌面端框架。<br>官网: https://tauri.studio<br>Github: https://github.com/tauri-apps/tauri</p><h2 id="Capacitor"><a href="#Capacitor" class="headerlink" title="Capacitor"></a>Capacitor</h2><p>Capacitor 是 Ionic 团队开发的一款跨平台应用框架，可以开发响应式的 iOS、Android、Web 应用。<br>官网: https://capacitorjs.com/<br>Github: https://github.com/ionic-team/capacitor</p><h2 id="Expo"><a href="#Expo" class="headerlink" title="Expo"></a>Expo</h2><p>Expo 是一款使用 React 开发跨平台应用的开源平台。<br>官网: https://expo.dev/<br>Github: https://github.com/expo/expo</p><h1 id="css扩展"><a href="#css扩展" class="headerlink" title="css扩展"></a>css扩展</h1><h2 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a>Sass</h2><p>css 扩展语言解析器<br>官网: http://sass-lang.com<br>Github: https://github.com/sass/sass<br>中文学习网站: https://www.sasscss.com</p><h2 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h2><p>css 预处理解析器<br>官网: http://lesscss.org<br>Github: https://github.com/less/less.js<br>中文学习网站:<br>http://lesscss.cn/<br>http://www.bootcss.com/p/lesscss/<br>https://less.bootcss.com</p><h2 id="Stylus"><a href="#Stylus" class="headerlink" title="Stylus"></a>Stylus</h2><p>css 预编译解析器<br>官网: http://stylus-lang.com<br>Github: https://github.com/stylus/stylus<br>中文学习网站: https://stylus.bootcss.com</p><h1 id="html模板"><a href="#html模板" class="headerlink" title="html模板"></a>html模板</h1><h2 id="mustache-js"><a href="#mustache-js" class="headerlink" title="mustache.js"></a>mustache.js</h2><p>HTML模板，特点是通过 <code>&#123;&#123;mustache&#125;&#125;</code> 引用变量<br>官网: https://mustache.github.io<br>Github: https://github.com/janl/mustache.js</p><h2 id="Handlebars"><a href="#Handlebars" class="headerlink" title="Handlebars"></a>Handlebars</h2><p>html语义模板<br>官网: http://handlebarsjs.com<br>Github: https://github.com/wycats/handlebars.js<br>中文学习网站: https://handlebars.bootcss.com</p><h2 id="Pug"><a href="#Pug" class="headerlink" title="Pug"></a>Pug</h2><p>html语义模板<br>官网: https://pugjs.org<br>Github: https://github.com/pugjs/pug<br>中文学习网站: https://pug.bootcss.com/api/getting-started.html</p><h2 id="Liquid"><a href="#Liquid" class="headerlink" title="Liquid"></a>Liquid</h2><p>html语义模板<br>官网: http://liquidmarkup.org/<br>Github: https://github.com/Shopify/liquid<br>中文学习网站: https://liquid.bootcss.com</p><h2 id="EJS"><a href="#EJS" class="headerlink" title="EJS"></a>EJS</h2><p>嵌入式 JavaScript 模板引擎，特点是通过 <code>&lt;%= EJS %&gt;</code> 将 js 语法嵌入 HTML<br>官网: http://ejs.co<br>github: v1: https://github.com/tj/ejs v2: https://github.com/mde/ejs<br>中文学习网站: https://ejs.bootcss.com</p><h1 id="静态站点生成"><a href="#静态站点生成" class="headerlink" title="静态站点生成"></a>静态站点生成</h1><h2 id="Jekyll"><a href="#Jekyll" class="headerlink" title="Jekyll"></a>Jekyll</h2><p>Jekyll 是一个使用 Ruby 编写的博客流静态站点生成器<br>官网: https://jekyllrb.com<br>Github: https://github.com/jekyll/jekyll<br>中文学习网站: https://www.jekyll.com.cn/</p><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p>一个快速、简单及强力的博客框架，由 Node.js 支持<br>官网: https://hexo.io<br>Github: https://github.com/hexojs/hexo<br>中文学习网站: https://hexo.bootcss.com</p><h2 id="Vuepress"><a href="#Vuepress" class="headerlink" title="Vuepress"></a>Vuepress</h2><p>极简的 Vue 驱动的静态站点生成器<br>官网: https://vuepress.vuejs.org<br>Github: https://github.com/vuejs/vuepress<br>中文学习网站: https://vuepress.vuejs.org/zh/</p><h2 id="Gatsby"><a href="#Gatsby" class="headerlink" title="Gatsby"></a>Gatsby</h2><p>基于 React 的静态站点生成器<br>官网: https://www.gatsbyjs.com<br>Github: https://github.com/gatsbyjs/gatsby<br>中文学习网站: https://www.gatsbyjs.cn/docs/</p><h2 id="docsify"><a href="#docsify" class="headerlink" title="docsify"></a>docsify</h2><p>文档站点生成器<br>官网: https://docsify.js.org<br>Github: https://github.com/docsifyjs/docsify</p><h2 id="WordPress"><a href="#WordPress" class="headerlink" title="WordPress"></a>WordPress</h2><p>静态网站和博客生成框架<br>官网: https://wordpress.org/<br>Github: https://github.com/WordPress/WordPress</p><h2 id="jsdoc"><a href="#jsdoc" class="headerlink" title="jsdoc"></a>jsdoc</h2><p>一款 JavaScript API 文档生成器<br>Github: https://github.com/jsdoc/jsdoc</p><h1 id="css库"><a href="#css库" class="headerlink" title="css库"></a>css库</h1><h2 id="Tailwind"><a href="#Tailwind" class="headerlink" title="Tailwind"></a>Tailwind</h2><p>一个用于快速 UI 开发的实用工具集 css 框架。<br>官网: https://tailwindcss.com<br>Github: https://github.com/tailwindcss/tailwindcss<br>中文学习文档: https://www.tailwindcss.cn</p><h2 id="MaterializeCSS"><a href="#MaterializeCSS" class="headerlink" title="MaterializeCSS"></a>MaterializeCSS</h2><p>一款基于 Material Design 的 css 框架。<br>Github: https://github.com/Dogfalo/materialize</p><h2 id="normalize-css"><a href="#normalize-css" class="headerlink" title="normalize.css"></a>normalize.css</h2><p>一款css库，用以针对不同浏览器的默认CSS样式进行重置，来减少浏览器之间的样式差异<br>官网: http://necolas.github.io/normalize.css/<br>Github: https://github.com/necolas/normalize.css</p><h2 id="Animate-css"><a href="#Animate-css" class="headerlink" title="Animate.css"></a>Animate.css</h2><p>一款css动画库，包含了众多css动画效果，跨浏览器开箱即用<br>Github: https://github.com/animate-css/animate.css</p><h2 id="Bluma"><a href="#Bluma" class="headerlink" title="Bluma"></a>Bluma</h2><p>一款基于 Flexbox 的 css 框架<br>官网: https://bulma.io<br>Github: https://github.com/jgthms/bulma</p><h1 id="其它库与工具"><a href="#其它库与工具" class="headerlink" title="其它库与工具"></a>其它库与工具</h1><h2 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h2><h3 id="socket-io"><a href="#socket-io" class="headerlink" title="socket.io"></a>socket.io</h3><p>实时双向基于事件的通信框架，采用 Typescript 编写，同时也有 Java、C++、Swift、Dart、Python 等其它语言版本<br>官网: https://socket.io<br>Github: https://github.com/socketio/socket.io</p><h3 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h3><p>Axios 是一个基于 Promise 的可以运行在浏览器和 Node.js 中的HTTP客户端库。<br>Github: https://github.com/axios/axios<br>中文学习网站: http://www.axios-js.com</p><h2 id="图表-amp-动画"><a href="#图表-amp-动画" class="headerlink" title="图表&amp;动画"></a>图表&amp;动画</h2><h3 id="D3"><a href="#D3" class="headerlink" title="D3"></a>D3</h3><p>一款数据可视化库，支持采用 SVG、Canvas 与 HTML 渲染。<br>官网: https://d3js.org<br>Github: https://github.com/d3/d3<br>中文学习网站: https://www.d3js.org.cn</p><h3 id="three-js"><a href="#three-js" class="headerlink" title="three.js"></a>three.js</h3><p>使用默认 WebGL 渲染的 Javascript 3d 库<br>官网: https://threejs.org<br>Github: https://github.com/mrdoob/three.js</p><h3 id="anime-js"><a href="#anime-js" class="headerlink" title="anime.js"></a>anime.js</h3><p>一款轻量级的 Javascript 动画库<br>官网: https://animejs.com<br>Github: https://github.com/juliangarnier/anime</p><h3 id="PixiJS"><a href="#PixiJS" class="headerlink" title="PixiJS"></a>PixiJS</h3><p>Pixi是一个非常快的2D sprite渲染引擎，可以用来做游戏渲染<br>官网: https://pixijs.com<br>Github: https://github.com/pixijs/pixijs<br>中文学习网站: https://pixijs.huashengweilai.com</p><h3 id="Babylon-js"><a href="#Babylon-js" class="headerlink" title="Babylon.js"></a>Babylon.js</h3><p>Babylon是一个强力的3D游戏渲染引擎<br>官网: https://www.babylonjs.com<br>Github: https://github.com/BabylonJS/Babylon.js</p><h3 id="Chart-js"><a href="#Chart-js" class="headerlink" title="Chart.js"></a>Chart.js</h3><p>基于 canvas 的简单的HTML5图表库<br>官网: https://www.chartjs.org<br>Github: https://github.com/chartjs/Chart.js</p><h3 id="Mermaid"><a href="#Mermaid" class="headerlink" title="Mermaid"></a>Mermaid</h3><p>Mermaid 是一个基于 Javascript 的图表绘制工具，通过解析类 Markdown 的文本语法来实现图表的创建和动态修改，使用了 d3.js 来生成图形<br>Github: https://github.com/mermaid-js/mermaid</p><h3 id="Echarts"><a href="#Echarts" class="headerlink" title="Echarts"></a>Echarts</h3><p>一款图表与可视化的库<br>官网: https://echarts.apache.org/zh/index.html<br>Github: https://github.com/apache/echarts</p><h3 id="Highcharts"><a href="#Highcharts" class="headerlink" title="Highcharts"></a>Highcharts</h3><p>一款基于 SVG 的 JavaScript 图表库<br>官网: <a href="http://www.highcharts.com">www.highcharts.com</a><br>Github: https://github.com/highcharts/highcharts</p><h3 id="react-grid-layout"><a href="#react-grid-layout" class="headerlink" title="react-grid-layout"></a>react-grid-layout</h3><p>一款可拖动和可调整大小的网格布局，基于 React<br>官网: https://react-grid-layout.github.io/react-grid-layout/examples/0-showcase.html<br>Github: https://github.com/react-grid-layout/react-grid-layout</p><h2 id="日期-amp-时间"><a href="#日期-amp-时间" class="headerlink" title="日期&amp;时间"></a>日期&amp;时间</h2><h3 id="Moment-js"><a href="#Moment-js" class="headerlink" title="Moment.js"></a>Moment.js</h3><p>一款 js 日期库，可以方便的对日期进行解析、校验、操作与格式化显示<br>官网: https://momentjs.com<br>Github: https://github.com/moment/moment</p><h3 id="Luxon"><a href="#Luxon" class="headerlink" title="Luxon"></a>Luxon</h3><p>一款 js 日期与时间库<br>Github: https://github.com/moment/luxon/</p><h3 id="Day-js"><a href="#Day-js" class="headerlink" title="Day.js"></a>Day.js</h3><p>一款 js 日期库，只有2kB<br>官网: https://day.js.org<br>Github: https://github.com/iamkun/dayjs<br>中文网站: https://dayjs.gitee.io/zh-CN/</p><h3 id="date-fns"><a href="#date-fns" class="headerlink" title="date-fns"></a>date-fns</h3><p>一款 js 日期库，提供了多种日期相关基础方法<br>官网: https://date-fns.org<br>Github: https://github.com/date-fns/date-fns</p><h2 id="日志-amp-数据可视化平台"><a href="#日志-amp-数据可视化平台" class="headerlink" title="日志&amp;数据可视化平台"></a>日志&amp;数据可视化平台</h2><h3 id="Sentry"><a href="#Sentry" class="headerlink" title="Sentry"></a>Sentry</h3><p>前端错误监控服务<br>官网: https://sentry.io<br>Github: https://github.com/getsentry/sentry<br>中文学习文档: https://zhuanlan.zhihu.com/p/161276192</p><h3 id="Rollbar-js"><a href="#Rollbar-js" class="headerlink" title="Rollbar.js"></a>Rollbar.js</h3><p>Javascript 错误捕捉与日志分析框架<br>Github: https://github.com/rollbar/rollbar.js</p><h3 id="Front-js"><a href="#Front-js" class="headerlink" title="Front.js"></a>Front.js</h3><p>前端错误监控平台<br>官网: https://www.frontjs.com</p><h3 id="Fundebug"><a href="#Fundebug" class="headerlink" title="Fundebug"></a>Fundebug</h3><p>前端错误监控平台<br>官网: https://www.fundebug.com</p><h3 id="Bugsnag"><a href="#Bugsnag" class="headerlink" title="Bugsnag"></a>Bugsnag</h3><p>前端错误监控平台<br>官网: https://www.bugsnag.com<br>Github: https://github.com/bugsnag/bugsnag-js</p><h3 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h3><p>一款开源的数据可视化平台<br>官网: https://grafana.com<br>Github: https://github.com/grafana/grafana</p><h3 id="Superset"><a href="#Superset" class="headerlink" title="Superset"></a>Superset</h3><p>官网: 一个现代的、企业级的商业智能(BI)web应用<br>Github: https://github.com/apache/superset</p><h3 id="Ghost"><a href="#Ghost" class="headerlink" title="Ghost"></a>Ghost</h3><p>官网: 一款开源的内容管理系统（CMS），基于 Node.js 。<br>官网: https://ghost.org<br>Github: https://github.com/TryGhost/Ghost</p><h2 id="API管理"><a href="#API管理" class="headerlink" title="API管理"></a>API管理</h2><h3 id="Yapi"><a href="#Yapi" class="headerlink" title="Yapi"></a>Yapi</h3><p>接口管理平台<br>官网: https://hellosean1025.github.io/yapi<br>Github: https://github.com/YMFE/yapi</p><h3 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h3><p>接口管理平台<br>官网: https://swagger.io<br>Github: https://github.com/swagger-api</p><h3 id="strapi"><a href="#strapi" class="headerlink" title="strapi"></a>strapi</h3><p>接口管理平台<br>官网: https://strapi.io<br>Github: https://github.com/strapi/strapi</p><h3 id="json-server"><a href="#json-server" class="headerlink" title="json-server"></a>json-server</h3><p>接口测试工具，可以通过配置json文件生成快速原型的后端接口响应<br>Github: <a href="https://github.com/typicode/json-server">json-server</a></p><h2 id="代码编辑与管理"><a href="#代码编辑与管理" class="headerlink" title="代码编辑与管理"></a>代码编辑与管理</h2><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>代码版本管理工具。<br>官网: https://git-scm.com<br>Github: https://github.com/git/git<br>中文学习网站: https://progit.bootcss.com<br>学习文档: <a href="/blog/2019/02/01/FE-Git小抄/">Git小抄</a></p><h2 id="拖放（Drag-amp-Drop）"><a href="#拖放（Drag-amp-Drop）" class="headerlink" title="拖放（Drag&amp;Drop）"></a>拖放（Drag&amp;Drop）</h2><h3 id="react-dnd"><a href="#react-dnd" class="headerlink" title="react-dnd"></a>react-dnd</h3><p>React 拖放库<br>官网: http://react-dnd.github.io/react-dnd/<br>Github: github.com/react-dnd/react-dnd</p><h4 id="react-dnd-html5-backend"><a href="#react-dnd-html5-backend" class="headerlink" title="react-dnd-html5-backend"></a>react-dnd-html5-backend</h4><p>React DnD 官方支持的 HTML5 后端</p><h3 id="react-beautiful-dnd"><a href="#react-beautiful-dnd" class="headerlink" title="react-beautiful-dnd"></a>react-beautiful-dnd</h3><p>基于 React 的漂亮且易于理解的拖拽库。由 Atlassian 开发支持。<br>官网: https://react-beautiful-dnd.netlify.com<br>Github: https://github.com/atlassian/react-beautiful-dnd</p><h3 id="react-draggable"><a href="#react-draggable" class="headerlink" title="react-draggable"></a>react-draggable</h3><p>一个简单的组件使元素可拖拽<br>Github: https://github.com/react-grid-layout/react-draggable</p><h3 id="sortablejs"><a href="#sortablejs" class="headerlink" title="sortablejs"></a>sortablejs</h3><p>Sortable是一个用于可重新排序的拖放列表的 JavaScript 库。<br>Github: github.com/SortableJS/Sortable<br>官网: http://sortablejs.github.io/Sortable/</p><h2 id="其它组件-amp-API-amp-工具"><a href="#其它组件-amp-API-amp-工具" class="headerlink" title="其它组件&amp;API&amp;工具"></a>其它组件&amp;API&amp;工具</h2><h3 id="RxJS"><a href="#RxJS" class="headerlink" title="RxJS"></a>RxJS</h3><p>RxJS 是一款响应式扩展库。<br>官网: https://rxjs.dev/<br>Github: https://github.com/ReactiveX/rxjs</p><h3 id="Ramda"><a href="#Ramda" class="headerlink" title="Ramda"></a>Ramda</h3><p>一款实用的 Javascript 函数式编程库。<br>官网: https://ramdajs.com/<br>Github: https://github.com/ramda/ramda<br>中文: https://ramda.cn/</p><h3 id="video-js"><a href="#video-js" class="headerlink" title="video.js"></a>video.js</h3><p>video.js是一款开源的 HTML5&amp;Flash 音频播放器组件<br>官网: https://videojs.com<br>Github: https://github.com/videojs/video.js</p><h3 id="sheet-js"><a href="#sheet-js" class="headerlink" title="sheet.js"></a>sheet.js</h3><p>sheetjs是一个各种电子表格格式的解析器和编写器组件<br>官网: https://sheetjs.com/<br>Github: https://github.com/SheetJS/sheetjs</p><h3 id="pdf-js"><a href="#pdf-js" class="headerlink" title="pdf.js"></a>pdf.js</h3><p>一个基于web标准的通用平台，用于解析和呈现PDF<br>官网: https://mozilla.github.io/pdf.js/<br>Github: https://github.com/mozilla/pdf.js</p><h3 id="clipboard-js"><a href="#clipboard-js" class="headerlink" title="clipboard.js"></a>clipboard.js</h3><p>一款将文本复制到剪贴板的库<br>官网: https://clipboardjs.com<br>Github: https://github.com/zenorocha/clipboard.js</p><h3 id="handsontable"><a href="#handsontable" class="headerlink" title="handsontable"></a>handsontable</h3><p>handsontable 是一款 JavaScript/HTML5数据网格与电子表格的组件。可用于 React、Vue 和 Angular 。<br>官网: https://handsontable.com<br>Github: https://github.com/handsontable/handsontable</p><h3 id="intro-js"><a href="#intro-js" class="headerlink" title="intro.js"></a>intro.js</h3><p>introjs是一个新功能介绍和步进用户指导的组件<br>官网: https://introjs.com<br>Github: https://github.com/usablica/intro.js</p><h3 id="timesheet-js"><a href="#timesheet-js" class="headerlink" title="timesheet.js"></a>timesheet.js</h3><p>timesheetjs是一个时间线组件<br>官网: https://sbstjn.github.io/timesheet.js<br>Github: https://github.com/sbstjn/timesheet.js</p><h3 id="reveal-js"><a href="#reveal-js" class="headerlink" title="reveal.js"></a>reveal.js</h3><p>在线ppt制作工具<br>官网: https://revealjs.com<br>Github: https://github.com/hakimel/reveal.js</p><h3 id="impress-js"><a href="#impress-js" class="headerlink" title="impress.js"></a>impress.js</h3><p>ppt制作框架，基于CSS3提供的变化和转换能力<br>官网: https://impress.js.org/#/bored<br>Github: https://github.com/impress/impress.js</p><h3 id="faker-js"><a href="#faker-js" class="headerlink" title="faker.js"></a>faker.js</h3><p>一款可以在 Node.js 和浏览器环境中可创造假数据的库<br>Github: https://github.com/Marak/faker.js</p><h3 id="immutable-js"><a href="#immutable-js" class="headerlink" title="immutable-js"></a>immutable-js</h3><p>Javascript 的不可变持久数据集合，提高了效率和简单性<br>Github: https://github.com/immutable-js/immutable-js</p><h3 id="Immer"><a href="#Immer" class="headerlink" title="Immer"></a>Immer</h3><p>Immer 支持了使用 Javascript 创建不可变数据结构<br>官网: https://immerjs.github.io/immer/<br>Github: https://github.com/immerjs/immer</p><h4 id="use-immer"><a href="#use-immer" class="headerlink" title="use-immer"></a>use-immer</h4><p>提供了 use-immer 和 useImmerReducer 钩子，方便在 React 中使用<br>Github: https://github.com/mweststrate/use-immer</p><h3 id="FileSaver-js"><a href="#FileSaver-js" class="headerlink" title="FileSaver.js"></a>FileSaver.js</h3><p>H5 文件保存方案<br>Github: https://github.com/eligrey/FileSaver.js</p><h3 id="StreamSaver-js"><a href="#StreamSaver-js" class="headerlink" title="StreamSaver.js"></a>StreamSaver.js</h3><p>H5 文件保存方案<br>Github: https://github.com/jimmywarting/StreamSaver.js</p><h3 id="Leaflet"><a href="#Leaflet" class="headerlink" title="Leaflet"></a>Leaflet</h3><p>移动端友好的开源地图js库<br>官网: https://leafletjs.com<br>Github: https://github.com/Leaflet/Leaflet</p><h3 id="blind-watermark-1"><a href="#blind-watermark-1" class="headerlink" title="blind-watermark"></a>blind-watermark</h3><p>用于给图片添加隐形水印<br>Github: https://github.com/Sherryer/blind-watermark</p><h3 id="interact-js"><a href="#interact-js" class="headerlink" title="interact.js"></a>interact.js</h3><p>支持 JavaScript拖放、调整大小和多点触摸手势，具有惯性和捕捉功能，适合现代浏览器<br>官网: http://interactjs.io/<br>Github: https://github.com/taye/interact.js</p><h3 id="simple-keyboard"><a href="#simple-keyboard" class="headerlink" title="simple-keyboard"></a>simple-keyboard</h3><p>Javascript虚拟键盘-可定制、响应灵敏、轻量级<br>官网: https://virtual-keyboard.js.org/<br>Github: https://github.com/hodgef/simple-keyboard</p><h3 id="localForage"><a href="#localForage" class="headerlink" title="localForage"></a>localForage</h3><p>localForage 是一个快速简单的JavaScript存储库。localForage 通过使用异步存储（IndexedDB 或 WebSQL）和简单的类似 localStorage 似的 API 来改善 web 应用程序的离线体验。<br>官网: https://localforage.github.io/localForage/<br>Github: https://github.com/localForage/localForage<br>官方中文文档: https://localforage.docschina.org/</p><!--## SketchSketch 是一款适用于设计师的矢量绘图应用。http://www.sketchcn.com/sketch-chinese-user-manual.html## Axure rpAxure 是一款快速原型工具https://www.axure.com.cn--><h3 id="Serverless"><a href="#Serverless" class="headerlink" title="Serverless"></a>Serverless</h3><p>Serverless Framework 是一个命令行工具用以快速部署无服务器(serverless)应用，它使用基于事件触发的计算资源（例如腾讯云云函数 SCF，AWS Lambda）<br>官网: http://www.serverless.com<br>Github: https://github.com/serverless/serverless</p><h3 id="Hyper"><a href="#Hyper" class="headerlink" title="Hyper"></a>Hyper</h3><p>采用 HTML/JS/CSS 编写的终端命令行工具<br>官网: https://hyper.is<br>Github: https://github.com/vercel/hyper</p><h3 id="Quill"><a href="#Quill" class="headerlink" title="Quill"></a>Quill</h3><p>一款所见即所得的富文本编辑器<br>官网: https://quilljs.com<br>Github: https://github.com/quilljs/quill</p><h3 id="storybook"><a href="#storybook" class="headerlink" title="storybook"></a>storybook</h3><p>UI组件开发与测试环境<br>官网: https://storybook.js.org<br>Github: https://github.com/storybookjs/storybook</p><h3 id="Yoga"><a href="#Yoga" class="headerlink" title="Yoga"></a>Yoga</h3><p>Yoga 是一款实现了 Flexbox 的跨平台的布局引擎，由 facebook 提供<br>官网: https://yogalayout.com<br>Github: https://github.com/facebook/yoga</p><h3 id="React-pdf"><a href="#React-pdf" class="headerlink" title="React-pdf"></a>React-pdf</h3><p>React-pdf 是一款支持在浏览器和服务器环境下创建 PDF 文件的 React 渲染器<br>官网: https://react-pdf.org<br>Github: https://github.com/diegomura/react-pdf</p><h3 id="Watchman"><a href="#Watchman" class="headerlink" title="Watchman"></a>Watchman</h3><p>Watchman 是一款便捷工具，用于监视文件变更并记录或触发某些操作。由 facebook 提供。<br>官网: https://facebook.github.io/watchman<br>Github: https://github.com/facebook/watchman</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> language </tag>
            
            <tag> framework </tag>
            
            <tag> front-end </tag>
            
            <tag> library </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
