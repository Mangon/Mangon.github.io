<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    

    
    <title>
        标签: Web API | 
        Gblog
    </title>
    <meta name="author" content="Mangon" />
    <meta name="version" content="1.1.0" />
    
    <meta name="keywords" content="Mangon blog, 技术博客, 前端学习, 前端基础" />
    
    
    <meta name="description" content="Mangon&#39;s Technology Blog" />
    
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    
    <meta name="baidu-site-verification" content="pWri9ahJmw" />
    
    
    
    <link rel="icon" href="/blog/images/favicon.ico">
    
    
<link rel="stylesheet" href="/blog/css/style.css">

    <link rel="stylesheet" href="/blog/css/jquery.modal.min.css"></link>
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/blog/atom.xml" title="Gblog" type="application/atom+xml">
</head>
<body>

    <main class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>
    <nav class="nav-inner">
        
            
                <li class="nav-item ">
                    <a class="nav-link" href="/blog/">主页</a>
                </li>
            
        
            
                <li class="nav-item ">
                    <a class="nav-link" href="/blog/archives">目录</a>
                </li>
            
        
    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <div class="search-box" id="search-box">
    <form>
        <div class="search-btn"></div>
        <input autocomplete="off" type="text" id="search-input" name="q" results="0" placeholder="搜索"
        />
        <button type="reset" class="reset-search-btn"></button>
    </form>
</div>        
        

        
            <div class="author-meta">
                
                <div class="author-avatar">
                    <a href="/blog/">
                        <img src="/blog/images/avatar.jpeg" title="Mangon">
                    </a>
                </div>
                
                <div class="author-name">Mangon</div>
                <div class="author-work">前端开发工程师</div>
                <div class="author-location">
                    <i class="icon-location vm"></i>
                    <span class="vm">中国北京</span>
                </div>
                
                <div class="author-thread-wrap">
                    <div class="author-threads clearfix">
                        
                            <a class="thread-item" href="https://github.com/mangon" target="_blank" rel="external noopener noreferrer"><i class="icon-github"></i></a>
                        
                        
                        
                            <a class="thread-item" href="https://mangon.cn/blog/atom.xml" target="_blank" rel="external noopener noreferrer"><i class="icon-favorite"></i></a>
                        
                        
                            <a class="thread-item" href="https://mangon.cn/resume" target="_blank" rel="external noopener noreferrer"><i class="icon-circle-more"></i></a>
                        
                    </div>
                </div>
                
            </div>
        
        <div id="coffee-content"></div>
    </div>
</aside>

</header>

        
            <div data-spy="scroll" data-target="#aside-inner" id="content" class="content">
        
            
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/blog/2023/08/04/FE-EventSource/">EventSource API</a>
        </h1>
        
        <div class="article-meta clearfix">
            <span class="article-date">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2023-08-04T07:22:51.000Z" itemprop="datePublished">2023-08-04</time>
</span>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/blog/tags/Web-API/" rel="tag">Web API</a>, <a class="article-tag-link" href="/blog/tags/performance/" rel="tag">performance</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
            <p>EventSource 接口是 web 内容与服务器发送事件通信的接口。</p>
<p>一个 EventSource 实例会对 HTTP 服务器开启一个持久化的连接，以 <code>text/event-stream</code> 格式发送事件，此连接会一直保持开启直到通过调用 <code>EventSource.close()</code> 关闭。一旦连接开启，来自服务端传入的消息会以事件的形式分发至客户端中，如果接收消息中有一个 event 字段，触发的事件与 event 字段的值相同。如果不存在 event 字段，则将触发通用的 message 事件。</p>
<p>与 WebSocket 不同的是，服务器发送事件是单向的。数据消息只能从服务端发送到客户端（如用户的浏览器）。这使其成为不需要从客户端往服务器发送消息的情况下的最佳选择。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p><code>EventSource()</code></p>
<p>创建一个新的 EventSource，用于从指定的 URL 接收服务器发送事件，可以选择开启凭据模式。</p>
<p>用法： <code>cosnt pc = new EventSource(url, configuration);</code></p>
<p>url 表示远程资源的位置，configuration 为配置新连接提供选项，目前只有一个可选项 withCredentials，默认为 false，指示 CORS 是否应包含凭据。</p>
<h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><p>此接口从其父接口 EventTarget 继承属性。</p>
<ul>
<li><p>EventSource.readyState 只读<br>一个代表连接状态的数字。可能值是 CONNECTING（0）、OPEN（1）或 CLOSED（2）。</p>
</li>
<li><p>EventSource.url 只读<br>一个表示事件源的 URL 字符串。</p>
</li>
<li><p>EventSource.withCredentials 只读<br>一个布尔值，表示 EventSource 对象是否使用跨域资源共享（CORS）凭据来实例化（true），或者不使用（false，即默认值）。</p>
</li>
</ul>
<h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><p>此接口从其父接口 EventTarget 继承方法。</p>
<ul>
<li>EventSource.close()<br>关闭连接（如果有），并将 readyState 属性设置为 CLOSED。如果连接已经关闭，则该方法不执行任何操作。</li>
</ul>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ul>
<li><p>error<br>在事件源连接未能打开时触发。</p>
</li>
<li><p>message<br>在从事件源接收到数据时触发。</p>
</li>
<li><p>open<br>在与事件源的连接打开时触发。</p>
</li>
</ul>
<p>此外，事件源本身可以发送具有 event 字段的消息，这将创建一个以该值为键的特定事件。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>在这个基本的例子中，创建了一个 EventSource 来从服务器接收未命名的事件；一个名为 sse.php 的页面负责生成这些事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> evtSource = <span class="keyword">new</span> <span class="title class_">EventSource</span>(<span class="string">&quot;sse.php?message=hello&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> eventList = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;ul&quot;</span>);</span><br><span class="line"></span><br><span class="line">evtSource.<span class="property">onmessage</span> = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> newElement = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;li&quot;</span>);</span><br><span class="line"></span><br><span class="line">  newElement.<span class="property">textContent</span> = <span class="string">`message: <span class="subst">$&#123;e.data&#125;</span>`</span>;</span><br><span class="line">  eventList.<span class="title function_">appendChild</span>(newElement);</span><br><span class="line">  evtSource.<span class="title function_">close</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每个接收到的事件都会导致我们的 EventSource 对象的 onmessage 事件处理程序运行。它会创建一个新的 <code>&lt;li&gt;</code> 元素，并将消息的数据写入其中，然后将新元素附加到文档中已有的列表元素中。</p>
<p>要监听具名事件，你需要为每种类型的事件添加一个监听器。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sse = <span class="keyword">new</span> <span class="title class_">EventSource</span>(<span class="string">&quot;/api/v1/sse&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这将仅监听类似下面的事件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * event: notice</span></span><br><span class="line"><span class="comment"> * data: useful data</span></span><br><span class="line"><span class="comment"> * id: someid</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sse.<span class="title function_">addEventListener</span>(<span class="string">&quot;notice&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">data</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 同理，以下代码将监听具有字段 `event: update` 的事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sse.<span class="title function_">addEventListener</span>(<span class="string">&quot;update&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">data</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * “message”事件是一个特例，因为它可以捕获没有 event 字段的事件，</span></span><br><span class="line"><span class="comment"> * 以及具有特定类型 `event：message` 的事件。</span></span><br><span class="line"><span class="comment"> * 它不会触发任何其他类型的事件。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sse.<span class="title function_">addEventListener</span>(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">data</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li><p>浏览器同域名下的HTTP请求数量是有限制的（例如Chrome浏览器的限制为6个），所以如果打开多个选项卡，这种长连接可能会因为占满限制名额而导致无法发送新的HTTP请求。</p>
</li>
<li><p>EventSource API 发送的HTTP请求为GET类型的，如果想要发送POST类型的HTTP请求，或者修改HTTP请求的headers，可以使用 <code>@microsoft/fetch-event-source</code> 库，该库对这种情况进行了polyfill，使用方法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; fetchEventSource &#125; <span class="keyword">from</span> <span class="string">&#x27;@microsoft/fetch-event-source&#x27;</span>;</span><br><span class="line"><span class="title function_">fetchEventSource</span>(url, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    <span class="title class_">Accept</span>: <span class="string">&#x27;*/*&#x27;</span>,</span><br><span class="line">    <span class="title class_">Connection</span>: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">    <span class="attr">messages</span>: [&#123;</span><br><span class="line">      <span class="attr">content</span>: <span class="string">&#x27;Hello.&#x27;</span>,</span><br><span class="line">      <span class="attr">role</span>: <span class="string">&#x27;user&#x27;</span>,</span><br><span class="line">    &#125;],</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="title function_">onmessage</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`EventSource onmessage <span class="subst">$&#123;<span class="built_in">Date</span>.now()&#125;</span>: <span class="subst">$&#123;event.data&#125;</span>`</span>);</span><br><span class="line">  &#125;，</span><br><span class="line">  <span class="title function_">onerror</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;EventSource onerror&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>类似的库还有 <code>event-source-polyfill</code> 库。</p>
</li>
<li><p>针对问答式的请求，服务器端返回的文本数据为流式时，EventSource API 相比 WebSocket 更加简单便捷，chatGPT 类问答服务多采用 EventSource API 来实现。</p>
</li>
</ol>

        
    </section>
    
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/blog/2022/06/14/HTML-DOM%E4%B8%AD%E7%9A%84%E9%AB%98%E5%BA%A6%E3%80%81%E5%AE%BD%E5%BA%A6%E4%B8%8E%E8%B7%9D%E7%A6%BB/">DOM中的高度、宽度与距离</a>
        </h1>
        
        <div class="article-meta clearfix">
            <span class="article-date">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2022-06-14T02:25:26.000Z" itemprop="datePublished">2022-06-14</time>
</span>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/blog/tags/HTML/" rel="tag">HTML</a>, <a class="article-tag-link" href="/blog/tags/Web-API/" rel="tag">Web API</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
            <h2 id="HTMLElement-Element-属性"><a href="#HTMLElement-Element-属性" class="headerlink" title="HTMLElement/Element 属性"></a>HTMLElement/Element 属性</h2><h3 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h3><p><code>HTMLElement.offsetWidth</code> 属性表示元素的布局宽度。该属性包括元素的内容宽度（content-width）、竖直方向滚动条宽度（scrollbar-width）（如果存在的话）、水平方向的内边距（padding-left padding-right）以及水平方向的边框（border-left-width border-right-width）。</p>
<p><code>HTMLElement.offsetHeight</code> 属性表示元素的布局高度。该属性包括元素的内容高度（content-height）、水平方向滚动条高度（scrollbar-height）（如果存在的话）、竖直方向的内边距（padding-top padding-bottom）以及竖直方向的边框（border-top-width border-bottom-width）。</p>
<p>offsetWidth = 水平方向content-width + 左右padding + 左右border + 竖直方向滚动条scrollbar-width（如果存在的话）<br>offsetHeight = 竖直方向content-height + 上下padding + 上下border + 水平方向滚动条scrollbar-height（如果存在的话）</p>
<p><img src="/blog/static/imgs/dom/offset.png" alt="offset_inner"></p>
<p><em>offsetWidth 和 offsetHeight 可以理解为一个 边框盒（border box） 的 width 和 height。</em></p>
<p><code>HTMLElement.offsetTop</code> 属性表示元素的左上角相对于其 offsetParent 元素的顶部边框的距离。<br><code>HTMLElement.offsetLeft</code> 属性表示元素左上角相对于其 offsetParent 元素的左边框的距离。</p>
<p><code>HTMLElement.offsetParent</code> 返回一个指向最近的（指包含层级上的最近）包含该元素的定位元素或者最近的 <code>table,td,th,body</code> 元素。当元素的 <code>style.display</code> 设置为 “none” 时，或者该元素的 <code>style.position</code> 被设为 “fixed” 时，<code>offsetParent</code> 返回 <code>null</code>。</p>
<h3 id="client"><a href="#client" class="headerlink" title="client"></a>client</h3><p><code>Element.clientWidth</code> 属性表示元素的内部宽度。该属性包括元素的内容宽度（content-width）和内边距（padding），但不包括竖直方向滚动条宽度（scrollbar-width）（如果存在的话），边框（border）和外边距（margin）。</p>
<p><code>Element.clientHeight</code> 属性表示元素的内部高度。该属性包括元素的内容宽度（content-width）和内边距（padding），但不包括水平方向滚动条高度（scrollbar-height）（如果存在的话），边框（border）和外边距（margin）。</p>
<p>clientWidth = 水平方向content-width + 左右padding<br>clientHeight = 竖直方向content-height + 上下padding</p>
<p><img src="/blog/static/imgs/dom/client.png" alt="client_inner"></p>
<p><em>offsetWidth 和 offsetHeight 可以理解为一个 内边距盒（padding box） 的 width 和 height。</em><br><em>padding-box 并不是一个标准的盒模型选项，这里只是为了方便理解</em></p>
<p><code>Element.clientTop</code> 属性表示元素顶部边框的宽度。该属性仅包括元素的顶部边框宽度<br>（border-top-width）。</p>
<p><code>Element.clientLeft</code> 属性表示元素的左边框宽度。该属性包括元素的左边框 （border-left-width），如果元素的文本方向是从右向左（RTL, right-to-left），并且由于内容溢出导致左边出现了一个垂直滚动条，则该属性包括滚动条的宽度。</p>
<h3 id="scroll"><a href="#scroll" class="headerlink" title="scroll"></a>scroll</h3><p><code>Element.scrollWidth</code> 属性表示元素在不使用滚动条的情况下适合视口中的所有内容所需的最小宽度。scrollWidth 的测量方式与 clientWidth 相同：包含元素的内边距（padding），但不包括边框（border），外边距（margin）或垂直滚动条（如果存在）。scrollWidth 也包括伪元素的宽度，例如 ::before 或 ::after 。如果元素的内容可以正常展示而不需要水平滚动条，则其 scrollWidth 等于 clientWidth 。</p>
<p><code>Element.scrollHeight</code> 属性表示元素在不使用滚动条的情况下为了适应视口中所用内容所需的最小高度。scrollHeight 的测量方式与 clientHeight 相同：包括元素的内边距（padding），但不包括元素的边框（border）和外边距（margin）。scrollHeight 也包括 ::before 和 ::after 这样的伪元素的高度。 如果元素的内容不需要垂直滚动条就可以正常展示，则其 scrollHeight 等于 clientHeight。</p>
<p><img src="/blog/static/imgs/dom/scrollheight.png" alt="scroll-height_inner"></p>
<p><code>Element.scrollTop</code> 属性可以获取或<em>设置</em>（和前面的属性不同，scrollTop 是一个可读写的属性）元素的顶部到可视内容顶部的距离。如果一个元素的内容没有产生垂直方向的滚动条，那么它的 scrollTop 值为 0 。</p>
<p><code>Element.scrollLeft</code> 属性可以获取或<em>设置</em>元素的左边到可视内容左边的距离。如果一个元素的内容没有产生水平方向的滚动条，那么它的 scrollLeft 值为 0 。</p>
<h3 id="style-属性"><a href="#style-属性" class="headerlink" title="style 属性"></a>style 属性</h3><p>通过 <code>HTMLElement.style</code> 可以获取或<em>设置</em>元素的样式属性。但大部分时候，样式并不是直接存在于元素上而是通过继承等原因体现到的。我们可以通过 <code>window.getComputedStyle(element, [pseudoElt])</code> 获取到已经解析的 CSS 样式，该方法返回一个 <code>CSSStyleDeclaration</code> 对象，当元素的样式更改时，它会自动更新。</p>
<p><code>HTMLElement.style.&#123;top|left|right|bottom&#125;</code> 属性定义了定位元素的外边距边界与其包含块边界或正常位置之间的距离，非定位元素设置此属性无效。</p>
<p>以 top 为例，top 的效果取决于元素的 position 属性：</p>
<ul>
<li>当 position 设置为 absolute 或 fixed 时，top 属性指定了定位元素上外边距边界与其包含块上边界之间的偏移。</li>
<li>当 position 设置为 relative 时，top 属性指定了元素的上边界离开其正常位置的偏移。</li>
<li>当 position 设置为 sticky 时，如果元素在 viewport 里面，top 属性的效果和  position 为 relative 等同；如果元素在 viewport 外面，top 属性的效果和 position 为 fixed 等同。</li>
<li>当 position 设置为 static 时，top 属性无效。</li>
</ul>
<p><code>HTMLElement.style.margin&#123;Left|Top|Right|Bottom&#125;</code> 属性定义了元素的外边距<br><code>HTMLElement.style.padding&#123;Left|Top|Right|Bottom&#125;</code> 属性定义了元素的内边距<br><code>HTMLElement.style.border&#123;Left|Top|Right|Bottom&#125;Width</code> 属性定义了元素边框的宽度</p>
<h3 id="getBoundingClientRect-方法"><a href="#getBoundingClientRect-方法" class="headerlink" title="getBoundingClientRect 方法"></a>getBoundingClientRect 方法</h3><p><code>Element.getBoundingClientRect()</code> 方法返回一个 <code>DOMRect</code> 对象，其提供了元素的大小及其相对于视口的位置。值得注意的是，以上像 <code>offsetWidth</code> 等只读属性返回的都是四舍五入（round）之后的整数数值，<code>getBoundingClientRect</code> 可以返回精确的小数数值。</p>
<p>该方法返回的 <code>DOMRect</code> 对象中的 <code>width</code> 和 <code>height</code> 属性是包含了 <code>padding</code> 和 <code>border-width</code> 的，而不仅仅是内容部分的宽度和高度。在 <code>content-box</code> 模型中，这两个属性值分别与元素的 width/height + padding + border-width 相等。而如果是 border-box，两个属性则直接与元素的 width 或 height 相等。</p>
<p><img src="/blog/static/imgs/dom/element-box-diagram.png" alt="element-box_inner"></p>
<h3 id="getClientRects-方法"><a href="#getClientRects-方法" class="headerlink" title="getClientRects 方法"></a>getClientRects 方法</h3><p><code>Element.getClientRects()</code> 方法返回一个 <code>DOMRect</code> 集合，其包括元素内所有<br>边框盒（border box）的边界矩形（bounding rectangles）。大多数元素只有一个边框盒（border box），但是诸如一个多行的内联元素（例如多行的 span 元素）每行都有一个边框盒（border box）。</p>
<h2 id="window-属性"><a href="#window-属性" class="headerlink" title="window 属性"></a>window 属性</h2><p><code>window.innerWidth</code> 属性表示以像素为单位的窗口的视口（viewport）宽度。如果垂直滚动条存在，则这个属性将包括它的宽度。</p>
<p><code>window.innerHeight</code> 属性表示以像素为单位的窗口的视口（viewport）高度。如果水平滚动条存在，则这个属性将包括它的高度。</p>
<p><code>window.outerWidth</code> 属性表示整个浏览器外部窗口的宽度。包括侧边栏（如果存在）、窗口镶边和调整窗口大小的边框。</p>
<p><code>window.outerHeight</code> 属性表示整个浏览器外部窗口的高度。包括工具栏（如果存在）、窗口镶边和调整窗口大小的边框。</p>
<p><img src="/blog/static/imgs/dom/inner-outer.png" alt="inner-outer_inner"></p>
<p>一个显著的区分 inner 和 outer 的例子就是打开浏览器的 开发者工具，outerHeight 将会计算上开发者工具的高度，而 innerHeight 不会。</p>
<h3 id="screen-属性"><a href="#screen-属性" class="headerlink" title="screen 属性"></a>screen 属性</h3><p><code>window.screen.width</code> 属性表示屏幕的宽度。</p>
<p><code>window.screen.height</code> 属性表示屏幕的高度。</p>
<p><code>window.screen.availWidth</code> 属性表示浏览器窗口在屏幕上可占用的最大宽度。</p>
<p><code>window.screen.availHeight</code> 属性表示浏览器窗口在屏幕上可占用的最大高度。小工具（Widgets），如任务栏或其他特殊的程序窗口，可能会减少浏览器窗口和其他应用程序能够利用的空间。</p>
<h2 id="document-属性"><a href="#document-属性" class="headerlink" title="document 属性"></a>document 属性</h2><p><code>document.documentElement</code> 返回的是整个 html 文档<br><code>document.body</code> 返回的是 body 元素</p>
<p>html 文档 与 body 元素都是有效的 HTMLElement ， 所以，他们的属性也符合对应属性的定义：</p>
<p><code>document.documentElement.clientWidth</code> 浏览器窗口可视区宽度（不包括浏览器控制台、菜单栏、工具栏、滚动条）<br><code>document.documentElement.clientHeight</code> 浏览器窗口可视区高度（不包括浏览器控制台、菜单栏、工具栏、滚动条）</p>
<p><code>document.documentElement.offsetHeight</code> 获取整个文档的高度（包含 body 的 margin ）<br><code>document.documentElement.offsetWidth</code> 获取整个文档的宽度（包含 body 的 margin ）</p>
<p><code>document.documentElement.scrollTop</code> 返回文档的滚动 top 方向的距离（当窗口发生滚动时值改变）<br><code>document.documentElement.scrollLeft</code> 返回文档的滚动 left 方向的距离（当窗口发生滚动时值改变）</p>
<p><code>document.body.offsetHeight</code> 获取整个 body 的高度（不包含 body 的 margin ）<br><code>document.body.offsetWidth</code> 获取整个 body 的宽度（不包含 body 的 margin ）</p>
<p><img src="/blog/static/imgs/dom/distance.webp" alt="distance_inner"></p>

        
    </section>
    
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/blog/2022/03/09/JS-Fetch-API%E5%B0%8F%E6%8A%84/">Fetch API小抄</a>
        </h1>
        
        <div class="article-meta clearfix">
            <span class="article-date">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2022-03-09T03:23:35.000Z" itemprop="datePublished">2022-03-09</time>
</span>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/blog/tags/HTTP/" rel="tag">HTTP</a>, <a class="article-tag-link" href="/blog/tags/Web-API/" rel="tag">Web API</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
            <p>Fetch API 提供了一个 <code>window.fetch()</code> 接口来获取资源（包括网络资源）。Fetch API 可以用来替代 XMLHttpRequest ，可以在 Web Workers 中使用( <code>WorkerGlobalScope.fetch()</code> )。</p>
            
            <p class="article-more-link">
                <a href="/blog/2022/03/09/JS-Fetch-API%E5%B0%8F%E6%8A%84/#more">
                    <span class="vm">阅读更多</span>
                    <i class="icon-arrow-double-right vm"></i>    
                </a>
            </p>
            
        
    </section>
    
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/blog/2022/02/15/FE-Web-Components/">Web Components 小抄</a>
        </h1>
        
        <div class="article-meta clearfix">
            <span class="article-date">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2022-02-15T15:01:12.000Z" itemprop="datePublished">2022-02-15</time>
</span>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/blog/tags/Web-API/" rel="tag">Web API</a>, <a class="article-tag-link" href="/blog/tags/component/" rel="tag">component</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
            <p><a target="_blank" rel="noopener" href="https://github.com/WICG/webcomponents">Web Components</a> 是 W3C 在2014年提出的网页组件式开发的技术规范，旨在给 Web 开发者提供浏览器原生级别的组件能力。通过 Web Components 规范开发者可以自定义可重用的 Web 组件并引入到任意项目中而不必借助 Web 组件化框架，并且不必考虑组件内样式和变量污染的问题。</p>
            
            <p class="article-more-link">
                <a href="/blog/2022/02/15/FE-Web-Components/#more">
                    <span class="vm">阅读更多</span>
                    <i class="icon-arrow-double-right vm"></i>    
                </a>
            </p>
            
        
    </section>
    
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/blog/2021/06/23/HTML-history-API/">浏览器会话历史 history API</a>
        </h1>
        
        <div class="article-meta clearfix">
            <span class="article-date">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2021-06-22T16:43:58.000Z" itemprop="datePublished">2021-06-23</time>
</span>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/blog/tags/HTML/" rel="tag">HTML</a>, <a class="article-tag-link" href="/blog/tags/Web-API/" rel="tag">Web API</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
            <h2 id="History-API"><a href="#History-API" class="headerlink" title="History API"></a>History API</h2><p>History 接口允许操作浏览器的会话历史记录。</p>
<h2 id="History-API-的方法和属性"><a href="#History-API-的方法和属性" class="headerlink" title="History API 的方法和属性"></a>History API 的方法和属性</h2><table>
<thead>
<tr>
<th>属性</th>
<th>是否只读</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>history.length</code></td>
<td>只读</td>
<td>整数</td>
<td>history 堆栈中会话的数量</td>
</tr>
<tr>
<td><code>history.state</code></td>
<td>只读</td>
<td>object</td>
<td>返回一个表示历史堆栈顶部的状态的值</td>
</tr>
<tr>
<td><code>history.scrollRestoration</code></td>
<td>否</td>
<td>auto｜manual (string)</td>
<td>允许Web应用程序在历史导航上显式地设置默认滚动恢复行为</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>history.back()</code></td>
<td>在浏览器历史记录里前往上一页, 用户可点击浏览器左上角的返回按钮模拟此方法. 等价于 <code>history.go(-1)</code></td>
</tr>
<tr>
<td><code>history.forward()</code></td>
<td>在浏览器历史记录里前往下一页，用户可点击浏览器左上角的前进按钮模拟此方法. 等价于 <code>history.go(1)</code></td>
</tr>
<tr>
<td><code>history.go()</code></td>
<td>入参为整数，通过当前页面的相对位置从浏览器历史记录加载页面。</td>
</tr>
<tr>
<td><code>history.pushState(state, title[, url])</code></td>
<td>按指定的名称和URL（如果提供该参数）将数据 push 进会话历史栈，数据被 DOM 进行不透明处理；可以指定任何可以被序列化的 javascript 对象。</td>
</tr>
<tr>
<td><code>history.replaceState(state, title[, url])</code></td>
<td>按指定的数据，名称和URL(如果提供该参数)，更新历史栈上最新的入口。这个数据被 DOM 进行了不透明处理。你可以指定任何可以被序列化的 javascript 对象。</td>
</tr>
</tbody>
</table>
<h2 id="History-API-用法"><a href="#History-API-用法" class="headerlink" title="History API 用法"></a>History API 用法</h2><p>History API 最常见的用法是通过 <code>pushState()</code> 方法添加浏览器url历史（浏览器不会加载该 url ，甚至不会检查 url 是否真的存在），这样，在回退的时候就会加载 history 堆栈中的页面。在某种意义上，调用 <code>pushState()</code> 与 设置 <code>window.location = &quot;#foo&quot;</code> 类似，二者都会在当前页面创建并激活新的历史记录。但 <code>pushState()</code> 具有如下几条特点：</p>
<ul>
<li>新的 URL 可以是与当前 URL 同源的任意 URL 。相反，只有在修改哈希时，设置 <code>window.location</code> 才能是同一个 document。</li>
<li>如果你不想改 URL ，就不用改。相反，设置 <code>window.location = &quot;#foo&quot;;</code> 在当前哈希不是 #foo 时，才能创建新的历史记录项。</li>
<li>你可以将任意数据和新的历史记录项相关联。而基于哈希的方式，要把所有相关数据编码为短字符串。</li>
<li>如果 标题(title 随后还会被浏览器所用到，那么这个数据是可以被使用的（哈希则不是）。</li>
<li><code>pushState()</code> 不会触发 hashchange 事件，即使新的 URL 与旧的 URL 仅哈希不同也是如此</li>
</ul>
<p>每当活动的历史记录项发生变化时， popstate 事件都会被传递给 window 对象。如果当前活动的历史记录项是被 <code>pushState()</code> 创建的，或者是由 <code>replaceState()</code> 改变的，那么 popstate 事件的状态属性 state 会包含一个当前历史记录状态对象的拷贝。</p>
<p>参考： https://developer.mozilla.org/zh-CN/docs/Web/API/History</p>

        
    </section>
    
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/blog/2021/06/23/HTML-Event/">DOM中的事件 Event</a>
        </h1>
        
        <div class="article-meta clearfix">
            <span class="article-date">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2021-06-22T16:41:21.000Z" itemprop="datePublished">2021-06-23</time>
</span>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/blog/tags/HTML/" rel="tag">HTML</a>, <a class="article-tag-link" href="/blog/tags/Web-API/" rel="tag">Web API</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
            <h2 id="DOM中的事件-Event"><a href="#DOM中的事件-Event" class="headerlink" title="DOM中的事件 Event"></a>DOM中的事件 Event</h2><p>Event 接口表示在 DOM 中出现的事件。</p>
<p>Event（事件）可以由三种方式触发：</p>
<ul>
<li>由用户触发动作，例如鼠标或键盘事件</li>
<li>由 API 生成，例如指示动画已经完成运行的事件，视频已被暂停等</li>
<li>通过脚本代码触发，例如对元素调用 <code>HTMLElement.click()</code> 方法，或者定义一些自定义事件，再使用 <code>EventTarget.dispatchEvent()</code> 方法将自定义事件派发往指定的目标（target）</li>
</ul>
<p>有许多不同类型的事件，其中一些使用基于 Event 主接口的二次接口。Event 本身包含适用于所有事件的属性和方法。</p>
<p>很多DOM元素可以被设计接收（或者监听) 这些事件, 并且执行代码去响应（或者处理）它们。通过 <code>EventTarget.addEventListener()</code> 方法可以将事件处理函数绑定到不同的HTML elements上 (比如&lt;button>, &lt;div>, &lt;span>等等) 。这种绑定事件处理函数的方式基本替换了老版本中使用 HTML event handler attributes（例如 <code>HTMLElement.onclick = ...</code> ） 来绑定事件处理函数的方式。除此之外，通过正确使用 <code>removeEventListener()</code> 方法，这些事件处理函数也能被移除。</p>
            
            <p class="article-more-link">
                <a href="/blog/2021/06/23/HTML-Event/#more">
                    <span class="vm">阅读更多</span>
                    <i class="icon-arrow-double-right vm"></i>    
                </a>
            </p>
            
        
    </section>
    
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/blog/2021/05/17/FE-webworker%E5%B0%8F%E6%8A%84/">Web Worker小抄</a>
        </h1>
        
        <div class="article-meta clearfix">
            <span class="article-date">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2021-05-17T15:13:01.000Z" itemprop="datePublished">2021-05-17</time>
</span>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/blog/tags/Web-API/" rel="tag">Web API</a>, <a class="article-tag-link" href="/blog/tags/webworker/" rel="tag">webworker</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
            <h2 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h2><p>Web Worker 为 Web 内容在后台线程中运行脚本提供了一种简单的方法，线程可以执行任务而不干扰用户界面。  </p>
<p>它有以下特点：  </p>
<ul>
<li><em>异步多线程</em> 在主线程运行的同时，Worker 线程在后台运行，两者互不干扰</li>
<li><em>同源限制</em> 分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源，Worker 也仅能被生成它的脚本所使用</li>
<li><em>DOM 限制</em> Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用 <code>document</code>、<code>window</code>、<code>parent</code> 这些对象。但是，Worker 线程可以访问 <code>navigator</code> 和 <code>location</code> 对象，可以使用大量 window 对象之下的东西，包括 WebSockets ， IndexedDB </li>
<li><em>message通信机制</em> Worker 线程和主线程间的数据传递通过这样的消息机制进行——双方都使用 <code>postMessage()</code> 方法发送各自的消息，使用 <code>onmessage</code> 事件处理函数来响应消息</li>
<li><em>支持web IO</em> Worker 线程可以使用 XMLHttpRequest 进行网络I/O</li>
</ul>
            
            <p class="article-more-link">
                <a href="/blog/2021/05/17/FE-webworker%E5%B0%8F%E6%8A%84/#more">
                    <span class="vm">阅读更多</span>
                    <i class="icon-arrow-double-right vm"></i>    
                </a>
            </p>
            
        
    </section>
    
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/blog/2021/05/14/FE-performance-timing%E5%90%84%E4%B8%AA%E5%8F%82%E6%95%B0%E5%90%AB%E4%B9%89/">performance.timing各个参数含义</a>
        </h1>
        
        <div class="article-meta clearfix">
            <span class="article-date">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2021-05-14T04:15:42.000Z" itemprop="datePublished">2021-05-14</time>
</span>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/blog/tags/Web-API/" rel="tag">Web API</a>, <a class="article-tag-link" href="/blog/tags/performance/" rel="tag">performance</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
            <h2 id="performance-timing"><a href="#performance-timing" class="headerlink" title="performance.timing"></a>performance.timing</h2><p>window.performance.timing 是W3C规范提供的接口，可以通过它获取到用户访问一个页面的每个阶段的精确时间(timestamp), 从而对性能进行分析  </p>
<p><img src="/blog/static/imgs/timing.png" alt="timer_inner"></p>
            
            <p class="article-more-link">
                <a href="/blog/2021/05/14/FE-performance-timing%E5%90%84%E4%B8%AA%E5%8F%82%E6%95%B0%E5%90%AB%E4%B9%89/#more">
                    <span class="vm">阅读更多</span>
                    <i class="icon-arrow-double-right vm"></i>    
                </a>
            </p>
            
        
    </section>
    
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/blog/2021/03/19/HTML-cookie%E3%80%81sessionStorage%E3%80%81localStorage%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%9C%E7%94%A8/">cookie、sessionStorage、localStorage区别与作用</a>
        </h1>
        
        <div class="article-meta clearfix">
            <span class="article-date">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2021-03-19T07:36:17.000Z" itemprop="datePublished">2021-03-19</time>
</span>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/blog/tags/Web-API/" rel="tag">Web API</a>, <a class="article-tag-link" href="/blog/tags/cookie/" rel="tag">cookie</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
            <p>相同点：  </p>
<ol>
<li>都是客户端临时信息对象</li>
<li>只能存储字符串类型对象</li>
</ol>
<p>不同点：   </p>
<ol>
<li>生命周期不同，cookie可以设置过期时间，localStorage始终有效，sessionStorage在关闭窗口后失效</li>
<li>cookie的主要内容包括：名字、值、过期时间、路径和域,有路径的概念，可以限制cookie只属于某个路径下</li>
<li>存储大小限制不同，cookie 4k localStorage/sessionStorage 5M</li>
<li>cookie始终在http请求中携带，Web Storage仅在本地保存</li>
<li>作用域不同，sessionStorage在不同的浏览器窗口中不共享，即使是同一个页面，localStorage/cookie在所有同源的窗口中是共享的。</li>
<li>Web Storage 有API setItem getItem removeItem clear， cookie需要自己解析</li>
<li>document.cookie window.localStorage window.sessionStorage</li>
<li>web storage是html5引入的，部分老旧浏览器不支持</li>
</ol>

        
    </section>
    
</article>






        
            </div>
        
        <article id="search-result" class="search-result content"></article>
        <footer class="footer">
    
        <div class="license">
            <p>版权声明
                <a target="_blank" rel="license noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商用-相同方式共享4.0 (CC BY-NC-SA 4.0)</a>
            </p>
        </div>
    
</footer>


    </main>

    
    <div id="appreciate-modal" class="modal">
    <div class="appreciate-container">
        <div class="appreciate-image">
            <img src="/blog/images/zfb.png" alt="支付宝二维码"></img>
            <p>⬆️支付宝</p>
        </div>
        <div class="appreciate-image">
            <img src="/blog/images/wx.png" alt="微信二维码"></img>
            <p>⬆️微信</p>
        </div>
    </div>
</div>
    
    <script type="text/javascript" src="/blog/js/jquery.min.js"></script>
    <script type="text/javascript" src="/blog/js/jquery.modal.min.js"></script>
    <script type="text/javascript" src="/blog/js/common.js"></script>
    <script type="text/javascript" src="/blog/js/home.js"></script>
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('.toc-link').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();
                // console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');
                // console.log(nodes.navTags.attr('class'))
            });/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/
        });
    </script>
    
        <script type="text/javascript" src="/blog/js/search.js"></script>
        <script type="text/javascript">
            var search_path = "search.xml";
            if (search_path.length == 0) {
                search_path = "search.xml";
            }
            var path = "/blog/" + search_path;
            searchFunc(path, 'search-box', 'search-result');
        </script>
    
    
    
        <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?bd8c20273d10c04abf64252ca5fdf77b";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
        </script>
    
</body>
</html>
