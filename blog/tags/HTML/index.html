<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    

    
    <title>
        标签: HTML | 
        Gblog
    </title>
    <meta name="author" content="Mangon" />
    <meta name="version" content="1.1.0" />
    
    <meta name="keywords" content="Mangon blog, 技术博客, 前端学习, 前端基础" />
    
    
    <meta name="description" content="Mangon&#39;s Technology Blog" />
    
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    
    <meta name="baidu-site-verification" content="pWri9ahJmw" />
    
    
    
    <link rel="icon" href="/blog/images/favicon.ico">
    
    
<link rel="stylesheet" href="/blog/css/style.css">

    <link rel="stylesheet" href="/blog/css/jquery.modal.min.css"></link>
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/blog/atom.xml" title="Gblog" type="application/atom+xml">
</head>
<body>

    <main class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>
    <nav class="nav-inner">
        
            
                <li class="nav-item ">
                    <a class="nav-link" href="/blog/">主页</a>
                </li>
            
        
            
                <li class="nav-item ">
                    <a class="nav-link" href="/blog/archives">目录</a>
                </li>
            
        
    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <div class="search-box" id="search-box">
    <form>
        <div class="search-btn"></div>
        <input autocomplete="off" type="text" id="search-input" name="q" results="0" placeholder="搜索"
        />
        <button type="reset" class="reset-search-btn"></button>
    </form>
</div>        
        

        
            <div class="author-meta">
                
                <div class="author-avatar">
                    <a href="/blog/">
                        <img src="/blog/images/avatar.jpeg" title="Mangon">
                    </a>
                </div>
                
                <div class="author-name">Mangon</div>
                <div class="author-work">前端开发工程师</div>
                <div class="author-location">
                    <i class="icon-location vm"></i>
                    <span class="vm">中国北京</span>
                </div>
                
                <div class="author-thread-wrap">
                    <div class="author-threads clearfix">
                        
                            <a class="thread-item" href="https://github.com/mangon" target="_blank" rel="external noopener noreferrer"><i class="icon-github"></i></a>
                        
                        
                        
                            <a class="thread-item" href="https://mangon.cn/blog/atom.xml" target="_blank" rel="external noopener noreferrer"><i class="icon-favorite"></i></a>
                        
                        
                            <a class="thread-item" href="https://mangon.cn/resume" target="_blank" rel="external noopener noreferrer"><i class="icon-circle-more"></i></a>
                        
                    </div>
                </div>
                
            </div>
        
        <div id="coffee-content"></div>
    </div>
</aside>

</header>

        
            <div data-spy="scroll" data-target="#aside-inner" id="content" class="content">
        
            
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/blog/2022/06/14/HTML-DOM%E4%B8%AD%E7%9A%84%E9%AB%98%E5%BA%A6%E3%80%81%E5%AE%BD%E5%BA%A6%E4%B8%8E%E8%B7%9D%E7%A6%BB/">DOM中的高度、宽度与距离</a>
        </h1>
        
        <div class="article-meta clearfix">
            <span class="article-date">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2022-06-14T02:25:26.000Z" itemprop="datePublished">2022-06-14</time>
</span>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/blog/tags/HTML/" rel="tag">HTML</a>, <a class="article-tag-link" href="/blog/tags/Web-API/" rel="tag">Web API</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
            <h2 id="HTMLElement-Element-属性"><a href="#HTMLElement-Element-属性" class="headerlink" title="HTMLElement/Element 属性"></a>HTMLElement/Element 属性</h2><h3 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h3><p><code>HTMLElement.offsetWidth</code> 属性表示元素的布局宽度。该属性包括元素的内容宽度（content-width）、竖直方向滚动条宽度（scrollbar-width）（如果存在的话）、水平方向的内边距（padding-left padding-right）以及水平方向的边框（border-left-width border-right-width）。</p>
<p><code>HTMLElement.offsetHeight</code> 属性表示元素的布局高度。该属性包括元素的内容高度（content-height）、水平方向滚动条高度（scrollbar-height）（如果存在的话）、竖直方向的内边距（padding-top padding-bottom）以及竖直方向的边框（border-top-width border-bottom-width）。</p>
<p>offsetWidth = 水平方向content-width + 左右padding + 左右border + 竖直方向滚动条scrollbar-width（如果存在的话）<br>offsetHeight = 竖直方向content-height + 上下padding + 上下border + 水平方向滚动条scrollbar-height（如果存在的话）</p>
<p><img src="/blog/static/imgs/dom/offset.png" alt="offset_inner"></p>
<p><em>offsetWidth 和 offsetHeight 可以理解为一个 边框盒（border box） 的 width 和 height。</em></p>
<p><code>HTMLElement.offsetTop</code> 属性表示元素的左上角相对于其 offsetParent 元素的顶部边框的距离。<br><code>HTMLElement.offsetLeft</code> 属性表示元素左上角相对于其 offsetParent 元素的左边框的距离。</p>
<p><code>HTMLElement.offsetParent</code> 返回一个指向最近的（指包含层级上的最近）包含该元素的定位元素或者最近的 <code>table,td,th,body</code> 元素。当元素的 <code>style.display</code> 设置为 “none” 时，或者该元素的 <code>style.position</code> 被设为 “fixed” 时，<code>offsetParent</code> 返回 <code>null</code>。</p>
<h3 id="client"><a href="#client" class="headerlink" title="client"></a>client</h3><p><code>Element.clientWidth</code> 属性表示元素的内部宽度。该属性包括元素的内容宽度（content-width）和内边距（padding），但不包括竖直方向滚动条宽度（scrollbar-width）（如果存在的话），边框（border）和外边距（margin）。</p>
<p><code>Element.clientHeight</code> 属性表示元素的内部高度。该属性包括元素的内容宽度（content-width）和内边距（padding），但不包括水平方向滚动条高度（scrollbar-height）（如果存在的话），边框（border）和外边距（margin）。</p>
<p>clientWidth = 水平方向content-width + 左右padding<br>clientHeight = 竖直方向content-height + 上下padding</p>
<p><img src="/blog/static/imgs/dom/client.png" alt="client_inner"></p>
<p><em>offsetWidth 和 offsetHeight 可以理解为一个 内边距盒（padding box） 的 width 和 height。</em><br><em>padding-box 并不是一个标准的盒模型选项，这里只是为了方便理解</em></p>
<p><code>Element.clientTop</code> 属性表示元素顶部边框的宽度。该属性仅包括元素的顶部边框宽度<br>（border-top-width）。</p>
<p><code>Element.clientLeft</code> 属性表示元素的左边框宽度。该属性包括元素的左边框 （border-left-width），如果元素的文本方向是从右向左（RTL, right-to-left），并且由于内容溢出导致左边出现了一个垂直滚动条，则该属性包括滚动条的宽度。</p>
<h3 id="scroll"><a href="#scroll" class="headerlink" title="scroll"></a>scroll</h3><p><code>Element.scrollWidth</code> 属性表示元素在不使用滚动条的情况下适合视口中的所有内容所需的最小宽度。scrollWidth 的测量方式与 clientWidth 相同：包含元素的内边距（padding），但不包括边框（border），外边距（margin）或垂直滚动条（如果存在）。scrollWidth 也包括伪元素的宽度，例如 ::before 或 ::after 。如果元素的内容可以正常展示而不需要水平滚动条，则其 scrollWidth 等于 clientWidth 。</p>
<p><code>Element.scrollHeight</code> 属性表示元素在不使用滚动条的情况下为了适应视口中所用内容所需的最小高度。scrollHeight 的测量方式与 clientHeight 相同：包括元素的内边距（padding），但不包括元素的边框（border）和外边距（margin）。scrollHeight 也包括 ::before 和 ::after 这样的伪元素的高度。 如果元素的内容不需要垂直滚动条就可以正常展示，则其 scrollHeight 等于 clientHeight。</p>
<p><img src="/blog/static/imgs/dom/scrollheight.png" alt="scroll-height_inner"></p>
<p><code>Element.scrollTop</code> 属性可以获取或<em>设置</em>（和前面的属性不同，scrollTop 是一个可读写的属性）元素的顶部到可视内容顶部的距离。如果一个元素的内容没有产生垂直方向的滚动条，那么它的 scrollTop 值为 0 。</p>
<p><code>Element.scrollLeft</code> 属性可以获取或<em>设置</em>元素的左边到可视内容左边的距离。如果一个元素的内容没有产生水平方向的滚动条，那么它的 scrollLeft 值为 0 。</p>
<h3 id="style-属性"><a href="#style-属性" class="headerlink" title="style 属性"></a>style 属性</h3><p>通过 <code>HTMLElement.style</code> 可以获取或<em>设置</em>元素的样式属性。但大部分时候，样式并不是直接存在于元素上而是通过继承等原因体现到的。我们可以通过 <code>window.getComputedStyle(element, [pseudoElt])</code> 获取到已经解析的 CSS 样式，该方法返回一个 <code>CSSStyleDeclaration</code> 对象，当元素的样式更改时，它会自动更新。</p>
<p><code>HTMLElement.style.&#123;top|left|right|bottom&#125;</code> 属性定义了定位元素的外边距边界与其包含块边界或正常位置之间的距离，非定位元素设置此属性无效。</p>
<p>以 top 为例，top 的效果取决于元素的 position 属性：</p>
<ul>
<li>当 position 设置为 absolute 或 fixed 时，top 属性指定了定位元素上外边距边界与其包含块上边界之间的偏移。</li>
<li>当 position 设置为 relative 时，top 属性指定了元素的上边界离开其正常位置的偏移。</li>
<li>当 position 设置为 sticky 时，如果元素在 viewport 里面，top 属性的效果和  position 为 relative 等同；如果元素在 viewport 外面，top 属性的效果和 position 为 fixed 等同。</li>
<li>当 position 设置为 static 时，top 属性无效。</li>
</ul>
<p><code>HTMLElement.style.margin&#123;Left|Top|Right|Bottom&#125;</code> 属性定义了元素的外边距<br><code>HTMLElement.style.padding&#123;Left|Top|Right|Bottom&#125;</code> 属性定义了元素的内边距<br><code>HTMLElement.style.border&#123;Left|Top|Right|Bottom&#125;Width</code> 属性定义了元素边框的宽度</p>
<h3 id="getBoundingClientRect-方法"><a href="#getBoundingClientRect-方法" class="headerlink" title="getBoundingClientRect 方法"></a>getBoundingClientRect 方法</h3><p><code>Element.getBoundingClientRect()</code> 方法返回一个 <code>DOMRect</code> 对象，其提供了元素的大小及其相对于视口的位置。值得注意的是，以上像 <code>offsetWidth</code> 等只读属性返回的都是四舍五入（round）之后的整数数值，<code>getBoundingClientRect</code> 可以返回精确的小数数值。</p>
<p>该方法返回的 <code>DOMRect</code> 对象中的 <code>width</code> 和 <code>height</code> 属性是包含了 <code>padding</code> 和 <code>border-width</code> 的，而不仅仅是内容部分的宽度和高度。在 <code>content-box</code> 模型中，这两个属性值分别与元素的 width/height + padding + border-width 相等。而如果是 border-box，两个属性则直接与元素的 width 或 height 相等。</p>
<p><img src="/blog/static/imgs/dom/element-box-diagram.png" alt="element-box_inner"></p>
<h3 id="getClientRects-方法"><a href="#getClientRects-方法" class="headerlink" title="getClientRects 方法"></a>getClientRects 方法</h3><p><code>Element.getClientRects()</code> 方法返回一个 <code>DOMRect</code> 集合，其包括元素内所有<br>边框盒（border box）的边界矩形（bounding rectangles）。大多数元素只有一个边框盒（border box），但是诸如一个多行的内联元素（例如多行的 span 元素）每行都有一个边框盒（border box）。</p>
<h2 id="window-属性"><a href="#window-属性" class="headerlink" title="window 属性"></a>window 属性</h2><p><code>window.innerWidth</code> 属性表示以像素为单位的窗口的视口（viewport）宽度。如果垂直滚动条存在，则这个属性将包括它的宽度。</p>
<p><code>window.innerHeight</code> 属性表示以像素为单位的窗口的视口（viewport）高度。如果水平滚动条存在，则这个属性将包括它的高度。</p>
<p><code>window.outerWidth</code> 属性表示整个浏览器外部窗口的宽度。包括侧边栏（如果存在）、窗口镶边和调整窗口大小的边框。</p>
<p><code>window.outerHeight</code> 属性表示整个浏览器外部窗口的高度。包括工具栏（如果存在）、窗口镶边和调整窗口大小的边框。</p>
<p><img src="/blog/static/imgs/dom/inner-outer.png" alt="inner-outer_inner"></p>
<p>一个显著的区分 inner 和 outer 的例子就是打开浏览器的 开发者工具，outerHeight 将会计算上开发者工具的高度，而 innerHeight 不会。</p>
<h3 id="screen-属性"><a href="#screen-属性" class="headerlink" title="screen 属性"></a>screen 属性</h3><p><code>window.screen.width</code> 属性表示屏幕的宽度。</p>
<p><code>window.screen.height</code> 属性表示屏幕的高度。</p>
<p><code>window.screen.availWidth</code> 属性表示浏览器窗口在屏幕上可占用的最大宽度。</p>
<p><code>window.screen.availHeight</code> 属性表示浏览器窗口在屏幕上可占用的最大高度。小工具（Widgets），如任务栏或其他特殊的程序窗口，可能会减少浏览器窗口和其他应用程序能够利用的空间。</p>
<h2 id="document-属性"><a href="#document-属性" class="headerlink" title="document 属性"></a>document 属性</h2><p><code>document.documentElement</code> 返回的是整个 html 文档<br><code>document.body</code> 返回的是 body 元素</p>
<p>html 文档 与 body 元素都是有效的 HTMLElement ， 所以，他们的属性也符合对应属性的定义：</p>
<p><code>document.documentElement.clientWidth</code> 浏览器窗口可视区宽度（不包括浏览器控制台、菜单栏、工具栏、滚动条）<br><code>document.documentElement.clientHeight</code> 浏览器窗口可视区高度（不包括浏览器控制台、菜单栏、工具栏、滚动条）</p>
<p><code>document.documentElement.offsetHeight</code> 获取整个文档的高度（包含 body 的 margin ）<br><code>document.documentElement.offsetWidth</code> 获取整个文档的宽度（包含 body 的 margin ）</p>
<p><code>document.documentElement.scrollTop</code> 返回文档的滚动 top 方向的距离（当窗口发生滚动时值改变）<br><code>document.documentElement.scrollLeft</code> 返回文档的滚动 left 方向的距离（当窗口发生滚动时值改变）</p>
<p><code>document.body.offsetHeight</code> 获取整个 body 的高度（不包含 body 的 margin ）<br><code>document.body.offsetWidth</code> 获取整个 body 的宽度（不包含 body 的 margin ）</p>
<p><img src="/blog/static/imgs/dom/distance.webp" alt="distance_inner"></p>

        
    </section>
    
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/blog/2021/11/24/FE-png%E3%80%81jpg%E3%80%81bmp%E3%80%81gif%E3%80%81tif%E5%9B%BE%E7%89%87%E7%9A%84%E5%8C%BA%E5%88%AB/">png、jpg、bmp、gif、tif图片的区别</a>
        </h1>
        
        <div class="article-meta clearfix">
            <span class="article-date">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2021-11-24T07:52:13.000Z" itemprop="datePublished">2021-11-24</time>
</span>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/blog/tags/CSS/" rel="tag">CSS</a>, <a class="article-tag-link" href="/blog/tags/HTML/" rel="tag">HTML</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
            <h2 id="BMP"><a href="#BMP" class="headerlink" title="BMP"></a>BMP</h2><p>BMP（Bitmap）位图，是 Windows 操作系统中的标准图像文件格式，可以分成两类：设备相关位图（DDB）和设备无关位图（DIB）。它采用位映射存储格式，除了图像深度可选以外，不采用其他任何压缩，因此，BMP文件所占用的空间很大。BMP文件的图像深度可选1bit、4bit、8bit及24bit。BMP文件存储数据时，图像的扫描方式是按从左到右、从下到上的顺序。由于BMP文件格式是 Windows 环境中交换与图有关的数据的一种标准，因此在 Windows 环境中运行的图形图像软件都支持BMP图像格式。</p>
            
            <p class="article-more-link">
                <a href="/blog/2021/11/24/FE-png%E3%80%81jpg%E3%80%81bmp%E3%80%81gif%E3%80%81tif%E5%9B%BE%E7%89%87%E7%9A%84%E5%8C%BA%E5%88%AB/#more">
                    <span class="vm">阅读更多</span>
                    <i class="icon-arrow-double-right vm"></i>    
                </a>
            </p>
            
        
    </section>
    
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/blog/2021/11/23/TIPS-input%E8%BE%93%E5%85%A5%E6%A1%86%E7%9A%84autocomplete%E5%B1%9E%E6%80%A7/">input输入框的autocomplete属性</a>
        </h1>
        
        <div class="article-meta clearfix">
            <span class="article-date">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2021-11-23T09:19:43.000Z" itemprop="datePublished">2021-11-23</time>
</span>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/blog/tags/HTML/" rel="tag">HTML</a>, <a class="article-tag-link" href="/blog/tags/autocomplete/" rel="tag">autocomplete</a>, <a class="article-tag-link" href="/blog/tags/input/" rel="tag">input</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
            <p>在开发过程中遇到了一个兼容性相关的问题，具体为在Firefox浏览器中，浏览器自带的账号密码自动补全功能显示异常将输入框挡住了，如下。</p>
<p><img src="/blog/static/imgs/input_error.png" alt="input_error"></p>
<p>操作系统: macOS 10.15.7<br>浏览器: Firefox 91.0.2 (64 位)</p>
            
            <p class="article-more-link">
                <a href="/blog/2021/11/23/TIPS-input%E8%BE%93%E5%85%A5%E6%A1%86%E7%9A%84autocomplete%E5%B1%9E%E6%80%A7/#more">
                    <span class="vm">阅读更多</span>
                    <i class="icon-arrow-double-right vm"></i>    
                </a>
            </p>
            
        
    </section>
    
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/blog/2021/06/23/HTML-history-API/">浏览器会话历史 history API</a>
        </h1>
        
        <div class="article-meta clearfix">
            <span class="article-date">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2021-06-22T16:43:58.000Z" itemprop="datePublished">2021-06-23</time>
</span>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/blog/tags/HTML/" rel="tag">HTML</a>, <a class="article-tag-link" href="/blog/tags/Web-API/" rel="tag">Web API</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
            <h2 id="History-API"><a href="#History-API" class="headerlink" title="History API"></a>History API</h2><p>History 接口允许操作浏览器的会话历史记录。</p>
<h2 id="History-API-的方法和属性"><a href="#History-API-的方法和属性" class="headerlink" title="History API 的方法和属性"></a>History API 的方法和属性</h2><table>
<thead>
<tr>
<th>属性</th>
<th>是否只读</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>history.length</code></td>
<td>只读</td>
<td>整数</td>
<td>history 堆栈中会话的数量</td>
</tr>
<tr>
<td><code>history.state</code></td>
<td>只读</td>
<td>object</td>
<td>返回一个表示历史堆栈顶部的状态的值</td>
</tr>
<tr>
<td><code>history.scrollRestoration</code></td>
<td>否</td>
<td>auto｜manual (string)</td>
<td>允许Web应用程序在历史导航上显式地设置默认滚动恢复行为</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>history.back()</code></td>
<td>在浏览器历史记录里前往上一页, 用户可点击浏览器左上角的返回按钮模拟此方法. 等价于 <code>history.go(-1)</code></td>
</tr>
<tr>
<td><code>history.forward()</code></td>
<td>在浏览器历史记录里前往下一页，用户可点击浏览器左上角的前进按钮模拟此方法. 等价于 <code>history.go(1)</code></td>
</tr>
<tr>
<td><code>history.go()</code></td>
<td>入参为整数，通过当前页面的相对位置从浏览器历史记录加载页面。</td>
</tr>
<tr>
<td><code>history.pushState(state, title[, url])</code></td>
<td>按指定的名称和URL（如果提供该参数）将数据 push 进会话历史栈，数据被 DOM 进行不透明处理；可以指定任何可以被序列化的 javascript 对象。</td>
</tr>
<tr>
<td><code>history.replaceState(state, title[, url])</code></td>
<td>按指定的数据，名称和URL(如果提供该参数)，更新历史栈上最新的入口。这个数据被 DOM 进行了不透明处理。你可以指定任何可以被序列化的 javascript 对象。</td>
</tr>
</tbody>
</table>
<h2 id="History-API-用法"><a href="#History-API-用法" class="headerlink" title="History API 用法"></a>History API 用法</h2><p>History API 最常见的用法是通过 <code>pushState()</code> 方法添加浏览器url历史（浏览器不会加载该 url ，甚至不会检查 url 是否真的存在），这样，在回退的时候就会加载 history 堆栈中的页面。在某种意义上，调用 <code>pushState()</code> 与 设置 <code>window.location = &quot;#foo&quot;</code> 类似，二者都会在当前页面创建并激活新的历史记录。但 <code>pushState()</code> 具有如下几条特点：</p>
<ul>
<li>新的 URL 可以是与当前 URL 同源的任意 URL 。相反，只有在修改哈希时，设置 <code>window.location</code> 才能是同一个 document。</li>
<li>如果你不想改 URL ，就不用改。相反，设置 <code>window.location = &quot;#foo&quot;;</code> 在当前哈希不是 #foo 时，才能创建新的历史记录项。</li>
<li>你可以将任意数据和新的历史记录项相关联。而基于哈希的方式，要把所有相关数据编码为短字符串。</li>
<li>如果 标题(title 随后还会被浏览器所用到，那么这个数据是可以被使用的（哈希则不是）。</li>
<li><code>pushState()</code> 不会触发 hashchange 事件，即使新的 URL 与旧的 URL 仅哈希不同也是如此</li>
</ul>
<p>每当活动的历史记录项发生变化时， popstate 事件都会被传递给 window 对象。如果当前活动的历史记录项是被 <code>pushState()</code> 创建的，或者是由 <code>replaceState()</code> 改变的，那么 popstate 事件的状态属性 state 会包含一个当前历史记录状态对象的拷贝。</p>
<p>参考： https://developer.mozilla.org/zh-CN/docs/Web/API/History</p>

        
    </section>
    
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/blog/2021/06/23/HTML-Event/">DOM中的事件 Event</a>
        </h1>
        
        <div class="article-meta clearfix">
            <span class="article-date">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2021-06-22T16:41:21.000Z" itemprop="datePublished">2021-06-23</time>
</span>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/blog/tags/HTML/" rel="tag">HTML</a>, <a class="article-tag-link" href="/blog/tags/Web-API/" rel="tag">Web API</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
            <h2 id="DOM中的事件-Event"><a href="#DOM中的事件-Event" class="headerlink" title="DOM中的事件 Event"></a>DOM中的事件 Event</h2><p>Event 接口表示在 DOM 中出现的事件。</p>
<p>Event（事件）可以由三种方式触发：</p>
<ul>
<li>由用户触发动作，例如鼠标或键盘事件</li>
<li>由 API 生成，例如指示动画已经完成运行的事件，视频已被暂停等</li>
<li>通过脚本代码触发，例如对元素调用 <code>HTMLElement.click()</code> 方法，或者定义一些自定义事件，再使用 <code>EventTarget.dispatchEvent()</code> 方法将自定义事件派发往指定的目标（target）</li>
</ul>
<p>有许多不同类型的事件，其中一些使用基于 Event 主接口的二次接口。Event 本身包含适用于所有事件的属性和方法。</p>
<p>很多DOM元素可以被设计接收（或者监听) 这些事件, 并且执行代码去响应（或者处理）它们。通过 <code>EventTarget.addEventListener()</code> 方法可以将事件处理函数绑定到不同的HTML elements上 (比如&lt;button>, &lt;div>, &lt;span>等等) 。这种绑定事件处理函数的方式基本替换了老版本中使用 HTML event handler attributes（例如 <code>HTMLElement.onclick = ...</code> ） 来绑定事件处理函数的方式。除此之外，通过正确使用 <code>removeEventListener()</code> 方法，这些事件处理函数也能被移除。</p>
            
            <p class="article-more-link">
                <a href="/blog/2021/06/23/HTML-Event/#more">
                    <span class="vm">阅读更多</span>
                    <i class="icon-arrow-double-right vm"></i>    
                </a>
            </p>
            
        
    </section>
    
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/blog/2021/06/04/CSS-%E8%84%B1%E7%A6%BB%E6%96%87%E6%A1%A3%E6%B5%81%E7%9A%84%E6%96%B9%E6%B3%95/">脱离文档流的方法</a>
        </h1>
        
        <div class="article-meta clearfix">
            <span class="article-date">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2021-06-04T07:34:43.000Z" itemprop="datePublished">2021-06-04</time>
</span>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/blog/tags/CSS/" rel="tag">CSS</a>, <a class="article-tag-link" href="/blog/tags/HTML/" rel="tag">HTML</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
            <h2 id="正常文档布局流"><a href="#正常文档布局流" class="headerlink" title="正常文档布局流"></a>正常文档布局流</h2><p>正常文档布局流（normal document layout flow）是指在没有改变默认布局规则情况下的页面元素布局方式。如果你未曾应用任何CSS规则来改变它们的展现方式，网页上的元素将会按照正常布局流来组织布局。<br>首先说一下独立元素的布局。元素的内容被放在一个独立的元素盒子中，然后在其周边加上内边距（padding）、边框（border）和外边距（margin） — 就是我们所说的盒子模型（box model）。默认情况下，一个块级元素（典型如div）的内容宽度是其父元素的100%，其高度与其内容高度一致。内联元素（典型如span）的高度、宽度与内容一致。你可以通过设置 <code>display: block</code> 与 <code>display: inline</code> 来将一个元素变为块级元素或内联元素。<br>元素之间又是如何相互影响的呢？块级元素默认会按照基于其父元素的书写顺序（writing-mode: horizontal-tb）的块流动方向（block flow direction）放置 — 每个块级元素会在上一个元素下面另起一行，它们会被设置好的外边距（margin）分隔。在英语，或者其他水平书写、自上而下模式里，块级元素是垂直组织的。内联元素的表现有所不同 — 它们不会另起一行；只要在其父级块级元素的宽度内有足够的空间，它们与其他内联元素、相邻的文本内容（或者被包裹的）被安排在同一行。如果空间不够，溢出的文本或元素将移到新的一行。</p>
            
            <p class="article-more-link">
                <a href="/blog/2021/06/04/CSS-%E8%84%B1%E7%A6%BB%E6%96%87%E6%A1%A3%E6%B5%81%E7%9A%84%E6%96%B9%E6%B3%95/#more">
                    <span class="vm">阅读更多</span>
                    <i class="icon-arrow-double-right vm"></i>    
                </a>
            </p>
            
        
    </section>
    
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/blog/2021/03/25/HTML-HTML5%E7%89%B9%E6%80%A7/">HTML5特性</a>
        </h1>
        
        <div class="article-meta clearfix">
            <span class="article-date">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2021-03-25T09:14:29.000Z" itemprop="datePublished">2021-03-25</time>
</span>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/blog/tags/HTML/" rel="tag">HTML</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
            <p>HTML5 是定义 HTML 标准的最新的版本。<a target="_blank" rel="noopener" href="https://whatwg.org/">WHATWG</a> 致力于 web 表单和应用程序，而 <a target="_blank" rel="noopener" href="https://www.w3.org/">W3C</a> 专注于 XHTML 2.0。在 2006 年，双方决定进行合作，来创建一个新版本的 HTML，这就是HTML5。  </p>
            
            <p class="article-more-link">
                <a href="/blog/2021/03/25/HTML-HTML5%E7%89%B9%E6%80%A7/#more">
                    <span class="vm">阅读更多</span>
                    <i class="icon-arrow-double-right vm"></i>    
                </a>
            </p>
            
        
    </section>
    
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/blog/2021/03/19/HTML-%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0-%E5%9D%97%E7%8A%B6%E5%85%83%E7%B4%A0/">HTML 行内元素&amp;块状元素</a>
        </h1>
        
        <div class="article-meta clearfix">
            <span class="article-date">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2021-03-19T13:09:58.000Z" itemprop="datePublished">2021-03-19</time>
</span>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/blog/tags/HTML/" rel="tag">HTML</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
            <h2 id="行内元素与块状元素有什么区别"><a href="#行内元素与块状元素有什么区别" class="headerlink" title="行内元素与块状元素有什么区别?"></a>行内元素与块状元素有什么区别?</h2><p>行内元素：会在水平方向排列，不能包含块级元素，设置width无效，height无效（可以设置line-height），margin上下无效，padding上下无效<br>块级元素：各占据一行，垂直方向排列。从新行开始结束接着一个断行  </p>
<h2 id="列举常用行内与块状元素"><a href="#列举常用行内与块状元素" class="headerlink" title="列举常用行内与块状元素"></a>列举常用行内与块状元素</h2><p>块级元素：div, p, h1-h5, form, ul, li<br>行内元素：span, a, label, input, img, strong, em  </p>

        
    </section>
    
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/blog/2021/03/19/HTML-html5%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/">HTML html5常用标签</a>
        </h1>
        
        <div class="article-meta clearfix">
            <span class="article-date">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2021-03-19T13:08:57.000Z" itemprop="datePublished">2021-03-19</time>
</span>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/blog/tags/HTML/" rel="tag">HTML</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
            <h3 id="html5新增的常用标签有哪些"><a href="#html5新增的常用标签有哪些" class="headerlink" title="html5新增的常用标签有哪些"></a>html5新增的常用标签有哪些</h3><p><code>header</code> 定义一个页面或一个区域的头部<br><code>footer</code> 定义一个页面或一个区域的底部<br><code>nav</code> 定义导航链接<br><code>aside</code> 定义页面内容部分的侧边栏<br><code>artical</code> 定义一篇文章<br><code>section</code> 定义一个区域<br><code>hgroup</code> 定义文件中一个区块的相关信息<br><code>figure</code> 定义一组媒体内容以及它们的标题<br><code>dialog</code> 定义一个对话框(会话框)类似微信<br><code>audio</code> 定义声音内容<br><code>video</code> 定义视频内容<br><code>canvas</code> 定义图形<br><code>embed</code> 定义外部交互内容或插件<br><code>mark</code> 定义有记号的文本  </p>

        
    </section>
    
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/blog/2021/03/19/HTML-%E8%AF%AD%E4%B9%89%E5%8C%96/">HTML 语义化</a>
        </h1>
        
        <div class="article-meta clearfix">
            <span class="article-date">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2021-03-19T13:05:44.000Z" itemprop="datePublished">2021-03-19</time>
</span>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/blog/tags/HTML/" rel="tag">HTML</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
            <h2 id="语义化"><a href="#语义化" class="headerlink" title="语义化"></a>语义化</h2><p>语义化就是根据内容选择标签。</p>
<h2 id="语义化的好处"><a href="#语义化的好处" class="headerlink" title="语义化的好处"></a>语义化的好处</h2><p>语义化的好处是使代码结构清晰，便于阅读，同时充分利用了SEO。  </p>

        
    </section>
    
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/blog/2021/03/19/HTML-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/">HTML 事件绑定&amp;事件委托</a>
        </h1>
        
        <div class="article-meta clearfix">
            <span class="article-date">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2021-03-19T07:45:56.000Z" itemprop="datePublished">2021-03-19</time>
</span>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/blog/tags/HTML/" rel="tag">HTML</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
            <h2 id="如何给一个元素绑定事件，分别有几种方式？各有什么好处？"><a href="#如何给一个元素绑定事件，分别有几种方式？各有什么好处？" class="headerlink" title="如何给一个元素绑定事件，分别有几种方式？各有什么好处？"></a>如何给一个元素绑定事件，分别有几种方式？各有什么好处？</h2><ol>
<li>监听方法绑定方式<br>事件冒泡 事件捕获<br>js事件流是先由 window-&gt;document-&gt;body-&gt;div-&gt;(text) 触发一遍捕获 capture ，<br>再由（text）-&gt;div-&gt;body-&gt;document-&gt;window触发一遍冒泡bubbling</li>
</ol>
<p>element.addEventListener(type, listener, useCapture);<br>type:事件类型<br>listener:监听方法<br>useCapture:是否捕获，默认false，即在冒泡时触发</p>
<p>listener的入参event可以获取到event.target event.currentTarget<br>其中，target是真正发生事件的DOM元素，而currentTarget是当前事件发生在哪个DOM元素上。</p>
            
            <p class="article-more-link">
                <a href="/blog/2021/03/19/HTML-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/#more">
                    <span class="vm">阅读更多</span>
                    <i class="icon-arrow-double-right vm"></i>    
                </a>
            </p>
            
        
    </section>
    
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/blog/2021/03/19/HTML-%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93html%E7%9A%84%E8%BF%87%E7%A8%8B/">页面渲染html的过程</a>
        </h1>
        
        <div class="article-meta clearfix">
            <span class="article-date">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2021-03-19T07:34:27.000Z" itemprop="datePublished">2021-03-19</time>
</span>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/blog/tags/HTML/" rel="tag">HTML</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
            <p>浏览器渲染页面的一般过程：</p>
<p>1.浏览器解析html源码，然后创建一个 DOM树。并行请求 css/image/js 在DOM树中，每一个HTML标签都有一个对应的节点，并且每一个文本也都会有一个对应的文本节点。DOM树的根节点就是 documentElement，对应的是 html 标签。</p>
<p>2.浏览器解析CSS代码，计算出最终的样式数据。构建CSSOM树。对CSS代码中非法的语法它会直接忽略掉。解析CSS的时候会按照如下顺序来定义优先级：浏览器默认设置 &lt; 用户设置 &lt; 外链样式 &lt; 内联样式 &lt; html中的style。</p>
<p>3.DOM Tree + CSSOM –&gt; 渲染树（rendering tree）。渲染树和DOM树有点像，但是是有区别的。</p>
<p>DOM树完全和html标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如 head、display:none 的元素等。而且一大段文本中的每一个行在渲染树中都是独立的一个节点。渲染树中的每一个节点都存储有对应的css属性。</p>
<p>4.一旦渲染树创建好了，浏览器就可以根据渲染树直接把页面绘制到屏幕上。</p>
<p>以上四个步骤并不是一次性顺序完成的。如果DOM或者CSSOM被修改，以上过程会被重复执行。实际上， CSS 和 JavaScript 往往会多次修改 DOM 或者 CSSOM 。</p>

        
    </section>
    
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/blog/2019/01/21/HTML-head%E4%B8%AD%E7%9A%84meta/">head中的meta</a>
        </h1>
        
        <div class="article-meta clearfix">
            <span class="article-date">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2019-01-21T12:53:30.000Z" itemprop="datePublished">2019-01-21</time>
</span>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/blog/tags/HTML/" rel="tag">HTML</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
            <p>meta指的是html元素中存在与head中的meta元素<br>它长这样  </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="meta的含义"><a href="#meta的含义" class="headerlink" title="meta的含义"></a>meta的含义</h2><p>HTML <meta> 元素表示那些不能由其它HTML元相关元素 (&lt;base>, &lt;link>, &lt;script>, &lt;style> 或 &lt;title>) 之一表示的任何元数据信息.  </p>
<h2 id="meta的属性"><a href="#meta的属性" class="headerlink" title="meta的属性"></a>meta的属性</h2><h3 id="charset"><a href="#charset" class="headerlink" title="charset"></a>charset</h3><p>此特性声明当前文档所使用的字符编码，但该声明可以被任何一个元素(通常是html)的 lang 特性的值覆盖。此特性的值必须是一个符合由IANA所定义的字符编码首选MIME 名称（preferred MIME name ）之一。</p>
<p>有几点需要注意：</p>
<ol>
<li>推荐使用 UTF-8；  </li>
<li><meta> 元素必须包含在 <head> 元素中并且在HTML代码的前1024个字节内，因为某些浏览器在选择编码之前只查看前面这些字节。  </li>
<li>meta charset元素并不能决定字符集，网页采用何种字符是由 <a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/multipage/parsing.html#encoding-sniffing-algorithm">网页字符算法</a> 决定的  </li>
<li>强烈建议使用该属性定义字符编码. 如果未定义，某些跨脚本技术可能危害网页， 例如 <a target="_blank" rel="noopener" href="http://code.google.com/p/doctype-mirror/wiki/ArticleUtf7">UTF-7 降级XSS攻击</a>  </li>
</ol>
<h3 id="http-equiv"><a href="#http-equiv" class="headerlink" title="http-equiv"></a>http-equiv</h3><p>这个枚举属性定义了能改变服务器和用户引擎行为的编译行为。值使用 content 来定义，如下：  </p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>content-security-policy</td>
<td>它允许页面作者定义当前页的内容策略。 内容策略主要指定允许的服务器源和脚本端点，这有助于防止跨站点脚本攻击。</td>
</tr>
<tr>
<td>default-style</td>
<td>这个属性指定了在页面上使用的首选样式表. content属性必须包含 <code>&lt;link&gt;</code> 元素的标题, href属性链接到CSS样式表或包含CSS样式表的 <code>&lt;style&gt;</code> 元素的标题.</td>
</tr>
<tr>
<td>refresh</td>
<td>这个属性规定了重新载入页面或跳转到指定链接的时间间隔（正整数）</td>
</tr>
</tbody>
</table>
<h3 id="name-amp-content"><a href="#name-amp-content" class="headerlink" title="name &amp; content"></a>name &amp; content</h3><p>全局属性 name 在 <meta> 元素中具有特殊的语义；<br>另外， 在同一个 <meta> 标签中，name、http-equiv 或者 charset 三者中任何一个属性存在时，itemprop 属性不能被使用。  </p>
<p>定义文档级元数据的名称 与 内容  </p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>application-name</td>
<td>定义正运行在该网页上的网络应用名称</td>
</tr>
<tr>
<td>author</td>
<td>这个文档的作者名称</td>
</tr>
<tr>
<td>description</td>
<td>其中包含页面内容的简短和精确的描述。 一些浏览器，如Firefox和Opera，将其用作书签页面的默认描述</td>
</tr>
<tr>
<td>generator</td>
<td>包含生成页面的软件的标识符</td>
</tr>
<tr>
<td>keywords</td>
<td>包含与逗号分隔的页面内容相关的单词（关键词）</td>
</tr>
<tr>
<td>referrer</td>
<td>控制所有从该文档发出的 HTTP 请求中HTTP Referer 首部的内容</td>
</tr>
</tbody>
</table>
<p>name 为 referrer 时 content 的可选值</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>no-referrer</td>
<td>不要发送 HTTP Referer 首部</td>
</tr>
<tr>
<td>origin</td>
<td>发送当前文档的 origin。</td>
</tr>
<tr>
<td>no-referrer-when-downgrade</td>
<td>当目的地是先验安全的(https-&gt;https)则发送 origin 作为 referrer ，但是当目的地是较不安全的 (https-&gt;http)时则不发送 referrer 。这个是默认的行为。</td>
</tr>
<tr>
<td>origin-when-crossorigin</td>
<td>在同源请求下，发送完整的URL (不含查询参数) ，其他情况下则仅发送当前文档的 origin。</td>
</tr>
<tr>
<td>unsafe-URL</td>
<td>在同源请求下，发送完整的URL (不含查询参数)。</td>
</tr>
</tbody>
</table>
<p>有些name虽然没有被正式承认，但是也被广泛使用，<a target="_blank" rel="noopener" href="https://wiki.whatwg.org/wiki/MetaExtensions">这个网站</a> 列举了所有存在的meta值。以下列举一些常用的。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>creator</td>
<td>文档的创建者</td>
</tr>
<tr>
<td>publisher</td>
<td>文档的发布者</td>
</tr>
<tr>
<td>robots</td>
<td>定义了合理的被允许的爬虫行为，注意只有搜索引擎爬虫会遵循此规则所以并不能阻止个人的爬虫程序，而且爬虫能读取到该属性说明已经在读取此网页了，所以最好使用robots.txt来阻止搜索引擎爬虫</td>
</tr>
<tr>
<td>viewport</td>
<td>视口，提供有关视口初始大小的提示，仅供移动设备使用，虽然目前标准化程度不高，还处于草案(work in progress)的进度，但由于事实上的几个浏览器的支配地位，大多数移动浏览器都尊重这一声明，更多有关viewport的解释参见<a target="_blank" rel="noopener" href="https://drafts.csswg.org/css-device-adapt/#viewport-meta">文档</a></td>
</tr>
</tbody>
</table>
<p>有关viewport的相关内容，参见 <a href="/2019/01/21/浅谈viewport/">浅谈viewport</a></p>

        
    </section>
    
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/blog/2019/01/21/HTML-viewport/">viewport</a>
        </h1>
        
        <div class="article-meta clearfix">
            <span class="article-date">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2019-01-21T11:53:30.000Z" itemprop="datePublished">2019-01-21</time>
</span>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/blog/tags/HTML/" rel="tag">HTML</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
            <h2 id="viewport来源"><a href="#viewport来源" class="headerlink" title="viewport来源"></a>viewport来源</h2><p>通常为了使得网页能够成为响应式的，我们需要在head内声名有关viewport的meta。<br>它长这样  </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1,user-scalable=no&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>viewport的设计是由于pc互联网向移动互联网的过渡。在过去，多数文档被设计用来在pc上进行阅读，而pc的设备通常比较宽，同样的网页不进行任何改变放到移动端的话，内容就会变得无法辨认。</p>
            
            <p class="article-more-link">
                <a href="/blog/2019/01/21/HTML-viewport/#more">
                    <span class="vm">阅读更多</span>
                    <i class="icon-arrow-double-right vm"></i>    
                </a>
            </p>
            
        
    </section>
    
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/blog/2019/01/03/HTML-a-%E7%9A%84%E7%94%A8%E6%B3%95/">链接a标签的用法</a>
        </h1>
        
        <div class="article-meta clearfix">
            <span class="article-date">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2019-01-03T12:16:31.000Z" itemprop="datePublished">2019-01-03</time>
</span>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/blog/tags/HTML/" rel="tag">HTML</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
            <h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><p>&lt;a> 标签定义超链接，用于从一张页面链接到另一张页面。</p>
<p>在所有浏览器中，链接的默认外观是：  </p>
<ul><li style="text-decoration: underline; color:blue;">未被访问的链接带有下划线而且是蓝色的</li><li style="text-decoration: underline; color:red;">活动链接带有下划线而且是红色的</li><li style="text-decoration: underline; color:purple;">已被访问的链接带有下划线而且是紫色的</li></ul>

<p>链接默认样式</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;<span class="attribute">color</span>: blue;<span class="attribute">text-decoration</span>: underline;&#125;    <span class="comment">/* 未访问的链接 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">color</span>: blue;<span class="attribute">text-decoration</span>: underline;&#125;    <span class="comment">/* 鼠标移动到链接上 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;<span class="attribute">color</span>: red;<span class="attribute">text-decoration</span>: underline;&#125;     <span class="comment">/* 鼠标按下但还未收起时的链接 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;<span class="attribute">color</span>: purple;<span class="attribute">text-decoration</span>: underline;&#125;    <span class="comment">/* 已访问的链接 */</span></span><br></pre></td></tr></table></figure>
<p>&lt;a>不能自闭合，必须有开始标识与结束标识。  </p>
            
            <p class="article-more-link">
                <a href="/blog/2019/01/03/HTML-a-%E7%9A%84%E7%94%A8%E6%B3%95/#more">
                    <span class="vm">阅读更多</span>
                    <i class="icon-arrow-double-right vm"></i>    
                </a>
            </p>
            
        
    </section>
    
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/blog/2018/09/07/HTML-%E9%A1%B5%E9%9D%A2%E7%A6%81%E6%AD%A2%E9%80%89%E4%B8%AD%E5%A4%8D%E5%88%B6/">页面禁止选中复制</a>
        </h1>
        
        <div class="article-meta clearfix">
            <span class="article-date">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-09-07T15:12:46.000Z" itemprop="datePublished">2018-09-07</time>
</span>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/blog/tags/HTML/" rel="tag">HTML</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
            <p>有时，为了防止用户随意的获取页面内的内容，我们需要禁止用户选中和拷贝，下面介绍两种禁止的方法。  </p>
            
            <p class="article-more-link">
                <a href="/blog/2018/09/07/HTML-%E9%A1%B5%E9%9D%A2%E7%A6%81%E6%AD%A2%E9%80%89%E4%B8%AD%E5%A4%8D%E5%88%B6/#more">
                    <span class="vm">阅读更多</span>
                    <i class="icon-arrow-double-right vm"></i>    
                </a>
            </p>
            
        
    </section>
    
</article>






        
            </div>
        
        <article id="search-result" class="search-result content"></article>
        <footer class="footer">
    
        <div class="license">
            <p>版权声明
                <a target="_blank" rel="license noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商用-相同方式共享4.0 (CC BY-NC-SA 4.0)</a>
            </p>
        </div>
    
</footer>


    </main>

    
    <div id="appreciate-modal" class="modal">
    <div class="appreciate-container">
        <div class="appreciate-image">
            <img src="/blog/images/zfb.png" alt="支付宝二维码"></img>
            <p>⬆️支付宝</p>
        </div>
        <div class="appreciate-image">
            <img src="/blog/images/wx.png" alt="微信二维码"></img>
            <p>⬆️微信</p>
        </div>
    </div>
</div>
    
    <script type="text/javascript" src="/blog/js/jquery.min.js"></script>
    <script type="text/javascript" src="/blog/js/jquery.modal.min.js"></script>
    <script type="text/javascript" src="/blog/js/common.js"></script>
    <script type="text/javascript" src="/blog/js/home.js"></script>
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('.toc-link').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();
                // console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');
                // console.log(nodes.navTags.attr('class'))
            });/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/
        });
    </script>
    
        <script type="text/javascript" src="/blog/js/search.js"></script>
        <script type="text/javascript">
            var search_path = "search.xml";
            if (search_path.length == 0) {
                search_path = "search.xml";
            }
            var path = "/blog/" + search_path;
            searchFunc(path, 'search-box', 'search-result');
        </script>
    
    
    
        <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?bd8c20273d10c04abf64252ca5fdf77b";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
        </script>
    
</body>
</html>
